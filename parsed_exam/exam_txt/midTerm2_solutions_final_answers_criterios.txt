PROBLEM 1 Section 1.1 (1 point) public void init(ArrayList<String> drivers){  for(int i=0; i<drivers.size(); i++){   Node newDriver = new Node(drivers.get(i), Double.POSITIVE_INFINITY);   newDriver.setNext(first);   first = newDriver;  }   }  Section 1.2 (1.5 points) public void selectionSort(){  for(int i=0; i<size; i++){   int m = i;   for(int j=i; j<size; j++){    if(getNode(j).getFastestLap()<getNode(m).getFastestLap()){     m = j;    }   }   swap(i, m);  } } Section 1.3 (1.5 points) public void newFastestLap(String driver, double time){  Node current = first;  while(current != null){   if(current.getDriver().equals(driver)){    if(time < current.getFastestLap()){     current.setFastestLap(time);     selectionSort();    }    history.enqueue(new Node(driver, time));    break;   }   current = current.getNext();  } } Section 1.1 (1 point) • 0.25: Loop to consider all the elements of the ArrayList • 0.75: Insertion of the node at the beginning of the list o 0.25: Creation of the node o 0.25: Link node and first o 0.25: Update first • Significant errors are subject to additional penalties  Section 1.2 (1.5 points) • 0.25: External loop, from 0 to size or size – 1 • 0.25: Initialize m • 0.25: Internal loop from i to size • 0.25: Comparison of times in ascending order. If the comparison is correct, but not the order, maximum 0.15. • 0.25: Get the minimum value into a local variable  

• 0.25: Calling the method that swaps correctly • Significant errors are subject to additional penalties  Section 1.3 (1.5 points) • 0.25: Traverse the list with an auxiliary node • 0.25: Check if the driver given as a parameter is the same of the driver in current node • 0.25: Check if the lap is faster than the current fastest lap of the driver • 0.25: Update fastest lap when new lap is faster • 0.25: Call to selection sort when the fastest lap has changed. If selection sort is always called (it is called outside the if), penalize 0.1. • 0.25: Enqueue a node with the driver and time. If the enqueue call is carried out only when the lap is faster than the current lap or the call is carried out even when the driver is not found, penalize 0.1. Penalize 0.1 current is enqueued instead of a new node. • Significant errors are subject to additional penalties  PROBLEM 2 Section 2.1 (1.5 points) public static void main (String args[]){    CityTree t1 = new CityTree("Tilted Towers",10);  CityTree t2 = new CityTree("Greasy Grove",5);  CityTree t3 = new CityTree("Loot Lake",4);  CityTree t4 = new CityTree("Fatal Fields",3);  CityTree t5 = new CityTree("Flush Factory",1);  CityTree t6 = new CityTree("Pleasant Park",1);  CityTree t7 = new CityTree("Haunted Hills",3);  t2.insert(t4, 1);  t2.insert(t5, 2);  t3.insert(t6, 1);  t3.insert(t7, 2);  t1.insert(t2, 1);  t1.insert(t3, 2);  System.out.println(l1.computeOptimal());    } Section 2.2 (1.5 points) public String computeOptimal(){  if(this.root==null){   return "";  }  if(this.root.getOption1()!=null && this.root.getOption2()!=null){    if(root.getOption1().maximumChests() > root.getOption2().maximumChests()){    return this.root.getName() + root.getOption1().computeOptimal();   } else{    return this.root.getName() + root.getOption2().computeOptimal();   }  } else{   return this.root.getName();  } }    

Section 2.1 (1.5 points) • 0.6: Creation of the trees. • 0.6: Insertion of the subtrees. • 0.3: Printing the optimal route invoking the computeOptimal( ) method • Significant errors are subject to additional penalties  Section 2.2 (1.5 points) • 0.25: Checking if the tree is empty (root==null) • 1.0: Recursive case o 0.5: Comparison of the two options using the maximumChests( ) method. o 0.5: Recursive call • 0.25: Base case o 0.10: Checking that it is a leaf node (no options). o 0.15: Returning the name of the leaf node. • Significant errors are subject to additional penalties
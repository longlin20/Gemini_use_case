PROBLEM 1 Section 1.1 (0.4 points) public interface AdvancedTyreInterface {    public static final double NORMAL_TEMPERATURE = 25;   public abstract double calculateOptimumTemp(); }   Evaluation criteria: ● 0 if the code makes no sense or the interface has any code different from declarations. ● 0.1 for declaring the interface. ● 0.15 for declaring the constant. ● 0.15 for declaring the abstract method. ● Significant errors are subject to additional penalties.  Section 1.2 (0.8 points) public abstract class AdvancedTyre implements AdvancedTyreInterface {   private double height;  private double temp;   public AdvancedTyre(double height, double temp) {   try {    setHeight(height);   } catch (NegativeNumberException e) {    e.printStackTrace();   }   this.temp = temp;  }   public double getHeight() {   return height;  }   public void setHeight(double height) throws NegativeNumberException {   if (height < 0)    throw new NegativeNumberException("Invalid positive number");    this.height = height;  } }  Evaluation criteria ● 0 if the code makes no sense. ● 0.1 for declaring the class as abstract and implementing the interface. ● 0.1 for declaring the attributes (0 if not declared as private or protected). ● 0.3 if the constructor is OK. If the exception is not caught nor thrown, maximum 0.1 ● 0.3 if the setter and the getter are OK (if the exception is not thrown maximum 0.1). ● Significant errors are subject to additional penalties.   

Section 1.3 (1.2 points) public class SummerTyre extends AdvancedTyre {   private boolean runFlat;  private double wear;   public double calculateOptimumTemp() {    double result;    if (runFlat) {    result = NORMAL_TEMPERATURE * 2.5;   } else    result = NORMAL_TEMPERATURE * wear;    return result;  } }  public class WinterTyre extends AdvancedTyre {   private double snowGrip;   public double calculateOptimumTemp() {    return NORMAL_TEMPERATURE * snowGrip;  } }   public class AllSeasonTyre extends AdvancedTyre {   public double calculateOptimumTemp() {    double result;    if (getHeight() > 50) {    result = 80.3;   } else    result = 75.7;    return result;  } }  Evaluation criteria: ● 0 if the code makes no sense. ● 0.4 for each class (0.1 for declaring the class and the attributes, and 0.3 if the method calculateOptimumTemp is OK). ● Constructors are optional ● Significant errors are subject to additional penalties.      

Section 1.4 (0.8 points)  @Test public void testCalculateOptimumTemp() {   AllSeasonTyre tyre = new AllSeasonTyre(55,    AdvancedTyreInterface.NORMAL_TEMPERATURE);   assertEquals(tyre.calculateOptimumTemp(), 80.3, 0.1);   AllSeasonTyre tyre2 = new AllSeasonTyre(45,    AdvancedTyreInterface.NORMAL_TEMPERATURE);   assertEquals(tyre2.calculateOptimumTemp(), 75.7, 0.1); }  Evaluation criteria ● 0 if the code makes no sense. ● 0.1 for the annotation. ● 0.1 for properly creating the object from class AllSeasonTyre with the right values (or setting them after the creation). ● 0.25 for each call to the method assertEquals (each call will cover one branch of the if-else structure). If the precision argument is missing in calling the method assertEquals, maximum 0.2 for each call. ● 0.1 for creating a second object, or altering the height of the first object in order to test the second branch. ● Significant errors are subject to additional penalties.  Section 1.5 (0.8 points)  @Test public void testSetHeight() {  // Two possibilities:     // Junit4  try {   SummerTyre tyre = new SummerTyre();   tyre.setHeight(-1);   fail("Failed test");  } catch (NegativeNumberException e) {   e.printStackTrace();  }   // JUnit5:   assertThrows(NegativeNumberException.class, ()->{SummerTyre tyre = new SummerTyre(); tyre.setHeight(-1);}); }  Evaluation criteria ● 0 if the code makes no sense. ● 0.1 for the annotation. ● 0.1 for properly creating the object from class SummerTyre. ● 0.2 for setting the height to a value which will throw the exception. ● 0.4 for properly calling assertThrows, or using the try-catch block and calling method fail inside it. ● Significant errors are subject to additional penalties.   

PROBLEM 2 Section 2.1. (1 point)   public class Provider {  private int vat;  private String name;  private String taxAddress;  private Person contactPerson;      public Provider (int vat, String name, String taxAddress, Person c) {   this.vat = vat;   this.name = name;   this.taxAddress = taxAddress;   contactPerson = c;  }  public String toString() { return vat + "|" + name + "|" + taxAddress + "|" + contactPerson.toString();  } }  Evaluation criteria • 0. If the code makes no sense • 0.1 Defines vat, name, taxAddress OK • 0.15 Defines the attribute contactPerson OK • 0.35 Defines constructor OK • 0.1 Defines toString with String as a return type   • 0.2 Implements method toString() well with attributes vat, name and taxAddress • 0.1 Calls attribute contactPerson in method toString() OK Significant errors are subject to additional penalties.  Section 2.2 (1 point)  public class Worker extends Person {    private static int salary = 2000;  private String job;  private final static String WAREHOUSE = "stockman";  private final static String SELLER = "sales";   public Worker (int id, String firstName, String lastName, String email, String job) {  super(id,firstName, lastName, email);  if (!job.equals(WAREHOUSE) && !job.equals(SELLER)) {   job = WAREHOUSE;  }   this.job = job;  }  public String toString() {  return salary + "|" + job + "|" + super.toString();  } }   

Evaluation criteria: • 0 If the code makes no sense • 0.2 Defines attribute job, salary OK • 0.2 Defines WAREHOUSE and SELLER OK • 0.4 Implements constructor OK • 0.2 Assign id, firstName, email OK • 0.2 Assign attribute job OK • 0.2 Defines method toString() well • 0.1 Attributes salary, job • 0.1 Call to method toString() • Significant errors are subject to additional penalties.   Section 2.3 (1 point)  public class DatabaseWarehouse {    public static void main(String[] args) { Person a = new Person(2,"John", "Miller", "john@gmail.com");  Worker t1 = new Worker(1, "Eva","Garcia", "eva@gmail.com","stockman");         Provider c1 = new Provider(3, "Ivan", "Cliente 1",a);    ArrayList<Person> list = new ArrayList<Person>();    list.add(t1);    list.add(c1.getContactPerson());    for (int i=0; i< list.size(); i++) {        System.out.println(list.get(i).toString());          }   } }  Evaluation criteria: • 0.5 Defines all the objects OK  • 0.15 Object Person, • 0.15 Object Worker,  • 0.2 Object Provider • 0.1 Creates ArrayList <Person> OK • 0.1 Adds object Worker to ArrayList OK • 0.1 Adds attribute contactPerson of Provider to ArrayList() OK • 0.2 Implements the method toString(). OK • The toString() in the get(i).toString() is optional (no necessary) • Significant errors are subject to additional penalties.
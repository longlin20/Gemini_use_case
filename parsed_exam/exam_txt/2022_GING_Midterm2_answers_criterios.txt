PROBLEM 1  Section 1.1 (1 point) public int compareTo(Object o) throws ClassCastException, NullPointerException {   int result = 0;   if (o == null)   throw new NullPointerException("null object");   Product product;  try {   product = (Product) o;  } catch (ClassCastException e) {   throw new ClassCastException("Bad product argument");  }   // First compare the names  result = this.getName().compareTo(product.getName());   if (result == 0)   // Now compare the brands   result = this.getBrand().compareTo(product.getBrand());   return result;  }    Evaluation criteria ● 0 if the code makes no sense. ● 0.1 if the signature of the method is correct (throws the exceptions). ● 0.1 if the NullPointerException is thrown. ● 0.15 if casting is OK in method compareTo. ● 0.1 if the exception capture and launch is correct. ● 0.2 if the names are compared correctly. ● 0.2 if the brands are compared correctly. ● 0.05 for each correct return value (equals, lesser, greater). ● Significant errors are subject to additional penalties.  Section 1.2 (1 point) public int countOrders(Person p){       int result = 0;       for(int i=0;i<ordersToProcess.size(); i++){       Order order = ordersToProcess.dequeue();       if (order.getClient().equals(p))    result++;        ordersToProcess.enqueue(order);      }       return result; }    

Evaluation criteria ● 0 if the code makes no sense. ● 0.3 if the queue is traversed correctly. ● 0.25 if the method equals is used to compare. ● 0.25 if the queue remains unaltered at the end of the method (the element can be enqueued or an auxiliary queue can be used).  ● 0.2 if the correct result is returned. ● If the interface methods are not used the highest mark is 0.5. ● Significant errors are subject to additional penalties.  Section 1.3 (1 point) public double getBenefit(){        double result =0;     for(int i=0;i<ordersToProcess.size(); i++){      Order order = ordersToProcess.dequeue();       for(int j=0;j<order.getList().size();j++){     Product p = order.getList().get(j);    result += p.getNumUnits()*(p.getPricePerUnit()-p.getCostPerUnit());        }   ordersToProcess.enqueue(order);     }  return result;   }  Evaluation criteria ● 0 if the code makes no sense. ● 0,2 if the queue is traversed correctly. ● 0,25 if the list of products is traversed correctly. ● 0,2 if the benefit is updated correctly. ● 0.25 if the queue remains unaltered at the end of the method (the element can be enqueued or an auxiliary queue can be used).  ● 0.1 if the correct result is returned. ● If the interface methods are not used the highest mark is 0.5. ● Significant errors are subject to additional penalties.  PROBLEM 2 Section 2.1 (1 point) public boolean isBSTOrNot(LBSNode<E> root, int minValue, int maxValue) {         // check for root is not null or not         if (root == null) {             return true;         }   // check for current node value with left node value and right node value      and recursively check for left sub tree and right sub tree if(root.getKey() >= minValue && root.getKey() <= maxValue &&   isBSTOrNot(root.getLeft(), minValue, root.getKey()) && isBSTOrNot(root.getRight(), root.getKey(), maxValue)){             return true;         }         return false;     }   

Evaluation criteria ● 0 if the code makes no sense. ● 0.1 if the signature of the method is correct. ● 0.4 if check OK the base case ● 0.1 if check OK root.getKey() >= minValue && root.getKey() <= maxValue ● 0.2 if check OK root.left ● 0.2 if check OK root.right ● Significant errors are subject to additional penalties.  Section 2.2 (1 point) public LBSNode<E> search_Recursive(LBSNode root, int key)  {          // Base Cases: root is null or key is present at root          if (root==null || root.getKey()==key)              return root;          // val is greater than root's key          if (root.getKey() > key)              return search_Recursive(root.getLeft(), key);          // val is less than root's key          return search_Recursive(root.getRight(), key);  }  Evaluation criteria ● 0 if the code makes no sense. ● 0.3 if the basic case is OK o 0,15. root == null o 0,15 root.key == key ● 0.35 if the search is OK for one of the branches ● 0.35 if the search is OK for the other branch ● Significant errors are subject to additional penalties.  Section 2.3 (0.75 points) private void inorder_Recursive(LBSNode root) {          if (root != null) {              inorder_Recursive(root.getLeft());              System.out.print(root.getKey() + " ");              inorder_Recursive(root.getRight());          }  }  Evaluation criteria ● 0 if the code makes no sense. ● 0,15 if checks the root ! = null. ● 0,3 if call recursive one branch. ● 0,3 if call recursive the other branch. ● Significant errors are subject to additional penalties.         

Section 2.4 (1.25 points) public class BinaryTreeExample {       public static void main(String[] args) {         // Creating the object of BinaryTree class         BinaryTree<Integer> bt = new BinaryTree<Integer>();         bt.insert(100);         bt.insert(110);         bt.insert(80);         bt.insert(95);         bt.insert(79);          System.out.println(bt.isBSTOrNot());           LBSNode<Integer> find = bt.search_Recursive(bt.getroot(), 95);           if (find!= null)          System.out.println("Find it!!");         else          System.out.println("Not Find it!!!");     } }   Evaluation criteria ● 0 if the code makes no sense. ● 0,1 if BinaryTree() is correctly created ● 0,5 if Tree is correctly created using insert method ● 0,3 if isBSTOrNot() is check and call correctly  ● 0,35 if the number 95 in the tree is correctly searched ● Significant errors are subject to additional penalties.
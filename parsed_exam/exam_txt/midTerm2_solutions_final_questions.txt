Problem 1 (4 / 7 points) The qualifying of the 2019 Spanish Grand Prix in Montmeló will be held tomorrow. The organizers are facing some issues with the timing application and they have asked you to support them in the last minute. You are required to implement the leaderboard with a linked list. This leaderboard will show the names of the drivers in order, according to their fastest lap (in seconds). In order to do that, you are given a partial implementation of the following classes: • Node: Stores the name of the driver and his fastest lap. The node also has a reference to the next node. • Queue<E>: It implements the behavior of a queue. It is already programmed, and it implements the interface QueueInterface<E> • Leaderboard: It implements the list with the drivers’ time. It contains the reference to the first node, a queue to store the lap history (i.e., all the laps in the track) and the size (i.e., number of drivers). Some methods of this class are already implemented.  What follows is the code of the partial implementation of the abovementioned classes. You will be asked to implement some methods, but you cannot implement any additional method. public class Node { private String driver; private double fastestLap; private Node next; public Node(String driver, double fastestlap){     this.driver = driver;      this.fastestLap = fastestlap; }  public double getFastestLap(){     return fastestLap; } public void setFastestLap(double f){     fastestLap = f; } public Node getNext(){     return next;} public void setNext(Node next){     this.next = next; } public String getDriver(){     return driver; } public void setDriver(String dr){     driver = dr; } } public class Leaderboard { private Node first; private Queue<Node> history; private int size;   public Leaderboard(ArrayList<String> drivers){         init(drivers);     history = new Queue<Node>();     size = drivers.size(); } public void init(ArrayList<String> drivers){     // SECTION 1.1  } public void selectionSort(){     // SECTION 1.2 } public void newFastestLap(String driver, double time){        // SECTION 1.3  }   public Node getNode(int pos){...} public void swap(int pos1, int pos2){...} public void print(){...} }    public interface QueueInterface<E> {  void enqueue(E e);  E dequeue(); }  

Section 1.1 (1 point) Implement the method init(ArrayList<String> drivers) of class Leaderboard, which is called in the constructor to initialize the list. This method receives an ArrayList with the name of the drivers who will participate in the Grand Prix. You have to initialize the linked list with the drivers by inserting them one by one at the beginning of the list (first should always point at the last inserted driver). As they do not have completed any lap at the beginning, you can set the fastest lap as the maximum possible time (Double.POSITIVE_INFINITY). After creating the leaderboard, you will have an empty list containing all the drivers with Double.POSITIVE_INFINITY as their time. You can see it in the following example. Note that the word Infinity is automatically printed by Java when printing a double with value Double.POSITIVE_INFINITY. public static void main(String []args){     ArrayList<String> drivers = new ArrayList<String>();     drivers.add("Lewis Hamilton");     drivers.add("Sebastian Vettel");     drivers.add("Valtteri Bottas");     Leaderboard l = new Leaderboard(drivers);     l.print();  } Valtteri Bottas Infinity Sebastian Vettel Infinity Lewis Hamilton Infinity  NOTE: Some of the methods of ArrayList<E>, which may be useful for this section are: • boolean add(E e)  • E get(int index)  • int indexOf(Object o) 	• int size() 	 Section 1.2 (1.5 points) Implement the method selectionSort(). This method sorts the list of drivers according to their fastest lap using the Selection Sort algorithm. This method should use the version of the Selection Sort algorithm which sorts in ascending order (from lowest time to highest time, that is from fastest driver to slowest driver), searching for the fastest driver in the unsorted part of the array and swapping it with the first unsorted element. You can use the already implemented methods getNode(int pos) and swap(int pos1, int pos2) to get the node in a specified position, and swap two nodes given their positions, respectively. NOTE: You do not need to implement getNode(int pos) and swap(int pos1, int pos2)  Section 1.3 (1.5 points) Implement the method newFastestLap(String driver, double time). This method sets the new fastest lap of the driver and updates the classification. In order to do that, the driver is searched in the list. If the driver is found, his new time is compared with his best time (as it is stored in the Node). If the new time is lower than the stored time, the stored time will be updated with the new time. In that case, you also need to internally call the selection sort method programmed in Section 1.2 to update the overall classification. Moreover, you need to (create and) add an independent node with the driver and his time to the history queue which keeps a record with all the laps in the track. You need to add this node no matter if the driver’s time is better or not, but only if the drive is found in the list. What follows is an example of calls to this method in the main method: l.newFastestLap("Valtteri Bottas", 100.456); l.newFastestLap("Lewis Hamilton", 100.324); l.newFastestLap("Valtteri Bottas", 100.399); l.newFastestLap("Valtteri Bottas", 100.321); l.newFastestLap("Sebastian Vettel", 100.399); l.print(); Valtteri Bottas 100.321 Lewis Hamilton 100.324 Sebastian Vettel 100.399  

Problem 2 (3 / 7 points) A good friend of ours requests our help as engineers to help him to win a game. The game consists of visiting different cities and collecting treasures which are inside chests. Our friend is looking for an algorithm to compute the optimal path along the cities to achieve the maximum number of treasures/chests. For this purpose, a tree data structure has been defined. The root of this tree is the city where the player starts at the beginning of the game and the rest of the nodes represent the cities of the map where the player can go afterwards. An example of the tree can be seen here: 
 The expected output of the algorithm for this tree is: Tilted Towers – Greasy Grove – Fatal Fields Notice that this path achieves the maximum possible number of chests for this tree: 18. To model the cities, the class City has been implemented. This class has four attributes: (1) name, (2) number_chests,  (3) option1 and (4) option2. Attribute name represents the name of the city (e.g., “Tilted Towers”),  number_chests stores the number of chests/treasures that can be found in the city. Finally, option1 and option2 store the subtrees which can be followed.  Moreover, there is a class CityTree to model the trees, which only contains the reference to the root. This root is the starting city of the player, which is used to build the tree upon it.  public class City { private String name; private int number_chests; private CityTree option1, option2;  public City(String name, int chests){       this.name = name;      this.number_chests = chests;  }  public String getName() {      return name; } public int getNumber_chests() {      return number_chests; }  public CityTree getOption1() {        return option1; } public void setOption1(CityTree opt1) {       this.option1 = opt1; } public CityTree getOption2() {       return option2; } public void setOption2(CityTree opt2) {       this.option2 = opt2; }  } public class CityTree { private City root;  public CityTree(String name, int number_chests){      this.root = new City(name,number_chests); }  public void insert(CityTree subtree, int option){     if(root==null) return;     if(option==1){         this.root.setOption1(subtree);     } else if (option==2){         this.root.setOption2(subtree);     } }  public int maximumChests(){     if(root==null){ return 0; }     if(root.getOption1()!=null && root.getOption2()!=null){         return root.getNumber_chests() +              Math.max(root.getOption1().maximumChests(),                        root.getOption2().maximumChests());     } else { return root.getNumber_chests(); } }  public String computeOptimal(){ //Section 2.2 } public static void main(String args[]){ //Section 2.1 }  } 
Tilted Towers
Greasy Grove
Fatal Fields
Flush Factory
Loot Lake
Pleasant Park
Haunted Hills  10 chests 5 chests 4 chests 3 chests 3 chests 1 chest 1 chest

Section 2.1 (1.5 points) We will have to show our friend how the program works. He knows how to compile and run Java programs, but he does not really understand the Java programming language. For this reason, you need to write a main method which creates the tree shown in the figure above and prints the optimal path (you can use the method computeOptimal() as it were already implemented).  Section 2.2 (1.5 points) Implement the method computeOptimal(). This method returns in a String the optimal route (the one with a higher number of chests). You can use the already-implemented method maximumChests() which returns the maximum number of chests that can be achieved in a certain tree. You must use recursion in the implementation of the method. NOTE: Check the implementation of the method maximumChests(). Notice that we only consider cities which either have 2 options or 0 options (but they can never have just one option). Assume this fact as true to solve this problem.           

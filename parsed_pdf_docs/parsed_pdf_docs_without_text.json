[{"filename": "10 en calario-ObjectOrientedProgramming.pdf", "pages_description": ["Overview\n\nThis slide presents an overview of key object-oriented programming concepts. The six concepts listed are: Objects and Classes, Object encapsulation, Message passing, Overloading, Constructors, and Modifiers and access. \n", "1. Objects and Classes\n\nOn the left side, there is a gray box with the word \"class\" at the top and a dotted outline of a car labeled \"Car\" inside. On the right side, there is another gray box with the word \"objects\" at the top and three filled-in car outlines inside. The top car is green and labeled \"Mercedes,\" the middle car is blue and labeled \"BMW,\" and the bottom car is orange and labeled \"Audi.\" \n", "Objects\n\nComputational representations of simple or complex, real or imagined things. Some examples are: car, clock, airplane, bird, and so on. Some things are simply characteristics of the objects, for example, a car's color, speed, and number of wheels. Objects have concrete values for their characteristics. For example, a car might have the color red, a speed of 90, and four wheels. \n", "Objects and classes\n\nObjects are sets of related data (state) and functionality (behavior). Classes are blocks of code which include attributes and methods. Attributes are variables used to store the state of objects of the same type. Methods are functions used to carry out the behavior of objects of the same type.\n\nThere are two boxes, one labeled \"class\" and the other labeled \"objects.\" The \"class\" box contains the outline of a car with the label \"Car\" inside. The \"objects\" box contains three filled-in cars, one green, one blue, and one orange. The green car is labeled \"Mercedes,\" the blue car is labeled \"Bmw,\" and the orange car is labeled \"Audi.\"\n", "Objects and classes\n\nCreating a new class means creating a new data type. There are two types of data types: primitive data types, which are not classes, and non-primitive data types, which are classes. Primitive data types include integers, booleans, characters, and doubles. Non-primitive data types include strings, integers, doubles, booleans, and cars.\n\nCreating a new object from a class is called instantiation. Objects are instances of classes. Classes are the pattern to create objects.\n\nClasses are stored in files with the extension \".java\". The file name must be the same as the class name. Objects are stored in the memory of our program and only exist in runtime.\n", "Objects: functional and data abstractions\n\nWe have two types of abstractions: functional abstraction and data abstraction. Functional abstraction refers to the things the object does, its behavior. For example: move forward, move backwards, turn left, turn right, speed up, brake, refuel, and so on. Data abstraction refers to the properties of the object, its state. For example: color, brand, maximum speed, number of wheels, number of doors, fuel, and so on. \n", "Example\n\nThe image shows an example of a class and objects in programming.\n\nOn the left side, we have the definition of a class named \"Car\". This class has:\n- 3 private attributes: color (String), speed (int), and size (float).\n- 1 constructor that takes the color, speed, and size as input and initializes the corresponding attributes.\n- 5 public methods: advance(), stop(), turnLeft(), turnRight() (all of which have empty implementations), and a constructor.\n\nOn the right side, we have the instantiation of 3 objects from the \"Car\" class:\n- myCar: with color \"green\", speed 80, and size 3.2f.\n- yourCar: with color \"red\", speed 120, and size 4.1f.\n- hisCar: with color \"yellow\", speed 100, and size 3.4f.\n\nThe example also highlights three important concepts:\n- The \"new\" keyword is used to create new instances of a class.\n- The \"this\" keyword refers to the current object.\n- The \"public\" and \"private\" keywords are access modifiers that control the visibility and accessibility of class members.\n", "Exercise 1\n\nWe need to implement a class named \"Bicycle\". It has three attributes: speed, cadence, and gear, all of which are integers. The class has four methods: \"speedUp\", which doubles the current speed, \"brake\", which halves the current speed, \"setCadence\", which takes an integer argument and sets the cadence to that value, and \"setGear\", which takes an integer argument and sets the gear to that value. The class must also have a constructor that initializes all three attributes. Finally, we need to create two objects of this class: \"myBicycle\" and \"yourBicycle\". \n", "2. Object encapsulation\n\nObjects bundle data and methods together. Methods are used to operate on that data. Direct access to some parts of the object are restricted. Private attributes and methods cannot be accessed directly (information hiding). Public methods (public interface) allow accessing private data and methods. We don't need to know the internal implementation of the private part. The private part can change as long as the public interface remains.\n\nThere is a diagram showing an object with public methods, private data, and private methods. The public methods interact with an interaction interface. \n", "2. Object encapsulation\n\nMethods are typically public. Methods for internal use only can be private. Attributes are typically private. It is dangerous to have public attributes.\n\nThere is a diagram showing an object and an interaction interface. The object contains public methods, private data and private methods. The interaction interface interacts with the object through its public methods.\n", "3. Message passing\n\nAn object sends a message to another object by calling a method of the public interface of the receiving object. The receiving object will then: change its state by modifying its attributes, call public or private methods of the same object, or send a message to another object.\n\nA diagram shows two objects, object A and object B. Object A is sending a message to object B. Object A is labeled \"sending object\" and object B is labeled \"receiving object.\" \n", "Example Class Car\n\nWe have three classes: Car, Engine and Wheel. The Car class has private String color, int speed, float size, Wheel array wheels and Engine engine. The Car constructor takes color, speed, size, wheels and engine as parameters. The advance method calls injectFuel on the engine object and then iterates through the wheels array calling turn on each wheel. The main method creates a Wheel array with four new Wheel objects and a Car object with \"green\" color, 80 speed, 3.2f size, the wheels array and a new Engine object with \"Diesel\" type and 100 hp. The Engine class has private String type and int hp. The Engine constructor takes type and hp as parameters. The injectFuel method is empty. The Wheel class has private double diameter and public String manufacturer. The Wheel constructor takes diameter and manufacturer as parameters. The turn method is empty. \n", "4. Overloading\n\nTwo methods with the same name can be defined in the same class if they have different parameters. It is widely used for constructors. The method actually executed depends on the parameters passed when it is called.\n\nWe see an example of three methods, all named \"add\". The first method takes two integer parameters and returns their sum. The second method takes three integer parameters and returns their sum. The third method takes four integer parameters and returns their sum as a float. \n", "Example\n\nWe have a class named Car. The class has private attributes: color as String, speed as integer, and size as float. \n\nThe class has a constructor that takes color, speed and size as parameters and sets the attributes of the class to the given values.\n\nThe class has several methods named advance. These methods have the same name but different parameters. This is called overload. \n\nThe first advance method doesn't take any parameters. The second one takes an integer called meters as a parameter. The third one takes two integers as parameters: meters and speed.\n\nThe class also has three other methods: break, turnLeft and turnRight. They don't take any parameters.\n\nWe also have some objects. We define myCar object of type Car with \"green\" color, 80 speed and 3.2f size. \n\nWe define another object, yourCar, of type Car with \"red\" color, 120 speed and 4.1f size. \n\nAnd finally, we define another object, hisCar, of type Car with \"yellow\" color, 100 speed and 3.4f size.\n\nThen we call the advance method on each of these objects. For myCar, we call the advance method without any parameters. For yourCar, we call the advance method with 1000 as parameter. And for hisCar, we call the advance method with 1000 and 120 as parameters.\n", "Exercise 2\n\nIn the class Bicycle, implement the overloaded methods setCadence() and setGear(), which do not receive arguments and change the values of cadence and gear to one value by default: 1. \n", "5. Constructors\n\nWhen an object is created, its members are initialized using a constructor method. Constructors have the same name as the class. They have no return type, not even void. At least one constructor should be defined per class. \n", "Example\n\nWe have a class named Car. The class has three private attributes: String color, int speed, float size. There is a constructor that takes color, speed and size as input and sets the attributes of the class to these values. In the main function, we are creating three instances of the Car class: myCar, yourCar and hisCar. Each of these instances is created with different values for color, speed and size. \n", "5. Constructors\n\nSeveral constructors can exist, this is called overloading. They are distinguished by their parameters. If no explicit constructor is defined, then there is a default constructor without parameters. It initializes the attributes to their default values. If a constructor is defined, the default constructor no longer exists. \n", "Example\n\nThe code shows an example of overloaded constructors in object-oriented programming. \n\nThe class \"Car\" has three private attributes: \"color\" of type String, \"speed\" of type integer, and \"size\" of type float. \n\nThe class has four public constructors: \n- The first constructor takes no arguments. \n- The second constructor takes one argument, a String representing the color, and initializes the \"color\" attribute. \n- The third constructor takes two arguments, a String for the color and an integer for the speed, and initializes the \"color\" and \"speed\" attributes. \n- The fourth constructor takes three arguments, a String for the color, an integer for the speed, and a float for the size, and initializes the \"color\", \"speed\", and \"size\" attributes. \n\nThe class also has four public methods: \"advance\", \"brake\", \"turnLeft\", and \"turnRight\", all of which take no arguments and have no return type. \n", "Exercise 3\n\nIn the class \"Bicycle\", implement an additional constructor, which does not receive arguments, and that initializes the speed to 0, and the cadence and gear to 1. \n", "6. Modifiers and Access: static\n\nStatic members exist only once per class, independently of the number of instances of the class that have been created. They exist even if no instances have been created yet.\n\nThe value of static attributes is shared by all objects. Changing it for one object affects all the others.\n\nStatic methods do not depend on attributes, although they might depend on input parameters.\n\nStatic elements can be accessed using the class name. However, a static method cannot access non-static members directly. An object must be created first. \n", "6. Modifiers and Access: static\n\nStatic attributes\n\nLet's see an example of static attributes in Java. We have a class named Car with private String color, private int speed, private float size and private static int numberOfWheels equals 4. This is a static attribute. Then we have a public static void main method that prints Car.numberOfWheels. \n\nOther examples are int radium equals 3, double areaCircle equals Math.PI multiplied by radium, multiplied by radium, int minValue equals Integer.MIN_VALUE and int maxValue equals Integer.MAX_VALUE. \n", "Modifiers and Access: static\n\nA static method has access to static attributes and we do not need to create instances.\n\nExample of a static method:\n- It is a public static method that returns void and takes an array of strings as arguments.\n- It declares an integer variable x1 and assigns it the value of the first argument parsed as an integer.\n- It declares a double variable y1 and assigns it the value of the second argument parsed as a double.\n\nOther examples of static methods are:\n- Math.sqrt(100)\n- Math.cos(76)\n\nThe source of the examples is the Java documentation for the Math class.\n", "Modifiers and Access: static\n\nStatic members are invoked with: ClassName.staticMethod(); and ClassName.staticAttribute; Non-static members require an instance (object) in order to be accessed. They are invoked with: objectName.normalMethod(); and objectName.normalAttribute; When a static member is invoked within the same class, the class name can be deleted: staticMethod(); and staticAttribute; instead of: ClassName.staticMethod(); and ClassName.staticAttribute;\n", "6. Modifiers and Access: public/private\n\nThis slide explains the concepts of public and private modifiers in programming. \n\nIt is divided into two sections: public and private.\n\nThe public section states that public attributes, methods, and classes are visible from any other class. It also mentions that each public class needs to be in a separate file with the same name as the class.\n\nThe private section states that private attributes, methods, and classes are visible only within the class. It also mentions that private classes are rarely used as inner classes inside a file with another public class.\n\nThere is an image of two signs, one pointing to the left saying \"Public\" and the other pointing to the right saying \"Private\". \n", "6. Modifiers and Access: methods get/set\n\nThis slide explains the concept of getter and setter methods in object-oriented programming.\n\nIt starts by stating that public methods can be used to control access to private attributes. This means that instead of allowing direct access to an object's internal data, we can use public methods to retrieve or modify that data. This approach provides a layer of abstraction and allows for better control over how the data is accessed and modified.\n\nThe slide then introduces the concept of \"get/set methods\", also known as getters and setters. These methods are specifically designed to get (retrieve) and set (modify) the values of private attributes.\n\nTo illustrate this concept, the slide provides a code example in the form of a \"Car\" class. This class has two private attributes: \"color\" of type String and \"speed\" of type int. The class also includes four public methods: \"getColor()\", \"setColor()\", \"getSpeed()\", and \"setSpeed()\".\n\nThe \"getColor()\" method is a getter method that returns the value of the \"color\" attribute. The \"setColor()\" method is a setter method that takes a String argument and sets the \"color\" attribute to the value of the argument. Similarly, the \"getSpeed()\" method returns the value of the \"speed\" attribute, and the \"setSpeed()\" method sets the \"speed\" attribute to the value of an integer argument.\n\nThe use of getter and setter methods is a common practice in object-oriented programming as it promotes encapsulation and data hiding, which are important principles for building robust and maintainable software.\n", "Exercise 4\n\nIn the class Bicycle, implement the necessary get() and set() methods which allow accessing and modifying all the attributes. \n"]}, {"filename": "9 en calario-Errors.pdf", "pages_description": ["Overview\n\nThe slide titled \"Overview\" outlines two main topics: syntax errors and error correction.  Error correction is further broken down into four sub-topics: hand tracing, extra code, assertions, and Eclipse Debugger. \n", "1. Syntax errors\n\nThe slide shows a dialog box titled \"ERROR\" with the message \"Syntax error....I think\" and an \"OK\" button. \n", "Examples of basic syntax errors (1)\n\nThe image shows three examples of basic syntax errors. The first example is an assignment vs. boolean expression error. The code shows an if statement with the condition \"x=0\" in parentheses. This is an assignment, not a boolean expression. The comment to the right of the code \"// if(x==0)\" shows the correct boolean expression to use. The second example is a missing curly brackets error. The code shows an if statement with no curly brackets. This means that only the first statement after the if statement will be executed if the condition is true. The comment to the right of the code \"//statement 2 is always executed\" indicates that the second statement will always be executed, regardless of whether the condition is true or false. The third example is a missing operators error. The code shows a System.out.println statement that is missing a plus operator (+) between the string \"Value:\" and the variable x. The comment to the right of the code \"//+ missing\" indicates that the plus operator is missing. \n", "The compiler (sometimes) warns us (1)\n\nWe have three code snippets, each with a different type of error.\n\nThe first snippet shows a type mismatch error, where an integer (x=0) is used in an if statement instead of a boolean (x==0).\n\nThe second snippet shows a logical error, where the second statement is always executed because the if statement is not enclosed in curly braces.\n\nThe third snippet shows a syntax error, where the plus sign is missing in the System.out.println statement. \n", "Examples of basic syntax errors (II)\n\nThis slide shows an example of a basic syntax error in Java. The code snippet shows a variable declaration \"int Var=0;\" followed by an if statement \"if(var==0) { statement; }\". Then a string variable declaration \"string s = \u201cHello\u201d;\". Below the code snippet, there are two comments about Java conventions. The first one says: \"By agreement, variables and methods start with lowercase, and classes with capital letters\". The second one says: \"Primitive data types must be written with lowercase\".  The error in the code is in the if statement, where the variable \"var\" is used with a lowercase \"v\", while it was declared with an uppercase \"V\". This is a syntax error because Java is a case-sensitive language, as mentioned in the title of the slide. \n", "The compiler (sometimes) warns us (II)\n\nWe have two examples of compiler warnings. The first one reads \"Line nn: 'var' cannot be resolved to a variable\". The code shows a variable declaration of type integer: \"int Var=0;\". Then, we have an if statement: \"if(var==0) { statement; }\".\n\nThe second example reads \"Line nn: 'string' cannot be resolved to a type\". The code shows a string variable being declared and initialized with the value \"Hello\": \"string s = \"Hello\";\". \n", "Examples of syntax errors in methods\n\nThere are two code snippets, both showing syntax errors in methods.\n\nThe first snippet shows a method with the signature \"public boolean method()\". This method has no return statement, which is a syntax error because it is declared to return a boolean value.\n\nThe second snippet shows a method with the signature \"public boolean method(int a)\". This method has a return statement inside an if statement. However, if the condition in the if statement is not met, the method will not return any value, which is a syntax error because it is declared to return a boolean value.\n\nThe note at the bottom states that a return value must be provided if the condition is not met.\n", "The compiler in Eclipse\n\nThe slide describes two features of the compiler in Eclipse. First, Eclipse compiles automatically as we write and when we save. Second, Eclipse provides quick fixes. For example, in the code snippet, the variable \"result\" is not declared. The Eclipse IDE shows an error and suggests different quick fixes such as creating a local variable, a field, or a parameter named \"result\". It also suggests removing the assignment or changing the variable in the assignment to \"val1\" or \"val2\". Finally, it suggests renaming \"result\" in the file. The slide stresses that we should use quick fixes carefully. \n", "Errors affecting multiple lines\n\nThis slide is about errors that affect multiple lines of code. Sometimes there are no quick fixes for these errors. If you are sure a line is correct, an error in another line might be affecting the overall structure of the program.\n\nThe slide contains an image of a code editor. The code is as follows:\n\n```java\npublic class Example1 {\n  public boolean method(int a, b){\n    return true;\n  }\n}\n```\n\nThere are three red Xs next to lines 3, 4, and 7. This indicates that there are errors on these lines. The error on line 4 is highlighted in pink. This indicates that this is the current line being edited. \n", "Errors closing curly brackets\n\nWe have a slide titled \"Errors closing curly brackets\". The slide shows two code snippets, both containing a syntax error. The slide explains that proper code indentation helps to identify this kind of error. It also shows the keyboard shortcuts to trigger code indentation on PC and Mac. In the first code snippet, the closing curly bracket for the class declaration is missing. The second code snippet shows the same code, but properly indented, which makes it easier to spot the missing curly bracket. \n", "Exercise 1\n\nThe image shows a slide titled \"Exercise 1\" with an exercise about fixing syntax errors in a Java code snippet. The code is supposed to calculate the average value of numbers entered by the user. The user is first asked to enter the number of elements, then prompted to enter each element. The code then calculates the sum of the elements and divides it by the number of elements to get the average. Finally, the average value is printed to the console. \nThe code contains several syntax errors that need to be fixed. \n- The variable 'i' in the for loop is not declared. \n- The variable 'average' in the last print statement is not capitalized, which doesn't match the variable declaration. \n- There's a missing '+' sign between the string \"is : \" and the variable 'average' in the last print statement. \n", "Execution errors (1)\n\nThe code compiles, but the result is not as expected. We have a snippet of Java code that declares two strings, a and b, both initialized with the value \"Hello\". Inside an if-else block, it checks if a is equal to b using the \"==\" operator. If true, it prints \"a and b are equal\", otherwise, it prints \"a and b are different\". The code highlights that strings are compared with the \"equals\" method, implying that using \"==\" might lead to unexpected results. \n", "Execution errors (II)\n\nThe code compiles, but the program crashes. This slide shows an example of a Java code with an execution error. The code defines a class named \"Example\" with two methods: \"divide\" and \"main\". The \"divide\" method takes two integers as input and returns their division. The \"main\" method calls the \"divide\" method with the arguments 3 and 0 and stores the result in a variable named \"result\". Then, it prints the value of \"result\" to the console. \n\nHowever, when the code is executed, it throws an ArithmeticException with the message \"/ by zero\" because dividing by zero is not allowed in Java. The exception occurs in the \"divide\" method at line 3 and is caught in the \"main\" method at line 6. \n", "Execution errors (III)\n\nThe image shows a code snippet with a title \"Execution errors (III)\" and point number 2 \"Use of try-catch block to handle Exceptions\". The code is an example of how to handle exceptions in Java. The code defines a class called \"Example\" with two methods: \"divide\" and \"main\". The \"divide\" method takes two integers as input and returns the result of dividing the first integer by the second integer. The \"main\" method is the entry point of the program. It first calls the \"divide\" method with the values 3 and 0. This will result in an ArithmeticException being thrown because you cannot divide by zero. The \"try\" block catches this exception and prints an error message to the console. \n", "2. Error correction\n\nThe image shows the word \"Error\" being erased from a piece of lined paper. The eraser is attached to the end of a red pencil. \n", "2.A. Hand tracing (1)\n\nWe have a java program that calculates the integer division of two numbers and a table to hand trace the values of the variables during the execution of the program. The program first checks if the divisor is not zero. If it is not, it initializes two variables, x and y, with the dividend and zero respectively. Then, it iterates while x is greater than the divisor, subtracting the divisor from x and incrementing y in each iteration. Finally, it returns the value of y. If the divisor is zero, the program throws an exception. The table has four columns, one for each variable (m, n, x, y). The first row of the table contains the initial values of the variables: m=12, n=3, x=12, y=0. The second row of the table contains the values of the variables after the first iteration of the while loop: m=12, n=3, x=9, y=1. The third row of the table contains the values of the variables after the second iteration of the while loop: m=12, n=3, x=6, y=2. The fourth row of the table contains the values of the variables after the third iteration of the while loop: m=12, n=3, x=3, y=3. The last row of the table shows the equation y*n + x = m. \n", "2.A. Hand tracing (II)\n\nWe have a java program that calculates the integer division of two numbers. The program first checks if the divisor is not zero. If it is, it throws an exception. Otherwise, it initializes two variables, x and y, to the dividend and zero, respectively. Then, it enters a while loop that continues as long as x is greater than or equal to the divisor. Inside the loop, x is decremented by the divisor, and y is incremented by one. Finally, the program returns the value of y.\n\nOn the right side of the image, we have a table that shows the values of the variables m, n, x, and y at each iteration of the while loop. The table shows that the program correctly calculates the integer division of 12 by 3, which is 4. The last row of the table shows the final values of the variables after the loop has finished executing.\n\nFinally, we have an equation that shows the relationship between the variables y, n, x, and m. The equation states that the product of y and n plus x is equal to m. This equation is true because the program calculates the integer division of m by n, which is equal to y, with a remainder of x. \n", "Exercise 2\n\nWe have a Java program that calculates the factorial of a number. The program defines a method called \"fac\" that takes an integer as input and returns a long. The method first checks if the input is greater than 0. If it is, it calculates the factorial of the input using a for loop and returns the result. If the input is not greater than 0, the method throws an exception. The main method then calls the \"fac\" method with the input 12 and prints the result. If an exception is caught, the program prints an error message to the console. \n", "Extra code\n\nThe code snippet shows a Java program that demonstrates exception handling. The program defines a method called \"intDiv\" that takes two integers as input and returns the result of dividing the first integer by the second integer. The method throws an exception if the second integer is zero. The main method of the program calls the \"intDiv\" method with the values 12 and 3. The program then prints the result of the division. If an exception is thrown, the program catches the exception and prints an error message.\n\nThe code also includes two print statements within the \"intDiv\" method, before and inside the while loop, to print the values of variables \"x\" and \"y\" during each iteration. The output of these print statements is shown on the right side of the image, indicating the values of \"x\" and \"y\" at different stages of the loop execution. \n", "Exercise 3\n\nWe have a piece of Java code that aims to determine if a given number is a prime number. The code defines a function called \"checkPrime\" that takes an integer as input and returns a boolean value. The function first checks if the input is less than or equal to 0. If it is, it returns false. Otherwise, it iterates through all the numbers from 2 to half of the input number. For each number, it calculates the remainder of the division between the input number and the current number. If the remainder is 0, it means that the input number is divisible by the current number, so it's not a prime number, and the function returns false. If the loop finishes without returning false, it means that the input number is not divisible by any number from 2 to its half, so it's a prime number, and the function returns true.\n\nThe main function then calls the \"checkPrime\" function with different inputs (0, 1, 4, 6, and 11) and prints the results to the console. \n\nThe output of the code shows that the function incorrectly identifies the number 4 as a prime number. \n", "2.C. Assertions\n\n- Statements to test assumptions (assert)\n    - assert booleanExpression;\n    - assert booleanExpression:value;\n- If the boolean expression is false, an AssertionError is thrown with the value\n- Errors, unlike Exceptions, should not be caught\n", "2.C. Assertions\n\nWe see a code snippet written in Java. The code defines a class named \"Example_\" with two methods: \"intDiv\" and \"main\".\n\nThe \"intDiv\" method takes two integer arguments, \"m\" and \"n\", and is designed to perform integer division of \"m\" by \"n\". It first checks if \"n\" is not equal to zero. If this condition is true, it initializes two integer variables, \"x\" to the value of \"m\" and \"y\" to zero. It then enters a while loop that continues as long as \"x\" is greater than \"n\". Inside the loop, it subtracts \"n\" from \"x\" and increments \"y\" by one.\n\nThere are two assertions in the code. The first one, \"assert y * n + x == m\", checks if the result of the division is correct. This assertion is placed inside the while loop, after updating the values of \"x\" and \"y\".\n\nThe second assertion, \"assert x < n : x\", checks if the remainder of the division is less than the divisor \"n\". This assertion is placed after the while loop. If this condition is not met, it means that the division was not performed correctly.\n\nIf \"n\" is equal to zero, the method throws an exception.\n\nThe \"main\" method is the entry point of the program. It calls the \"intDiv\" method with arguments 12 and 3, and prints the result to the console. If an exception is thrown, it catches it and prints an error message to the console.\n\nWhen the code is executed, it throws an \"AssertionError\" because the first assertion, \"assert y * n + x == m\", fails. The error message indicates that the assertion failed on line 11 of the \"Example_.java\" file, which is the line where the first assertion is located. The error also indicates that the \"main\" method was called from line 19 of the same file. \n", "2.C. Assertions\n\nAssertions are normally ignored while running the program. We need to configure the JVM with \"-ea\" before running the program. Run configurations, arguments, then VM arguments. In the VM arguments field, we have \"-ea\". \n", "2.D. Eclipse Debugger\n\nRunning the program step by step tracking the values of variables:\n1. Set a breakpoint in the line you want the program to stop (double click on the number of the line)\n2. Run the program with the option \u201cDebug as\u201d => \u201cJava application\"\n3. The new \"Debug\" view opens\n", "2.D. Eclipse Debugger\n\nThe code is in a debugging state. A breakpoint is set at line 6 inside a method called \"intDiv\". This method takes two integers, m and n, as input and is supposed to return an integer value. It throws an exception if the input n is zero. \n\nThe current values of the variables are: m = 12, n = 3, x = 12, and y = 0.\n\nThe left panel shows the call stack with \"intDiv\" method being called from the \"main\" method. The right panel shows the list of methods in the \"Example\" class, including \"intDiv\" and \"main\". The bottom panel is the console. \n", "2.D. Eclipse Debugger\n\nThis slide describes the different actions that can be performed in the Eclipse debugger. The actions are: Resume, which continues running the program until the next breakpoint or the end of the program. Terminate, which forces the termination of the program. Step into, which executes the next line, and if it is a method call, goes into the first line of the method. Step over, which executes the following line, and if it is a method call, executes it completely. Finally, Step return, which executes the rest of the current method returning the control to the calling method. Each action is represented by an icon. \n", "Exercise 4\n\nThe following code calculates the greatest divisor of a random number between 1 and 100. Run it several times and try to detect the error using the Eclipse debugger.\nThe code is as follows:\n```java\npublic class Example4 {\npublic static void main(String[] args) {\nint t = (int) (Math.random() * 100) + 1;\nSystem.out.println(\"The number is: \"+t);\nint result = 1;\nfor(int i =t/2; i>1; i--){\nif(t%i==0)\nresult = i;\ni = 1;\n}\n}\n}\nSystem.out.println(\"The greatest divisor is: \"+result);\n```\n", "Summary\n\nErrors will always happen, but we need to try to detect and correct them. The compiler helps us to detect some syntax errors. Execution errors are critical as they end the program. Hand tracing and adding extra code are not elegant/efficient solutions. If you have errors use the Eclipse debugger. \n"]}, {"filename": "5 en.pdf", "pages_description": ["Methods, Scope\n\nWe see two sets, X and Y. Set X contains the elements 1, 2, and 3. Set Y contains the elements a, b, c, and d.  There are arrows pointing from element 1 in set X to element d in set Y, from element 2 in set X to element d in set Y, and from element 3 in set X to element c in set Y. The author of this presentation is Carlos Delgado Kloos from Universidad Carlos III de Madrid. \n", "From the Calculator to the Computer\n\nThe image shows the evolution from a calculator to a computer, highlighting the differences in how they handle values, expressions, and statements.\n\nOn the left, a calculator displays the value \"36\". \n\nIn the center, another calculator shows the expression \"3 x 12\".\n\nOn the right, a more complex device, representing a computer, presents the statement \"x = x * 12;\". This statement assigns the result of the calculation \"x * 12\" back to the variable \"x\".\n\nEach device has buttons labeled \"C\" and \";\", likely representing \"Clear\" and \"Enter\" or similar functions. Additionally, the computer has buttons labeled \"set\" and \"get\", suggesting the ability to store and retrieve values.\n\nThe image emphasizes the increasing complexity and capability from a simple calculator to a computer, highlighting the fundamental difference between evaluating expressions and executing statements.\n", "The image shows a calculator with a display at the top and a keypad at the bottom. \n\nThe display shows \"d = 0\" on the first line and \"C\" and \";\" on the second line. The \"C\" and \";\" are inside separate yellow boxes.\n\nThe keypad has the digits 0 to 9, the four arithmetic operators, a decimal point, and a divide symbol. The operators and the divide symbol are in orange boxes. There is also a blue square button to the right of the keypad with the letter \"f\" in it. \n", "Method Definition\n\nWe have a method definition for a method called \"square\". The method takes an integer as input and returns an integer as output. The method calculates the square of the input integer and returns the result. \nThere is a diagram showing the input and output of the method. The input is an integer and the output is also an integer. The method is represented by a blue box with the name \"square\" inside. \nThe code for the method is written in a programming language. The code first declares the method signature, which includes the method name, input parameters, and return type. Then, the code defines the method body, which contains the logic for calculating the square of the input integer. The return statement specifies the value that will be returned by the method. \n", "Method Definition\n\nThe image describes the structure of a method definition. A method definition consists of a method header and a method body. The method header specifies the result type, the method name, and the parameter type. In this example, the result type is \"int\", the method name is \"square\", and the parameter type is \"int x\". The method body contains the code that is executed when the method is called. In this example, the method body contains a single statement that returns the value of \"x*x\". The input to the method is an integer \"x\" and the output of the method is an integer representing the square of \"x\". \n", "Method Name\n\n- Recommendations for method names\n- Initial small letter\n- Verb: move\n- Phrase: isEmpty\n- For understanding purposes, it should have a meaning \n", "Parameter Names\n\nThis method gets an integer, which we will call x, and will return an integer by multiplying x*x. Let's call this method square. The code snippet shows the method signature: int square (int x) and inside the body of the method, the return statement: return x*x;  A blue arrow goes from the word square to the word int, above the code snippet. A red arrow goes from the x in the method signature to the x in the box below. The box is labeled square and has x*x inside. There are downward arrows from the word int above the box to the x in the box and from the x*x to the word int below the box. A blue arrow goes from the return statement to the word int below the box. \n", "Consistent Substitution\n\nThis method gets an integer, which we will call Y, and will return an integer by multiplying Y*Y. Let's call this method square. There is a blue arrow pointing from the word \"square\" to the word \"int\" above a blue box. Inside the box, there is a red arrow pointing to the letter \"Y,\" the word \"square,\" and \"Y*Y.\" Below the box, there is a red arrow pointing from \"Y*Y\" to the word \"int.\" \n", "Parameter: Placeholder\n\nThis slide explains the concept of a parameter as a placeholder. The text states that this method gets an integer and will return an integer by multiplying it by itself. The method is called \"square\". There is a blue rectangle with the word \"square\" in it, which represents the method. There are two red arrows pointing from the word \"int\" in the code to the blue rectangle, indicating that the integer is passed as a parameter to the method. There are also two red arrows pointing from the multiplication symbol in the code to the blue rectangle, indicating that the multiplication operation is performed within the method. Finally, there is a red arrow pointing from the word \"return\" in the code to the blue rectangle, indicating that the result of the multiplication is returned by the method. \n", "One Parameter\n\nWe have a function definition for a function called square. The function takes an integer as input and returns an integer as output. The function squares the input value. There is a diagram showing the input and output of the function. The input is an integer and the output is an integer. The function is represented by a blue box with the word \"square\" in it. \n", "Exercise 1\n\nCreate a new Java class that contains the method \"int square (int x)\", which returns the square of the parameter received.\n\nIt also contains a main method that calls the method square, you need to add \"public static\" in the method signature of square, and prints the result on the screen.\n\nThe value for which the square is calculated will be an input argument to the program. Collect this argument in the main method in \"args\" and transform it to an int with \"Integer.parseInt()\". \n", "More Parameters\n\nWe have a function named \"average\" that takes two integer parameters, x and y, and returns their product as an integer. \n", "Exercise 2\n\nCreate a new Java class that contains the method: double average (double x, double y), which returns the average of the two parameters received. It also contains a main method that calls the method average and prints the result on the screen. The values for which the average is calculated will be input arguments to the program. Collect these arguments in the main method in args and transform them to double with Double.parseDouble() \n", "No Parameters\n\nWe have a function called \"sayHello\". It's return type is String and it takes no parameters. The body of the function simply returns the string \"Hello!\". \n", "No Result\n\nWe have a function definition for printOpposite which takes a double x as argument. Inside the function, we print to the console the additive inverse of x. The output of this function is not shown. \n", "No Parameters, No Result\n\nWe have a function definition for a function called print hello. This function takes no parameters and returns void. The body of the function simply prints out the string hello. \n", "Method Definition\n\nThe image describes how to define a method called \"square\". The method takes an integer as input and returns an integer as output. The method calculates the square of the input integer by multiplying it by itself. The image shows a diagram of the method, with an arrow pointing to a box labeled \"square\". The box has two arrows pointing to it, one labeled \"int\" and the other labeled \"int\". The arrow labeled \"int\" represents the input integer, and the arrow labeled \"int\" represents the output integer. The box also contains the code for the method, which is \"return x*x;\". \n", "Outside / Inside\n\nWe have a function definition for square which takes an integer x as input and returns the square of x. The body of the function is inside. The call to the function is outside. \n", "Outside / Inside\n\nWe have a function definition for the function \"square\" which takes an integer \"x\" as input and returns an integer. The body of the function calculates the square of the input integer \"x\" using the formula (1 + (x+1) * (x-1)) and returns the result. \n", "Method Call\n\nThe image describes how a method call works, using the example of a 'square' method. \n\nAt the top, we see a mathematical expression: \"y = square(3) + square(4);\". This represents a call to a method named \"square\" with the arguments 3 and 4. The results of these calls are added together and assigned to the variable 'y'.\n\nThe results of these calls are shown as 9 and 16 respectively.\n\nBelow the expression, the definition of the 'square' method is shown. It takes an integer 'x' as input and returns an integer which is the result of 'x*x'.\n\nThe flow of data during the method call is illustrated with arrows. The value 4 is passed as an argument to the 'square' method. Inside the method, the value of 'x*x' (which is 16 in this case) is calculated and returned. This returned value is then shown to be used in the original expression. \n", "Scope\n\nWhat happens if I use an identifier used in a method body also outside of the method?\n\nThere are two \"X\"s, one outside of a circle and one inside. The circle is labeled \"Method\". \n", "Example 1\n\nWe have a piece of code. The code defines an integer variable x and sets it to 1. Then, it defines a function f that takes an integer as input and returns the sum of the input with itself. Finally, it defines an integer variable z and sets it to the result of calling function f with x plus 1 as input. \nThere is a diagram on the right side. The diagram shows a stack with three boxes. The top box is labeled x and contains the value 1. The middle box is labeled x and contains the value 2. The bottom box is labeled z. The top two boxes are red and the bottom box is black. \n", "Example 1\n\nWe have a piece of code. First, an integer x is initialized to 1. Then, we define a function f that takes an integer as input. Inside the function f, we return the input plus 1. Finally, we define an integer z and assign it to the result of calling function f with x plus 1 as input. \n", "Example 2\n\nWe have a piece of code. The first line declares an integer variable x and assigns it the value 1. The next three lines define a function called f that takes an integer argument x and returns the value of x plus x. The last line declares an integer variable z and assigns it the value returned by calling the function f twice, first with the argument x plus 1 and then with the result of the first call to f. \n", "Example 3\n\nWe have a piece of code. The code defines an integer variable x and sets it to 1. Then, it defines a function f that takes an integer y as input and returns the sum of x and y. Finally, it defines an integer variable z and sets it to the result of calling the function f with the value of x+1 as input. There are three boxes, one labeled x with the value 1, one labeled y with the value 2, and one labeled z. \n", "Example 4\n\nWe have a code snippet that defines an integer variable x and assigns it the value of 1. Then, we define a function called f that takes no arguments and returns an integer. Inside the function, we define an integer variable y and assign it the value of 2. The function returns the sum of x and y. Finally, we define an integer variable z and assign it the value returned by the function f. \n\nThere are three boxes, one below the other. The top box is labeled X and contains the number 1. The middle box is labeled Y and contains the number 2. The bottom box is labeled Z. The middle box is colored red. \n", "Example 5\n\nWe have a piece of code that defines an integer variable x and assigns it the value of 1. Then, we have a function called f that defines an integer variable x and assigns it the value of 2. The function returns the sum of x plus x, which is 4. Finally, we have an integer variable z that is assigned the value returned by the function f, which is 4. \n", "Example 6\n\nWe have a code snippet with a comment \"x only exists in for loop\". The code is:\nint y=0;\nfor (int x=1; x<3; x++)\n{\ny=y+x;\n}\nint z=y;\n\nWe also see a table with three columns: X, Y, and Z. The X column contains the values 1 and 2. The Y column contains the value 0. The Z column is empty. \n", "Example 7\n\nWe have a code snippet showing a name conflict. We declare an integer variable x and initialize it to 1. Then, we declare an integer variable y and initialize it to 0. Next, we have a for loop, and in the initialization statement of the for loop, we declare an integer variable x and initialize it to 1. This x variable declared inside the for loop is conflicting with the x variable declared outside the for loop. Inside the for loop, we are adding the value of x to y. After the for loop, we declare an integer variable z and assign it the value of y. \n", "Example 8\n\nWe have a code snippet that initializes two integer variables, x and y, to 1 and 0, respectively.\nA for loop iterates twice, incrementing x by 1 in each iteration. Inside the loop, y is updated by adding the current value of x to it.\nAfter the loop completes, an integer variable z is declared and initialized with the sum of y and x.\nThere is a callout highlighting that the variable x still exists outside of the for loop.\nA table illustrates the values of x and y during the execution of the code.\nInitially, x is 1 and y is 0.\nAfter the first iteration of the loop, x becomes 2 and y becomes 1.\nAfter the second iteration, x becomes 3 and y becomes 3.\nFinally, z is assigned the value of 6, which is the sum of y (3) and x (3).\n", "Example 9\n\nWe have a piece of code. First, an integer x is initialized with value 1. Then, an integer function f is defined, which returns the value of x. Finally, an integer z is defined and assigned the value returned by the function f. The memory allocation for the variables is shown on the right. x and z are allocated memory in the main function, while x is passed by value to the function f. \n", "Example 10\n\nWe have a code snippet with three functions: f, g, and the main function. The main function first defines an integer variable x and initializes it to 1. Then, it defines an integer function f. This function returns the value of x. Next, the main function defines another integer function g. Inside the g function, an integer variable x is defined and initialized to 0. The g function then returns the value returned by calling the function f. Finally, the main function defines an integer variable z and assigns it the value returned by calling the function g. \n\nThere is a diagram on the right side. It has three boxes stacked vertically. The top box is labeled \"x\" and contains the value \"1\". The middle box is labeled \"x\" and contains the value \"0\". The bottom box is labeled \"z\". The top two boxes are colored red and the bottom box is black. \n", "Example 11\n\nWe have two functions, f and g. Function f returns the value of x. Function g initializes x to zero and then returns the result of calling function f. Finally, we have a variable z that is assigned the result of calling function g. \n", "Environment\n\nWe have a piece of code that defines an integer variable x and assigns it the value of 1. Then, it defines a function f that takes an integer as input and returns the sum of the input with itself. Finally, it defines an integer variable z and assigns it the value returned by calling the function f with x+1 as input. On the right hand side, there is a diagram with three boxes stacked vertically. The top box is black with a white 'x' and a red '1'. The middle box is red with a white 'x' and a white '2'. The bottom box is blue with the text 'f' and '(x)->x+x'. \n", "To Remember\n\n- A variable is valid in a scope from its declaration to the end of the block, but can be temporarily hidden by another variable with the same name\n- However arrays are passed by reference\n- If there are free variables in a method definition, they are bound at its definition, not at its call \n", "Exercise 3\n\nWe are asked to program a method that receives three integers and returns the squares of each of these three integers. We should think of different implementations with and without the use of arrays and take into account the scope for each of these cases. \n", "Exercise 4\n\nWe need to program a method called \"power\" that calculates the power of a number. The method takes the base and a non-negative exponent as parameters.\n\nThen, we need to program two more methods: one that calculates the area of a sphere given its radius and another one that calculates the volume of a sphere given its radius. These methods should use the \"power\" method.\n\nThe formula for the volume of a sphere is \"V = (4/3)\u03c0r\u00b3\" where \"r\" is the radius.\nThe formula for the area of a sphere is \"A = 4\u03c0r\u00b2\" where \"r\" is the radius.\n\nFinally, we need to program a main method to test the program. \n", "The word \"wooclap\" is written in blue, bubbly letters. \n"]}, {"filename": "3 en calario-StateTransformation_I.pdf", "pages_description": ["Overview\n\nThe overview covers two main topics: repetition and arrays. Repetition includes while, for, and do-while loops. Arrays include declaration, initialization, and access. \n", "1. Repetition\n\nA 3D figure is running in a hamster wheel. \n", "1. Repetition\n\nThis slide lists three types of repetition statements. The first is a while loop, which has the condition in parenthesis after the while keyword, followed by the statements to be executed in curly braces. The second is a for loop, which has the initialization, condition, and update statements in parenthesis after the for keyword, followed by the statements to be executed in curly braces. The third is a do-while loop, which has the keyword do followed by the statements to be executed in curly braces, and then the keyword while followed by the condition in parenthesis. \n", "1.A. While\n\nWe have a code snippet and a table. The code snippet shows a while loop in Java. It initializes an integer variable i to 5. The while loop continues as long as i is greater than 0. Inside the loop, the value of i is printed to the console, and then i is decremented by 1. \n\nThe table illustrates the execution of the while loop. Each row in the table represents an iteration of the loop. The columns show the value of i, the condition (i>0), the value printed to the console, and the new value of i after each iteration. The loop iterates 5 times, printing the values 5, 4, 3, 2, and 1 to the console. The loop terminates when i becomes 0, and the condition (i>0) becomes false. \n", "1.B. For\n\nWe have a for loop that iterates as long as the variable i, initialized to zero, is less than 5. At each iteration, the variable i is incremented. The body of the loop prints the current value of the variable i.\n\nA table describes the state of the program at each iteration. The first column shows the value of the variable i. The second column shows the evaluation of the condition. The third column shows what is being printed at each iteration. The last column shows the new value of i after the increment is performed. \n", "1.B. For\n\nWhen the loop has several statements in initialization, condition or update, they will be separated by commas. The example shows a for loop with multiple statements. The initialization statement declares an integer variable i and sets it to zero and it also declares an integer variable sum and sets it to zero. The condition statement checks if i is less than or equal to five. The update statement increments i by one and adds five to sum. The body of the loop contains statements that will be executed as long as the condition is true. \n", "1.B. For\n\nThe image shows four code snippets, each demonstrating a for loop in programming.\n\nThe first snippet initializes an integer \"i\" to 0. The loop continues as long as \"i\" is less than 10, and in each iteration, \"i\" is incremented by 2.\n\nThe second snippet also initializes an integer \"i\" to 0. However, the loop condition is set to \"i\" less than 10, but \"i\" is initialized to 13 and incremented by 1 in each iteration.\n\nThe third snippet initializes an integer \"i\" to 4. The loop continues as long as \"i\" is less than 10, and in each iteration, \"i\" is incremented by 2.\n\nThe fourth snippet initializes two integers, \"i\" and \"sum,\" to 0 and 5, respectively. The loop continues as long as \"i\" is less than 10. In each iteration, \"sum\" is incremented by the value of \"i,\" and \"i\" is incremented by 8.\n\nThe image also poses two questions:\n\n* How many times are these loops executed?\n* What is the value of \"i\" in each example at the end of the loop?\n", "While vs. For\n\nThis table describes when to use a \"while\" loop and when to use a \"for\" loop. Use a \"for\" loop when the number of iterations is known, such as when iterating over an array. Use a \"while\" loop when the number of iterations is unknown. The table also notes that \"for\" loops are used when there is an increase of variables in each cycle.\n\nSome examples of when to use each type of loop are provided. For example, you would use a \"while\" loop to read a file and a \"for\" loop to cover an array. \n", "1.C. Do-While\n\nWe have a code snippet and a table. The code snippet is a do-while loop that initializes an integer variable 'i' to 5. The loop prints the value of 'i' and then decrements it by 1. The loop continues as long as the value of 'i' is greater than 0.\n\nThe table shows the values of 'i', the printed output, the new value of 'i' after each iteration, and the condition for the loop continuation. The table shows that the loop iterates 5 times, printing the values of 'i' from 5 to 1. After each iteration, the value of 'i' is decremented by 1. The loop terminates when the value of 'i' becomes 0, and the condition (i>0) becomes false. \n", "Summary\n\nThe table compares the \"for\", \"while\", and \"do-while\" loop constructs in terms of variable initialization, variable updates, minimum number of executions, and frequency of use.\n\nThe \"for\" loop initializes and updates variables and has a minimum of zero executions. It is frequently used.\n\nThe \"while\" loop does not initialize or update variables and has a minimum of zero executions. It is also frequently used.\n\nThe \"do-while\" loop does not initialize or update variables and has a minimum of one execution. It is less commonly used compared to the other two loop constructs. \n", "Additional remarks\n\n- Nested loops: Program slows down\n- The statements in a `while` or `for` might never run; in a `do-while` statements are executed at least once\n- Avoid infinite loops (always check termination condition)\n- A `for` loop always can be converted into a `while` loop, and vice versa \n", "Exercise 1\n\nWe are asked to write a method that prints numbers from 1 to 100 in steps of seven. The expected output is 1 8 15 22 29 36 43 50 57 64 71 78 85 92 99. We should think of an efficient solution for this. \n", "Exercise 2\n\nWe are asked to write a method that calculates whether an input number n is prime.\nThe output should be:\n- 13 is a prime number\n- 16 is not a primer number\n\nWe are reminded that a prime number is a positive integer number that has no positive divisors other than 1 and itself. \n", "Exercise 2:\nStep 1: Think about the algorithm\n\nSplit the problem into simpler steps:\n- Starting by 2, check for each number if it is an integer divisor of n\n- We only need to repeat it until n/2\n- Or until we find an integer divisor\n- We will use a boolean variable as \"sentinel\"\n", "Exercise 2:\nStep 2: Represent the algorithm\n\nThe image shows a flowchart. \nThe flowchart starts with an initialization step: \"divisor equals 2\" and \"isPrime equals true\".\nThen we have a decision box: \"divisor less than n divided by 2 AND isPrime\". If the condition is true, we move to the next decision box: \"n modulo divisor equals 0\". If true, then \"isPrime\" is set to false. If the condition \"n modulo divisor equals 0\" is false, the flow goes back to the previous decision box. If the condition \"divisor less than n divided by 2 AND isPrime\" is false, the flow goes to the end.\nThe \"false\" path from the decision box \"n modulo divisor equals 0\" is connected to the \"divisor++\" step.\nThe \"divisor++\" step is connected to the decision box \"divisor less than n divided by 2 AND isPrime\".\nThe flowchart ends with a terminator symbol. \n", "Exercise 2: Step 3: Write the code\n\nThis slide shows a piece of code and a flowchart. \n\nThe code is a Java function that determines if a given integer is a prime number. The function iterates through all numbers from 2 to half of the input number. For each number, it checks if the input number is divisible by the current number. If it is, the input number is not a prime number, and the function returns false. Otherwise, the loop continues. If the loop completes without returning false, the input number is a prime number, and the function returns true.\n\nThe flowchart visually represents the logic of the code. It starts by initializing a variable named \"divisor\" to 2 and a boolean variable named \"isPrime\" to true. Then, it enters a loop that continues as long as the value of \"divisor\" is less than half of the input number, and \"isPrime\" is true. Inside the loop, it checks if the input number is divisible by the current value of \"divisor\". If it is, it sets \"isPrime\" to false. If it is not, the loop continues. After the loop, the value of \"isPrime\" is returned. \n", "2. Arrays\n\nThe image shows rows of empty chairs in an auditorium. \n", "2. Arrays\n\nArrays are sets of elements belonging to the same data type. The index, represented by square brackets, is an operator used to set or retrieve individual elements from the array. The length attribute returns the number of elements in the array. The range of the index is from 0 to length minus 1. It's important not to exceed the maximum length of the array, otherwise, an IndexOutOfBoundsException will be thrown. \n\nThe image shows a set of colorful lockers, visually representing an array. Each locker represents an element in the array, with the index labeled on each locker door. \n", "Arrays\n\nThe first element in an array has an index of 0. The last element in an array has an index of the array's length minus 1. The nth element in an array has an index of n - 1. Indexes are integer expressions that must be greater than or equal to 0 and less than or equal to the array's length minus 1.\n\nHere we have an array with a length of 10. The first element is -7 and has an index of 0. The last element is 2 and has an index of 9. \n", "2.A. Declaration\n\nAssigning an identifier to the array and specify the data type of the elements that will be stored.\n\nThere are two code snippets:\n- type arrayName[];\n- type[] arrayName;\nBoth snippets declare a variable of type \"type\" which is an array.\n\nThere are two code snippets:\n- int arrayName[];\n- boolean[] arrayName;\nBoth snippets declare a variable of type \"int\" and \"boolean\" respectively which are an array.\n\nNo memory to store the array is allocated in the declaration.\nThe contents cannot be accessed yet.\n", "2.B. Creation\n\nTo create an array, we need to allocate memory for it. We do this by using the reserved word \"new\" and specifying the array size. Once created, the elements have default values until the array is initialized.\n\nHere are some examples:\n\n- To create an array of any type with the name \"arrayName\" and size \"arraySize\", we can use the following syntax: \n\"arrayName[] = new type[arraySize];\"\n\n- To create an integer array with the name \"arrayName\" and size 10, we can use the following syntax: \n\"arrayName[] = new int[10];\"\n\n- To create a boolean array with the name \"arrayName\" and size 5, we can use the following syntax: \n\"arrayName[] = new boolean[5];\"\n\nThe default values for the different data types are:\n- int, short, long = 0\n- float, double = 0.0\n- boolean = false\n- String = null\n- Object = null \n", "2.C. Initialization\n\nWe're going to talk about how to assign values to each of the elements of the array.\n\nOne way is to assign element by element. For example, we can assign element0 to arrayName at index 0 and element1 to arrayName at index 1.\n\nAnother way is using a loop. We can iterate from i equals 0 until i is less than the length of the array, incrementing i after each iteration. Inside the loop, we can assign element at index negative i to arrayName at index i.\n\nFinally, we can use direct assignment. We can assign a set of elements to arrayName. For example, we can assign element1, element2, element3, and so on to arrayName. \n", "Examples\n\nThe image shows three different ways to declare, create, and initialize an integer array in Java. \n\nThe first example shows how to declare an array variable, create an array object, and then initialize the array elements separately. \n\nThe second example shows how to declare an array variable, create an array object, and initialize the array elements in a single statement. \n\nThe third example shows how to declare an array variable, create an array object, and initialize the array elements using a for loop. \n", "Common errors\n\nThis slide explains a common error when working with arrays in Java. The code declares a double array variable named \"myArray\" but does not initialize it. Trying to print the value of the first element of the uninitialized array leads to a compilation error. The slide highlights that when an array is declared but not created or initialized, its elements cannot be accessed. The program will not compile and will display an error message indicating that the variable \"myArray\" may not have been initialized. \n", "**Common errors**\n\nWe see a code snippet showing the declaration and initialization of different types of arrays in Java. \n\nThe code first declares an array of integers called \"myArrayOfIntegers\" and initializes it with a new array of size 10. \n\nIt then does the same for arrays of floats, booleans, characters, and strings, using the appropriate data types and array sizes. \n\nFinally, the code prints the value of the first element of each array using the `System.out.println()` method.\n\nThe output of this code will be the default values for each data type in Java, which are:\n\n- integer by default: 0\n- float by default: 0.0\n- boolean by default: false\n- char by default: \n- String by default: null\n\nThis code highlights the fact that when an array is declared and created but not explicitly initialized with values, its elements will contain the default values for their respective data types.\n", "Exercise 3\n\nWrite a method that receives a set of integer values as input, and prints the sum on screen. For example, if the method receives as input the set of 1, 2, 3 and 4, then it will print 10.\n\nAssume that the values received as input will be always integer values. In case that no input is received, the program will print 0. \n", "Exercise 4\n\nWe have to write a method that receives a set of integer values as input and prints the maximum value on the screen. For example, if the method receives as input the set containing the numbers 1, -2, 3 and -4, then it will print the number 3.\n\nWe should assume that the values received as input will be always integer values. In case that no input is received, the program will print the smallest integer value in Java, which is contained in Integer.MIN_VALUE. \n", "N-dimensional Arrays\n\nWe need more than one index to set and retrieve the elements of an array.\n\nThere are two arrays:\n- The first one is a 3x3 array initialized to 0.\n- The second one is also a 3x3 array initialized to the following values:\n    - First row: 1, 2, 3\n    - Second row: 4, 5, 6\n    - Third row: 7, 8, 9 \n", "N-dimensional Arrays\n\nThe image shows two diagrams representing arrays and code snippets that declare, create and initialize these arrays.\n\nThe first diagram represents a two-dimensional array. It has 3 rows and 3 columns. Each cell in the array contains a letter. The cell in row 0 and column 2 contains the letter 'C'.\n\nThe second diagram represents a three-dimensional array. It has 3 rows, 3 columns and 3 layers. Each cell in the array contains a letter. The cell in row 0, column 2 and layer 1 contains the letter 'l'.\n\nThe first code snippet declares a two-dimensional array of characters named 'a', creates a new array of size 3x3 and assigns the character 'A' to the cell in row 0 and column 0.\n\nThe second code snippet declares a three-dimensional array of characters named 'a', creates a new array of size 3x3x3 and assigns the character 'a' to the cell in row 0, column 0 and layer 0.\n", "Exercise 5\n\nWe're going to write a method in Java called \"max\" that takes a two-dimensional array of integers as input. This method will find the largest integer in the array and print it to the screen. For example, if the input array is {{1, -2, 8, -4},{3, -1, 7, -2}}, the method will print the value 8.\n\nWe'll assume that the input array will always contain integers. If the method doesn't receive any input, it will print the smallest possible integer value in Java, which is represented by the constant \"Integer.MIN_VALUE\". \n", "Exercise 6\n\nWe need to write a method in Java with the following signature: `public static int rowSum(int[][] a, int r)`. This method receives a two-dimensional array of integers named 'a' and an integer 'r' as input. It calculates and prints the sum of the elements present in row 'r' of the array. The row indexing starts from 0.\n\nFor instance, if the input array 'a' is `{{1, -2, 3, -4},{3, -1, 7, -2}}` and 'r' is 1, the method should output 7, which is the sum of elements in the second row (3 + (-1) + 7 + (-2) = 7).\n\nImportant: We can assume that the input array and 'r' will always hold integer values. If no input is provided, the program should display an error message. \n"]}, {"filename": "8 en calario-Sorting (II).pdf", "pages_description": ["Overview\n\nThis slide titled \"Overview\" outlines advanced sorting algorithms. It lists Heap Sort, Merge Sort, and Quick Sort as the three algorithms to be covered. \n", "1. Sorting (Advanced)\n\nThis slide is titled \"1. Sorting (Advanced)\". The slide number is 3. There is an image of a long narrow room with wooden shelves on either side. The shelves are empty. The room is lit by a window at the far end. \n", "1.1 Heap\n\nLet's talk about the heap data structure.\n\nA heap is a hierarchical data structure in the form of a tree. The root of the tree is at the top, and the leaves are at the bottom. Every parent node, also known as an ascendant, can have zero, one, or two children, also known as descendants. All levels of the tree are complete, except maybe for the last one, where nodes are arranged from left to right.\n\nThere are two types of heaps: max-heaps and min-heaps. In a max-heap, parent nodes contain larger values than their children. In a min-heap, parent nodes contain smaller values than their children. \n", "1.1 Heap: Example\n\nWe have a diagram representing a min-heap data structure. The heap contains the values 1, 2, 3, 4, 5, 6, and 7.\n\nThe root of the heap is 1, which has no parent. The children of 1 are 2 and 3. The children of 2 are 4 and 5. The children of 3 are 6 and 7.\n\nThe nodes 4, 5, 6, and 7 are leaves, meaning they have no children.\n\nThe diagram illustrates the key properties of a min-heap:\n\n- The parent node is always smaller than or equal to its children.\n- The heap is a complete binary tree, meaning all levels are completely filled except possibly for the last level, which is filled from left to right.\n", "1.1 Heap: Example (completeness)\n\nWe have three binary trees. The first one is complete, the second one is not complete because it is missing a node on the last level, and the third one is not complete because it is missing a node on the second to last level. The tree on the left with the red nodes is labeled \"Not a heap: it is not complete\". \n", "1.1 Heap: Example (values in the nodes)\n\nWe have a tree with nodes containing numerical values. The root node has value 1. The children of the root node have values 3 and 4. The children of node 3 are 2 and 5. The children of node 4 are 6 and 9. Finally, the children of node 2 are 8 and 7.\n\nThis is not a heap, because the values in some children are lower than those of the parent. \n", "1.1 Heap: Example\n\nThis slide titled \"1.1 Heap: Example\" shows an example of a min-heap data structure. The min-heap is represented as a binary tree with the smallest value, 1, at the root. The other values in the tree are 2, 4, 3, 5, 6, 9, 8, and 7. The tree is arranged so that the value of each node is less than or equal to the values of its children. For example, the value of the root node, 1, is less than the values of its children, 2 and 4. The value of the node with value 2 is less than the values of its children, 3 and 5. And so on. \n", "1.1 Heap: From the array to the heap\n\nWe have a binary tree with nodes numbered 1, 2, 3, 4, 5, 6, and 7. Node 1 is the root, 2 and 3 are its children, 4 and 5 are children of 2, and 6 and 7 are children of 3. \n\nThe nodes are also stored in an array with indices from 0 to 6. Node 1 is at index 0, node 2 is at index 1, node 3 is at index 2, and so on. \n\nThe relationship between a node's index in the array, p(x), and the indices of its left and right children is given by:\n\n- p(root) = 0\n- p(x.left) = 2 * p(x) + 1\n- p(x.right) = 2 * p(x) + 2\n", "1.1 Heap Sort\n\nHeap sort is an improved version of selection sort. It is done in two steps. The first step is to build a heap. A heap is a binary tree that is complete, meaning that all levels of the tree are filled except for possibly the last level, which is filled from left to right. In a heap, the value of each node is greater than or equal to the values of its children. The root of the heap is the node with the highest value. The parent of a node at index i is at index i/2, the left child is at index 2*i+1, and the right child is at index 2*i+2. The second step is to repeatedly swap the highest element of the heap with the last unsorted element and then update the heap. This process is repeated until the entire array is sorted. \n", "Heap Sort. Example (I)\n\nThe image describes the first step in building a max-heap data structure from an unsorted array of numbers: 80, 95, 14, 98, 29, 49, 66. The goal is to sort the array in ascending order using the heap sort algorithm.\n\nThe first step is to build a max-heap, where the parent node is always greater than or equal to its children. The image shows the initial state of the heap, with the number 80 as the root. The rules for building the heap are as follows:\n\n- The root of the heap is at position 0 in the array.\n- The left child of a node at position 'i' is at position '2*i + 1'.\n- The right child of a node at position 'i' is at position '2*i + 2'.\n\nThe image shows the initial arrangement of the numbers in a binary tree structure, with arrows indicating the parent-child relationships. The green arrows point from parent nodes to their children. The process of building the max-heap will involve rearranging these nodes to satisfy the max-heap property.\n", "1.1 Heap Sort. Example (II)\n\nThe image describes the first step of the heap sort algorithm, which is ordering the heap. \n\nThe first bullet point explains that the root of the heap needs to be higher than its children. It also explains that the algorithm starts from the penultimate row to the right and checks if the children are higher than the parent.\n\nThe second bullet point explains that the nodes go down to their corresponding position. It also lists four swappings that need to be done: 66 and 14, 98 and 95, 98 and 80, and 95 and 80.\n\nThere are two diagrams that illustrate the heap sort algorithm. The first diagram shows the initial state of the heap, with the numbers 80, 95, 14, 98, 29, 49, and 66. The second diagram shows the heap after the four swappings have been performed. The numbers in the second diagram are in the following order: 98, 95, 66, 80, 29, 49, and 14. The second diagram also shows the steps that were taken to order the heap, with arrows indicating the swappings that were made.\n\nFinally, a table shows the final order of the numbers: 98, 95, 66, 80, 29, 49, and 14.\n", "1.1 Heap Sort. Example (III)\n\nThe slide describes step 2 in the heap sort example. It shows how to extract the root and reorder the heap.\n\nWe start with the array: 14 95 66 80 29 49 98. The array is represented as a binary tree. The root of the tree is 14, its left child is 95 and its right child is 66. 95 has 2 children: 80 and 29. 66 has 2 children: 49 and 98.\n\nThe first step is to extract the root, 98, and place it at the end of the array. The root of the tree becomes 14. This is shown in the first tree.\n\nThe second step is to replace 14 by the highest element of the array, 95, and reorder the heap. This is shown in the second tree. The root of the tree is now 95, its left child is 80 and its right child is 66. 80 has 2 children: 14 and 29. 66 has 2 children: 49 and 98. \n", "**1.1 Heap Sort. Example (IV)**\n\nThe image illustrates Step 2 in the Heap Sort algorithm, which involves extracting the root and reordering the heap.\n\n- **Step 2.1:** The root node with a value of 95 is taken and placed at the end of the array, which is now considered sorted. The root node now becomes 49.\n\n- **Step 2.2:** The highest element in the remaining array, which is 80, replaces the root node of 49. The heap is then reordered to maintain its properties. \n\nThe image shows two trees representing the heap before and after the reordering. \n\n- **Tree 1** shows the heap before Step 2 with the root node 95. The child nodes of 95 are 49 and 66. The child nodes of 49 are 80 and 29, and the child node of 80 is 14.\n\n- **Tree 2** shows the heap after Step 2 with the root node 80. The child nodes of 80 are 49 and 66. The child nodes of 49 are 14 and 29. \n\nThe red vertical line in the array representation separates the sorted part of the array from the unsorted part. \n", "1.1 Heap Sort. Example (V)\n\nThe slide describes step 2 of a heap sort example. Step 2 is extracting the root and reordering the heap. This step has two sub-steps: taking 80 and placing it at the end, which is sorted, making the root become 29; and replacing 29 by the highest element of the array, 66, and reordering the heap.\n\nThere are two diagrams illustrating the heap sort algorithm. The first diagram shows the state of the heap after the first step of the algorithm. The root of the heap is 80, and the left and right children are 49 and 66, respectively. The second diagram shows the state of the heap after the second step of the algorithm. The root of the heap is now 66, and the left and right children are 49 and 29, respectively. The number 80 has been moved to the end of the array. The red numbers in the diagrams represent the nodes of the heap, and the black lines represent the edges between the nodes. The green arrow in the first diagram indicates that the value 80 is being moved to the end of the array. The red numbers below the diagrams indicate the steps of the algorithm.", "1.1 Heap Sort. Example (VI)\n\nThe image describes the second step of the heap sort algorithm, extracting the root and reordering the heap.\n\nThere are two diagrams, both representing a heap, and a two-item list describing the two sub-steps of the second step.\n\nThe first sub-step is \"taking 66 and placing it at the end (sorted). The root becomes 14.\"\nThe second sub-step is \"replacing 14 by the highest element of the array (49) and reordering the heap.\"\n\nBoth diagrams represent the state of the heap, before and after the second sub-step.\n\nThe heap is represented with numbers organized in a tree-like structure.\nThe first level has one node with value 14 on the left diagram and 49 on the right diagram.\nOn the second level, there are two nodes, 49 and 29 on the left diagram, and 14 and 29 on the right diagram.\nOn the third and last level, there are also two nodes, both with the same values: 14 and 29.\n\nAn arrow is connecting the node with value 14 on the first level of the left diagram to the node with value 49 on the second level.\nSimilarly, an arrow is connecting the node with value 49 on the first level of the right diagram to the node with value 14 on the second level.\nFinally, a green arrow is connecting the node with value 14 on the second level to the node with value 29 on the third level of both diagrams.\n\nThe values in both diagrams are also present in two tables, below each diagram.\nThe tables contain the same values in the same order, the only difference is that the value 66 is in red in both tables.\nThe table on the left contains the values: 14 49 29 *66* 80 95 98\nThe table on the right contains the values: 49 14 29 *66* 80 95 98\n\nFinally, the number 1 is below the left diagram, and the number 2 is below the right diagram.\n", "1.1 Heap Sort. Example (VI)\n\nThe slide describes step 2 of extracting the root and reordering the heap in a heap sort example. The first step is to take the root node with value 49 and place it at the end of the heap, which is the sorted portion of the array. The root node then becomes 29. Next, take the new root node 29 and place it at the end after 49 in the sorted portion. The root node then becomes 14. Finally, take the last root node 14 and place it at the end after 29. The heap is now empty. The array at each step is shown at the top of the slide and an arrow points from the root node to its new position at each step. The final sorted array is shown at the bottom of the slide. \n", "Heap Sort. Two external loops\n\nWe have three points that describe the heap sort algorithm. The first point, \"External loop 1 (Step 1): Building the heap\", states that for each node, we need to check that the children are smaller. The number of iterations for this step is half the length of the array. We are traversing all the nodes except for the leaves, because they do not have children. The range of the index of external loop 1 is from zero to length of the array minus two, divided by two. \n\nThe second point is \"Internal loop 2 (Step 2): Extracting the root and reordering\". This step says that the root is extracted, placed at the end of the data structure, and the heap is reordered. The number of iterations is the length of the array. The range of the index of external loop two is from zero to the length of the array minus one. \n\nThe third point is \"After m-th iteration (i=m-1) of the external loop 2\". This point states that the elements from zero to length of array minus two minus \"i\" are unsorted. The elements from length of array minus one minus \"i\" to length of array minus one are sorted. \n", "1.1 Heap Sort. Code (I)\n\nThe image shows two code snippets. The first one is a function called \"heapSort\" which takes an array of integers as input. It first iterates over the array from the middle to the beginning, calling the function \"heapify\" for each element. Then it iterates over the array from the end to the beginning, swapping the first element with the current one and calling \"heapify\" again for the first element and the index of the current element minus one. \n\nThe second code snippet is a function called \"swap\" which takes an array of integers and two integer indices as input. It swaps the elements at the given indices in the array. \n", "1.1 Heap Sort. Code (II)\n\nThis code snippet shows a private static method called \"heapify\" that takes three arguments: an integer array \"a\", an integer \"i\", and an integer \"m\". The method first initializes an integer variable \"j\". Then, it enters a while loop that continues as long as 2 times \"i\" plus 1 is less than or equal to \"m\". Inside the loop, \"j\" is set to 2 times \"i\" plus 1. If \"j\" is less than \"m\", the code checks if the element at index \"j\" of array \"a\" is less than the element at index \"j\" plus 1. If it is, \"j\" is incremented. Next, if the element at index \"i\" of array \"a\" is less than the element at index \"j\", the \"swap\" method is called with array \"a\", \"i\", and \"j\" as arguments. Then, \"i\" is set to \"j\". Otherwise, \"i\" is set to \"m\". The loop continues until the condition is no longer met. \n", "Exercise 1\n\nUsing the sorting algorithm Heap Sort, how many swaps are needed to sort the following array from the lowest element to the highest element, in ascending order: 7, 3, 13, 1, 11, 5. \n", "1.1 Heap Sort: Conclusions\n\nThis slide describes the advantages and drawbacks of Heap Sort.\n\nAdvantages:\n- Efficient for arrays with many elements, even in the worst case.\n- O(n log n)\n- Little additional memory is needed.\n\nDrawbacks:\n- Complex code. \n", "Merge Sort\n\nThe image describes the Merge Sort algorithm.\n\nThe algorithm consists of 3 steps:\n1. Divide the array in two subarrays of approximately the same length (half the original array)\n2. Divide each subarray recursively until we have subarrays of length 1, in which case that array is returned\n3. Merge the two subarrays in a new sorted subarray recursively\n\nThe diagram shows an example of the algorithm applied to an unsorted array: [38, 27, 43, 3, 9, 82, 10].\nThe array is recursively divided in half until we get to subarrays of length 1.\nThen, the subarrays are merged back together in sorted order.\nFor example, [38] and [27] are merged into [27, 38].\nThe process continues until the entire array is sorted: [3, 9, 10, 27, 38, 43, 82].\n", "1.2 Merge Sort. Example (I)\n\nThis example shows how to sort an array of numbers in ascending order using merge sort.\n\nThe initial array is: 80, 95, 14, 98, 29, 49, 66.\n\nThe array is recursively divided into subarrays until each subarray contains only one element. Then, the subarrays are merged back together in sorted order.\n\nThe first level of the tree shows the initial array divided into two subarrays: 80, 95, 14, 98 and 29, 49, 66.\n\nThe second level of the tree shows the subarrays further divided into subarrays of one or two elements: 80, 95, 14, 98 is divided into 80, 95 and 14, 98, and 29, 49, 66 is divided into 29, 49 and 66.\n\nThe third level of the tree shows the subarrays merged back together in sorted order: 80, 95 is merged into 80, 95, 14, 98 is merged into 14, 98, 29, 49 is merged into 29, 49, and 66 remains as 66.\n\nThe fourth level of the tree shows the final sorted array: 14, 29, 49, 66, 80, 95, 98.\n", "1.2 Merge Sort. Example (II)\n\nThe image illustrates the merge sort algorithm with an example. The unsorted list is: 80, 95, 14, 98, 29, 49, 66. The algorithm recursively divides the list into sub-lists until each sub-list contains only one element. Then, it repeatedly merges the sub-lists to produce new sorted sub-lists until there is only one sorted list remaining. The merging process is shown step-by-step in the image, with red arrows indicating the merging of two sub-lists into a larger sorted sub-list. The final sorted list is: 14, 29, 49, 66, 80, 95, 98. \n", "1.2 Merge Sort. Recursive division and merging with auxiliary array\n\nThe image describes the two steps of the merge sort algorithm. \n\nStep 1 is the recursive division. Given an array, or part of an array, defined by its first position \"l\", its last position \"r\" and its middle position \"m\" which is equal to (l+r)/2, the array is divided recursively in two until l and r are equal. The two subarrays created are from l to m and from m+1 to r.\n\nStep 2 is the sorting by merging subarrays. An auxiliary array is created containing the two subarrays that need to be sorted. Then the elements of each subarray are compared. It is important to note that the elements are not in their final correct position until the merging of the subarrays is finished. \n", "1.2 Merge Sort. Code (I)\n\nThis slide presents the code for a merge sort algorithm in an unspecified language. There are two functions defined: mergeSort and mSort. \n\nThe mergeSort function takes an integer array a as input and calls the mSort function with the array, 0, and the length of the array minus 1 as arguments.\n\nThe mSort function takes an integer array a, an integer l, and an integer r as input. It first checks if l is greater than or equal to r. If it is, the function returns. Otherwise, it calculates an integer m as the average of l and r, then calls the mSort function twice: once with the array, l, and m as arguments, and once with the array, m+1, and r as arguments. Finally, it calls the merge function with the array, l, m, and r as arguments. \n", "1.2 Merge Sort. Code (II)\n\nThis slide shows a code snippet of a function called \"merge\" that takes as input an array of integers \"a\", and three integers \"l\", \"m\", and \"r\". The code first checks if m+1 is greater than r. If it is, the function returns. Otherwise, it creates a new array \"b\" of integers with the same length as \"a\". The code then enters a for loop that iterates from 1 to m+1. For each iteration, the i-th element of \"b\" is set to the i-th element of \"a\". The code then enters another for loop that iterates from m+1 to r+1. For each iteration, the i-th element of \"b\" is set to the (r+m+1-i)-th element of \"a\". The code then initializes two integer variables, \"k\" and \"j\", to 1 and \"r\", respectively. The code then enters a for loop that iterates from 1 to r+1. For each iteration, the code checks if the k-th element of \"b\" is less than or equal to the j-th element of \"b\". If it is, the i-th element of \"a\" is set to the k-th element of \"b\" and \"k\" is incremented by 1. Otherwise, the i-th element of \"a\" is set to the j-th element of \"b\" and \"j\" is decremented by 1.\n\nTo the right of the code, there are three bullet points that describe the code. The first bullet point states that the left subarray is copied as it is in the auxiliary array. The second bullet point states that the right subarray is copied in the auxiliary array in reverse order. The third bullet point states that the merging starts from the two ends of the auxiliary array, which contain the elements with the lowest values of each subarray. \n", "Exercise 2\n\nUsing the sorting algorithm Merge Sort, describe the process needed to sort the following array in ascending order: 7, 3, 13, 1, 11, 5. \n\nUnlike in other cases, with Merge Sort there are no swapping in the arrays, as we are using an auxiliary array. \n", "1.2 Merge Sort: Conclusions\n\nMerge sort has some advantages: it's efficient for arrays with many elements, even in the worst case, with a time complexity of O(n log n). It is also highly parallelizable.\n\nMerge sort also has some drawbacks: the code is complex and it requires more memory space to store more auxiliary variables, for example, an auxiliary array. \n", "1.3 Quick Sort\n\nThis slide describes the Quick Sort algorithm.\n\nThe algorithm has 3 steps:\n1. Choose an element: the pivot\n2. Reorder the data structure so that:\n    - elements lower than the pivot are on its left\n    - elements higher than the pivot are on its right\n3. Sort recursively:\n    - the part whose elements are lower than the pivot\n    - the part whose elements are higher than the pivot\n\nTwo URLs are provided at the bottom of the slide. \n", "1.3 Quick Sort. Example (1)\n\nThe image describes the Quick Sort algorithm with an example.\n\nThe algorithm sorts an array of numbers in ascending order. The first step is to choose a pivot, in this case, the first element of the array, which is 80. Then, the algorithm iterates through the array from both ends, comparing each element with the pivot. If the element on the left is greater than the pivot, and the element on the right is smaller than the pivot, the two elements are swapped. The iteration continues until the two pointers meet. At this point, the pivot is in its final sorted position. The algorithm then recursively sorts the subarrays to the left and right of the pivot.\n\nThe example shows the first iteration of the Quick Sort algorithm on the array [80, 95, 14, 98, 29, 49, 66]. The pivot is 80. The algorithm first compares 95 and 66. Since 95 is greater than 80 and 66 is smaller than 80, they are swapped. The array becomes [80, 66, 14, 98, 29, 49, 95]. The algorithm then repeats the process on the subarrays [80, 66, 14, 29, 49] and [95]. \n", "1.3 Quick Sort. Example (II)\n\nThe image illustrates an example of the Quick Sort algorithm. We have a list of numbers: 80, 66, 14, 98, 29, 49, and 95. The first element, 80, is chosen as the pivot. The algorithm iterates through the list, comparing each element with the pivot. If an element is greater than the pivot, it changes sides. If an element is smaller than the pivot, it's time to swap it with the pivot and then change sides. The process continues until the list is sorted in ascending order. \n", "1.3 Quick Sort. Example (III)\n\nWe have two arrays of numbers. The first array is: 80, 66, 14, 49, 29, 98, 95. The second array is the same as the first array, except that the numbers 29 and 80 have been swapped. There is an arrow pointing from the number 29 in the first array to the number 80 in the second array. There is text that says \"29 < 80 (after converging, place the pivot in its correct location with a swap)\". There are also brackets below the second array that divide the array into two partitions. The left partition contains the numbers 29, 66, 14, and 49. The right partition contains the numbers 80, 98, and 95. Below the left partition, there is text that says \"< 80\". Below the right partition, there is text that says \"> 80\". Finally, there is a bullet point that says \"Repeat recursively for the left and right partitions\". \n", "1.3 Quick Sort. Recursive partition and sorting by swapping\n\nQuick sort has two steps: recursive partition and sorting by swapping. \n\nThe first step, recursive partition, takes an array or part of an array, with the first position marked as *l* and the last position marked as *r*. An algorithm is run on the array to determine the partition: elements on the left are lower than the pivot, and elements on the right are higher than the pivot. The next partition is computed recursively.\n\nThe second step, sorting by swapping, involves moving forward from both the left and the right, comparing elements with the pivot and swapping them as needed. Finally, the pivot is placed in its correct location.\n\nThe algorithm always places pivots in their final sorted position. \n", "1.3 Quick Sort. Code (I)\n\nThis code snippet shows the implementation of the Quick Sort algorithm in Java. The first function, `quickSort`, takes an integer array `a` as input and calls the `qSort` function with the array, the starting index `0`, and the ending index `a.length-1`. \n\nThe `qSort` function implements the recursive part of the Quick Sort algorithm. It takes the array `a`, the starting index `l`, and the ending index `r` as input. It first checks if the starting index is greater than or equal to the ending index. If it is, it means that the subarray has only one element or is empty, so it returns. Otherwise, it calls the `partition` function with the array, the starting index, and the ending index. The `partition` function partitions the array around a pivot element and returns the index of the pivot element. The `qSort` function then recursively calls itself twice, once for the subarray to the left of the pivot element and once for the subarray to the right of the pivot element. \n", "1.3 Quick Sort. Code (II)\n\nThe image shows a code snippet of a 'partition' function in Java. The function takes an integer array 'a', and two integers 'l' and 'r' as input. It first initializes three integer variables 'i', 'j', and 'p' to l+1, r, and a[l] respectively. The variable 'p' represents the pivot element. The code then enters a while loop that continues as long as 'i' is less than or equal to 'j'. Inside the loop, it compares the value of the element at index 'i' with the pivot 'p'. If the element at index 'i' is less than or equal to 'p', the value of 'i' is incremented. Otherwise, it checks if the element at index 'j' is greater than 'p'. If it is, the value of 'j' is decremented. If neither of these conditions is true, it means that the element at index 'i' is greater than 'p' and the element at index 'j' is less than or equal to 'p'. In this case, the elements at indices 'i' and 'j' are swapped using the 'swap' function. After the loop completes, the elements at indices 'l' and 'j' are swapped, and the value of 'j' is returned.\n\nThe code snippet also includes a bullet list with two items. The first item states that when comparing with a[i], if an element higher than a[i] is found on the left and an element lower than a[i] is found on the right, then the elements at indices 'i' and 'j' are swapped. The second item states that before finishing, the pivot must be placed in its correct location by swapping the elements at indices 'l' and 'j'.\n\nFinally, the code snippet includes the definition of the 'swap' function. The function takes an integer array 'a' and two integers 'i' and 'j' as input. It swaps the elements at indices 'i' and 'j' using an auxiliary variable 'aux'. \n", "Exercise 3\n\nUsing the sorting algorithm Quick Sort, how many swaps are needed to sort the following array from the lowest element to the highest element, in ascending order: 7, 3, 13, 1, 11, 5. \n", "1.3 Quick Sort: Conclusions\n\nThis slide describes the advantages and drawbacks of using the Quick Sort algorithm.\n\nAdvantages:\n- Very efficient for arrays with many elements\n- O(n log n) time complexity, but the worst case is O(n^2)\n- Little additional memory\n- Highly parallelizable\n\nDrawbacks:\n- Complex code \n", "Comparison\n\nThe image shows a comparison of different sorting algorithms. The algorithms are Insertion, Selection, Bubble, Shell, Merge, Heap, Quick, and Quick3. The algorithms are compared on five different types of data: Random, Nearly Sorted, Reversed, Few Unique, and a control group. For each algorithm and data type combination, there is a bar chart. The bar charts show the number of comparisons that each algorithm makes when sorting the data. The height of the bar represents the number of comparisons. The higher the bar, the more comparisons the algorithm makes. \n", "Comparison\n\nWe are comparing basic sorting algorithms, bubble, insertion and selection, with more advanced algorithms such as heap, merge and quick sort.\n\nBasic algorithms have an average complexity of O(n squared), which makes them inefficient when used with many elements. On the plus side, they are simple to code and use little memory.\n\nAdvanced algorithms have an average complexity of O(n log n), making them more efficient when dealing with a large number of elements. However, the code is more complex. In terms of memory usage, they are comparable to basic algorithms, with the exception of merge sort which uses more memory. \n"]}, {"filename": "4 en.pptx.pdf", "pages_description": ["Slide 3: 1. Representation of Data\n\nSlide 4: Flip Flop\n\nThe image on this slide shows a diagram of a flip flop circuit. The flip flop has two inputs, one labeled \"set (to 1)\" and the other labeled \"reset (to 0)\". It also has one output labeled \"output (0 or 1)\". \n", "Binary, Boolean\n\nThe slide shows the relationship between binary values and Boolean values. \n\nThe first slide shows that a set value of 1 corresponds to a Boolean value of true, represented by a lit light bulb, while a reset value of 0 corresponds to a Boolean value of false, represented by an unlit light bulb. \n\nThe second slide shows that with two bits, there are 2 to the power of 2, or 4, possible combinations. These combinations are represented in a table with two columns and four rows. The first column represents the value of the first bit, and the second column represents the value of the second bit. The four rows represent the four possible combinations of these two bits: 00, 01, 10, and 11. \n", "**Byte**\n\nA byte is composed of 8 bits. Each bit can be either 0 or 1. Therefore, there are 2\u2078 = 256 possible combinations for a byte.\n\n**Natural Numbers from 0 to 255**\n\nA byte can represent natural numbers from 0 to 255. For example, 00000000 represents 0, 00000010 represents 65, 00000011 represents 66, 00000100 represents 67, 11111110 represents 254, and 11111111 represents 255. \n", "Red Levels\n\nThis slide describes how to encode characters using red levels.  Zero red level is represented by \"00000000\" and full red level is represented by \"11111111\". There are two special symbols that are encoded using \"00000000\" and \"11111111\". Characters 'A', 'B' and 'C' are encoded using \"00000010\", \"00000011\" and \"00000100\" respectively. \n", "**Weight System (Decimal)**\n\nThis slide explains the weight system using the decimal system as an example. The number 972 is shown as the sum of 9 times 10 to the power of 2, plus 7 times 10 to the power of 1, plus 2 times 10 to the power of 0. This is illustrated with three bags of marbles. The first bag is labeled 100 and contains a large number of marbles, representing the 9 hundreds in 972. The second bag is labeled 10 and contains 7 marbles. The third bag is labeled 1 and contains 2 marbles. The slide also notes that there are 10 decimal digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. \n\n**Weight System (Binary)**\n\nThis slide explains the weight system using the binary system as an example. The number 101 is shown as the sum of 1 times 2 to the power of 2, plus 0 times 2 to the power of 1, plus 1 times 2 to the power of 0. This is illustrated with three bags of marbles. The first bag contains 4 marbles, representing the 1 in the 101 binary number. The second bag is empty, representing the 0 in the 101 binary number. The third bag contains 1 marble, representing the last 1 in the 101 binary number. The slide also notes that there are 2 binary digits (bits): 0 and 1. \n", "Natural Numbers from 0 to 255\n\nThis slide shows how natural numbers from zero to 255 can be represented in binary format using eight bits. The smallest natural number, zero, is represented by eight zeros. The largest natural number that can be represented using eight bits is 255, which is represented by eight ones. There are two to the power of eight, or 256, possible combinations of zeros and ones in an eight-bit binary number.\n\nIntegers from -128 to 127\n\nThis slide shows how integers from -128 to 127 can be represented in binary format using eight bits and two's complement. The smallest integer, -128, is represented by a one followed by seven zeros. The largest integer that can be represented using eight bits is 127, which is represented by a zero followed by seven ones. There are two to the power of eight, or 256, possible combinations of zeros and ones in an eight-bit binary number. \n", "Java Data Types for Integers\n\nThis slide describes the Java data types for integers. \n- byte data type: requires 8 bits and can store values from -128 to 127. \n- short data type: requires 16 bits and can store values from -32,768 to 32,767. \n- int data type: requires 32 bits and can store values from -2 to the power of 31 to 2 to the power of 31 minus 1. \n- long data type: requires 64 bits and can store values from -2 to the power of 63 to 2 to the power of 63 minus 1.\n\nJava Data Types for Reals\n\nThis slide describes the Java data types for real numbers. \n- float data type: is a single-precision 32-bit IEEE 754 floating point. \n- double data type: is a double-precision 64-bit IEEE 754 floating point. \n", "Primitive Data Types\n\nA list of primitive data types is presented, categorized as integers and reals. Integers include: byte, short, int, long. Reals include: float, double. Other primitive data types listed: boolean, char.\n\nPlay with Unsigned & Signed Integers\n\nThis slide presents a binary representation of a number and its decimal equivalent.  The binary representation is shown as a sum of powers of 2, with each bit multiplied by the corresponding power of 2.  The decimal representation is shown as a sum of powers of 10. \n", "Slide 1: 2. Representation of Programs\n\nSlide 2: Edition and Execution together\n\nThe slide shows a calculator with a piece of paper being fed into it. The paper has the mathematical operation \"153 / 2\" written on it. A hand is pressing the \"2\" key on the calculator. Below the calculator, there is another piece of paper with the same mathematical operation \"153 / 2\" written on it. \n", "Slide 21: Edition and Execution separated\n\nThis slide explains the concept of Edition and Execution being separated.\nThere are two columns, one for Edition and one for Execution.\nIn the Edition column, there is a hand using a calculator to enter the numbers 153 and 2.\nThere is an upward arrow pointing to a piece of paper with the same numbers 153 and 2 written on it.\nIn the Execution column, there is a calculator with the number 256 on the display.\nThere is a downward arrow pointing to a piece of paper with the numbers 153 and 2 written on it.\n\nSlide 22: Interpretation\n\nThis slide shows a diagram explaining the concept of Interpretation.\nThere are three boxes, one labeled \"input\", one labeled \"Interpretation\" and one labeled \"output\".\nThere is an arrow going from the \"input\" box to the \"Interpretation\" box, and another arrow going from the \"Interpretation\" box to the \"output\" box.\nBelow the \"Interpretation\" box, there is a box labeled \"program\" and an arrow pointing upwards from the \"program\" box to the \"Interpretation\" box.\n", "Compilation\n\nThe first diagram shows the process of compilation. The input is a program, which is fed into the compiler. The compiler then outputs an executable. The executable is then executed, which produces the output. \n\nThe second diagram shows a more detailed view of the compilation process. The input is source code, which is fed into the compiler. The compiler then outputs machine code. The machine code is then executed, which produces the output. \n", "Java Virtual Machine\n\nThe first diagram shows the process flow of the Java Virtual Machine. The input is source code, which is compiled into byte code. The byte code is then executed by the JVM, which uses the class libraries to execute the code. The output is the result of the execution.\n\nThe second diagram shows the same process flow, but with the addition of the Write Once Run Anywhere (WORA) principle. WORA means that Java code can be compiled on one platform and then run on any other platform that has a JVM. This is because the JVM is platform-independent. The diagram shows that the byte code can be executed on multiple platforms, each with its own machine code.\n", "Java Development Kit\n\nThis slide describes the Java Development Kit (JDK) and provides a simple Java program. \n\nThe JDK diagram illustrates the process of compiling and running a Java program. It starts with the input source code, which is then compiled into byte code. The byte code is then executed by the Java Virtual Machine (JVM), which uses class libraries and converts it into machine code. Finally, the output is generated. The JDK is represented by the dashed box encompassing the compilation and source code elements, while the JRE (Java Runtime Environment) is represented by the dashed box encompassing the JVM and class libraries.\n\nThe \"Program\" section presents a basic \"Hello World\" program written in Java. The code defines a class called \"HelloWorld\" with a \"main\" method. Inside the \"main\" method, the code uses \"System.out.println\" to display the text \"Hello, World!\" on the console. \n", "**Program as Data**\n\nWe see a snippet of Java code that defines a class called \"HelloWorld\" with a main method. This method prints the text \"Hello, World!\" to the console.\n\nThe code is shown passing through a \"compiler\" represented by a red arrow. The compiler transforms the code into a sequence of binary digits (0s and 1s).\n\n**Program as Instructions**\n\nThe same Java code snippet is shown again. This time, it is being executed by a \"computer\" represented by a red arrow. The computer interprets the code as instructions and produces the output \"Hello, World!\".\n\nThis slide illustrates the two ways in which a computer program can be viewed: as data (a sequence of bits) and as instructions (commands that the computer can execute). \n", "The image shows a diagram representing the interaction between a computer's primary and secondary storage and two mobile phones.\n\nThe diagram shows two boxes, one labeled \"Secondary storage\" and the other \"Primary storage\". An arrow labeled \"load\" goes from the secondary storage to the primary storage. The primary storage box shows three memory locations, 254, 255, and 256. Arrows labeled \"run\", \"get\", and \"set\" go from the primary storage to a box below labeled \"Processing unit\". Arrows labeled \"output\" and \"input\" go from the processing unit to a group of icons representing I/O devices: a mobile phone, a printer, and a keyboard.\n\nThe two mobile phones in the image show different applications installed on them. The first phone shows applications like \"edx\", \"Safari\", and \"UC3M\". The second phone shows applications like \"Camera\", \"Photos\", \"Music\", \"Videos\", \"Calculator\", \"Safari\", \"Recordatorios\", \"Passbook\", \"UC3M\", \"JavaMOOC\", \"edX\", \"Tel\u00e9fono\", \"iTunes Store\", \"App Store\", and \"Ajustes\". \n"]}, {"filename": "2 en.pptx.pdf", "pages_description": ["**1. Conditional Statement**\n\n**Conditional Statement**\n\nWe have a code snippet that demonstrates a conditional statement. The statement checks if the value of variable 'n' is less than zero. If the condition is true, the code within the if statement will be executed, which in this case is assigning the negative of 'n' back to 'n'. \n", "Conditional Statement\n\nWe have a table with one column labeled 'n'. The first row has the value '-3'. The second row is empty. The third row has the value '3'. There is a conditional statement: if n is less than 0, then n equals -n.\n\nConditional Statement\n\nWe have a table with one column labeled 'n'. The first row has the value '3'. The second row is empty. The third row has the value '3'. There is a conditional statement: if n is less than 0, then n equals -n.\n", "Conditional Statement\n\nWe have a conditional statement \"if n is less than 0, then n becomes -n and x becomes 0\".\n\nA table shows different values for n and x.\nWhen n is -3, x is 1.\nWhen n is 3, x is 1.\nWhen n is 3, x is 0.\nWhen n is 3, x is 0.\n\nConditional Statement\n\nWe have a conditional statement \"if n is less than 0, then n becomes -n\".\n", "Slide 1: Conditional Statement\n\nWe see a code snippet showing an if statement. The condition of the if statement is n less than zero. If the condition is true, the statement inside the curly braces will be executed. The statement inside the curly braces is n equals minus n. There is a warning sign on the right side of the code snippet.\n\nSlide 2: Conditional Statement\n\nWe see a code snippet with a generic if statement. The code is showing the syntax of an if statement. The if keyword is followed by a boolean expression in parentheses. If the boolean expression is true, the statements inside the curly braces will be executed. \n", "2. Alternative\n\nWe have a code snippet and two tables with data. The code snippet shows an if-else statement. If the variable \"n\" is less than 0, then the variable \"x\" will be assigned the value of negative \"n.\" Otherwise, if \"n\" is not less than 0, the variable \"x\" will be assigned the value of \"n.\"\n\nThe first table shows \"n\" with a value of -3. After the if-else statement, the \"x\" variable is assigned a value of 3.\n\nThe second table shows \"n\" with a value of 3. After the if-else statement, the \"x\" variable is assigned a value of 3. \n", "Alternative\n\nWe have a code snippet with an if-else statement. The if condition checks if 'n' is less than 0. If true, it sets 'x' to '-n', 's' to \"n\\<0\", and 'b' to true. Otherwise, it sets 'x' to 'n', 's' to \"n>=0\", and 'b' to false.\n\nNested Conditionals\n\nAnother code snippet shows an if-else statement with a nested condition. The initial if condition checks if 'n' is less than 0. If true, it sets 'x' to '-n' and 's' to \"n\\<0\". The else block should contain the logic for when 'n' is greater than or equal to 0. There are two logical conditions suggested for this block: one checks if 'n' is not less than 0 and 'n' equals 0, while the other checks if 'n' is not less than 0 and 'n' is not equal to 0. \n", "Nested Conditionals\n\nWe have some code examples of nested conditionals. The first example has three branches. The first branch checks if n is less than zero. If so, x is assigned negative n and s is assigned the string \"n<0\". Otherwise, if n equals zero, then x is assigned zero and s is assigned the string \"n==0\". Otherwise, x is assigned n and s is assigned the string \"n>0\". To the right of the code, we have the conditions that are true for each branch. The first branch is true if n is less than zero. The second branch is true if n is not less than zero and n equals zero. The third branch is true if n is not less than zero and n does not equal zero.\n\nThe second example has four branches. The first branch checks if n is less than zero. If so, x is assigned negative n and s is assigned the string \"n<0\". Otherwise, if n equals zero, then x is assigned zero and s is assigned the string \"n==0\". Otherwise, if n is less than 5, then x is assigned n and s is assigned the string \"0<n<5\". Otherwise, x is assigned n and s is assigned the string \"n>=5\". To the right of the code, we have the conditions that are true for each branch. The first branch is true if n is less than zero. The second branch is true if n is not less than zero and n equals zero. The third branch is true if n is not less than zero, n does not equal zero, and n is less than 5. The fourth branch is true if n is not less than zero, n does not equal zero, and n is not less than 5. \n", "Nested Conditionals\n\nThe image shows two code snippets, both of them implement the same logic using nested conditional statements.\n\nThe first snippet uses an if-elseif-else statement to check the value of a variable 'n'. If 'n' is less than 0, 'x' is assigned the value of '-n' and 's' is assigned the string \"n<0\". If 'n' is equal to 0, 'x' is assigned the value 0 and 's' is assigned the string \"n==0\". If 'n' is less than 5, 'x' is assigned the value of 'n' and 's' is assigned the string \"0<n<5\". Otherwise, 'x' is assigned the value of 'n' and 's' is assigned the string \"n>=5\".\n\nThe second snippet uses nested if statements to implement the same logic. If 'n' is less than 0, 'x' is assigned the value of '-n'. Otherwise, if 'n' is equal to 0, 'x' is assigned the value 0. Otherwise, 'x' is assigned the value of 'n'.\n", "3. Conditional Expression\n\nThis slide explains conditional expressions with ternary operators. A conditional expression with a ternary operator follows this format: Boolean Expression question mark Expression colon Expression. An example is shown as (n greater than 0) question mark 1 colon 2. The Boolean expression has to be a Boolean type. The other expressions can be arbitrary but must be the same type. \n", "Expression with Ternary Operator\n\nThis slide explains how to use the ternary operator. \n\nA ternary operator follows this structure:  Boolean Expression, followed by a question mark, followed by Expression 1, followed by a colon, followed by Expression 2.\n\nIf the Boolean Expression is true, the entire expression evaluates to Expression 1. If the Boolean Expression is false, the entire expression evaluates to Expression 2.\n\nFor example, if n is greater than 0, then the expression (n > 0) ? 1 : 2 evaluates to 1. If n is not greater than 0, the expression evaluates to 2.\n\nExample: Absolute Value\n\nThis slide provides an example of how to use the ternary operator to calculate the absolute value of a variable.\n\nWe declare an integer variable called x.\n\nWe then declare an integer variable called absx and set it equal to the following expression: (x > 0) ? x : -x;\n\nIf x is greater than 0, absx will be assigned the value of x. If x is not greater than 0, absx will be assigned the value of -x.\n\nThe slide concludes by stating that absx is always non-negative and that it is the absolute value of x.\n", "Example: Absolute Value\n\nThe expression \"absx = (x greater than 0) ? x : -x\" is equivalent to \"if (x greater than 0) absx=x; else absx=-x\"\n\nConditional Statement and Conditional Expression\n\nThe conditional statement \"if (b) {x=m;} else {x=n;}\" is equivalent to the conditional expression \"x = (b) ? m : n\"\n", "Never-ending Computations\n\nThe image shows examples of never-ending computations. \n\nFor example, the expression \"(true) ? 1 : never-end\" evaluates to 1. The expression \"(false) ? 1 : never-end\" evaluates to \"never-end\". \n\nThe image also shows two conditional statements. The first statement is \"if (b==true) {S1;} else {S2;}\". The second statement is \"if (b) {S1;} else {S2;}\". \n", "There are three conditional statements that determine whether to execute statement S1 or S2. The first statement checks if the variable 'b' is equal to false. If it is, then S1 is executed, otherwise S2 is executed. The second statement checks if 'b' is not true. If it is not, then S1 is executed, otherwise S2 is executed. The third statement checks if 'b' is true. If it is, then S2 is executed, otherwise S1 is executed. \n", "There are two truth tables shown, one above the other. \n\nThe first truth table has one input, \"b\", and two possible outputs, \"false\" and \"true\". If \"b\" is false, the output is \"false\". If \"b\" is true, the output is \"true\". The third line shows the logical operation \"not b\".\n\nThe second truth table has two inputs, \"b\" and \"c\", and shows the outputs for three different expressions. The first expression, \"b?c:false\", evaluates to \"c\" if \"b\" is true, and \"false\" otherwise. The second expression, \"b&&c\", is a logical AND operation, evaluating to \"true\" only if both \"b\" and \"c\" are true. \n", "There are two code snippets, \"b ? true : c\" and \"b || c\".  The title of the next slide is \"4. Expressions and Statements for Assignment\". \n", "Expressions and Statements\n\nThe first slide defines expressions and statements. It assumes x equals 3. An expression, x plus 2, evaluates to 5. A statement, x equals x plus 1, produces an effect and changes the value of x to 4.\n\nThe second slide shows the same example, but with additional descriptions. Expressions are defined as evaluating to a value, while statements are defined as producing an effect or doing something. \n", "Statement with Value?\n\nWe see four different statements. The first one is \"x equals x plus 1\". The second statement is \"y equals x equals x plus 1\". The third statement is \"y equals, open parenthesis, x equals x plus 1, close parenthesis\". Finally, the fourth statement is \"x equals x plus 1\" and \"y equals x\".\n\nIncrement x\n\nWe see eight different statements. The first one is \"x equals x plus 1\". The second statement is \"x plus equals 1\". The third statement is \"x minus equals 2\". The fourth statement is \"x times equals 3\". The fifth statement is \"x divided equals 4\". The sixth statement is \"x modulo equals 5\". \n", "Increment x by 1\n\nThe first slide shows four ways to increment the value of a variable x by 1. They are x = x + 1, x += 1, ++x, and x++. The first two are simple assignments, while the last two are prefix and postfix increment operators, respectively. The prefix increment operator (++x) increments the value of x before the value of x is used, while the postfix increment operator (x++) increments the value of x after the value of x is used. In this example, the initial value of x is 3. When the prefix increment operator (++x) is used, the value of x is incremented to 4, and then the new value of x (4) is used. When the postfix increment operator (x++) is used, the old value of x (3) is used, and then the value of x is incremented to 4.\n\nThe second slide shows the same four ways to increment the value of a variable x by 1, but this time the initial value of x is not shown. The values of x after each operation are shown in speech bubbles. The values in the speech bubbles confirm that the prefix increment operator (++x) increments the value of x before the value of x is used, while the postfix increment operator (x++) increments the value of x after the value of x is used. \n", "Pre- and Post-fix Increment\n\nWe have a table that shows the values of x, y, and z after applying pre- and post-fix increment operations.\n\nInitially, x is 3.\n\nIn the first scenario, using the prefix increment (++x), y becomes 4, and z also becomes 5.\n\nIn the second scenario, using the postfix increment (x++), x is incremented to 4, then assigned to y, resulting in y being 4. Finally, z is assigned the value of x before the increment, which is 4, and then x is incremented to 5.\n\nSummary\n\nExpressions have values, while statements perform actions and change the program's state.\n\nThe prefix increment operator (++x) returns the value after the increment, while the postfix increment operator (x++) returns the value before the increment.\n"]}, {"filename": "1.pdf", "pages_description": ["Overview\n\nThe slide is titled \"Overview\" and lists six items: Values, Expressions, Statements, Programs, Data Types, and Identifiers.\n\nThe second slide is titled \"1. Display for Values\" and shows an image of a basic calculator with the number 36 in the display. \n", "Values\n\nThis slide introduces the concept of numeric integer values. It specifies that these values can have multiple digits and may include a minus sign. Examples of such values are provided: 0, -1, 36, and 987654321.\n\n2. Display for Expressions\n\nThis slide, titled \"2. Display for Expressions,\" features an illustration of a calculator. The calculator screen displays the expression \"3\u00d712\". \n", "Expressions\n\nThe image describes the concept of expressions using two examples.\n\nThe first example shows the multiplication \"3 * 12\" and labels the number 3 and the number 12 as operands and the multiplication symbol \"*\" as the operator.\n\nThe second example shows the expression \"(1 + 2) * 12\". It labels \"(1 + 2)\" and \"12\" as expressions and the multiplication symbol \"*\" as the operator.\n", "Expressions (with Integers)\n\nThe slide shows examples of expressions with integers and their values. For example, 3 to the power of 2 is 9, the square root of 9 is 3, and the factorial of 3 is 6. The slide also shows different operators, such as infix, postfix, and prefix operators. In infix notation, the operator is placed between the operands, while in postfix notation, the operator is placed after the operands. In prefix notation, the operator is placed before the operands.\n\nExpressions evaluate to a Value\n\nThe slide shows examples of expressions and their values. For example, (3*4)+2 evaluates to 14, 3*(4+2) evaluates to 18, and 3*4+2 evaluates to 14. The slide also shows that the factorial of 3 is 6 and that 3 to the power of 2 is 9. \n", "**3. Display for Statements**\n\nThe image shows a calculator with a display that reads \"x = x * 12;\". There are two memory cells labeled \"2 y\" and \"3 x\". The \"2 y\" memory cell has buttons labeled \"set\" and \"get\". The \"3 x\" memory cell also has buttons labeled \"set\" and \"get\".\n\n**Variables**\n\n- Extensions, or memory cells, can be purchased for the calculator.\n- These memory cells can store a value for future use.\n- Each memory cell has a predefined name.\n- Each memory cell is called a variable.\n- A value can be stored in the variable (set) or retrieved from the variable (get). \n", "Expressions with Variables (get)\n\nThis slide introduces the concept of expressions with variables. It explains that to get the value stored in a variable, you simply write the name of the variable. For example, if the variable 'x' is set to 3, then writing 'x' in an expression will evaluate to 3. The slide then provides three examples of expressions with variables, assuming that 'x' is set to 3 and 'y' is set to 2. The expressions are: (x * 4) + 2, (x * 4) + y, and (x * 4) + (x - 1).\n\nVariable Assignment (set)\n\nThis slide explains how to assign a value to a variable. It states that to set a variable to a value, you write the name of the variable followed by an equal sign (=), then the expression whose value you want to store, and finally a semicolon (;). The slide emphasizes that this is not an equation to be solved or an equality to be computed. Instead, it's an assignment operation. The expression on the right side of the equal sign is evaluated first, and then the resulting value is assigned to the variable on the left side. The slide provides three examples of variable assignments: x = 3;, y = 3 * 2;, and y = x * 2; x = x * y;. The first assignment sets the variable 'x' to 3. The second assignment sets the variable 'y' to the value of the expression 3 * 2, which is 6. The third assignment first sets the variable 'y' to the value of the expression x * 2 (which is 6, since 'x' is 3), and then sets the variable 'x' to the value of the expression x * y (which is 18, since 'x' is 3 and 'y' is now 6). \n", "**Statement**\n\nAn assignment is not an expression, it is a statement. Statements have effects on the set of values stored, the state.\n\nThere are three code snippets and their effects on variable values.\n\n- Initially, both x and y have a value of 1. After executing the statement \"x=3\", the value of x changes to 3 while y remains 1.\n\n- In the second snippet, x is initially 3 and y is 1. After executing \"y=x*2\", the value of y becomes 6 (3 multiplied by 2) while x remains 3.\n\n- In the third snippet, x is initially 3 and y is 6. After executing \"x=x*y\", the value of x becomes 18 (3 multiplied by 6) while y remains 6.\n\n**State Transformation**\n\nThis slide illustrates how the values of variables change as a sequence of statements is executed.\n\nInitially, all variables (u, v, w, x, y, z) have a value of 1.\n\n- After executing \"w=2\", the value of w changes to 2 while all other variables remain unchanged.\n\n- Then, the statement \"z=u+v+w+x\" is executed. As a result, the value of z becomes 5 (1+1+2+1) while all other variables remain unchanged.\n\n- Finally, the statement \"x=x-y\" is executed. This changes the value of x to 0 (1-1) while all other variables remain unchanged.\n", "Display for Statements\n\nThe image shows a calculator with the statement \"x = x * 12\" displayed on the screen. The keys \"2\", \"y\", \"set\", \"get\", \"3\", \"x\" are highlighted to indicate the sequence of keys pressed to enter the statement.\n\nDisplay for Programs\n\nThe image shows a calculator with the statements \"x = 3\" and \"x = x * 12\" displayed on the screen. The keys \"3\", \"x\", \"set\", \"get\" are highlighted to indicate the sequence of keys pressed to enter the statements as a program. \n", "There are two slides.\n\nThe first slide numbered 19 shows a calculator with a blue up arrow on top of it and a piece of paper with the number 153 and 2 written on it. There is another blue arrow pointing up from the bottom of the calculator to another piece of paper with the same numbers 153 and 2 written on it.\n\nThe second slide numbered 20 is titled **Program** and shows a definition of a computer program and an example.\n\nA program is a recorded computation, it is a record of the computation. It can be stored for later use, run several times, checked for correctness, and modified. The program is the software, the device, the hardware.\n\nThe example shows a function written in a c-style language. The function is called **processData** and it takes no arguments. The function has a do-while loop that gets data by calling a function **getData** which takes no arguments. If the data is less than 0, it calls a function **performOperation1** with data as the argument, otherwise, it calls a function **performOperation2** with data as the argument. The loop continues as long as the function **hasMoreData** which takes no arguments returns true.\n", "**Recipe for Spanish Potato Omelet**\n\nThe recipe for Spanish Potato Omelet lists the ingredients: 1lb/450g waxy potatoes, 1 large white/Spanish onion (optional), about 1 liter of oil (olive oil is best), 6 eggs, and a pinch of salt. \n\nThe procedure is as follows: Peel and slice the potatoes thinly. Heat the oil in a large saut\u00e9 pan. Add the potatoes and fry until soft and cooked through. Slice the onion thinly and fry. Beat the eggs in a large bowl and add salt. Add the potatoes and onion to the eggs. Drain the oil. Pour the potato mixture back into the pan and cook. Place a large plate over the pan and turn it over. Slide the omelet back into the pan and cook. Repeat the turning process. Serve on a large plate. \n\nAn image of a Spanish Potato Omelet is shown. \n\n**Instructions to Draw a Triangle**\n\nThe instructions to draw a triangle are presented as code blocks. The code sequence is: repeat 3 times (move 100 steps, wait 1 second, turn 120 degrees, wait 1 second). \n\nThe output of the code is shown as a drawing of a triangle. \n", "There are four concepts presented here: value, expression, statement, and program. A value is \"7\". An expression is \"3 + 4\". A statement is \"d = 3 + 4;\". A program is \"d = 2 - 1; x = d; d = x * d; d = 3 + 4;\".\n\nThe next slide is titled \"5. Data Types\". There are three data types listed: Arithmetic, Logic, and Text. Arithmetic data types are numbers. An example is \"1 + 2\". Logic data types are Boolean values. Examples are \"true\" and \"false\". Text data types are strings. An example is \"he\" + \"llo\". \n", "Arithmetic Calculator\n\nWe have an arithmetic calculator with a display showing \"d =\" and \"0;\". The calculator has buttons for the digits 0 through 9, as well as buttons for the operations plus, minus, multiplication, division, and modulo. There are also buttons for \"C\" and \";\".\n\nLogic Calculator\n\nWe have a logic calculator with a display showing \"d =\" and \"false;\". The calculator has buttons for \"C\" and \";\", as well as buttons for \"T\", \"F\", \"&&\", \"||\", and \"!\". \n", "**Boolean Algebra**\n\n- Values: true, false\n- Operations: Negation (not): !, Conjunction (logical and): &&, Disjunction (logical or): ||\n\n**Logic Gates**\n\nThe first figure shows four truth tables for negation, conjunction, implication, and disjunction.\n\nThe second figure shows the logic gates for the four operators: NOT, AND, implication, and XOR.\n\nThe third figure shows the De Morgan equivalents for AND and implication.\n\nThe fourth figure shows the Venn diagrams for conjunction, disjunction, implication, and XOR. \n", "Negation (not)\n\n- The negation of a boolean value 'a' is denoted by '! a'.\n- If 'a' is true, then '! a' is false.\n- If 'a' is false, then '! a' is true.\n\nConjunction (logical and)\n\n- The conjunction of two boolean values 'a' and 'b' is denoted by 'a && b'.\n- The conjunction is true only if both 'a' and 'b' are true.\n- In all other cases, the conjunction is false.\n- The truth table for conjunction is as follows:\n    - true && true equals true\n    - true && false equals false\n    - false && true equals false\n    - false && false equals false\n- There are three diagrams illustrating the concept of conjunction:\n    - The first diagram is a truth table for conjunction, showing the output for all possible combinations of inputs.\n    - The second diagram is a logic gate diagram for conjunction, showing two inputs (x and y) and one output (x^y).\n    - The third diagram is a Venn diagram for conjunction, showing the intersection of two sets (x and y).\n", "**Disjunction (logical or)**\n\nThe expression \"a or b\" is represented by the symbol \"||\".  The truth table for disjunction shows that the expression is true if either a is true, b is true, or both a and b are true. The expression is only false if both a and b are false. The truth table is represented in four different ways: a table, a logic gate diagram, a simplified logic gate diagram, and a Venn diagram.\n\n**Arithmetic & Logic Calculator**\n\nThere is a calculator with arithmetic and logic functions. The arithmetic functions include the numbers 0 through 9, the operators for addition, subtraction, multiplication, and division, and a decimal point. The logic functions include \"and\", \"or\", \"not\", \"equals\", \"not equals\", \"greater than or equals\", \"greater than\", \"less than or equals\", and \"less than\".  The calculator also has a clear button and a display. The display shows that the current value is 0. \n", "**Comparison Operations**\n\n- less than is represented by the symbol '<'\n- greater than is represented by the symbol '>'\n- less or equal than is represented by the symbol '<='\n- greater or equal than is represented by the symbol '>='\n- equal than is represented by the symbol '=='\n- not equal than is represented by the symbol '!='\n\n**Functionality**\n\n- the symbol '+' represents an addition operation from RxR to R. For example, the addition of 3 and 4 results in 7\n- the symbol '&&' represents an AND logical operation from Bx to B. For example, the AND logical operation between true and false results in false\n- the symbol '>' represents a comparison operation from RxR to B. For example, the comparison between 3 and 4 results in false \n", "Text\n\nThis slide explains the concept of Characters and Strings. Characters are denoted by single quotes, for example, 'a', 'A', '1', ''. Strings are denoted by double quotes, for example, \"Java\", \"Hello, World!\", \"2015\", \" \", \"\".\n\nEscaping\n\nThis slide explains the concept of escaping in programming. There are three examples: \"\\\"Hello\\\"\", \"Hello\\n\", and \"\\\\ and \\\"\". The first example shows how to escape double quotes within a string. The second example shows how to insert a new line within a string. The third example shows how to escape backslashes within a string. \n", "Identifiers and Strings\n\nWe have a code snippet that shows how to declare a string variable in programming. The syntax is \"String\" followed by the variable name \"s\",  an equal sign, and the string value enclosed in double quotes, in this case, \"s\". The variable \"s\" is identified as an identifier while the value \"s\" is identified as a string.\n\nConcatenation\n\nAnother code snippet shows how to concatenate strings. First, a string variable \"s\" is declared with the value \"s\". Then, another string variable \"t\" is declared with the value \"top\". Then, a string variable \"p\" is declared and its value is the concatenation of \"s\" and \"t\" which results in \"stop\". Finally, a string variable \"q\" is declared and its value is the concatenation of \"t\" and \"s\" which results in \"tops\".\n", "**Concatenation and Addition**\n\nWe have four variable declarations, an integer `n` initialized to 1 and a string `s` initialized to \"1\".\nThen we have `m` which is an integer resulting from the sum of `n` plus `n`, so `m` is equal to 2.\nThen we have string `p` which is the result of the concatenation of `s` and `s`, so `p` is equal to \"11\".\nFinally, we have string `q` which is the result of the concatenation of `s` and `n`, so `q` is equal to \"11\".\n\n**Length**\n\nWe have four string declarations, `s` initialized to \"s\", `t` initialized to \"top\", `p` initialized with an empty string and `q` initialized with an empty string.\nThen we have four integer variables.\n`n` is the length of string `s`, so `n` is equal to 1.\n`m` is the length of string `t`, so `m` is equal to 3.\n`j` is the length of string `p`, so `j` is equal to 0.\n`k` is the length of string `q`, so `k` is equal to 1.\n", "Substring\n\nThis slide explains how the substring method works in programming, using examples in what appears to be Java code.\n\n- First, a string with the value \"Hello!\" is created.\n- Then, the substring method is used to extract different portions of the string. \n- The first argument to the substring method is the starting index, and the second argument is the ending index. \n- If the second argument is omitted, the substring will include the rest of the string from the starting index.\n\nThe examples show how to extract \"11\", \"He\", \"llo!\", and \"llo!\" from the original string.\n\nPrinting\n\nThis slide shows two ways to print output to the console in Java:\n\n- System.out.print(...)\n- System.out.println(...) \n", "Identifiers (Freely Chosen Names) for Variables\n\nThere are two diagrams representing variables. The first one is a box labeled \"3\" and \"x\" with \"set\" and \"get\" buttons on the side. The second one is a box labeled \"3\" and a roller with letters and a digit \"1\" visible through a window. There are \"set\" and \"get\" buttons on the side.\n\nDeclaration of Variables\n\nThere is a list of variable declarations:\n- integer variable named \"number\"\n- integer variable named \"veryLongName\"\n- boolean variable named \"b\"\n- String variable named \"s\"\n", "What are Legal Names?\n\nThe slide shows correct and incorrect ways to name variables in a programming language.\n\n- Correct examples: \"n\", \"_n\", \"n1\", \"noMore\", \"no\", \"more\"\n- Incorrect examples: \"int\", \"n?\", \"1n\", \"no More\", \"no; int no\"\n\nRecommendations for Names\n\nThe slide shows recommended and not recommended ways to name variables.\n\n- Recommended examples: \"average\", \"finalBalance\", \"ONE\"\n- Not recommended example: \"sjdflsJDJF\", \"finalbalance\", \"one\"\n\nThe text \"For variables that are not going to change\" is pointing to the variable name \"ONE\". \n", "Declaration and Assignment\n\nOn the left hand side we have declaration of variables, first one is a boolean variable b and the second one is an integer variable n. On the right hand side we have declaration and assignment of variables, first we have a boolean variable b assigned to true and an integer variable n assigned to 1. The last two lines show incorrect syntax for declaration and assignment, the first one tries to assign an integer value to a boolean variable and the second one tries to assign a boolean value to an integer variable.\n\nRemember to watch videos and do exercises before you come to class! \n"]}, {"filename": "6 en.pdf", "pages_description": ["Summary\n\nThe slide is titled \"Summary\" and lists two bullet points: \"Partial functions\" and \"Recursive methods\". \n\nThe first bullet point \"Partial functions\" is accompanied by a diagram showing two sets of dots, labeled \"X\" and \"Y\", with arrows connecting some of the dots between the sets.\n\nThe second bullet point \"Recursive methods\" is accompanied by an image of a computer screen showing multiple windows nested within each other, creating a visual effect of infinite regress. \n", "Partial Functions\n\nThe image shows two ovals, one labeled X and the other labeled Y, with an arrow pointing from X to Y. Inside each oval, there are several dots. Some of the dots in X are connected to dots in Y with lines. Some dots in both ovals are not connected. \n", "Total Function\n\nThe image depicts two ovals representing sets X and Y. Inside each oval, there are several dots. Each dot in set X is connected to one and only one dot in set Y by a red arrow, illustrating a total function where every element in set X maps to exactly one element in set Y. \n", "Partial Function\n\nThe image depicts two ovals representing sets X and Y, with an arrow pointing from X to Y, indicating a function mapping from X to Y. Within each oval, there are several dots representing elements. Some elements in X are connected to elements in Y with arrows, illustrating the mapping of the function. However, not all elements in X have corresponding arrows pointing to elements in Y, signifying that this is a partial function. \n", "Total Function\n\nWe see a diagram depicting a total function from X prime to Y. Both X prime and Y are sets of elements represented by dots within ovals. Each element in X prime has one and only one corresponding element in Y, indicated by the arrows connecting them. \n", "Mathematics and Programming\n\n- In mathematics, we can freely fine-tune the sets in order to make the functions total.\n- In programming, with types instead of sets, we cannot adjust the elements as we wish. \n", "Square Root\n\nThe image shows the definition and use of the square root function in a programming context. The function is named \"sqrt\" and takes an integer \"x\" as input. The output of the function is a double-precision floating-point number, which represents the square root of the input value. The code snippet also includes a return statement, indicating that the function will return the calculated square root value. \n", "Square Root\n\nThe image shows the definition and use of the square root function in a programming context. The function is named \"sqrt\" and takes an integer \"x\" as input. The return type of the function is a double. The example shows the use of the function with the input \"-4\". The data flow diagram shows that the integer input is passed to the \"sqrt\" function, which returns a double as output. \n", "Square Root: Partial Definition\n\nWe have a number line ranging from minus five to plus five. There are two lines below the number line. The first line starts from minus five and ends at zero. The second line starts at zero and ends at plus five. The section of the number line from minus five to zero, enclosed in the first line, is labeled \"Not defined\". The section of the number line from zero to plus five, enclosed in the second line, is labeled \"Defined\". Below the number line, we see \"N\" an arrow pointing right, and \"R\". \n", "What to do when a method is called with a value for which there is no image?\n\nWe have four options: expect an error, give information for correct use, prepare useful documentation, or treat this case programmatically. Expecting an error means that the programmer should pay more attention. Giving information for correct use helps the programmer pay attention. Preparing useful documentation helps building this documentation. Treating this case programmatically means programming the exceptional cases.\n", "Comments\n\nThe slide is titled \"Comments: one line\". The code snippet shows a function definition in c++. The function is called \"sqrt\" and takes an integer \"x\" as input and returns a double. There are two single-line comments in the function body. The first comment says that \"x has to be non-negative\". The second comment says \"here comes the return value\". \n", "Comments: multiple lines\n\nWe have a code snippet with a function definition. The function is called \"sqrt\" and it takes an integer \"x\" as input and returns a double. There is a multi-line comment inside the function definition that says \"x has to be non-negative\". The function body also contains the statement \"return ...;\". \n", "Javadoc\n\nThis slide introduces the concept and usage of Javadoc. It shows an example of a Javadoc comment block that can be placed before a Java method declaration.\n\nThe comment block starts and ends with `/**` and `*/` respectively. Each line within the comment block starts with an asterisk `*`. \n\nThis specific Javadoc comment block documents a method named `sqrt` that takes an integer `x` as input and returns a double-precision floating-point value representing the square root of `x`. \n\nThe comment block also includes Javadoc tags such as `@author`, `@version`, `@param`, and `@return`. These tags provide specific information about the method, such as the author's name, the version of the method, the parameters passed to the method, and the value returned by the method.\n\nOn the right side, there is a box that shows how this Javadoc comment block would be rendered in a documentation tool. It presents the information extracted from the Javadoc tags in a structured format, including the method's description, parameters, return value, version, and author.\n", "Javadoc\n\nThe slide is titled \"Javadoc\" and focuses on the method \"sqrt\" provided by Java. The slide presents a screenshot of the Javadoc documentation for the \"sqrt\" method from the Java Math class. The documentation specifies that the method takes a double as an argument and returns the correctly rounded positive square root of that double value. It also outlines special cases: if the argument is NaN or less than zero, the result is NaN; if the argument is positive infinity, the result is positive infinity; if the argument is positive or negative zero, the result is the same as the argument. In all other cases, the result is the double value closest to the true mathematical square root of the argument. The documentation also provides the base URL for the Java documentation. The slide highlights the use of \"Math.sqrt(4)\" as an example. \n", "Exceptions\n\nThis slide is about exceptions. We see a code snippet defining a function called \"sqrt\" that takes an integer \"x\" as input and returns a double. The function throws an exception if the input \"x\" is less than 0. Otherwise, it returns a value, which is not specified in the code snippet. \n", "Exceptions: Examples\n\nWe have a code snippet that shows an example of an exception. The method takes an integer array as an argument and iterates through it using a for loop. The loop iterates from 0 to the length of the array. Inside the loop, the code prints the value of each element in the array. However, the loop condition is incorrect. It should be \"i < a.length\" instead of \"i <= a.length\". This will cause an ArrayIndexOutOfBoundsException when i equals the length of the array, as the index of the last element in an array is one less than its length. \n", "Exceptions: Examples\n\nWe have a code snippet that shows an example of an exception. The method takes an integer array as an argument and prints each element of the array. If the array is not initialized, a NullPointerException will be thrown. \n", "Exceptions: Examples\n\nWe have a code snippet that demonstrates exception handling in Java. The code defines a method named \"method\" that takes an integer array \"a\" as input. Inside the method, there is a try-catch block. The \"try\" block iterates through the input array \"a\" using a for loop and prints each element of the array using \"System.out.println(a[i])\". If the input array \"a\" is not initialized, a \"NullPointerException\" will occur. The \"catch\" block catches this exception and prints an error message \"The array was not initialized\" to the standard error stream using \"System.err.println\". \n", "Exceptions: Examples\n\nWe have a code snippet that shows an example of an exception. The method named \"method\" takes two integers, a and b, as input and returns their quotient. If the value of b is 0, it results in an ArithmeticException. \n", "Exceptions: Examples\n\nWe have a code snippet that shows an example of exceptions. The method takes two integers, a and b, as input and is designed to throw an exception. Inside the method, there is a condition that checks if b is equal to zero. If b is equal to zero, a new exception is thrown. If b is not zero, the method returns the result of a divided by b. \n", "Recursive Methods\n\nThe image shows multiple windows nested inside each other, creating an optical illusion of an endless tunnel. This visual represents the concept of recursion, where a function calls itself repeatedly, creating a nested structure of function calls. \n", "Square: x<sup>2</sup>\n\nWe have the definition of a function called \"square\" that takes an integer \"x\" as input and returns an integer. The function calculates the square of the input integer \"x\" by multiplying it by itself (x*x) and returns the result. There is a diagram showing the function call with an input of type integer and an output also of type integer. The box in the middle represents the \"square\" function.\n", "Power: XY\n\nWe have a function definition for the function \"power\" which takes two integer arguments, x and y, and returns an integer value. The function calculates the value of x raised to the power of y. \n", "Power: XY\n\nWe see a code snippet, apparently from a presentation about algorithms. The code is a function written in C that calculates the power of a number. The function takes two integer arguments, x and y, and returns an integer. The function first checks if y is equal to 0. If it is, it returns 1. Otherwise, it checks if y is equal to 1. If it is, it returns x. Otherwise, it checks if y is equal to 2. If it is, it returns the square of x. Otherwise, it checks if y is equal to 3. If it is, it returns the cube of x. The code ends with a comment that asks \"until when?\". This suggests that the code is incomplete and that there should be more else if statements to handle other values of y. \n", "Power: XY\n\nWe see a code snippet, a function definition written in C programming language. The function is named \"power\" and takes two integer arguments, x and y. The goal of the function is to calculate x raised to the power of y. \n\nThe logic of the function checks for specific values of y. If y is 0, it returns 1. If y is 1, it returns x. If y is 2, it calls another function named \"square\" with x as an argument and returns the result. Similarly, if y is 3, it calls a function named \"cube\" with x as an argument and returns the result. \n\nThere is a comment at the end stating \"not very intelligent\", implying that this implementation is not efficient for calculating powers for values of y other than 0, 1, 2, and 3. \n", "Power: XY\n\nProvided Y is greater than or equal to 0:\n\nX to the power of Y equals X multiplied by itself Y times. \n", "Power: XY\n\nWe have a code snippet that defines a function named \"power\" that takes two integer arguments, x and y. The function calculates x raised to the power of y. Inside the function, an integer variable z is initialized to 1. A for loop iterates from 1 to y, and in each iteration, z is updated by multiplying it with x. Finally, the function returns the value of z. \n", "Table for y equal 3\n\nWe have a table that describes the values of i, i less than or equal to y, z, and return. The table has 5 rows. The first row is a header row, with the following column headers: i, i less than or equal to y, z, and return. The second row has the following values: 1 for i, true for i less than or equal to y, and x for z. The third row has the following values: 2 for i, true for i less than or equal to y, and x squared for z. The fourth row has the following values: 3 for i, true for i less than or equal to y, and x cubed for z. The fifth row has the following values: 4 for i, false for i less than or equal to y, and x cubed for return. The cell for z in the fifth row is shaded gray. \n", "Table for y equal 0\n\nThe table has four columns: i, i less than or equal to y, z, and return. When i equals 1, i less than or equal to y is false, z is blank, and return is 1. \n", "Recurrence Equation\n\nThe image describes a recurrence equation for calculating the power of a number.\n\nThe precondition for this equation is that y should be greater than or equal to 0.\n\nThe equation has two parts:\n\n* If y is equal to 0, then x to the power of y is equal to 1.\n* If y is greater than 0, then x to the power of y is equal to x multiplied by x to the power of y minus 1.\n\nThe equation satisfies the precondition because if y is greater than or equal to 1, then y minus 1 will always be greater than or equal to 0.\n", "Recursive Method\n\nWe see a code snippet that shows a recursive method named \"power\". It takes two integer arguments, x and y, and returns an integer. The method calculates x raised to the power of y, given that y is greater than or equal to 0.\n\nIf y is equal to 0, the method returns 1. Otherwise, it returns x multiplied by the result of calling the power method recursively with arguments x and y-1.\n\nThere is a red starburst shape with the text \"Can we do that?\" pointing to the recursive call of the power method within its own definition. \n", "power(x,3)\n\nThis slide seems to illustrate a recursive approach to calculate the power of a number. The expression \"power(x,3)\" indicates the goal is to compute x raised to the power of 3. The subsequent lines break down this calculation into smaller steps.  It seems like there is an error in the code, as the condition (3==0) will always evaluate to false.  The code then attempts to calculate x*power(x,2) twice, which is redundant. Finally, the last line summarizes the outcome of this process, indicating that \"power(x,3)\" can be expressed as \"x*power(x,2)\". \n", "power(x,2)\n\nThe image shows a code snippet for a recursive function named \"power\" that takes two arguments, x and 2. The function is designed to calculate the result of x raised to the power of 2. The code first checks if the second argument, 2, is equal to 0. If it is, the function returns 1. Otherwise, it recursively calls itself with the same value for x and the second argument decremented by 1. The final returned value is x multiplied by the result of the recursive call. The code then shows a simplified representation of the function call, replacing it with x*power(x,1). \n", "power (x, 1)\n\nThe image shows a code snippet for a recursive function named \"power\" that takes two arguments, x and l, and returns x to the power of l. \n\nThe function first checks if l is equal to 0. If it is, it returns 1. Otherwise, it checks if l is equal to 1. If it is, it returns x. Otherwise, it returns x multiplied by the result of calling the power function recursively with x and l-1 as arguments.\n\nFinally, the image shows that the function call power(x, 1) is equivalent to x * power(x, 0). \n", "power(x,0)\n\nThe image shows a code snippet for a function named \"power\" that takes two arguments, x and 0. \nThe function first checks if 0 is equal to 0. If it is, it returns 1. \nOtherwise, it recursively calls the power function with x and 0-1 as arguments. \nThe code then checks if true is true, which it always is, and returns 1. \nOtherwise, it recursively calls the power function with x and -1 as arguments. \nFinally, the function returns 1. \n\nThe last line shows the result of calling the power function with x and 0 as arguments, which is 1. \n", "Summary\n\nWe see four mathematical equations that define a recursive function named \"power\".  The function \"power\" takes two arguments: a variable named \"x\" and an integer exponent. The equations show that the function \"power\" of x to the nth power is equal to x times the \"power\" of x to the (n-1)th power. The base case is when the exponent is zero, in which case the function returns 1. \n", "All Together\n\nHere we have a series of mathematical expressions, all of which are equivalent ways of representing x cubed. \n\nThe first expression, \"power(x,3),\" represents x raised to the power of 3. \n\nThe subsequent expressions break down x cubed into progressively simpler multiplications. For instance, \"x*power(x,2)\" expresses x cubed as x multiplied by x squared. \n\nThis pattern continues, with each expression expanding the previous one by replacing a power of x with an additional multiplication by x. \n\nThe final expression, \"x*(x*x),\" represents x cubed in its most basic form: x multiplied by itself three times. \n", "power(x,y)\n\nThis code defines a function called \"power\" that takes two integer arguments, x and y. The function calculates x raised to the power of y. The function includes a comment indicating that y should be greater than or equal to 0. Inside the function, there is an if statement that checks if y is equal to 0. If y is equal to 0, the function returns 1. Otherwise, the function returns x multiplied by the result of calling the power function recursively with x and y-1 as arguments. \n", "power(x,-2)\n\nThe image shows a code snippet for a recursive function named \"power\" that calculates the result of x raised to the power of -2. \n\nThe function first checks if the exponent (-2 in this case) is equal to 0. If it is, it returns 1. \n\nIf the exponent is not 0, the function checks if a condition is false. In this case, the condition is always false, so the function proceeds to the else block. \n\nIn the else block, the function recursively calls itself with the same value of x and the exponent decremented by 1 (x, -2-1, which is x, -3). This recursive call is multiplied by x and returned as the result.\n\nFinally, the last line shows the initial call to the power function with the arguments (x, -2) and indicates that this call can be represented as x*power(x, -3). \n", "power(x,-3)\n\nThe image shows a code snippet for a recursive function named \"power\" that calculates the result of x to the power of -3. The function first checks if -3 is equal to 0. If it is, it returns 1. Otherwise, it recursively calls itself with x and -3-1 as arguments, multiplies the result by x, and returns the value. The code then shows that the expression \"power(x,-3)\" is equivalent to \"x*power(x,-4)\". \n", "The image shows a series of recursive calls to a function named \"power\". \n\n- The first call is power(x, -2), which leads to x*power(x, -3).\n- The second call is power(x, -3), which leads to x*power(x, -4).\n- The third call is power(x, -4), which leads to x*power(x, -5).\n- The fourth call is power(x, -5), which leads to x*power(x, -6).\n\nThe ellipsis (...) indicates that this pattern continues indefinitely. \n\nFinally, the text \"Non-termination\" states that this recursive process will never end. \n", "A code snippet shows a function named \"power\" that takes two integer arguments, x and y. \nThe function returns an integer value. \nThere is a comment \"// y>=0\" next to the function definition.\nInside the function, there is an if statement that checks if y is equal to 0. \nIf y is equal to 0, the function returns 1. \nOtherwise, the function returns the product of x and the result of calling the power function recursively with arguments x and y-1. \n", "Termination condition\n\nWe see a code snippet that shows a function called \"power\" that takes two integer arguments, x and y. The function has a comment indicating that y should be greater than or equal to zero. Inside the function, there is an if statement that checks if y is equal to zero. If it is, the function returns 1. This is labeled as the \"Base case\". Otherwise, the function returns x multiplied by the result of calling the power function recursively with arguments x and y-1. This is labeled as the \"Recursive case\". \n", "Exercise 1\n\nImplement the recursive method \"square\" of integer N, which calculates the square of N when N is greater than 1. We shall consider the following formula in your implementation: open parenthesis N minus 1 close parenthesis squared, equals N squared minus 2N plus 1. \n", "Exercise 2\n\nImplement the recursive method riddle, which takes two integer arguments p and q, both greater than 0. Each time this method is called, the value of q increases by one, while the value of p decreases by one. When p is zero, the method returns the value of q.\n\nHow many times are the recursive and base cases executed when calling riddle with arguments 3 and 5, and what value is returned?\n", "Factorial\n\nThe image shows the definition of the factorial of a natural number n, and two examples.\nThe factorial of n is defined as n!=n*(n-1)*...*2*1\nThe first example shows that the factorial of 5 is 5!=5*4*3*2*1\nThe second example shows that the factorial of 4 is 4!=4*3*2*1 \n", "Factorial\n\nThis slide explains a mathematical trick for calculating factorials. It starts by stating the trick, which is to assume you already have the problem solved for a simpler task. Then it shows four equations. The first equation defines the factorial of n, denoted as fac(n), as n! which is equal to n multiplied by (n-1) multiplied by all the numbers down to 2 multiplied by 1. The second equation defines the factorial of (n-1), denoted as fac(n-1), as (n-1)! which is equal to (n-1) multiplied by all the numbers down to 2 multiplied by 1. The third equation states that n! is equal to n multiplied by (n-1)!. The fourth equation states that fac(n) is equal to n multiplied by fac(n-1). \n", "Factorial\n\nThe slide is about factorials. The second trick to remember about factorials is to check the border conditions. The factorial of zero is equal to zero factorial, which is equal to one. \n", "Factorial\n\nThis slide describes a factorial function, called \"fac\".\nIf the input \"n\" is equal to zero, the function returns one.\nIf the input \"n\" is greater than zero, the function returns n multiplied by the factorial of n minus one. \n", "Factorial\n\nThe image shows a mathematical formula for calculating the factorial of a number. The formula is defined recursively. It states that the factorial of n, denoted as fac(n), is equal to 1 if n is less than or equal to 1. Otherwise, it is equal to n multiplied by the factorial of (n-1).\n\nThe formula is also presented as a C++ function named \"fac\". The function takes an integer \"n\" as input and returns a long integer. The function implements the recursive definition of the factorial: if n is less than or equal to 1, it returns 1. Otherwise, it returns n multiplied by the result of calling the \"fac\" function with (n-1) as input.\n\nThe code is annotated with comments indicating the base case and the recursive case of the function. The base case is when n is less than or equal to 1, in which case the function returns 1. The recursive case is when n is greater than 1, in which case the function calls itself with a smaller value of n.\n", "Operational View\n\nThis slide describes the operational view of a factorial function. It shows how the function is evaluated step-by-step for the input value of 3. \n\nFirst, fac(3) is evaluated to 3 * fac(2). Then, fac(2) is evaluated to 2 * fac(1). Finally, fac(1) is evaluated to 1. \n\nThe second part of the slide shows the complete evaluation of fac(3) by substituting the values obtained in the previous steps. It shows that fac(3) is equal to 3 * (2 * 1), which is equal to 6. \n", "Mathematical View\n\nWe have three equations that describe a mathematical view of the factorial function. The first equation states that the factorial of 3 is equal to 3 multiplied by the factorial of 2, which is 6. The second equation states that the factorial of 2 is equal to 2 multiplied by the factorial of 1, which is 2. The third equation states that the factorial of 1 is equal to 1. \n", "Exercise 3\n\nImplement the recursive method gcd(int a, int b), which allows computing the greatest common divisor of two integer numbers.\n\nThe method is defined as follows:\n\ngcd(x, y) = x if y = 0\ngcd(x, y) = gcd(y, remainder(x, y)) if y > 0\n", "Exercise 4\n\nImplement the recursive method \"decToBin\" that takes an integer \"decimal\" and a String \"binary\" as parameters. This method receives a decimal number and returns a String containing the equivalent binary representation of that number. \n"]}, {"filename": "7 en calario-Sorting (I).pdf", "pages_description": ["Overview\n\nThis slide presents an overview of searching and sorting algorithms. The two main topics are searching and sorting. Under sorting, there are three basic algorithms: bubble sort, selection sort, and insertion sort. \n", "1. Searching\n\nThe image shows wooden letter tiles spelling out the word \"SEARCH\". The tiles are scattered among many other blank tiles. \n", "1. Searching\n\n- One of the most common operations in computer science.\n- The efficiency of the searching algorithm depends on whether the information is sorted or not.\n- Searching algorithms may internally call a sorting algorithm. \n", "1. Searching: Practical example\n\nWe have a three-step practical example of searching.\nFirst, think of a number between 0 and 999.\nSecond, tell someone to guess your number.\nThird, in every try, your colleague tells you a number and you can answer if the number is correct, higher than your number, or lower than your number. \n", "Searching: Linear search\n\nLinear search can be described in 3 steps: \nFirst, we start from an array of elements and an element we want to search. \nSecond, we traverse the array from left to right comparing each of its elements with the element we are searching for. If they are equal, then we return the position of the element and the search ends. If they are different, then we keep searching until the end of the array. \nThird, if we do not find the element, we return value -1.\nThe complexity of linear order is O(n). \n", "1. Searching: Linear search\n\nThis slide explains the concept of linear search with a code snippet and an example. The code snippet shows a function called \"linearSearch\" that takes an integer array \"a\" and an integer \"x\" as input and returns the index of \"x\" in \"a\" if it is found, otherwise it returns -1. The function iterates through the array \"a\" using a for loop and checks if each element is equal to \"x\". If it finds the element \"x\", it returns the index \"i\". If the loop completes without finding \"x\", it returns -1.\n\nThe example shows an array of 10 integers: 26, 8, 0, -2, 31, 3, 12, 9, 10, -5, and 6. The indices of the array are also shown below the array: 0 to 9. \n", "1. Searching: Binary search\n\nThe image describes the binary search algorithm.\n\nWe start from a sorted array of elements and an element x that we want to search. We store in a variable called \"half\" the position of the element which is in the middle of the array. We compare the element which is in \"half\" with x. If they are equal, then we return \"half\". If it is lower, then we repeat the search between \"half+1\" and the end of the array. If it is higher, then we repeat the search between the beginning of the array and \"half-1\". In each iteration we get a sub-array which is approximately half the size. If we do not find the element x we return value -1.\n\nThe complexity of the binary search algorithm is logarithmic order, which is more efficient than linear order.\n", "1. Searching: Binary search\n\nThis slide presents a Java implementation of the binary search algorithm. The code snippet shows a method called \"binarySearch\" that takes an integer array \"a\" and an integer \"x\" as input and returns the index of \"x\" in the array if found, otherwise -1. The algorithm initializes two pointers, \"first\" and \"last\", to the first and last indices of the array, respectively. It then repeatedly calculates the middle index \"half\" and compares the element at \"a[half]\" with \"x\". If they are equal, the method returns \"half\". If \"a[half]\" is less than \"x\", the search continues in the right half of the array by updating \"first\" to \"half+1\". Otherwise, the search continues in the left half by updating \"last\" to \"half-1\". The loop continues until \"first\" is greater than \"last\", indicating that \"x\" is not found in the array.\n\nThe slide also includes a diagram that illustrates the first iteration of the binary search algorithm on an example array. The array contains the following elements: -5, -2, 0, 3, 6, 8, 9, 10, 12, 26, and 31. The target value \"x\" is not shown in the diagram. The diagram highlights two possible scenarios based on the comparison between \"a[half]\" and \"x\" in the first iteration. If \"a[half]\" is greater than \"x\", the search continues in the subarray from index 0 to \"half-1\". If \"a[half]\" is less than \"x\", the search continues in the subarray from index \"half+1\" to the last index.\n", "Exercise 1\n\nWe will implement the method \"binarySearchString\" which takes as input an array of strings \"s\" and a string \"x\". This method performs a binary search of the element \"x\" in the array \"s\" using the \"compareTo\" method of the String class, which compares two strings lexicographically.\n\nGiven the array \"a\", \"b\", \"d\", \"f\", \"h\", \"n\", \"p\", \"q\", \"r\", \"v\", \"z\", how many iterations are needed to search for \"f\", \"r\" and \"w\" with binary search and with linear search? \n", "Searching: Conclusions\n\nFor smaller sizes, for example, N smaller than 6, it is not worthy using a binary search since it uses approximately the same number of comparisons as a linear search.\nLast iterations in a binary search are slower.\nA hybrid approach could be interesting: we apply binary search until the range is small, then we apply linear search.\n", "2. Sorting\n\nThe image shows five glasses with colored liquid in them. The glasses are arranged in a row from left to right: orange, blue, yellow, turquoise, and red. They appear to be on a stone ledge in front of a snowy scene. \n", "2. Sorting\n\n- Sorted data structures make searching easier, for example, books and dictionaries.\n- Binary search takes advantage of the order. \n", "2.1 Bubble Sort\n\nThe bubble sort algorithm moves forward through the data structure swapping pairs of contiguous elements which are not in the correct order. When sorting from lowest to highest, the highest element moves to the end (as if it was a bubble). These passes are repeated until no more swapping is needed. Elements which advanced to their correct position do not need to be checked again. Each pass needs to check one less element. \n", "2.1 Bubble Sort. Example (I)\n\nWe have an example of a bubble sort algorithm with ascending order from the lowest to the highest. The initial array is 80 95 14 98 29 49 66.\n\nThe algorithm uses two loops: internal and external. The external loop iterates over the array multiple times. The internal loop iterates over the unsorted part of the array.\n\nIn the first iteration of the external loop, the internal loop iterates from index 0 to length-1, which is 6 in this example. In each step of the internal loop, the algorithm compares the element at position j with the element at position j+1. If the element at position j is higher than the element at position j+1, the algorithm swaps them. At the end of the first iteration of the external loop, the highest element, 98, is in its correct position.\n\nThe second iteration of the external loop is similar to the first iteration, but the internal loop iterates from index 0 to length-2, which is 5 in this example. At the end of the second iteration of the external loop, the two highest elements, 95 and 98, are in their correct positions. The algorithm continues in this manner until the entire array is sorted.\n", "2.1 Bubble Sort. Example (II)\n\nThe image describes the Bubble sort algorithm with an example.\n\nThe algorithm sorts an array of numbers in ascending order, from the lowest to the highest.\n\nThe example shows 7 arrays, each one showing the state of the array after each iteration of the external loop of the algorithm.\n\nThe initial array is: 14 80 29 49 66 95 98\n\nThe first 3 iterations of the external loop are explained in detail:\n- Iteration 1: the internal loop iterates from index 0 to index length-3, which is 4 in this example. After this iteration, the last 3 elements of the array are in their correct position: 14 29 49 66 **80 95 98**\n- Iteration 2: the internal loop iterates from index 0 to index length-4.\n- Iteration 3: the internal loop iterates from index 0 to index length-5.\n\nThe last 3 iterations are only described briefly:\n- Iteration 4: the internal loop iterates from index 0 to index length-6.\n- Iteration 5: the internal loop iterates from index 0 to index length-7.\n- Iteration 6: the internal loop iterates from index 0 to index length-8.\n\nAfter 6 iterations of the external loop, all the elements are in their correct position.\n\nThe final array is: 14 29 49 66 80 95 98\n", "2.1 Bubble Sort\n\nThe image describes the Bubble Sort algorithm.\n\n- The **external loop** iterates over the array. The number of iterations is equal to the length of the array minus 1. In each iteration, one element is sorted, except for the last iteration in which two elements are sorted. The range of the index in the external loop is from 0 to the length of the array minus 1.\n\n- The **internal loop** is nested inside the external loop. In the first iteration of the external loop, the internal loop iterates over the entire array (length of the array minus 1 iterations). In the second iteration of the external loop, the internal loop iterates over the array except for the last element (length of the array minus 2 iterations), and so on. In general, in the m-th iteration of the external loop, the internal loop iterates length of array minus 'i' minus 1 times. The range of the index in the internal loop is from 0 to the length of the array minus 'i' minus 1.\n\n- After the m-th iteration of the external loop, the elements from index 0 to the (length of the array minus 2 minus 'i') are unsorted, and the elements from the index (length of the array minus 1 minus 'i') to the (length of the array minus 1) are sorted.\n", "2.1 Bubble Sort\n\nThe image shows two code snippets. The first one is a function called \"bubbleSort\" which takes an integer array as input. It iterates through the array with two nested loops. The outer loop iterates from 0 to the second to last element of the array. The inner loop iterates from 0 to the last element of the array minus the index of the outer loop. For each iteration of the inner loop, it compares the element at the current index with the element at the next index. If the element at the current index is greater than the element at the next index, it calls the \"swap\" function. \n\nThe second code snippet is a function called \"swap\" which takes an integer array and two integer indices as input. It swaps the elements at the given indices in the array.\n\nThere is also an alternative implementation suggestion: the external loop can iterate from 1 to the length of the array and the internal loop can iterate from 0 to the length of the array minus the index of the outer loop. \n", "Exercise 2\n\nStarting from the implementation of Bubble Sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order. \n", "Exercise 3\n\nUsing the sorting algorithm Bubble Sort, how many swaps are needed to sort the following array from the highest element to the lowest element (descending order)?\n\nThe array is: 1, 3, 5, 7, 11, 13. \n", "2.1 Bubble Sort: Conclusions\n\nThe slide lists the advantages and drawbacks of the bubble sort algorithm.\n\nAdvantages:\n- Little additional memory is needed\n- Few lines of code\n- Efficient for arrays with few elements\n\nDrawbacks:\n- Inefficient for arrays with many elements\n  - O(n\u00b2) => quadratic order (two nested loops for an array of n elements)\n  - For a given array there are always the same number of iterations/comparisons (even though it is already sorted), even though there are no swaps\n  - Too many swaps\n- Larger elements move fast to the end (they can reach the end in one iteration of the external loop), but lower elements move slower to the beginning (they gain one position per iteration)\n\nImprovement: Cocktail sort (double internal loop to pass from left to right and from right to left in each iteration of the external loop)\n", "2.2 Selection Sort\n\nThe slide describes the selection sort algorithm.\n\nThere are two variations of the algorithm: ascending order and descending order.\n\nIn ascending order, the algorithm searches for the minimum element and puts it in the first position by swapping it with the element currently in the first position. Then it searches for the next minimum element and puts it in the second position, and so on. In general, the algorithm searches for the minimum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping.\n\nIn descending order, the algorithm searches for the maximum element and puts it in the first position by swapping it with the element currently in the first position. Then it searches for the next maximum element and puts it in the second position, and so on. In general, the algorithm searches for the maximum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping.\n\nThe slide also provides two URLs for further information.\n", "2.2 Selection Sort. Example (1)\n\nThe slide describes the Selection Sort algorithm, in ascending order, using an example.\n\nThe algorithm uses two loops: an external and an internal loop. The external loop sorts the first position of the data structure. As part of this loop, there is a swap between the element in position i, with the minimum unsorted element. The internal loop searches for the minimum element from position i until the end of the data structure.\n\nThe example shows the different iterations of the algorithm. The data structure contains the following elements: 80, 95, 14, 98, 29, 49, and 66. The algorithm sorts the elements in ascending order, starting with the smallest element, 14. The algorithm then swaps 14 with the element in the first position, 80. The next iteration finds the next smallest element, 29, and swaps it with the element in the second position, 95. The algorithm continues until the entire data structure is sorted. \n", "2.2 Selection Sort. Example (II)\n\nThe image describes the ascending order selection sort algorithm.\n\nThe algorithm starts with the array: 14, 29, 49, 98, 95, 80, 66.\n\nThe first step is to find the minimum element in the array. In this case, the minimum element is 66. 66 is in the 7th position. We swap the element in the 3rd position with the element in the 7th position. The array is now: 14, 29, 49, 98, 95, 80, 66.\n\nThe next step is to find the minimum element in the unsorted part of the array. In this case, the minimum element is 80. 80 is in the 6th position. We swap the element in the 4th position with the element in the 6th position. The array is now: 14, 29, 49, 66, 95, 80, 98.\n\nThe next step is to find the minimum element in the unsorted part of the array. In this case, the minimum element is 95. 95 is in the 5th position. Since 95 is already in the correct position, no swapping is needed. The array is now: 14, 29, 49, 66, 80, 95, 98.\n\nThe next step is to find the minimum element in the unsorted part of the array. In this case, the minimum element is 98. 98 is in the 7th position. Since 98 is already in the correct position, no swapping is needed. The array is now: 14, 29, 49, 66, 80, 95, 98.\n\nThe array is now sorted in ascending order.\n", "2.2 Selection Sort\n\nWe're looking at Selection Sort, and specifically at the external and internal loops involved in the algorithm.\n\nThe external loop iterates over the array, with the number of iterations equal to the length of the array. It's important to note that while each iteration typically sorts one element, the last iteration isn't strictly necessary. The index in this loop ranges from 0 to the length of the array minus 1.\n\nThe internal loop is responsible for searching for the minimum or maximum value. In the first iteration of the external loop, where i equals 0, the internal loop performs length of the array minus 1 iterations. This decreases with each iteration of the external loop. For example, in the second iteration where i equals 1, the internal loop performs length of the array minus 2 iterations. Generally, in the m-th iteration of the external loop where i equals m-1, the internal loop performs length of the array minus i iterations. The index in the internal loop ranges from i to the length of the array minus 1.\n\nAfter the m-th iteration of the external loop, where i equals m-1, the elements from index 0 to i are sorted, while the elements from index i plus 1 to the length of the array minus 1 remain unsorted.\n", "2.2 Selection Sort\n\nThe image shows a code snippet for the selection sort algorithm in Java. The first function `selectionSort` takes an integer array `a` as input. It then iterates through the array with a nested loop. The outer loop iterates through each element of the array with the index `i`. The inner loop iterates through the remaining unsorted subarray with the index `j` starting from `i`. The variable `m` keeps track of the index of the minimum element in the unsorted subarray. The inner loop compares the current element `a[j]` with the element at index `m`. If `a[j]` is smaller than `a[m]`, then `m` is updated to `j`. After the inner loop completes, the function calls the `swap` function to swap the elements at indices `i` and `m`. \n\nThe `swap` function takes an integer array `a` and two integer indices `i` and `j` as input. It swaps the elements at indices `i` and `j` using an auxiliary variable `aux`.\n\nThe code also includes an alternative implementation of the algorithm. The alternative implementation is more efficient because it avoids an unnecessary comparison in the inner loop. The external loop iterates to `a.length - 1` and the internal loop iterates from `j+1` to `a.length`. \n", "Exercise 4\n\nStarting from the implementation of Selection Sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order. \n", "Exercise 5\n\nUsing the sorting algorithm Selection Sort, how many swaps are needed to sort the following array from the highest element to the lowest element (descending order)? Use the algorithm we saw in the class, which moves to the left the maximum unsorted element.\n\nThe array is: 1, 3, 5, 7, 11, 13. \n", "2.2 Selection Sort: Conclusions\n\nLet's talk about the advantages and drawbacks of selection sort, as well as a variant of the algorithm.\n\nSome of the advantages of selection sort are that it requires little additional memory, has few lines of code, and is efficient for arrays with few elements.\n\nOne of the main drawbacks of selection sort is that it is inefficient for arrays with many elements. Selection sort has a time complexity of O(n^2), which means that the time it takes to sort an array increases quadratically with the number of elements in the array. This is because selection sort uses two nested loops to sort an array of n elements. Another drawback is that for a given array, there are always the same number of iterations, even if the array is already sorted. This means that selection sort will always perform the same number of operations, regardless of the order of the elements in the array. However, selection sort does perform much less swaps than bubble sort.\n\nA variant of selection sort involves placing the maximum or minimum element at the end of the array, instead of the beginning. \n", "2.3 Insertion Sort\n\nThe data structure is divided into two parts: the first part, for example, the left side, is already sorted, and the second part, for example, the right side, is unsorted. At the beginning, the first part is empty and the second part is full. We extract the first element of the second part, inserting it in its correct position in the first part. This step is repeated until all the elements are sorted in the first part.\n\nThe first diagram shows an example of this process. The sorted partial result has elements less than x and greater than x. The unsorted data has an element x that needs to be inserted into the sorted partial result. The second diagram shows the result after the insertion. The element x has been inserted into its correct position in the sorted partial result.\n", "2.3 Insertion Sort. Example (1)\n\nThe image describes the Insertion Sort algorithm with an example.\n\nThe algorithm sorts an array of numbers in ascending order, from the lowest to the highest.\n\nIt uses two loops: an external loop and an internal loop.\n\nThe external loop traverses the array, leaving sorted what is behind position i. As part of the external loop, the element to be sorted is moved to its right position.\n\nThe internal loop moves one position to the right all the elements that are located between where the new sorted element is inserted and the position it left in the unsorted part of the array (now that position is sorted).\n\nThe example shows how the algorithm works with the following array: 80 95 14 98 29 49 66\n\nThe algorithm starts by taking the first element of the array, 80, and inserting it in its correct position in the sorted part of the array. Since the sorted part of the array is empty, 80 is inserted in the first position.\n\nThe algorithm then takes the second element of the array, 95, and inserts it in its correct position in the sorted part of the array. Since 95 is greater than 80, it is inserted in the second position.\n\nThe algorithm then takes the third element of the array, 14, and inserts it in its correct position in the sorted part of the array. Since 14 is smaller than 80 and 95, it is inserted in the first position. To make space for 14, 80 and 95 are moved one position to the right.\n\nThe algorithm continues in this way until the entire array is sorted.\n", "2.3 Insertion Sort. Example (II)\n\nThe slide describes the insertion sort algorithm, more specifically how to sort an array of numbers in ascending order.\n\nWe start with the array: 14, 80, 95, 98, 29, 49, 66. The algorithm iterates through the array, and at each step, it takes the current element and inserts it into its correct position in the already sorted part of the array.\n\nThe first step is to take the number 98 and insert it into its correct position in the sorted part of the array, which is to the right of 95. The resulting array is: 14, 80, 95, 98, 29, 49, 66.\n\nThe second step is to take the number 29 and insert it into its correct position in the sorted part of the array, which is to the left of 80. To do this, we need to move 80, 95 and 98 one position to the right to make space for 29. The resulting array is: 14, 29, 80, 95, 98, 49, 66. \n", "2.3 Insertion Sort. Example (III)\n\nThe slide describes the insertion sort algorithm with an example in ascending order. We take the element 49 from the unsorted part of the array and insert it into its correct position in the sorted part of the array. The elements 80, 95, and 98 are moved one position to the right to fill the gap left by 49. In the next step, we take element 66 from the unsorted part of the array and insert it into its correct position in the sorted part of the array. The elements 80, 95, and 98 are moved one position to the right to fill the gap left by 66. \n", "2.3 Insertion Sort\n\nThe image describes the Insertion Sort algorithm.\n\nThere are two nested loops in this algorithm: an external loop and an internal loop.\n\nThe external loop iterates over the array. The number of iterations is equal to the length of the array. In each iteration, one element is sorted, including the last iteration. The range of the index in the external loop is from 0 to the length of the array - 1.\n\nThe internal loop finds the correct position to insert the element. The number of iterations depends on the position \"advanced\" by the element which is inserted. If the element inserted moves k positions to the left, then there are k elements that are moved one position to the right.\n\nAfter the m-th iteration (i=m-1) of the external loop:\n- Elements from 0 to i are sorted\n- Elements from i+1 to the length of the array - 1 are unsorted. \n", "2.3 Insertion Sort\n\nWe see the code for an insertion sort algorithm in Java. The method signature is public static void insertionSort and it takes an integer array a as input. \n\nThe algorithm iterates through the array with a for loop. For each element at index i, it stores the value in a temporary variable tmp and initializes a counter j to i. \n\nThen, a while loop iterates as long as j is greater than 0 and the value of tmp is less than the element at index j-1. Inside the loop, the element at index j is overwritten with the element at index j-1, effectively shifting the element to the right. Then j is decremented.\n\nAfter the while loop, the element at index j is set to tmp, placing the element at its correct position in the sorted subarray.\n\nThere is also a suggestion to optimize the algorithm by starting the outer loop from index 1, as the first element is already sorted. \n", "2.3 Insertion Sort with auxiliary method\n\nThe image shows two code snippets. \n\nThe first snippet shows a function called *insertionSort*, this function takes an array of integers as input. It iterates through the array and calls the function *insert* for each element.\n\nThe second snippet shows the function *insert*. This function takes as input an array of integers and an integer. This function inserts the element at the given position in the array, moving the needed elements one position to the right. \n", "Exercise 6\n\nStarting from the implementation of Insertion Sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order. \n", "Exercise 7\n\nWe are asked to calculate how many swaps are needed to sort the array {1, 3, 5, 7, 11, 13} from the highest element to the lowest element using the Insertion Sort algorithm.\n\nThen, we are asked which of the three algorithms seen so far is the most efficient one for this array and to try with other arrays with different values and lengths. \n", "2.3 Insertion Sort: Conclusions\n\nLet's talk about the advantages and drawbacks of insertion sort.\n\nSome of the advantages are that it requires little additional memory and has few lines of code. It is efficient for arrays with few elements and more efficient than selection sort for partially sorted arrays. This is because for a given array there are always the same number of iterations in the external loop, even though it is already sorted, but the internal loop is adaptable.\n\nHowever, it also has some drawbacks. It is inefficient for arrays with many elements. This is because it has a quadratic order, meaning there are two nested loops for an array of n elements. It is also inefficient when the array to sort is in reverse sorted order. \n"]}]
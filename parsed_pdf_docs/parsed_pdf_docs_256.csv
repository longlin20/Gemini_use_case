content_chunks
"Contents
v *** Introduction to generics
v Data structures
v Linked lists
• The class Node
• The class LinkedList
• Benefits and drawbacks of linked lists"
"Introduction to generics
• Service provided by Java (J2SE 5.0 and above)
• Generics allow checking object types during
compile timeo Errors are detected at compile time (guaranteeing
compatible types during runtime)"
"the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow checking object types during compile time. Errors are detected at compile time, guaranteeing compatible types during runtime."
Without Generics
"We have a code snippet that shows how to create a list in Java. First, we create a new ArrayList object and assign it to the variable list. Then, we add a string ""test"" to the list"
". Then, we add a string ""test"" to the list. Finally, we try to get the first element of the list and cast it to an Integer. However, this will cause a ClassCastException at runtime because the list contains a String, not an Integer. The program will stop."
"Below the code snippet, there is a diagram showing the relationship between the AbstractList and List interfaces. The ArrayList class extends the AbstractList class and implements the List interface."
"the concept of generics in programming, specifically focusing on Java's ArrayList.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test"");Integer value = list.get(0);
```"
"list.add(""test"");Integer value = list.get(0);
```
This code attempts to create an ArrayList of Integers, add a String ""test"" to it, and then retrieve the element at index 0.
However, this code will result in a compile-time error:
```
Error at compile time"
"```
Error at compile time
""The method add(Integer) in the type List<Integer> is not applicable for the arguments (String)""
The error is detected before running the program
```"
"This error highlights the benefit of using generics: **type safety**. By declaring the ArrayList as `List<Integer>`, we specify that it can only hold Integer objects"
". Attempting to add a String violates this type constraint, and the compiler detects this error early on."
"includes a diagram illustrating the inheritance hierarchy:
- `ArrayList<E>` extends `AbstractList<E>`
- `AbstractList<E>` implements `List<E>`"
"- `AbstractList<E>` implements `List<E>`
This diagram emphasizes that `ArrayList` is a specific implementation of the more general `List` interface, both utilizing generics with the type parameter `<E>`."
"an example of how to create a class that uses generics. The example is a class called ArrayList that takes a type parameter E. The class has methods for adding, getting, removing, and setting elements in the list"
". The type of the elements in the list is specified by the type parameter E. For example, to create an ArrayList of Strings, you would use the following code: ArrayList<String> myList = new ArrayList<String>();"
"We are working with a class that uses generics.
We have a code snippet that shows the creation of an ArrayList of Employees.
The code then adds a new Employee, gets the first employee and adds a new Secretary."
"The last two lines of code are highlighted in red because they are causing compilation errors.
The first one tries to add a Person to the ArrayList, and the second one tries to add an Object."
"The reason why these two lines of code are causing compilation errors is because the ArrayList was declared to only accept objects of type Employee.
A diagram shows that Person is a superclass of Employee and Object is a superclass of Person."
"Therefore, you cannot add a Person or an Object to an ArrayList of Employees."
"Introduction to generics
Without Generics
List list = new ArrayList();
list.add(“test”);
Integer value = (Integer) list.get(0);
Error at runtime
“ClassCastException”.          
The program stops
AbstractList
List
extends
implements
ArrayList"
"ArrayList
 the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow checking object types during compile time. Errors are detected at compile time, guaranteeing compatible types during runtime."
Without Generics
"We have a code snippet that shows how to create a list in Java. First, we create a new ArrayList object and assign it to the variable list. Then, we add a string ""test"" to the list"
". Then, we add a string ""test"" to the list. Finally, we try to get the first element of the list and cast it to an Integer. However, this will cause a ClassCastException at runtime because the list contains a String, not an Integer. The program will stop."
"Below the code snippet, there is a diagram showing the relationship between the AbstractList and List interfaces. The ArrayList class extends the AbstractList class and implements the List interface."
"the concept of generics in programming, specifically focusing on Java's ArrayList.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test"");Integer value = list.get(0);
```"
"list.add(""test"");Integer value = list.get(0);
```
This code attempts to create an ArrayList of Integers, add a String ""test"" to it, and then retrieve the element at index 0.
However, this code will result in a compile-time error:
```
Error at compile time"
"```
Error at compile time
""The method add(Integer) in the type List<Integer> is not applicable for the arguments (String)""
The error is detected before running the program
```"
"This error highlights the benefit of using generics: **type safety**. By declaring the ArrayList as `List<Integer>`, we specify that it can only hold Integer objects"
". Attempting to add a String violates this type constraint, and the compiler detects this error early on."
"includes a diagram illustrating the inheritance hierarchy:
- `ArrayList<E>` extends `AbstractList<E>`
- `AbstractList<E>` implements `List<E>`"
"- `AbstractList<E>` implements `List<E>`
This diagram emphasizes that `ArrayList` is a specific implementation of the more general `List` interface, both utilizing generics with the type parameter `<E>`."
"an example of how to create a class that uses generics. The example is a class called ArrayList that takes a type parameter E. The class has methods for adding, getting, removing, and setting elements in the list"
". The type of the elements in the list is specified by the type parameter E. For example, to create an ArrayList of Strings, you would use the following code: ArrayList<String> myList = new ArrayList<String>();"
"We are working with a class that uses generics.
We have a code snippet that shows the creation of an ArrayList of Employees.
The code then adds a new Employee, gets the first employee and adds a new Secretary."
"The last two lines of code are highlighted in red because they are causing compilation errors.
The first one tries to add a Person to the ArrayList, and the second one tries to add an Object."
"The reason why these two lines of code are causing compilation errors is because the ArrayList was declared to only accept objects of type Employee.
A diagram shows that Person is a superclass of Employee and Object is a superclass of Person."
"Therefore, you cannot add a Person or an Object to an ArrayList of Employees."
"Introduction to generics
With Generics
List<Integer> list = new ArrayList<Integer>();
list.add(“test”);
Integer value = list.get(0);"
"list.add(“test”);
Integer value = list.get(0);
Error at compile time“The method add(Integer) in the type List<Integer>is not applicable for the arguments (String)”  The error is detected before running the program
AbstractList<E>
List<E>
extends"
"AbstractList<E>
List<E>
extends
implements
ArrayList<E>"
"the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow checking object types during compile time. Errors are detected at compile time, guaranteeing compatible types during runtime."
Without Generics
"We have a code snippet that shows how to create a list in Java. First, we create a new ArrayList object and assign it to the variable list. Then, we add a string ""test"" to the list"
". Then, we add a string ""test"" to the list. Finally, we try to get the first element of the list and cast it to an Integer. However, this will cause a ClassCastException at runtime because the list contains a String, not an Integer. The program will stop."
"Below the code snippet, there is a diagram showing the relationship between the AbstractList and List interfaces. The ArrayList class extends the AbstractList class and implements the List interface."
"the concept of generics in programming, specifically focusing on Java's ArrayList.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test"");Integer value = list.get(0);
```"
"list.add(""test"");Integer value = list.get(0);
```
This code attempts to create an ArrayList of Integers, add a String ""test"" to it, and then retrieve the element at index 0.
However, this code will result in a compile-time error:
```
Error at compile time"
"```
Error at compile time
""The method add(Integer) in the type List<Integer> is not applicable for the arguments (String)""
The error is detected before running the program
```"
"This error highlights the benefit of using generics: **type safety**. By declaring the ArrayList as `List<Integer>`, we specify that it can only hold Integer objects"
". Attempting to add a String violates this type constraint, and the compiler detects this error early on."
"includes a diagram illustrating the inheritance hierarchy:
- `ArrayList<E>` extends `AbstractList<E>`
- `AbstractList<E>` implements `List<E>`"
"- `AbstractList<E>` implements `List<E>`
This diagram emphasizes that `ArrayList` is a specific implementation of the more general `List` interface, both utilizing generics with the type parameter `<E>`."
"an example of how to create a class that uses generics. The example is a class called ArrayList that takes a type parameter E. The class has methods for adding, getting, removing, and setting elements in the list"
". The type of the elements in the list is specified by the type parameter E. For example, to create an ArrayList of Strings, you would use the following code: ArrayList<String> myList = new ArrayList<String>();"
"We are working with a class that uses generics.
We have a code snippet that shows the creation of an ArrayList of Employees.
The code then adds a new Employee, gets the first employee and adds a new Secretary."
"The last two lines of code are highlighted in red because they are causing compilation errors.
The first one tries to add a Person to the ArrayList, and the second one tries to add an Object."
"The reason why these two lines of code are causing compilation errors is because the ArrayList was declared to only accept objects of type Employee.
A diagram shows that Person is a superclass of Employee and Object is a superclass of Person."
"Therefore, you cannot add a Person or an Object to an ArrayList of Employees."
"Introduction to generics
Creation of a class that uses generics
public class ArrayList<E>{
public boolean add(E e){…}
public void add(int index, E element)
public E get(int index){…}
public E remove(int index)
public set(int index, E element)
…
}"
"…
}
 the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow checking object types during compile time. Errors are detected at compile time, guaranteeing compatible types during runtime."
Without Generics
"We have a code snippet that shows how to create a list in Java. First, we create a new ArrayList object and assign it to the variable list. Then, we add a string ""test"" to the list"
". Then, we add a string ""test"" to the list. Finally, we try to get the first element of the list and cast it to an Integer. However, this will cause a ClassCastException at runtime because the list contains a String, not an Integer. The program will stop."
"Below the code snippet, there is a diagram showing the relationship between the AbstractList and List interfaces. The ArrayList class extends the AbstractList class and implements the List interface."
"the concept of generics in programming, specifically focusing on Java's ArrayList.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test"");Integer value = list.get(0);
```"
"list.add(""test"");Integer value = list.get(0);
```
This code attempts to create an ArrayList of Integers, add a String ""test"" to it, and then retrieve the element at index 0.
However, this code will result in a compile-time error:
```
Error at compile time"
"```
Error at compile time
""The method add(Integer) in the type List<Integer> is not applicable for the arguments (String)""
The error is detected before running the program
```"
"This error highlights the benefit of using generics: **type safety**. By declaring the ArrayList as `List<Integer>`, we specify that it can only hold Integer objects"
". Attempting to add a String violates this type constraint, and the compiler detects this error early on."
"includes a diagram illustrating the inheritance hierarchy:
- `ArrayList<E>` extends `AbstractList<E>`
- `AbstractList<E>` implements `List<E>`"
"- `AbstractList<E>` implements `List<E>`
This diagram emphasizes that `ArrayList` is a specific implementation of the more general `List` interface, both utilizing generics with the type parameter `<E>`."
"an example of how to create a class that uses generics. The example is a class called ArrayList that takes a type parameter E. The class has methods for adding, getting, removing, and setting elements in the list"
". The type of the elements in the list is specified by the type parameter E. For example, to create an ArrayList of Strings, you would use the following code: ArrayList<String> myList = new ArrayList<String>();"
"We are working with a class that uses generics.
We have a code snippet that shows the creation of an ArrayList of Employees.
The code then adds a new Employee, gets the first employee and adds a new Secretary."
"The last two lines of code are highlighted in red because they are causing compilation errors.
The first one tries to add a Person to the ArrayList, and the second one tries to add an Object."
"The reason why these two lines of code are causing compilation errors is because the ArrayList was declared to only accept objects of type Employee.
A diagram shows that Person is a superclass of Employee and Object is a superclass of Person."
"Therefore, you cannot add a Person or an Object to an ArrayList of Employees."
"Introduction to generics
Working with a class that uses generics
ArrayList<Employee> employees = new ArrayList<Employee>();
employees.add(new Employee());
Employee myEmployee = employees.get(0);
employees.add(new Secretary());
employees.add(new Person());"
"employees.add(new Secretary());
employees.add(new Person());
employees.add(new Object());
Compilation errors"
"the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow checking object types during compile time. Errors are detected at compile time, guaranteeing compatible types during runtime."
Without Generics
"We have a code snippet that shows how to create a list in Java. First, we create a new ArrayList object and assign it to the variable list. Then, we add a string ""test"" to the list"
". Then, we add a string ""test"" to the list. Finally, we try to get the first element of the list and cast it to an Integer. However, this will cause a ClassCastException at runtime because the list contains a String, not an Integer. The program will stop."
"Below the code snippet, there is a diagram showing the relationship between the AbstractList and List interfaces. The ArrayList class extends the AbstractList class and implements the List interface."
"the concept of generics in programming, specifically focusing on Java's ArrayList.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test"");Integer value = list.get(0);
```"
"list.add(""test"");Integer value = list.get(0);
```
This code attempts to create an ArrayList of Integers, add a String ""test"" to it, and then retrieve the element at index 0.
However, this code will result in a compile-time error:
```
Error at compile time"
"```
Error at compile time
""The method add(Integer) in the type List<Integer> is not applicable for the arguments (String)""
The error is detected before running the program
```"
"This error highlights the benefit of using generics: **type safety**. By declaring the ArrayList as `List<Integer>`, we specify that it can only hold Integer objects"
". Attempting to add a String violates this type constraint, and the compiler detects this error early on."
"includes a diagram illustrating the inheritance hierarchy:
- `ArrayList<E>` extends `AbstractList<E>`
- `AbstractList<E>` implements `List<E>`"
"- `AbstractList<E>` implements `List<E>`
This diagram emphasizes that `ArrayList` is a specific implementation of the more general `List` interface, both utilizing generics with the type parameter `<E>`."
"an example of how to create a class that uses generics. The example is a class called ArrayList that takes a type parameter E. The class has methods for adding, getting, removing, and setting elements in the list"
". The type of the elements in the list is specified by the type parameter E. For example, to create an ArrayList of Strings, you would use the following code: ArrayList<String> myList = new ArrayList<String>();"
"We are working with a class that uses generics.
We have a code snippet that shows the creation of an ArrayList of Employees.
The code then adds a new Employee, gets the first employee and adds a new Secretary."
"The last two lines of code are highlighted in red because they are causing compilation errors.
The first one tries to add a Person to the ArrayList, and the second one tries to add an Object."
"The reason why these two lines of code are causing compilation errors is because the ArrayList was declared to only accept objects of type Employee.
A diagram shows that Person is a superclass of Employee and Object is a superclass of Person."
"Therefore, you cannot add a Person or an Object to an ArrayList of Employees."
"Data Structures
• Abstraction that represents a
collection of data in a program inorder to ease its manipulation
• The suitability of a data structure
depends on the nature of the datato be stored, and how that data willbe manipulated"
"- Abstraction that represents a collection of data in a program in order to ease its manipulation
- The suitability of a data structure depends on the nature of the data to be stored, and how that data will be manipulated"
"Linear Data Structures
• They organize data as a sequence, whereeach piece of data has a preceding datum
(except for the first one) and a succeedingdatum (except for the last one)
• Examples of linear data structures:
– Arrays
– Linked lists
– Stacks"
"– Arrays
– Linked lists
– Stacks
– Queues
– Double-ended queues"
"Linear data structures organize data as a sequence, where each piece of data has a preceding datum, except for the first one, and a succeeding datum, except for the last one."
"Some examples of linear data structures are: arrays, linked lists, stacks, queues, and double-ended queues."
"Arrays
• Advantages for storing linear data
collections:
– Random access: any position in the array
can be accessed in constant time.
– Efficient use of memory when all the"
"– Efficient use of memory when all the
positions of the array are in use, becausethe array is stored in consecutive memorypositions."
advantages of arrays for storing linear data collections
". The advantages are: random access - any position in the array can be accessed in constant time; efficient use of memory when all the positions of the array are in use, because the array is stored in consecutive memory positions."
Let's talk about some disadvantages of arrays.
"First, arrays have static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems"
". This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed."
"Another disadvantage is the need for contiguous memory. Even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation.
Let's talk about some disadvantages of arrays."
"Let's talk about some disadvantages of arrays.
Some operations on the array have a sub-optimum cost:"
"Some operations on the array have a sub-optimum cost:
- insertions and extractions, that is removals, of data in the first position or intermediate positions need data to be moved to consecutive memory positions."
"- concatenation of arrays: data must be copied to a new array.
- partition of an array in several pieces: data must be copied to new arrays."
"Arrays
• Disadvantages (I):
– Static size: The size must be defined whenthe array is created and cannot be changedlater. The main problems this poses are:
• Inefficient use of memory when more positions
than needed are reserved"
"than needed are reserved
• It may happen at runtime that more positions than
reserved are needed
– Need of contiguous memory:
• Even having the system enough free memory, itmay happen that there is not enough contiguousspace, due to memory fragmentation"
advantages of arrays for storing linear data collections
". The advantages are: random access - any position in the array can be accessed in constant time; efficient use of memory when all the positions of the array are in use, because the array is stored in consecutive memory positions."
Let's talk about some disadvantages of arrays.
"First, arrays have static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems"
". This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed."
"Another disadvantage is the need for contiguous memory. Even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation.
Let's talk about some disadvantages of arrays."
"Let's talk about some disadvantages of arrays.
Some operations on the array have a sub-optimum cost:"
"Some operations on the array have a sub-optimum cost:
- insertions and extractions, that is removals, of data in the first position or intermediate positions need data to be moved to consecutive memory positions."
"- concatenation of arrays: data must be copied to a new array.
- partition of an array in several pieces: data must be copied to new arrays."
"Arrays
• Disadvantages (II):
– Some operations on the array have a
sub-optimum cost:
• Insertions and extractions (removals) of data in thefirst position or intermediate positions need data tobe moved to consecutive memory positions"
"• Concatenation of arrays: data must be copied to a
new array
• Partition of an array in several pieces: data must be
copied to new arrays"
advantages of arrays for storing linear data collections
". The advantages are: random access - any position in the array can be accessed in constant time; efficient use of memory when all the positions of the array are in use, because the array is stored in consecutive memory positions."
Let's talk about some disadvantages of arrays.
"First, arrays have static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems"
". This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed."
"Another disadvantage is the need for contiguous memory. Even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation.
Let's talk about some disadvantages of arrays."
"Let's talk about some disadvantages of arrays.
Some operations on the array have a sub-optimum cost:"
"Some operations on the array have a sub-optimum cost:
- insertions and extractions, that is removals, of data in the first position or intermediate positions need data to be moved to consecutive memory positions."
"- concatenation of arrays: data must be copied to a new array.
- partition of an array in several pieces: data must be copied to new arrays."
"Exercise 1
• Create a ten-element array of integers and initialize
all the elements with value 1. Then, insert anadditional element with value 0 in the fourthposition of the array.
• Note: Inserting a new element is different from replacing an"
"• Note: Inserting a new element is different from replacing an
element by another one."
"element by another one.
Create a ten-element array of integers and initialize all the elements with value 1. Then, insert an additional element with value 0 in the fourth position of the array."
Note: Inserting a new element is different from replacing an element by another one.
"Linked Lists
• Ordered sequence of nodes in which
each node stores:
– A piece of data (info)
– A reference pointing to the next node
• Nodes do not need to be in
consecutive memory positions
first
info
info
info
next
next
next
null"
A linked list is an ordered sequence of nodes. Each node stores a piece of data called info and a reference pointing to the next node in the list. The nodes do not need to be in consecutive memory positions.
"The diagram shows a linked list with three nodes. The first node contains the value ""info"" and a reference to the next node. The second node also contains the value ""info"" and a reference to the next node"
". The third node contains the value ""info"" and a reference to null, indicating the end of the list. The variable ""first"" points to the first node in the list."
"The Node Class
public class Node<E> {
private E info;private Node<E> next;
Use of generics to storeinformation of different types
Two attributes: info andreference to the next node
public Node(E info) {…}
Constructor toinitialize info"
"public Node(E info) {…}
Constructor toinitialize info
public Node<E> getNext() {…}
public void setNext(Node<E> next) {…}
public E getInfo() {…}
public void setInfo(E info) {…}
}
Getters and setters for the attributes"
We have a class definition for a generic class named Node. The class uses generics to store information of different types
". It has two attributes: info, which stores the actual data of type E, and next, which is a reference to the next node in the structure. The class has a constructor that takes an argument of type E and initializes the info attribute"
". Additionally, there are getters and setters for both attributes: getNext and setNext for the next node, and getInfo and setInfo for the info attribute."
"Exercise 2
• Complete the code in the class Node.
Program three constructors: one that does notreceive arguments to initialize the attributes;one that serves to initialize the attributeinfo; and another one that serves toinitialize the two attributes."
Complete the code in the class **Node**. Program three constructors: one that does not receive arguments to initialize the attributes; one that serves to initialize the attribute **info**; and another one that serves to initialize the two attributes.
"The class MyLinkedList
public class MyLinkedList<E> {
private Node<E> first;
public MyLinkedList() {…}
public void insert(E info) {…}
public E extract() {…}
private void insert(E info, Node<E> previous) {…}
private E extract(Node<E> previous) {…}"
"private E extract(Node<E> previous) {…}
public void insert(E info, int pos) {…}
public E extract(int pos) {…}
public void print() {…}
public Node<E> searchLastNode() {…}
public int search(E info) {…}
…
}"
"public int search(E info) {…}
…
}
The image shows the structure of a class named MyLinkedList in a programming language, likely Java. This class represents a linked list data structure."
"It starts by declaring a private variable ""first"" of type Node, which will hold the reference to the first node in the list. The Node class is not shown here, but it would typically contain data and a reference to the next node in the list."
"The class has a constructor and several public and private methods:
- A constructor `MyLinkedList()` to initialize the linked list, likely by setting the ""first"" node to null.
- Public methods:"
"- Public methods:
    - `insert(E info)`: Inserts a new node with the given data at the end of the list.
    - `extract()`: Removes and returns the data from the first node of the list."
"- `insert(E info, int pos)`: Inserts a new node with the given data at the specified position in the list.
    - `extract(int pos)`: Removes and returns the data from the node at the specified position in the list."
"- `print()`: Prints the contents of the linked list.
    - `searchLastNode()`: Returns a reference to the last node in the list.
    - `search(E info)`: Searches for a node containing the given data and returns its position in the list."
"- Private methods:
    - `insert(E info, Node<E> previous)`: Inserts a new node with the given data after the specified ""previous"" node.
    - `extract(Node<E> previous)`: Removes and returns the data from the node after the specified ""previous"" node."
The ellipses (...) within the method declarations indicate that the actual implementation details of these methods are not shown in this particular code snippet.
"1. Inserting a node at the beginning
public void insert(E info)
first
newNode
null
Step 1: Creating a new node
null
Node<E> newNode = new Node<E>(info);"
"The image shows the first step to insert a new node at the beginning of a linked list.
The code snippet shows the signature of the method: `public void insert(E info)`"
The diagram shows four nodes. The first three nodes are already in the linked list. The fourth node is the new node to be inserted.
"The first three nodes are light blue and contain an oval shape in a lighter color. They are connected with arrows. The first node is labeled ""first"". The last node's arrow points to the text ""null""."
"The new node is red and contains an oval shape in a lighter color. An arrow points from the text ""newNode"" to this node. Another arrow points from this node to the text ""null""."
"Below the diagram, we see the text ""Step 1: Creating a new node"" and the code `Node<E> newNode = new Node<E>(info);`"
"1. Inserting a node at the beginning
public void insert(E info)
first
newNode
null
Step 2: Assigning the first node as the nextone for the node just created
newNode.setNext(first);"
"The image shows the first step to insert a new node at the beginning of a linked list.
The code snippet shows the signature of the method: `public void insert(E info)`"
The diagram shows four nodes. The first three nodes are already in the linked list. The fourth node is the new node to be inserted.
"The first three nodes are light blue and contain an oval shape in a lighter color. They are connected with arrows. The first node is labeled ""first"". The last node's arrow points to the text ""null""."
"The new node is red and contains an oval shape in a lighter color. An arrow points from the text ""newNode"" to this node. Another arrow points from this node to the text ""null""."
"Below the diagram, we see the text ""Step 1: Creating a new node"" and the code `Node<E> newNode = new Node<E>(info);`"
"1. Inserting a node at the beginning
public void insert(E info)
first
newNode
null
Step 3: Assigning as first node in the list thenode just created
first = newNode;"
"The image shows the first step to insert a new node at the beginning of a linked list.
The code snippet shows the signature of the method: `public void insert(E info)`"
The diagram shows four nodes. The first three nodes are already in the linked list. The fourth node is the new node to be inserted.
"The first three nodes are light blue and contain an oval shape in a lighter color. They are connected with arrows. The first node is labeled ""first"". The last node's arrow points to the text ""null""."
"The new node is red and contains an oval shape in a lighter color. An arrow points from the text ""newNode"" to this node. Another arrow points from this node to the text ""null""."
"Below the diagram, we see the text ""Step 1: Creating a new node"" and the code `Node<E> newNode = new Node<E>(info);`"
"2. Extracting the first node
public E extract()
first
Step 1: Checking that the list is not empty
if (first != null)
null"
"The code snippet shows the method signature for extracting the first node: public E extract().
Step 3: Assigning the second node as the first one of the list"
"The diagram shows three nodes. The first node is highlighted in red. An arrow points from the word ""first"" to the second node. Another arrow points from the second node to the third node. A final arrow points from the third node to the word ""null""."
The code snippet shows the following instruction: first = first.getNext();
"The image shows step 4 of extracting the first node of a linked list. The code snippet shows the signature of the method: ""public E extract()"". The diagram shows three nodes. The first node is red and has an arrow pointing to it with the label ""first"""
". There is an arrow from the first node to the second node and an arrow from the second to the third. The third node has an arrow pointing away from it with the label ""null"""
". There is also an arrow pointing to the data of the first node with the label ""data"". There is a text box with the following text: ""The node is isolated and does not belong to the list anymore"""
". There is another text box with the label ""Step 4: Returning the piece of data"" and the text ""return data;""."
"2. Extracting the first node
public E extract()
first
data
Step 2: Getting the info from the node to extract
E data = first.getInfo();
null
null"
"The code snippet shows the method signature for extracting the first node: public E extract().
Step 3: Assigning the second node as the first one of the list"
"The diagram shows three nodes. The first node is highlighted in red. An arrow points from the word ""first"" to the second node. Another arrow points from the second node to the third node. A final arrow points from the third node to the word ""null""."
The code snippet shows the following instruction: first = first.getNext();
"The image shows step 4 of extracting the first node of a linked list. The code snippet shows the signature of the method: ""public E extract()"". The diagram shows three nodes. The first node is red and has an arrow pointing to it with the label ""first"""
". There is an arrow from the first node to the second node and an arrow from the second to the third. The third node has an arrow pointing away from it with the label ""null"""
". There is also an arrow pointing to the data of the first node with the label ""data"". There is a text box with the following text: ""The node is isolated and does not belong to the list anymore"""
". There is another text box with the label ""Step 4: Returning the piece of data"" and the text ""return data;""."
"2. Extracting the first node
public E extract()
first
data
Step 3: Assigning the second node as the first one of the list
first = first.getNext();
null
null"
"The code snippet shows the method signature for extracting the first node: public E extract().
Step 3: Assigning the second node as the first one of the list"
"The diagram shows three nodes. The first node is highlighted in red. An arrow points from the word ""first"" to the second node. Another arrow points from the second node to the third node. A final arrow points from the third node to the word ""null""."
The code snippet shows the following instruction: first = first.getNext();
"The image shows step 4 of extracting the first node of a linked list. The code snippet shows the signature of the method: ""public E extract()"". The diagram shows three nodes. The first node is red and has an arrow pointing to it with the label ""first"""
". There is an arrow from the first node to the second node and an arrow from the second to the third. The third node has an arrow pointing away from it with the label ""null"""
". There is also an arrow pointing to the data of the first node with the label ""data"". There is a text box with the following text: ""The node is isolated and does not belong to the list anymore"""
". There is another text box with the label ""Step 4: Returning the piece of data"" and the text ""return data;""."
"2. Extracting the first node
public E extract()
first
data
The node is isolated and doesnot belong to the list anymore
Step 4: Returning the piece of data
return data;
null
null"
"The code snippet shows the method signature for extracting the first node: public E extract().
Step 3: Assigning the second node as the first one of the list"
"The diagram shows three nodes. The first node is highlighted in red. An arrow points from the word ""first"" to the second node. Another arrow points from the second node to the third node. A final arrow points from the third node to the word ""null""."
The code snippet shows the following instruction: first = first.getNext();
"The image shows step 4 of extracting the first node of a linked list. The code snippet shows the signature of the method: ""public E extract()"". The diagram shows three nodes. The first node is red and has an arrow pointing to it with the label ""first"""
". There is an arrow from the first node to the second node and an arrow from the second to the third. The third node has an arrow pointing away from it with the label ""null"""
". There is also an arrow pointing to the data of the first node with the label ""data"". There is a text box with the following text: ""The node is isolated and does not belong to the list anymore"""
". There is another text box with the label ""Step 4: Returning the piece of data"" and the text ""return data;""."
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
Step 1: Checking that previous is not null
if (previous != null)
null"
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
newNode
null
Step 2: Creating a new node
null
Node<E> newNode = new Node<E>(info);"
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
newNode
null
Step 3: Assigning as the next for the nodejust created the next to previous
newNode.setNext(previous.getNext());"
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
newNode
null
Step 4: Assigning the node just created as the next to previous
previous.setNext(newNode);"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 1: Checking that the list is not empty
Checking that previous is not null.Checking that the next to previous is not null"
"if (first != null && previous!= null && previous.getNext() != null)
null"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 2: Retrieving the information in the node toextract
E data = previous.getNext().getInfo();
null"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 3: Assigning the next to the node to extract asthe next to previous
previous.setNext(previous.getNext().getNext());
null"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 4: Returning the piece of data
return data;
null"
"5. Inserting at an intermediate position(given the position)
public void insert(E info, int pos)
first
previous
null
If position is 0 or linked list is empty, then insert at the beginning,calling the insert (E info) method
if (pos == 0 || first == null) {"
"if (pos == 0 || first == null) {
insert(info);
}"
"5. Inserting at an intermediate position(given the position)
public void insert(E info, int pos)
first
previous
null"
"first
previous
null
Advance from first to the position of the previous node, and then callthe method that inserts at an intermediate position given previous. Ifposition is larger than number of nodes, then insert at the end.
else {
Node<E> tmp = first;"
"else {
Node<E> tmp = first;
for (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {
tmp = tmp.getNext();
}
insert(info, tmp);
}"
"6. Extracting an intermediate node(given the position)
public E extract(int pos)
previous
first
null
If position is 0 or linked list is empty, then extract at the beginning,calling the extract() method
if (pos == 0 || first == null) {
return extract();
}"
"6. Extracting an intermediate node(given the position)
public E extract(int pos)
previous
first
null"
"Advance from first to the position of the previous node, and then callAdvance from first to the position of previous, and call the methodthe method that extracts at an intermediate position given previous"
.that extracts an intermediate node given the previous node
"If position is larger than number of nodes, then null is returned.
else {
Node<E> tmp = first;
for (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {
tmp = tmp.getNext();
}
return extract(tmp);
}"
"7. Traversing the list:
printing the content
public void print()
current
first
null
if(first!=null){
Node<E> current = first;
while (current != null) {
System.out.println(current.getInfo());   current = current.getNext();
}
}"
"8. Traversing the list:searching for the last node
public Node<E> searchLastNode()
•
A reference steps the list until a node is reachedwhose reference to the next node is null :
public Node<E> searchLastNode() {
Node<E> current = first;"
"public Node<E> searchLastNode() {
Node<E> current = first;
if (current != null) {
while (current.getNext() != null) {current = current.getNext();
}
}
return current;
}"
"9. Traversing the list:searching for a piece of data
public int search(E info)
•
A reference steps the list until the piece of information is reached.A counter is used in order to return its position in the list:
public int search(E info) {
int pos = 0;"
"public int search(E info) {
int pos = 0;
Node<E> current = first;while (current != null
&& !current.getInfo().equals(info)) {   pos++;
current = current.getNext();
}
if (current != null){
return pos;
} else{
return -1;
}
}"
"Exercise 3
• Create the method
public int numberOfOcurrences(E info),which returns the number of nodes in a linkedlist whose stored information is the same as theone provided as argument."
"We need to create a method called ""numberOfOccurrences"" that takes an argument of type E called ""info"". This method will return an integer representing the number of nodes in a linked list where the stored information matches the ""info"" argument."
"Advantages of Linked Lists
• Inserting and extracting nodes have a costthat does not depend on the size of the list
• Concatenation and partition of lists have a
cost that does not depend on the size of thelist
• There is no need for contiguous memory"
"• There is no need for contiguous memory
• Memory in use at a given instant dependsonly on the number of data items stored inthe list at that instant"
"Inserting and extracting nodes have a cost that does not depend on the size of the list.
Concatenation and partition of lists have a cost that does not depend on the size of the list.
There is no need for contiguous memory."
"There is no need for contiguous memory.
Memory in use at a given instant depends only on the number of data items stored in the list at that instant."
"Disadvantages of Linked Lists
• Accessing to arbitrary intermediate
positions has a cost that depends onthe size of the list
• Each node represents an overhead in
memory usage"
"- Accessing to arbitrary intermediate positions has a cost that depends on the size of the list
- Each node represents an overhead in memory usage"
Exercise 4
"• Create a Linked List with ten elements of typeinteger, and initialize them to 1. Then, insert anadditional element with value 0 in the fourthpositon of the Linked List"
". Assume that classesNode and MyLinkedList already exist, andare implemented as we saw in this session."
Create a linked list with 10 elements of type integer and initialize them to one. Then insert an additional element with value zero in the fourth position of the linked list
. Assume that classes Node and MyLinkedList already exist and are implemented as we saw in this session.
Inserting a node at the beginning
"The image describes the second step in the process of inserting a node at the beginning of a linked list. The code snippet ""public void insert(E info)"" shows the method signature for the insertion operation"
". The diagram illustrates the linked list with three existing nodes. Each node is represented by a rectangle with an oval inside. The leftmost rectangle is labeled ""first"" indicating the head of the linked list"
". The ovals inside the rectangles represent the data stored in each node. An arrow pointing to the right connects each node to its next node. The last node's arrow points to the text ""null"" indicating the end of the list."
"A new node, represented by a rectangle with a red oval inside, is labeled ""newNode"". The second step of the insertion process is to assign the ""first"" node as the next node for the newly created node. This step is represented by the code ""newNode"
". This step is represented by the code ""newNode.setNext(first);"" and visually by an arrow from the new node to the ""first"" node."
"Inserting a node at the beginning
The image shows how to insert a node at the beginning of a linked list.
The code snippet shows the method signature: public void insert, which takes a generic type E info as input."
"The diagram shows a linked list with three nodes. The first node is labeled ""first"" and the last node points to null."
"A new node labeled ""newNode"" is added to the beginning of the list. The new node is colored in red. An arrow points from newNode to the previous first node. An arrow points from ""first"" to ""newNode""."
"Step 3 of the process is to assign the new node as the first node in the list. This is done by setting the ""first"" variable to the ""newNode""."
"**2. Extracting the first node**
The code snippet shows a function called ""extract"" which takes no arguments and returns a generic type E."
"The diagram shows three nodes, each represented by a rectangle with rounded corners. The first node is highlighted in red and labeled ""first"". An arrow points from the label ""first"" to the first node"
". An arrow points from the label ""first"" to the first node. The nodes are connected by arrows, indicating a linked list structure. The last node's arrow points to the word ""null""."
"The first step in extracting the first node is checking that the list is not empty. This is done by checking if the variable ""first"" is not equal to null."
"**2. Extracting the first node**
 the second step of extracting the first node from a linked list.
The code snippet shows a method named ""extract"" that returns a generic type ""E""."
"The diagram illustrates a linked list with three nodes. The first node is highlighted in red. An arrow labeled ""first"" points to the first node. Another arrow labeled ""data"" points to the data within the first node"
". The last node in the list points to ""null,"" indicating the end of the list."
"The second step, as highlighted in the red box, involves retrieving the information from the node to be extracted. This is achieved using the line ""E data = first"
". This is achieved using the line ""E data = first.getInfo();"", which retrieves the information from the first node and stores it in a variable named ""data"" of type ""E""."
**3. Inserting at an intermediate position (given the previous node)**
The code snippet shows the implementation of an insert method in Java. The method takes two arguments: info of type E and previous of type Node. The goal is to insert a new node with the value of info after the node pointed to by previous in a linked list
.
"The diagram illustrates the process. There are four nodes in the linked list. The first node is labeled ""first"" and the second node is labeled ""previous"". The last node points to null."
The first step of the insertion process is to check if the previous node is not null. This is done using the following code: if (previous != null)
"**3. Inserting at an intermediate position (given the previous node)**
The image illustrates step 2 of inserting a new node at an intermediate position in a linked list, given the previous node."
"- We have a code snippet: `private void insert(E info, Node<E> previous)` indicating a private method named ""insert"" that takes two arguments: ""info"" of type E and ""previous"" of type `Node<E>`."
"- There are four nodes visualized as rectangles with rounded corners. Each node, except the first one, has an arrow pointing to the next node.
- The second node from the left is labeled ""previous""."
"- The second node from the left is labeled ""previous"".
- The first node is labeled ""first"" and points to the ""previous"" node.
- The last node has an outgoing arrow pointing to the text ""null"", indicating the end of the list."
"- Below the ""first"" node, there's a red oval within a rectangle labeled ""newNode"" with an arrow pointing to it from the label. This node is not yet part of the list. An arrow from this node points to the text ""null""."
"- A red-bordered box highlights the text ""**Step 2: Creating a new node**"".
- Below this box, we see the code: `Node<E> newNode = new Node<E>(info);` which creates a new node (`newNode`) of type `Node<E>` and initializes it with the data ""info""."
"3. Inserting at an intermediate position (given the previous node)
 how to insert a new node in a linked list at an intermediate position, given the previous node."
"The code snippet shows the signature of the method: ""private void insert(E info, Node<E> previous)"".  The method takes two arguments: the information to be stored in the new node, and the previous node."
"The diagram shows four nodes: ""first"", two unnamed nodes, and a node that points to ""null"""
". There is an arrow pointing from ""first"" to the first unnamed node, another arrow from the first unnamed node to the second unnamed node, and a final arrow from the second unnamed node to the node that points to ""null"""
".  The second unnamed node is labeled as ""previous"".  There is a new node, labeled as ""newNode"", that needs to be inserted between the two unnamed nodes."
"Finally, step 3 of the insertion process is described.  This step consists of assigning the next node for the newly created node to the next node of the previous node.  This is done with the line of code ""newNode.setNext(previous.getNext());""."
3. Inserting at an intermediate position (given the previous node)
"The image shows four boxes connected with arrows pointing to the right. The leftmost box is red and labeled ""newNode"". The next box is blue and labeled ""previous"". The remaining two boxes are blue and unlabeled"
". The remaining two boxes are blue and unlabeled. The last box has an arrow pointing to the right labeled ""null"". There is also a line of code: ""previous.setNext(newNode);"" and a caption: ""Step 4: Assigning the node just created as the next to previous"""
". This diagram shows the process of inserting a new node into a linked list after the node labeled ""previous"". The line of code ""previous"
". The line of code ""previous.setNext(newNode);"" sets the ""next"" pointer of the ""previous"" node to the ""newNode"", effectively inserting the ""newNode"" into the linked list."
"Extracting an intermediate node (given the previous node)
We have some source code in a white box. The code is: ""private E extract(Node<E> previous)""."
"Below the code, there is a diagram representing a linked list. The first node is empty and has an arrow pointing to it, labeled ""first"""
". The first node is followed by two empty nodes, then a red node labeled ""data"", another empty node, and finally an arrow pointing to the last node, labeled ""null"". The nodes are connected by arrows."
"Below the diagram, there is a red box with the following text inside: ""Step 1: Checking that the list is not empty. Checking that previous is not null. Checking that the next to previous is not null""."
"Finally, there is more source code in a white box: ""if (first != null && previous != null && previous.getNext() != null)""."
"**4. Extracting an intermediate node (given the previous node)**
The code snippet shows the declaration of a private method called ""extract"" that takes a Node object of type E as input, named ""previous""."
"The diagram illustrates a linked list with 5 nodes. Each node is represented by a rectangle. The first node is labeled ""first"" and points to the next node in the list"
". The second node is labeled ""previous"" and points to the next node, which is highlighted in red and labeled ""data"". The fourth and fifth nodes are empty, and the last node points to ""null"", indicating the end of the list."
"The second step of the process, ""Retrieving the information in the node to extract"", involves getting the data from the node that is next to the ""previous"" node"
". This is done by calling the ""getNext()"" method on the ""previous"" node, which returns the next node in the list. Then, the ""getInfo()"" method is called on the next node to retrieve the data stored in that node"
". The retrieved data is then assigned to a variable of type E called ""data""."
"**4. Extracting an intermediate node (given the previous node)**
The code snippet `private E extract(Node<E> previous)` shows a method for extracting a node from a linked list given the previous node."
"The diagram illustrates the process with four nodes. The first node is on the left and the last node is on the right. The third node, colored in red, is the one being extracted. The ""previous"" node is the second node."
**Step 3: Assigning the next to the node to extract as the next to previous**
"This step is implemented with the code `previous.setNext(previous.getNext().getNext());`. This line of code sets the ""next"" pointer of the ""previous"" node to the ""next"" pointer of the node being extracted"
. This effectively removes the extracted node from the linked list.
"**4. Extracting an intermediate node (given the previous node)**
The image illustrates step 4 of a process involving a linked list data structure. The goal is to extract an intermediate node from the list, given a reference to the previous node."
"- The code snippet ""private E extract(Node<E> previous)"" represents a method signature for extracting the data from a node. ""E"" likely denotes a generic type parameter, indicating that the method can handle nodes containing various data types."
"- The diagram depicts a linked list with four nodes. Each node is represented by a rectangle, except for the third node, which is highlighted in red."
"- An arrow labeled ""previous"" points to the second node, indicating that this is the node referenced as ""previous"" in the code."
"- The third node, colored red, is the target node to be extracted. An arrow labeled ""data"" points to this node, signifying that its data will be returned."
"- The first and fourth nodes are shown for context, representing the preceding and succeeding nodes in the list.
- An arrow labeled ""first"" points to the first node, indicating the beginning of the linked list."
"- An arrow labeled ""null"" points away from the fourth node, indicating the end of the linked list.
- The text ""Step 4: Returning the piece of data"" highlights the current step in the process."
"- The code snippet ""return data;"" indicates that the data from the extracted node (the third node) is being returned."
5. Inserting at an intermediate position (given the position)
We see a code snippet that shows how to insert an element into a linked list at a given position. The code first checks if the position is 0 or if the linked list is empty
". If either of these conditions is true, the code inserts the element at the beginning of the list. Otherwise, the code inserts the element at the specified position."
"There is also a diagram that shows a linked list with five nodes. The first node is labeled ""first"" and the last node is labeled ""null"". The third node is colored red. An arrow points from the word ""previous"" to the second node in the list"
.  The diagram is meant to illustrate the process of inserting a new node into the linked list at a given position. The red node represents the new node that is being inserted.
"**5. Inserting at an intermediate position (given the position)**
The image shows a slide titled ""5. Inserting at an intermediate position (given the position)""."
The code snippet shows the implementation of the insert method in Java. The method takes two arguments: the information to be inserted (info) and the position where it should be inserted (pos).
"The code first checks if the position is larger than the number of nodes in the list. If it is, the new node is inserted at the end of the list. Otherwise, the code advances from the first node to the position of the previous node"
". Once the previous node is found, the code calls the insert method, passing the information to be inserted and the previous node as arguments."
"There is a diagram representing a linked list. The first node is on the left and the last node is on the right. The nodes are represented by rectangles. The first node is labeled ""first"" and the last node is labeled ""null"""
". The second node from the left is colored red. An arrow points from the text ""previous"" to the node before the red node."
This diagram illustrates the process of inserting a new node at a given position in a linked list. The red node represents the new node to be inserted
. The red node represents the new node to be inserted. The code first finds the node before the position where the new node should be inserted (represented by the arrow pointing to the node before the red node)
". Then, the new node is inserted after the previous node."
6. Extracting an intermediate node (given the position)
We have a piece of code that extracts an element from a linked list given its position. The code is a method called extract which takes an integer called pos as an argument
". If the position is 0 or the linked list is empty, then the element is extracted at the beginning of the list, calling the method extract without arguments. There is a diagram showing a linked list with 5 elements"
". There is a diagram showing a linked list with 5 elements. The third element is red, indicating that it is the element to be extracted. The second element is labeled ""previous"" and the first element is labeled ""first"". The last node points to null."
Extracting an intermediate node (given the position)
"We have some code and a diagram. The code is for a method called ""extract"" which takes an integer ""pos"" as input. The diagram shows a linked list with 5 nodes"
". The diagram shows a linked list with 5 nodes. The first node is labeled ""first"", the third node is colored red, and the last node's next pointer points to ""null"""
". An arrow points from the label ""previous"" to the second node, and an arrow points from the label ""first"" to the first node."
"The code first checks if the position is larger than the number of nodes. If it is, then null is returned. Otherwise, the code advances from the first node to the position of the previous node"
". Then, the code calls the method that extracts at an intermediate position given the previous node."
"7. Traversing the list: printing the content
We have some source code that shows a function called print. This function takes no arguments. The code is as follows:
```java
public void print() {
  if (first != null) {
    Node<E> current = first;"
"if (first != null) {
    Node<E> current = first;
    while (current != null) {
      System.out.println(current.getInfo());
      current = current.getNext();
    }
  }
}
```"
"Along with the code, there is a diagram that helps to explain how the code works. The diagram shows a linked list with five nodes. The first node is labeled ""first"" and the last node is labeled ""null"". Each node is represented by a rectangle"
". Each node is represented by a rectangle. The rectangles are connected by arrows, which indicate the order of the nodes in the list. The first arrow points to the first node in the list, and the last arrow points to null"
". There is also an arrow labeled ""current"" that points to the first node."
"The code works by first checking if the list is empty. If the list is not empty, the code creates a variable called ""current"" and sets it to the first node in the list. The code then enters a loop that continues as long as the ""current"" node is not null"
". Inside the loop, the code prints the information stored in the ""current"" node. The code then sets the ""current"" node to the next node in the list"
". The loop continues until the ""current"" node is null, which indicates that the end of the list has been reached."
"**8. Traversing the list: searching for the last node**
 a method written in Java that searches for the last node in a linked list.
The method is called `searchLastNode()` and it returns a `Node<E>` object."
The method starts by declaring a `Node<E>` variable called `current` and initializing it to the `first` node in the list.
"Then, it checks if `current` is not `null`. If it is not, it enters a `while` loop that iterates through the list until it finds a node whose `next` node is `null`."
"Inside the loop, the `current` node is updated to the next node in the list by calling the `getNext()` method.
Once the loop has finished, the `current` node will be the last node in the list, so the method returns the `current` node."
"**9. Traversing the list: searching for a piece of data**
 a piece of code that defines the method *search* that traverses a linked list to search for a specific piece of data."
The method takes as input a parameter *info* of generic type *E* representing the data to be searched
". It uses a *current* node reference to traverse the list, initialized to the *first* node, and a counter *pos* to keep track of the position of the node in the list."
The traversal is done in a *while* loop that iterates as long as the *current* node is not null and the information stored in the *current* node is not equal to the *info* we are looking for
". For each iteration, the counter *pos* is incremented and the *current* node is moved to the next one."
"If the loop terminates because the *current* node is not null, it means that the *info* has been found and the method returns the value of the counter *pos*. Otherwise, the *info* is not in the list and the method returns *-1*."
"Contents
v *** Introduction to generics
v Data structures
v Linked lists
• The class Node
• The class LinkedList
• Benefits and drawbacks of linked lists"
"Introduction to generics
• Service provided by Java (J2SE 5.0 and above)
• Generics allow checking object types during
compile timeo Errors are detected at compile time (guaranteeing
compatible types during runtime)"
the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow for checking object types during compile time
". They allow for checking object types during compile time. This means that errors related to incompatible types are detected at compile time, guaranteeing that only compatible types are used during runtime."
"how to use generics in Java.
Without generics, the following code will compile but throw a ClassCastException at runtime:
```java
List list = new ArrayList();
list.add(""test"");
Integer value = (Integer) list.get(0);
```"
"list.add(""test"");
Integer value = (Integer) list.get(0);
```
This is because we are adding a String to the list, but then trying to retrieve it as an Integer."
The diagram shows that the `ArrayList` class implements the `List` interface and extends the `AbstractList` class.
"the concept of generics in programming, specifically focusing on their use in Java with ArrayLists.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test""); // Error!
Integer value = list.get(0);
```"
"list.add(""test""); // Error!
Integer value = list.get(0);
```
This code attempts to create an `ArrayList` that should only contain `Integer` objects. However, it tries to add a `String` (""test"") to the list, which is a type mismatch."
"A red box highlights the error message that would be generated at compile time:
```
Error at compile time
""The method add(Integer) in the type List<Integer>
is not applicable for the arguments (String)""
The error is detected before running the program
```"
"The error is detected before running the program
```
This emphasizes that generics provide compile-time type safety. The error is caught early because the compiler knows the `list` object is designed to hold only `Integer` types."
"Finally, a diagram illustrates the class hierarchy involved:
- `ArrayList<E>` implements `AbstractList<E>`
- `AbstractList<E>` extends a more general class (not shown)"
"- `AbstractList<E>` extends a more general class (not shown)
This hierarchy, combined with generics (`<E>`), allows for type-safe collections in Java."
"an example of how to create a class that uses generics. The class is called ArrayList and it takes a type parameter E. The class has several methods, including add, get, remove, and set. Each of these methods takes an argument of type E"
". Each of these methods takes an argument of type E. This means that the ArrayList class can be used to store any type of object. For example, you could create an ArrayList of Strings, an ArrayList of Integers, or an ArrayList of any other type of object."
We are working with a class that uses generics. We have some example code that creates a new ArrayList of Employees. Then it adds a new Employee. Then it gets the first employee from the list
". Then it gets the first employee from the list. Then it tries to add a new Secretary, a new Person, and a new Object. These last three lines of code are highlighted in red with a large red arrow pointing to the right"
". Below the code, there is a diagram showing the inheritance hierarchy of the classes involved. Person is the parent class of Employee. Employee is the parent class of Professor and Secretary"
". The text ""Compilation errors"" is written below the code, indicating that these three lines of code will result in compilation errors because the ArrayList is defined to only hold objects of type Employee or its subclasses."
"Introduction to generics
Without Generics
List list = new ArrayList();
list.add(“test”);
Integer value = (Integer) list.get(0);
Error at runtime
“ClassCastException”.          
The program stops
AbstractList
List
extends
implements
ArrayList"
the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow for checking object types during compile time
". They allow for checking object types during compile time. This means that errors related to incompatible types are detected at compile time, guaranteeing that only compatible types are used during runtime."
"how to use generics in Java.
Without generics, the following code will compile but throw a ClassCastException at runtime:
```java
List list = new ArrayList();
list.add(""test"");
Integer value = (Integer) list.get(0);
```"
"list.add(""test"");
Integer value = (Integer) list.get(0);
```
This is because we are adding a String to the list, but then trying to retrieve it as an Integer."
The diagram shows that the `ArrayList` class implements the `List` interface and extends the `AbstractList` class.
"the concept of generics in programming, specifically focusing on their use in Java with ArrayLists.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test""); // Error!
Integer value = list.get(0);
```"
"list.add(""test""); // Error!
Integer value = list.get(0);
```
This code attempts to create an `ArrayList` that should only contain `Integer` objects. However, it tries to add a `String` (""test"") to the list, which is a type mismatch."
"A red box highlights the error message that would be generated at compile time:
```
Error at compile time
""The method add(Integer) in the type List<Integer>
is not applicable for the arguments (String)""
The error is detected before running the program
```"
"The error is detected before running the program
```
This emphasizes that generics provide compile-time type safety. The error is caught early because the compiler knows the `list` object is designed to hold only `Integer` types."
"Finally, a diagram illustrates the class hierarchy involved:
- `ArrayList<E>` implements `AbstractList<E>`
- `AbstractList<E>` extends a more general class (not shown)"
"- `AbstractList<E>` extends a more general class (not shown)
This hierarchy, combined with generics (`<E>`), allows for type-safe collections in Java."
"an example of how to create a class that uses generics. The class is called ArrayList and it takes a type parameter E. The class has several methods, including add, get, remove, and set. Each of these methods takes an argument of type E"
". Each of these methods takes an argument of type E. This means that the ArrayList class can be used to store any type of object. For example, you could create an ArrayList of Strings, an ArrayList of Integers, or an ArrayList of any other type of object."
We are working with a class that uses generics. We have some example code that creates a new ArrayList of Employees. Then it adds a new Employee. Then it gets the first employee from the list
". Then it gets the first employee from the list. Then it tries to add a new Secretary, a new Person, and a new Object. These last three lines of code are highlighted in red with a large red arrow pointing to the right"
". Below the code, there is a diagram showing the inheritance hierarchy of the classes involved. Person is the parent class of Employee. Employee is the parent class of Professor and Secretary"
". The text ""Compilation errors"" is written below the code, indicating that these three lines of code will result in compilation errors because the ArrayList is defined to only hold objects of type Employee or its subclasses."
"Introduction to generics
With Generics
List<Integer> list = new ArrayList<Integer>();
list.add(“test”);
Integer value = list.get(0);"
"list.add(“test”);
Integer value = list.get(0);
Error at compile time“The method add(Integer) in the type List<Integer>is not applicable for the arguments (String)”  The error is detected before running the program
AbstractList<E>
List<E>
extends"
"AbstractList<E>
List<E>
extends
implements
ArrayList<E>"
the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow for checking object types during compile time
". They allow for checking object types during compile time. This means that errors related to incompatible types are detected at compile time, guaranteeing that only compatible types are used during runtime."
"how to use generics in Java.
Without generics, the following code will compile but throw a ClassCastException at runtime:
```java
List list = new ArrayList();
list.add(""test"");
Integer value = (Integer) list.get(0);
```"
"list.add(""test"");
Integer value = (Integer) list.get(0);
```
This is because we are adding a String to the list, but then trying to retrieve it as an Integer."
The diagram shows that the `ArrayList` class implements the `List` interface and extends the `AbstractList` class.
"the concept of generics in programming, specifically focusing on their use in Java with ArrayLists.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test""); // Error!
Integer value = list.get(0);
```"
"list.add(""test""); // Error!
Integer value = list.get(0);
```
This code attempts to create an `ArrayList` that should only contain `Integer` objects. However, it tries to add a `String` (""test"") to the list, which is a type mismatch."
"A red box highlights the error message that would be generated at compile time:
```
Error at compile time
""The method add(Integer) in the type List<Integer>
is not applicable for the arguments (String)""
The error is detected before running the program
```"
"The error is detected before running the program
```
This emphasizes that generics provide compile-time type safety. The error is caught early because the compiler knows the `list` object is designed to hold only `Integer` types."
"Finally, a diagram illustrates the class hierarchy involved:
- `ArrayList<E>` implements `AbstractList<E>`
- `AbstractList<E>` extends a more general class (not shown)"
"- `AbstractList<E>` extends a more general class (not shown)
This hierarchy, combined with generics (`<E>`), allows for type-safe collections in Java."
"an example of how to create a class that uses generics. The class is called ArrayList and it takes a type parameter E. The class has several methods, including add, get, remove, and set. Each of these methods takes an argument of type E"
". Each of these methods takes an argument of type E. This means that the ArrayList class can be used to store any type of object. For example, you could create an ArrayList of Strings, an ArrayList of Integers, or an ArrayList of any other type of object."
We are working with a class that uses generics. We have some example code that creates a new ArrayList of Employees. Then it adds a new Employee. Then it gets the first employee from the list
". Then it gets the first employee from the list. Then it tries to add a new Secretary, a new Person, and a new Object. These last three lines of code are highlighted in red with a large red arrow pointing to the right"
". Below the code, there is a diagram showing the inheritance hierarchy of the classes involved. Person is the parent class of Employee. Employee is the parent class of Professor and Secretary"
". The text ""Compilation errors"" is written below the code, indicating that these three lines of code will result in compilation errors because the ArrayList is defined to only hold objects of type Employee or its subclasses."
"Introduction to generics
Creation of a class that uses generics
public class ArrayList<E>{
public boolean add(E e){…}
public void add(int index, E element)
public E get(int index){…}
public E remove(int index)
public set(int index, E element)
…
}"
the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow for checking object types during compile time
". They allow for checking object types during compile time. This means that errors related to incompatible types are detected at compile time, guaranteeing that only compatible types are used during runtime."
"how to use generics in Java.
Without generics, the following code will compile but throw a ClassCastException at runtime:
```java
List list = new ArrayList();
list.add(""test"");
Integer value = (Integer) list.get(0);
```"
"list.add(""test"");
Integer value = (Integer) list.get(0);
```
This is because we are adding a String to the list, but then trying to retrieve it as an Integer."
The diagram shows that the `ArrayList` class implements the `List` interface and extends the `AbstractList` class.
"the concept of generics in programming, specifically focusing on their use in Java with ArrayLists.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test""); // Error!
Integer value = list.get(0);
```"
"list.add(""test""); // Error!
Integer value = list.get(0);
```
This code attempts to create an `ArrayList` that should only contain `Integer` objects. However, it tries to add a `String` (""test"") to the list, which is a type mismatch."
"A red box highlights the error message that would be generated at compile time:
```
Error at compile time
""The method add(Integer) in the type List<Integer>
is not applicable for the arguments (String)""
The error is detected before running the program
```"
"The error is detected before running the program
```
This emphasizes that generics provide compile-time type safety. The error is caught early because the compiler knows the `list` object is designed to hold only `Integer` types."
"Finally, a diagram illustrates the class hierarchy involved:
- `ArrayList<E>` implements `AbstractList<E>`
- `AbstractList<E>` extends a more general class (not shown)"
"- `AbstractList<E>` extends a more general class (not shown)
This hierarchy, combined with generics (`<E>`), allows for type-safe collections in Java."
"an example of how to create a class that uses generics. The class is called ArrayList and it takes a type parameter E. The class has several methods, including add, get, remove, and set. Each of these methods takes an argument of type E"
". Each of these methods takes an argument of type E. This means that the ArrayList class can be used to store any type of object. For example, you could create an ArrayList of Strings, an ArrayList of Integers, or an ArrayList of any other type of object."
We are working with a class that uses generics. We have some example code that creates a new ArrayList of Employees. Then it adds a new Employee. Then it gets the first employee from the list
". Then it gets the first employee from the list. Then it tries to add a new Secretary, a new Person, and a new Object. These last three lines of code are highlighted in red with a large red arrow pointing to the right"
". Below the code, there is a diagram showing the inheritance hierarchy of the classes involved. Person is the parent class of Employee. Employee is the parent class of Professor and Secretary"
". The text ""Compilation errors"" is written below the code, indicating that these three lines of code will result in compilation errors because the ArrayList is defined to only hold objects of type Employee or its subclasses."
"Introduction to generics
Working with a class that uses generics
ArrayList<Employee> employees = new ArrayList<Employee>();
employees.add(new Employee());
Employee myEmployee = employees.get(0);
employees.add(new Secretary());
employees.add(new Person());"
"employees.add(new Secretary());
employees.add(new Person());
employees.add(new Object());
Compilation errors"
the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow for checking object types during compile time
". They allow for checking object types during compile time. This means that errors related to incompatible types are detected at compile time, guaranteeing that only compatible types are used during runtime."
"how to use generics in Java.
Without generics, the following code will compile but throw a ClassCastException at runtime:
```java
List list = new ArrayList();
list.add(""test"");
Integer value = (Integer) list.get(0);
```"
"list.add(""test"");
Integer value = (Integer) list.get(0);
```
This is because we are adding a String to the list, but then trying to retrieve it as an Integer."
The diagram shows that the `ArrayList` class implements the `List` interface and extends the `AbstractList` class.
"the concept of generics in programming, specifically focusing on their use in Java with ArrayLists.
**With Generics**
 a code snippet:
```java
List<Integer> list = new ArrayList<Integer>();
list.add(""test""); // Error!
Integer value = list.get(0);
```"
"list.add(""test""); // Error!
Integer value = list.get(0);
```
This code attempts to create an `ArrayList` that should only contain `Integer` objects. However, it tries to add a `String` (""test"") to the list, which is a type mismatch."
"A red box highlights the error message that would be generated at compile time:
```
Error at compile time
""The method add(Integer) in the type List<Integer>
is not applicable for the arguments (String)""
The error is detected before running the program
```"
"The error is detected before running the program
```
This emphasizes that generics provide compile-time type safety. The error is caught early because the compiler knows the `list` object is designed to hold only `Integer` types."
"Finally, a diagram illustrates the class hierarchy involved:
- `ArrayList<E>` implements `AbstractList<E>`
- `AbstractList<E>` extends a more general class (not shown)"
"- `AbstractList<E>` extends a more general class (not shown)
This hierarchy, combined with generics (`<E>`), allows for type-safe collections in Java."
"an example of how to create a class that uses generics. The class is called ArrayList and it takes a type parameter E. The class has several methods, including add, get, remove, and set. Each of these methods takes an argument of type E"
". Each of these methods takes an argument of type E. This means that the ArrayList class can be used to store any type of object. For example, you could create an ArrayList of Strings, an ArrayList of Integers, or an ArrayList of any other type of object."
We are working with a class that uses generics. We have some example code that creates a new ArrayList of Employees. Then it adds a new Employee. Then it gets the first employee from the list
". Then it gets the first employee from the list. Then it tries to add a new Secretary, a new Person, and a new Object. These last three lines of code are highlighted in red with a large red arrow pointing to the right"
". Below the code, there is a diagram showing the inheritance hierarchy of the classes involved. Person is the parent class of Employee. Employee is the parent class of Professor and Secretary"
". The text ""Compilation errors"" is written below the code, indicating that these three lines of code will result in compilation errors because the ArrayList is defined to only hold objects of type Employee or its subclasses."
"Data Structures
• Abstraction that represents a
collection of data in a program inorder to ease its manipulation
• The suitability of a data structure
depends on the nature of the datato be stored, and how that data willbe manipulated"
"- Data structures are abstractions that represent a collection of data in a program.
- They are used to ease the manipulation of data."
"- They are used to ease the manipulation of data.
- The suitability of a data structure depends on the nature of the data to be stored and how that data will be manipulated."
"Linear Data Structures
• They organize data as a sequence, whereeach piece of data has a preceding datum
(except for the first one) and a succeedingdatum (except for the last one)
• Examples of linear data structures:
– Arrays
– Linked lists
– Stacks"
"– Arrays
– Linked lists
– Stacks
– Queues
– Double-ended queues"
"Linear data structures organize data as a sequence, where each piece of data has a preceding datum, except for the first one, and a succeeding datum, except for the last one."
"Some examples of linear data structures are: arrays, linked lists, stacks, queues, and double-ended queues."
"Arrays
• Advantages for storing linear data
collections:
– Random access: any position in the array
can be accessed in constant time.
– Efficient use of memory when all the"
"– Efficient use of memory when all the
positions of the array are in use, becausethe array is stored in consecutive memorypositions."
"advantages for storing linear data collections with arrays. The advantages are: random access, meaning any position in the array can be accessed in constant time, and efficient use of memory when all the positions of the array are in use"
. This is because the array is stored in consecutive memory positions.
Let's talk about some of the disadvantages of using arrays.
"First, arrays have a static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems"
". This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed."
"The second disadvantage is that arrays require contiguous memory. This means that even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation."
Let's talk about some of the disadvantages of arrays.Some operations on arrays have a sub-optimum cost
".Some operations on arrays have a sub-optimum cost. For example, insertions and extractions, or removals, of data in the first position or intermediate positions require data to be moved to consecutive memory positions"
. Concatenation of arrays means that data must be copied to a new array. Partition of an array in several pieces means that data must be copied to new arrays.
"Arrays
• Disadvantages (I):
– Static size: The size must be defined whenthe array is created and cannot be changedlater. The main problems this poses are:
• Inefficient use of memory when more positions
than needed are reserved"
"than needed are reserved
• It may happen at runtime that more positions than
reserved are needed
– Need of contiguous memory:
• Even having the system enough free memory, itmay happen that there is not enough contiguousspace, due to memory fragmentation"
"advantages for storing linear data collections with arrays. The advantages are: random access, meaning any position in the array can be accessed in constant time, and efficient use of memory when all the positions of the array are in use"
. This is because the array is stored in consecutive memory positions.
Let's talk about some of the disadvantages of using arrays.
"First, arrays have a static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems"
". This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed."
"The second disadvantage is that arrays require contiguous memory. This means that even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation."
Let's talk about some of the disadvantages of arrays.Some operations on arrays have a sub-optimum cost
".Some operations on arrays have a sub-optimum cost. For example, insertions and extractions, or removals, of data in the first position or intermediate positions require data to be moved to consecutive memory positions"
. Concatenation of arrays means that data must be copied to a new array. Partition of an array in several pieces means that data must be copied to new arrays.
"Arrays
• Disadvantages (II):
– Some operations on the array have a
sub-optimum cost:
• Insertions and extractions (removals) of data in thefirst position or intermediate positions need data tobe moved to consecutive memory positions"
"• Concatenation of arrays: data must be copied to a
new array
• Partition of an array in several pieces: data must be
copied to new arrays"
"advantages for storing linear data collections with arrays. The advantages are: random access, meaning any position in the array can be accessed in constant time, and efficient use of memory when all the positions of the array are in use"
. This is because the array is stored in consecutive memory positions.
Let's talk about some of the disadvantages of using arrays.
"First, arrays have a static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems"
". This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed."
"The second disadvantage is that arrays require contiguous memory. This means that even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation."
Let's talk about some of the disadvantages of arrays.Some operations on arrays have a sub-optimum cost
".Some operations on arrays have a sub-optimum cost. For example, insertions and extractions, or removals, of data in the first position or intermediate positions require data to be moved to consecutive memory positions"
. Concatenation of arrays means that data must be copied to a new array. Partition of an array in several pieces means that data must be copied to new arrays.
"Exercise 1
• Create a ten-element array of integers and initialize
all the elements with value 1. Then, insert anadditional element with value 0 in the fourthposition of the array.
• Note: Inserting a new element is different from replacing an"
"• Note: Inserting a new element is different from replacing an
element by another one."
"Create a ten-element array of integers and initialize all the elements with value 1. Then, insert an additional element with value 0 in the fourth position of the array. Note: Inserting a new element is different from replacing an element by another one."
"Linked Lists
• Ordered sequence of nodes in which
each node stores:
– A piece of data (info)
– A reference pointing to the next node
• Nodes do not need to be in
consecutive memory positions
first
info
info
info
next
next
next
null"
"A linked list is an ordered sequence of nodes. Each node stores a piece of data, called info, and a reference pointing to the next node in the list. The nodes do not need to be in consecutive memory positions."
"The diagram shows a linked list with three nodes. The first node contains the value ""info"" and a reference to the second node. The second node contains the value ""info"" and a reference to the third node"
". The third node contains the value ""info"" and a reference to null, which indicates the end of the list. The variable ""first"" points to the first node in the list."
"The Node Class
public class Node<E> {
private E info;private Node<E> next;
Use of generics to storeinformation of different types
Two attributes: info andreference to the next node
public Node(E info) {…}
Constructor toinitialize info"
"public Node(E info) {…}
Constructor toinitialize info
public Node<E> getNext() {…}
public void setNext(Node<E> next) {…}
public E getInfo() {…}
public void setInfo(E info) {…}
}
Getters and setters for the attributes"
"}
Getters and setters for the attributes
This code snippet shows a Java implementation of a generic Node class. The class uses generics to store information of different types."
"It has two attributes: ""info"" of type E and ""next"" which is a reference to the next node. The constructor initializes the ""info"" attribute.
The class also includes getters and setters for both attributes: getNext, setNext, getInfo, and setInfo."
"Exercise 2
• Complete the code in the class Node.
Program three constructors: one that does notreceive arguments to initialize the attributes;one that serves to initialize the attributeinfo; and another one that serves toinitialize the two attributes."
"Complete the code in the class ""Node"". Program three constructors: one that does not receive arguments to initialize the attributes; one that serves to initialize the attribute ""info""; and another one that serves to initialize the two attributes."
"The class MyLinkedList
public class MyLinkedList<E> {
private Node<E> first;
public MyLinkedList() {…}
public void insert(E info) {…}
public E extract() {…}
private void insert(E info, Node<E> previous) {…}
private E extract(Node<E> previous) {…}"
"private E extract(Node<E> previous) {…}
public void insert(E info, int pos) {…}
public E extract(int pos) {…}
public void print() {…}
public Node<E> searchLastNode() {…}
public int search(E info) {…}
…
}"
"public int search(E info) {…}
…
}
This code defines a generic class called MyLinkedList in a programming language like Java. The class uses a data structure called a linked list to store a sequence of elements."
"- The class starts by declaring a private variable ""first"" of type Node<E>. This variable represents the first node in the linked list.
- Then, we have a constructor for the MyLinkedList class."
"- The class includes public methods for inserting and extracting elements from the linked list. These methods are overloaded to allow insertion and extraction at the beginning of the list, at a specific position, or after a given node."
"- There are also private helper methods for inserting and extracting elements, which are used by the public methods."
"- Additionally, the class has a public method ""print"" for displaying the contents of the linked list, a method ""searchLastNode"" for finding the last node in the list, and a method ""search"" for searching for a specific element in the list."
"1. Inserting a node at the beginning
public void insert(E info)
first
newNode
null
Step 1: Creating a new node
null
Node<E> newNode = new Node<E>(info);"
"The image shows a code snippet for a method called ""insert"" that takes a generic type ""E"" called ""info"" as input. The goal of the code is to insert a new node at the beginning of a linked list."
"The diagram shows a linked list with three nodes. The first node is labeled ""first"" and points to the second node. The second node points to the third node. The third node points to ""null""."
"There is a new node labeled ""newNode"" that points to ""null"". This node will be inserted at the beginning of the linked list.
Step 1: Creating a new node"
"Step 1: Creating a new node
The code first creates a new node of type ""Node"" with the value of ""info"" and assigns it to the variable ""newNode""."
"1. Inserting a node at the beginning
public void insert(E info)
first
newNode
null
Step 2: Assigning the first node as the nextone for the node just created
newNode.setNext(first);"
"The image shows a code snippet for a method called ""insert"" that takes a generic type ""E"" called ""info"" as input. The goal of the code is to insert a new node at the beginning of a linked list."
"The diagram shows a linked list with three nodes. The first node is labeled ""first"" and points to the second node. The second node points to the third node. The third node points to ""null""."
"There is a new node labeled ""newNode"" that points to ""null"". This node will be inserted at the beginning of the linked list.
Step 1: Creating a new node"
"Step 1: Creating a new node
The code first creates a new node of type ""Node"" with the value of ""info"" and assigns it to the variable ""newNode""."
"1. Inserting a node at the beginning
public void insert(E info)
first
newNode
null
Step 3: Assigning as first node in the list thenode just created
first = newNode;"
"The image shows a code snippet for a method called ""insert"" that takes a generic type ""E"" called ""info"" as input. The goal of the code is to insert a new node at the beginning of a linked list."
"The diagram shows a linked list with three nodes. The first node is labeled ""first"" and points to the second node. The second node points to the third node. The third node points to ""null""."
"There is a new node labeled ""newNode"" that points to ""null"". This node will be inserted at the beginning of the linked list.
Step 1: Creating a new node"
"Step 1: Creating a new node
The code first creates a new node of type ""Node"" with the value of ""info"" and assigns it to the variable ""newNode""."
"2. Extracting the first node
public E extract()
first
Step 1: Checking that the list is not empty
if (first != null)
null"
"The image shows step 4 of a process to extract the first node of a linked list.
The code snippet shows the signature of a method called ""extract"" that returns a generic type ""E""."
"The diagram shows three nodes. The first node is filled in red and has an arrow pointing to it with the label ""first"". The first node is followed by another node, which is followed by a last node that points to ""null"""
. There is an arrow from the bottom left corner pointing to the data section of the first node.
"Below the first node, there is a text box that reads: ""The node is isolated and does not belong to the list anymore"".
Finally, below the diagram, we see ""Step 4: Returning the piece of data"" and the instruction ""return data;""."
"2. Extracting the first node
public E extract()
first
data
Step 2: Getting the info from the node to extract
E data = first.getInfo();
null
null"
"The image shows step 4 of a process to extract the first node of a linked list.
The code snippet shows the signature of a method called ""extract"" that returns a generic type ""E""."
"The diagram shows three nodes. The first node is filled in red and has an arrow pointing to it with the label ""first"". The first node is followed by another node, which is followed by a last node that points to ""null"""
. There is an arrow from the bottom left corner pointing to the data section of the first node.
"Below the first node, there is a text box that reads: ""The node is isolated and does not belong to the list anymore"".
Finally, below the diagram, we see ""Step 4: Returning the piece of data"" and the instruction ""return data;""."
"2. Extracting the first node
public E extract()
first
data
Step 3: Assigning the second node as the first one of the list
first = first.getNext();
null
null"
"The image shows step 4 of a process to extract the first node of a linked list.
The code snippet shows the signature of a method called ""extract"" that returns a generic type ""E""."
"The diagram shows three nodes. The first node is filled in red and has an arrow pointing to it with the label ""first"". The first node is followed by another node, which is followed by a last node that points to ""null"""
. There is an arrow from the bottom left corner pointing to the data section of the first node.
"Below the first node, there is a text box that reads: ""The node is isolated and does not belong to the list anymore"".
Finally, below the diagram, we see ""Step 4: Returning the piece of data"" and the instruction ""return data;""."
"2. Extracting the first node
public E extract()
first
data
The node is isolated and doesnot belong to the list anymore
Step 4: Returning the piece of data
return data;
null
null"
"The image shows step 4 of a process to extract the first node of a linked list.
The code snippet shows the signature of a method called ""extract"" that returns a generic type ""E""."
"The diagram shows three nodes. The first node is filled in red and has an arrow pointing to it with the label ""first"". The first node is followed by another node, which is followed by a last node that points to ""null"""
. There is an arrow from the bottom left corner pointing to the data section of the first node.
"Below the first node, there is a text box that reads: ""The node is isolated and does not belong to the list anymore"".
Finally, below the diagram, we see ""Step 4: Returning the piece of data"" and the instruction ""return data;""."
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
Step 1: Checking that previous is not null
if (previous != null)
null"
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
newNode
null
Step 2: Creating a new node
null
Node<E> newNode = new Node<E>(info);"
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
newNode
null
Step 3: Assigning as the next for the nodejust created the next to previous
newNode.setNext(previous.getNext());"
"3. Inserting at an intermediate position(given the previous node)
private void insert(E info, Node<E> previous)
first
previous
newNode
null
Step 4: Assigning the node just created as the next to previous
previous.setNext(newNode);"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 1: Checking that the list is not empty
Checking that previous is not null.Checking that the next to previous is not null"
"if (first != null && previous!= null && previous.getNext() != null)
null"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 2: Retrieving the information in the node toextract
E data = previous.getNext().getInfo();
null"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 3: Assigning the next to the node to extract asthe next to previous
previous.setNext(previous.getNext().getNext());
null"
"4. Extracting an intermediate node(given the previous node)
private E extract(Node<E> previous)
previous
data
first
Step 4: Returning the piece of data
return data;
null"
"5. Inserting at an intermediate position(given the position)
public void insert(E info, int pos)
first
previous
null
If position is 0 or linked list is empty, then insert at the beginning,calling the insert (E info) method
if (pos == 0 || first == null) {"
"if (pos == 0 || first == null) {
insert(info);
}"
"5. Inserting at an intermediate position(given the position)
public void insert(E info, int pos)
first
previous
null"
"first
previous
null
Advance from first to the position of the previous node, and then callthe method that inserts at an intermediate position given previous. Ifposition is larger than number of nodes, then insert at the end.
else {
Node<E> tmp = first;"
"else {
Node<E> tmp = first;
for (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {
tmp = tmp.getNext();
}
insert(info, tmp);
}"
"6. Extracting an intermediate node(given the position)
public E extract(int pos)
previous
first
null
If position is 0 or linked list is empty, then extract at the beginning,calling the extract() method
if (pos == 0 || first == null) {
return extract();
}"
"6. Extracting an intermediate node(given the position)
public E extract(int pos)
previous
first
null"
"Advance from first to the position of the previous node, and then callAdvance from first to the position of previous, and call the methodthe method that extracts at an intermediate position given previous"
.that extracts an intermediate node given the previous node
"If position is larger than number of nodes, then null is returned.
else {
Node<E> tmp = first;
for (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {
tmp = tmp.getNext();
}
return extract(tmp);
}"
"7. Traversing the list:
printing the content
public void print()
current
first
null
if(first!=null){
Node<E> current = first;
while (current != null) {
System.out.println(current.getInfo());   current = current.getNext();
}
}"
"8. Traversing the list:searching for the last node
public Node<E> searchLastNode()
•
A reference steps the list until a node is reachedwhose reference to the next node is null :
public Node<E> searchLastNode() {
Node<E> current = first;"
"public Node<E> searchLastNode() {
Node<E> current = first;
if (current != null) {
while (current.getNext() != null) {current = current.getNext();
}
}
return current;
}"
"9. Traversing the list:searching for a piece of data
public int search(E info)
•
A reference steps the list until the piece of information is reached.A counter is used in order to return its position in the list:
public int search(E info) {
int pos = 0;"
"public int search(E info) {
int pos = 0;
Node<E> current = first;while (current != null
&& !current.getInfo().equals(info)) {   pos++;
current = current.getNext();
}
if (current != null){
return pos;
} else{
return -1;
}
}"
"Exercise 3
• Create the method
public int numberOfOcurrences(E info),which returns the number of nodes in a linkedlist whose stored information is the same as theone provided as argument."
Create the method public int number of occurrences E info which returns the number of nodes in a linked list whose stored information is the same as the one provided as argument.
"Advantages of Linked Lists
• Inserting and extracting nodes have a costthat does not depend on the size of the list
• Concatenation and partition of lists have a
cost that does not depend on the size of thelist
• There is no need for contiguous memory"
"• There is no need for contiguous memory
• Memory in use at a given instant dependsonly on the number of data items stored inthe list at that instant"
"- Inserting and extracting nodes have a cost that does not depend on the size of the list
- Concatenation and partition of lists have a cost that does not depend on the size of the list
- There is no need for contiguous memory"
"- There is no need for contiguous memory
- Memory in use at a given instant depends only on the number of data items stored in the list at that instant"
"Disadvantages of Linked Lists
• Accessing to arbitrary intermediate
positions has a cost that depends onthe size of the list
• Each node represents an overhead in
memory usage"
"- Accessing to arbitrary intermediate positions has a cost that depends on the size of the list
- Each node represents an overhead in memory usage"
Exercise 4
"• Create a Linked List with ten elements of typeinteger, and initialize them to 1. Then, insert anadditional element with value 0 in the fourthpositon of the Linked List"
". Assume that classesNode and MyLinkedList already exist, andare implemented as we saw in this session."
"Create a linked list with 10 integer elements, all initialized to 1. Then, insert an additional element with the value 0 in the fourth position of the linked list"
. Assume that the classes Node and MyLinkedList already exist and are implemented as previously discussed.
"**1. Inserting a node at the beginning**
 how to insert a new node at the beginning of a linked list. The code snippet shows a method called ""insert"" that takes a generic type ""E"" called ""info"" as input."
"There is a diagram showing four nodes. The first node is labeled ""first"" and points to the second node. The second node points to the third node, and so on. The last node points to ""null,"" indicating the end of the list."
"A new node labeled ""newNode"" is added to the beginning of the list. The ""newNode"" is colored red and contains data.
**Step 2: Assigning the first node as the next one for the node just created**"
"To insert the ""newNode,"" we need to update the ""next"" pointer of the ""newNode"" to point to the current ""first"" node. This is done using the code ""newNode.setNext(first);""."
Inserting a node at the beginning
"The image shows step 3 of inserting a node at the beginning of a linked list. The code snippet shows the method signature: ""public void insert(E info)"".  There is a variable named ""first"" that points to the first node in the list"
". The diagram shows three nodes in the list, each with an arrow pointing to the next node. The last node has an arrow pointing to the text ""null"".  A new node, colored red, is being inserted at the beginning of the list"
". An arrow labeled ""newNode"" points to the new node. Step 3 of the process involves assigning the ""first"" variable to point to the ""newNode"". The text ""Step 3: Assigning as first node in the list the node just created first = newNode;"" describes this step."
"**2. Extracting the first node**
The code snippet shows a function called ""extract"" which takes no arguments and returns a generic type E."
"The diagram shows three nodes. The first node is highlighted in red and labeled ""first"". The nodes are linked together in a singly linked list, with the last node pointing to ""null""."
"The first step of the ""extract"" function is to check if the list is not empty. This is done by checking if the ""first"" node is not null."
"**2. Extracting the first node**
The code snippet shows a function called ""extract"" that takes no arguments and returns a generic type E."
The diagram shows a linked list with three nodes. The first node is highlighted in red. The second node is connected to the first node with an arrow. The third node is connected to the second node with an arrow. The last node points to null.
"The second step of the extraction process involves getting the information from the node to extract. The code snippet shows that the data from the first node is retrieved using the ""getInfo()"" method and stored in a variable called ""data"" of type E."
Extracting the first node
"how to extract the first node from a linked list. The code snippet shows a method called ""extract"" that returns a generic type E. The diagram shows three nodes in a linked list. The first node is colored red and labeled ""first"""
". The first node is colored red and labeled ""first"". An arrow points from the label ""first"" to the first node. The first node points to the second node and the second node points to the third node. The third node points to ""null""."
"Step 3 of the process is to assign the second node as the first one of the list. This is done by setting the ""first"" variable to the next node after the current ""first"" node, using the ""getNext"" method."
**3. Inserting at an intermediate position (given the previous node)**
"The code snippet shows the implementation of an insert method in Java. The method takes two arguments: ""info"" of type E which represents the data to be inserted and ""previous"" of type Node<E> which represents the node previous to the insertion point."
"The diagram illustrates a linked list with three nodes. The first node is labeled ""previous"" and has an arrow pointing to the second node. The second node has an arrow pointing to the third node"
". The second node has an arrow pointing to the third node. The third node has an arrow pointing to ""null,"" indicating the end of the list."
"The first step of the insertion process is to check if the ""previous"" node is not null. This is done using an ""if"" statement that checks if ""previous"" is not equal to null."
**3. Inserting at an intermediate position (given the previous node)**
"We see four rectangular nodes, visually representing a linked list. The second node from the left is labeled ""previous"" and has an arrow pointing to the next node in the list"
". The next node has an arrow pointing to the last node, which has an arrow pointing to the word ""null"".  The word ""first"" has an arrow pointing to the first node. Below the first node is another node labeled ""newNode"" and colored red"
". This node has an arrow pointing to the word ""null""."
"Below the diagram, we see the code ""Node<E> newNode = new Node<E>(info);"" which is labeled as ""Step 2: Creating a new node""."
"3. Inserting at an intermediate position (given the previous node)
The image shows the third step in the process of inserting a new node at an intermediate position in a linked list, given the previous node.
We see a code snippet:"
"We see a code snippet:
_private void insert(E info, Node<E> previous)_
And a diagram with four nodes:
- The first node is labeled ""first"".
- The second node is labeled ""previous"".
- The third node has no label.
- The fourth node is labeled ""null""."
"There is an arrow pointing from the word ""first"" to the first node, an arrow pointing from the word ""previous"" to the second node, and an arrow pointing from the word ""newNode"" to a red oval located below the first node. The nodes are connected by arrows"
". The nodes are connected by arrows. The arrow pointing from the third node is pointing to the fourth node labeled ""null""."
"Finally, there is a text box with the following text:
_Step 3: Assigning as the next for the node just created the next to previous_
_newNode.setNext(previous.getNext());_"
"This step sets the ""next"" pointer of the new node to the node that is currently after the ""previous"" node in the list. This effectively inserts the new node between the ""previous"" node and the node that was originally after it."
3. Inserting at an intermediate position (given the previous node)
"The image shows four nodes, the second one labeled ""previous"" and the new node colored in red. An arrow points from the word ""first"" to the first node. An arrow points from the word ""newNode"" to the red node"
". An arrow points from the word ""newNode"" to the red node. An arrow points from the last node to the word ""null"". Two more arrows connect the nodes in the following order: first node, ""previous"" node, red node, last node."
"The code snippet shows the fourth step of the insertion process: ""previous.setNext(newNode);"". This line of code sets the next node of the ""previous"" node to the newly created node (the red one)."
"Extracting an intermediate node (given the previous node)
We have some source code in a white box:
```java
private E extract(Node<E> previous)
```"
"```java
private E extract(Node<E> previous)
```
First arrow is pointing to the first node of a linked list. Previous arrow is pointing to the previous node. Data arrow is pointing to the data we want to extract. The last node is pointing to null.
<br/>"
"<br/>
There are 3 steps to extract an intermediate node:
. Checking that the list is not empty
. Checking that previous is not null.
. Checking that the next to previous is not null
<br/>
Finally, we have a conditional statement:
```java"
"<br/>
Finally, we have a conditional statement:
```java
if (first != null && previous!= null && previous.getNext() != null)
```"
"**4. Extracting an intermediate node (given the previous node)**
We have a code snippet: ""private E extract(Node<E> previous)"""
"And a diagram showing a linked list with 5 nodes. The second node from the left is labeled ""previous"" and the fourth node is filled in red and labeled ""data"". There is an arrow pointing from ""first"" to the first node in the list"
". The last node has an arrow pointing to the right labeled ""null""."
"**Step 2: Retrieving the information in the node to extract**
And another code snippet: ""E data = previous.getNext().getInfo();"""
"**4. Extracting an intermediate node (given the previous node)**
The code snippet shows the private method ""extract"" which takes a node, called ""previous"", as an argument."
"The diagram shows a linked list with 5 nodes. The second node is colored light orange and labeled ""previous"". The fourth node is colored red and labeled ""data"". The last node points to ""null""."
"**Step 3: Assigning the next to the node to extract as the next to previous**
The code snippet shows how to assign the next node to the node to extract as the next to the previous node:
```java
previous.setNext(previous.getNext().getNext());
```"
"**4. Extracting an intermediate node (given the previous node)**
The image shows step 4 of a process to extract an intermediate node from a linked list, given the previous node."
We see a code snippet: `private E extract(Node<E> previous)` which is a method definition for extracting the node.
"There is a diagram showing four nodes. The first node is pointed by an arrow with the label ""first"". The second node is pointed by an arrow with the label ""previous"". The third node is colored in red and pointed by an arrow with the label ""data"""
". The fourth node is pointed by an arrow with the label ""null""."
"The fourth step of the process, as indicated in the red box, is returning the piece of data. The code snippet for this step is `return data;`."
5. Inserting at an intermediate position (given the position)
The image shows a code snippet for inserting an element into a linked list at a given position. The code first checks if the position is 0 or if the linked list is empty
". If either of these conditions is true, the code inserts the element at the beginning of the list. Otherwise, the code inserts the element at the specified position."
"The image also includes a diagram that illustrates the process of inserting an element into a linked list. The diagram shows a linked list with four nodes. The first node is labeled ""first"" and the last node is labeled ""null"""
". The code is inserting a new node with the value ""info"" at the third position in the list. The diagram shows the new node being inserted between the second and third nodes in the list."
"**5. Inserting at an intermediate position (given the position)**
The image shows a slide titled ""5. Inserting at an intermediate position (given the position)""."
The code snippet shows a method in Java that inserts a new node into a linked list at a given position. The method takes two arguments: the data to be stored in the new node (info) and the position where the new node should be inserted (pos).
"The method first checks if the given position is larger than the number of nodes in the list. If it is, the new node is inserted at the end of the list. Otherwise, the method iterates through the list until it reaches the node before the desired position"
". Once it has found the correct position, it inserts the new node."
The diagram illustrates the process of inserting a new node into a linked list at a given position. The red circle represents the new node to be inserted. The arrows indicate the links between the nodes
". The arrows indicate the links between the nodes. The first arrow points to the first node in the list. The last arrow points to null, indicating the end of the list"
". The last arrow points to null, indicating the end of the list. The ""previous"" arrow points to the node before the position where the new node will be inserted."
"6. Extracting an intermediate node (given the position)
We have a code snippet showing how to extract an intermediate node from a linked list, given its position. The method signature is public E extract(int pos)."
"If the position is zero or the linked list is empty, then we extract the first element by calling the method extract() with no arguments. This is illustrated by the code:
```java
if (pos == 0 || first == null) {
  return extract();
}
```"
"The diagram shows a linked list with five nodes. The first node is on the left and the last node is on the right. The third node is highlighted in red, indicating that it is the node to be extracted. The second node is labeled ""previous"""
". The second node is labeled ""previous"". The last node points to null."
Extracting an intermediate node (given the position)
"We have some code and a diagram. The code is for a method called ""extract"" that takes an integer ""pos"" as input. The diagram shows a linked list with 5 nodes"
". The diagram shows a linked list with 5 nodes. The first node is labeled ""first"", the third node is red, and the last node has an arrow pointing to the word ""null"""
". The second node is labeled ""previous"" and has an arrow pointing to it from the word ""previous""."
"The code first checks if the position is larger than the number of nodes. If it is, then null is returned"
". If it is, then null is returned. Otherwise, the code advances from the first node to the position of the previous node, and then calls the method that extracts at an intermediate position given previous."
"The code does this by first creating a temporary node variable ""tmp"" and setting it to the first node. Then, it iterates from 0 to pos-1. For each iteration, it sets tmp to the next node. After the loop, tmp will be pointing to the node at position pos-1"
". Finally, the code returns the result of calling the extract method with tmp as input."
"7. Traversing the list: printing the content
The code snippet shows a function called ""print"" that takes no arguments. This function iterates through a linked list and prints the information stored in each node."
"The diagram shows a linked list with five nodes. The first node is labeled ""first"" and the last node points to ""null"". Each node is connected to the next one by an arrow."
"The code first checks if the list is empty by checking if ""first"" is null. If not, it creates a ""current"" node, initialized to the ""first"" node. Then, it iterates through the list using a while loop"
". Then, it iterates through the list using a while loop. For each node, it prints the information stored in the node using ""System.out.println(current.getInfo())"". Then, it moves to the next node by setting ""current"" to ""current.getNext()"""
".getNext()"". The loop continues until ""current"" becomes null, indicating the end of the list."
"**8. Traversing the list: searching for the last node**
The code snippet shows a method called ""searchLastNode"" that searches for the last node in a linked list."
"The method starts by getting a reference to the first node in the list. Then, it iterates through the list until it finds a node whose ""next"" reference is null. This means that the current node is the last node in the list."
The method then returns a reference to the last node.
"**9. Traversing the list: searching for a piece of data**
The image shows a code snippet of a method called ""search"" that takes an argument of type E called ""info"" and returns an integer."
"- A reference steps the list until the piece of information is reached.
- A counter is used in order to return its position in the list."
"The code first initializes two variables: an integer called ""pos"" to 0 and a Node<E> called ""current"" to the first node in the list."
"Then, a while loop iterates as long as ""current"" is not null and the information stored in the current node is not equal to the ""info"" argument. Inside the loop, the counter ""pos"" is incremented and the current node is moved to the next node in the list."
"After the loop, the code checks if ""current"" is not null. If it is not null, it means that the information was found and the method returns the value of ""pos"". Otherwise, it means that the information was not found and the method returns -1."
"Contents
v Searching algorithms
o Linear search
o Binary search
v Basic sorting algorithms
o Bubble Sort
o Selection Sort
o Insertion Sort
v Advanced sorting algorithms
o Heap Sort
o Merge Sort
o Quick Sort"
"Searching algorithms
• Why are they important?
• Linear search
• Binary search

- Why are they important?
- Linear search
- Binary search"
"Why are they important?
• One of the most frequent uses of computers are
“static” searches of information in data structures(without modifying the stored values)"
"• The efficiency of the searching algorithm is related towhether the data structure in which we search is sortedor not.
• Many searching algorithms internally call a sorting"
"• Many searching algorithms internally call a sorting
method, and the cost of the sorting algorithmdetermines the global cost of the searching algorithm."
- One of the most frequent uses of computers is static searches of information in data structures without modifying the stored values.
- The efficiency of the searching algorithm is related to whether the data structure in which we search is sorted or not.
"- Many searching algorithms internally call a sorting method, and the cost of the sorting algorithm determines the global cost of the searching algorithm."
"Activity
• Let’s play a game
ü Think of a number between 0 and 999
ü Tell someone to guess your number
ü In every new try your colleague tells you a
number and you can answer
o if that number is correct
o If that number is higher or lower than your number"
"o If that number is higher or lower than your number
• What strategies optimize this game?"
"We are going to play a game. Think of a number between 0 and 999. Tell someone to guess your number. In every new try your colleague tells you a number and you can answer if that number is correct, or if that number is higher or lower than your number"
. What strategies optimize this game?
"Strategies
• Linear
o Start with one end (e.g., 0) and then move forward oneelement by one, until reaching the correct number
o O(n) => linear order
o
For both the successful and unsuccessful searches
• Binary"
"o
For both the successful and unsuccessful searches
• Binary
o Say a number which divides the range of numbers in two
approximately equal parts.
o Whenever you get an answer you have a new range, which
is approximately half the size of the previous range."
"is approximately half the size of the previous range.
o O(log n) => logarithmic order (more efficient)
o
For both the successful and unsuccessful searches"
There are two strategies: linear and binary.
"Linear: you start at one end, for example at point 0, and then you move forward one element at a time until reaching the correct number. This strategy has a linear order, expressed as O(n). This applies to both successful and unsuccessful searches."
"Binary: you say a number that divides the range of numbers in two approximately equal parts. Whenever you get an answer you have a new range, which is approximately half the size of the previous range"
". This strategy has a logarithmic order, expressed as O(log n), which is more efficient. This applies to both successful and unsuccessful searches."
"Linear search
• Starting from:
o An array of elements a[ ] and
o An element x
• We traverse the array from left to right comparing each
of its elements with x
o If they are equal, then we return the position of the element
and the search ends"
"and the search ends
o If they are different, then we keep searching until the end ofthe array, and if we do not find the element x we returnvalue -1, or an exception
http://www.cs.armstrong.edu/liang/animation/web/LinearSearch.html"
"- Starting from an array of elements and an element x.
- We traverse the array from left to right comparing each of its elements with x.
- If they are equal, then we return the position of the element and the search ends"
"- If they are different, then we keep searching until the end of the array, and if we do not find the element x we return value -1, or an exception."
"We see a code snippet for a linear search algorithm. The algorithm takes an array of integers and an integer as input. It iterates through the array, comparing each element to the input integer"
". If a match is found, the index of the matching element is returned. If no match is found, -1 is returned."
"Below the code, there is an array of integers: -5, -2, 0, 3, 6, 8, 9, 10, 12, 26, and 31. Each number is in a separate cell. The index of each cell is displayed below the cell, ranging from 0 to 10."
"Linear search
public static int linearSearch(int a[], int x) {
for (int i = 0; i < a.length ; i++) {
if (a[i] == x){
return i;
}
}
return -1;
}
-5 -2




 10 12 26 31
       1       2      3      4       5      6       7      8       9     10"
"- Starting from an array of elements and an element x.
- We traverse the array from left to right comparing each of its elements with x.
- If they are equal, then we return the position of the element and the search ends"
"- If they are different, then we keep searching until the end of the array, and if we do not find the element x we return value -1, or an exception."
"We see a code snippet for a linear search algorithm. The algorithm takes an array of integers and an integer as input. It iterates through the array, comparing each element to the input integer"
". If a match is found, the index of the matching element is returned. If no match is found, -1 is returned."
"Below the code, there is an array of integers: -5, -2, 0, 3, 6, 8, 9, 10, 12, 26, and 31. Each number is in a separate cell. The index of each cell is displayed below the cell, ranging from 0 to 10."
"Binary search
•
Starting from:
o A sorted array of elements a[ ] and
o An element x
• We store in a variable “half” the position of the element which is in the
middle of the array
• We compare the element which is in “half” with x"
"• We compare the element which is in “half” with x
If they are equal, then we return “half”
If it is lower, then we repeat the search between “half+1” and the end of the array"
"If it is higher, then we repeat the search between the beginning of the array and“half-1”
o
o
o
•
In each iteration we get a subarray which is approximately half the size
http://www.cs.armstrong.edu/liang/animation/web/BinarySearch.html"
"Starting from a sorted array of elements and an element x, we store in a variable ""half"" the position of the element which is in the middle of the array. We compare the element which is in ""half"" with x. If they are equal, then we return ""half"""
". If they are equal, then we return ""half"". If it is lower, then we repeat the search between ""half+1"" and the end of the array. If it is higher, then we repeat the search between the beginning of the array and ""half-1"""
. In each iteration we get a subarray which is approximately half the size.
"how the binary search algorithm works, and presents an example of its first iteration. The algorithm is implemented in a function called binarySearch, which takes an integer array a and an integer x as input"
". The function initializes three integer variables: half, first, and last. The variable first is initialized to 0, and last is initialized to the length of the array minus 1"
. The algorithm then enters a while loop that continues as long as the value of first is less than or equal to the value of last
". Inside the loop, the algorithm calculates the middle index of the search range by assigning the average of first and last to half. If the value at the middle index of the array is equal to the search value x, the index half is returned"
". Otherwise, if the value at the middle index is less than x, the search range is narrowed to the right half by updating first to half+1. Otherwise, the search range is narrowed to the left half by updating last to half-1"
". If the loop completes without finding the search value, the function returns -1."
"The example shows how the algorithm searches for a value in a sorted array. In the first iteration, the algorithm calculates the middle index as (0+10)/2 = 5"
". Since the value at index 5 is greater than the search value, the algorithm narrows the search range to the left half of the array, from index 0 to index 4."
"Binary search
public static int binarySearch(int a[], int x) {
int half;
int first = 0;
int last = a.length -1;
while (first <= last) {
half = (first + last)/2;
if(a[half] == x){
return half;
}else if(a[half] < x){
first = half+1;
}else if(a[half] > x){"
"}else if(a[half] < x){
first = half+1;
}else if(a[half] > x){
last = half-1;
}
}
return -1;
}
First iteration
•
•
If a[half]>x, we search in [0...half-1]
If a[half]<x, we search in a[half+1, a.length-1]
-5 -2"
"10 12 26 31
       1       2      3      4       5      6       7      8       9     10"
"Starting from a sorted array of elements and an element x, we store in a variable ""half"" the position of the element which is in the middle of the array. We compare the element which is in ""half"" with x. If they are equal, then we return ""half"""
". If they are equal, then we return ""half"". If it is lower, then we repeat the search between ""half+1"" and the end of the array. If it is higher, then we repeat the search between the beginning of the array and ""half-1"""
. In each iteration we get a subarray which is approximately half the size.
"how the binary search algorithm works, and presents an example of its first iteration. The algorithm is implemented in a function called binarySearch, which takes an integer array a and an integer x as input"
". The function initializes three integer variables: half, first, and last. The variable first is initialized to 0, and last is initialized to the length of the array minus 1"
. The algorithm then enters a while loop that continues as long as the value of first is less than or equal to the value of last
". Inside the loop, the algorithm calculates the middle index of the search range by assigning the average of first and last to half. If the value at the middle index of the array is equal to the search value x, the index half is returned"
". Otherwise, if the value at the middle index is less than x, the search range is narrowed to the right half by updating first to half+1. Otherwise, the search range is narrowed to the left half by updating last to half-1"
". If the loop completes without finding the search value, the function returns -1."
"The example shows how the algorithm searches for a value in a sorted array. In the first iteration, the algorithm calculates the middle index as (0+10)/2 = 5"
". Since the value at index 5 is greater than the search value, the algorithm narrows the search range to the left half of the array, from index 0 to index 4."
"Exercise 1
•
Implement the method public static int
binarySearchString(String[] s, String x),which does a binary search of element x in the arrayof strings s. Use the method compareTo() of classString, which compares two strings lexicographically."
"• Given the array {""a"",""b"",""d"",""f"",""h"",""n"",""p"",""q"",""r"",""v"",""z""}how many iterations are needed to search “f”, “r” and “w”with binary search? And with linear search?"
"We are asked to implement a method called ""binarySearchString"" in a programming language like Java. This method takes two arguments: an array of strings ""s"" and a string ""x"""
". It should perform a binary search to find the string ""x"" within the sorted array ""s"". The method should use the ""compareTo"" method of the String class, which compares two strings lexicographically."
"The second part of the exercise asks us to determine the number of iterations required to search for the strings ""f"", ""r"", and ""w"" in the given array: ""{""a"", ""b"", ""d"", ""f"", ""h"", ""n"", ""p"", ""q"", ""r"", ""v"", ""z""} using both binary and linear search."
"Exercise 2
• Think about the differences between
implementing a linear search and a binary searchin a stack/queue, and in a binary search tree.
• How does it affect in each case the fact that the"
"• How does it affect in each case the fact that the
implementation of the data structure can be donewith arrays or with linked lists?"
"Think about the differences between implementing a linear search and a binary search in a stack or queue, and in a binary search tree"
. How does it affect in each case the fact that the implementation of the data structure can be done with arrays or with linked lists?
"Recursive binary search (linear tail recursion)
public static int binarySearchRecursive(int[] a, int x) {
return binarySearchRecursive(a, 0, a.length-1, x);
}
public static int binarySearchRecursive(int[] a, int first, int last, int x) {
int half;"
"int half;
if(first <= last) {
half = (first + last) / 2;
if(a[half]==x) {
return half;
}else if(a[half]<x){
return binarySearchRecursive(a, half+1, last, x);
}else if(a[half]>x){
return binarySearchRecursive(a, first, half-1, x);
}
}
return -1;
}"
"}
}
return -1;
}
public static int binarySearch(int a[], int x) {
int half;
int first = 0;
int last = a.length -1;
while (first <= last) {
half = (first + last)/2;
if(a[half] == x){
return half;
}else if(a[half] < x){
first = half+1;"
"return half;
}else if(a[half] < x){
first = half+1;
}else if(a[half] > x){
last = half-1;
}
}
return -1;
}"
"We see two implementations of the binary search algorithm. The first one is a recursive implementation, and the second one is an iterative implementation. Both implementations take as input an integer array ""a"" and an integer ""x"""
". The goal is to find the index of ""x"" in the array ""a"". If ""x"" is not found, both functions return -1."
"The recursive implementation uses a helper function that takes as input the array ""a"", the first index, the last index, and the integer ""x"". The helper function first checks if the first index is less than or equal to the last index. If not, it returns -1"
". If not, it returns -1. Otherwise, it calculates the middle index. If the middle element is equal to ""x"", it returns the middle index"
". If the middle element is less than ""x"", it recursively calls the helper function with the first index set to the middle index plus 1"
". If the middle element is greater than ""x"", it recursively calls the helper function with the last index set to the middle index minus 1."
"The iterative implementation uses a while loop that continues as long as the first index is less than or equal to the last index. Inside the loop, it calculates the middle index. If the middle element is equal to ""x"", it returns the middle index"
". If the middle element is less than ""x"", it sets the first index to the middle index plus 1. If the middle element is greater than ""x"", it sets the last index to the middle index minus 1. If the loop finishes without finding ""x"", it returns -1."
"Exercise 3
•
Implement the method public static int
binarySearchString(String[] s, String x),which does a binary search of element x in the arrayof String s recursively. Use the methodcompareTo() of class String, which compares twostrings lexicographically"
"Implement the method ""public static int binarySearchString(String() s, String x)"", which does a binary search of element x in the array of String s recursively. Use the method ""compareTo()"" of class String, which compares two strings lexicographically."
"Conclusions
• For smaller sizes (e.g., N<6)
o It is not worthy using binary search since it uses approximately
the same number of comparisons as a linear search
• Last iterations in a binary search are slower
• A hybrid approach could be interesting"
"• A hybrid approach could be interesting
o We apply binary search until the range is small
o Then, we apply linear search"
"- For smaller sizes, for example, N smaller than 6, it is not worthy using binary search since it uses approximately the same number of comparisons as a linear search.
- Last iterations in a binary search are slower."
"- Last iterations in a binary search are slower.
- A hybrid approach could be interesting: we apply binary search until the range is small, then we apply linear search."
"Basic sorting algorithms
• Why are they important?
• Bubble Sort
• Selection Sort
•
Insertion Sort

- Why are they important?
- Bubble Sort
- Selection Sort
- Insertion Sort"
"Why are the important?
• Binary search takes advantage of the order
• Sorted data structures makes searching easier
(e.g., telephone book, dictionary…)
• Order facilitates searching"
"- Binary search takes advantage of the order
- Sorted data structures makes searching easier (e.g., telephone book, dictionary...)
- Order facilitates searching"
"Bubble Sort
• The algorithm moves forward through the data structure
swapping pairs of contiguous elements which are not in thecorrect order.
o
If we sort from the lowest to the highest, the highest elementmoves to the end (as it was a bubble)."
"• These passes are repeated until no more swapping is
needed.
• Elements which advanced to their correct position do notneed to be checked again. Each pass needs to check oneless element.
http://www.cs.armstrong.edu/liang/animation/web/BubbleSort.html"
"http://www.cs.armstrong.edu/liang/animation/web/BubbleSort.html
http://www.algostructure.com/sorting/bubblesort.php"
"The algorithm moves forward through the data structure swapping pairs of contiguous elements which are not in the correct order. If we sort from the lowest to the highest, the highest element moves to the end, as it was a bubble"
. These passes are repeated until no more swapping is needed. Elements which advanced to their correct position do not need to be checked again. Each pass needs to check one less element.There are two URLs at the bottom of the slide
.There are two URLs at the bottom of the slide. The first one is: http://www.cs.armstrong.edu/liang/animation/web/BubbleSort.html and the second one is: http://www.algostructure.com/sorting/bubblesort.php.
"Bubble Sort. Example (I)
• Ascending order (from the lowest to the highest)
 95 14 98 29 49 66
q Two loops: internal and external
 14 95 98 29 49 66
q External loop: first iteration
q Internal loop from 0 to length-1 (6 in
 14 95 29 98 49 66"
"q Internal loop from 0 to length-1 (6 in
 14 95 29 98 49 66
 14 95 29 49 98 66
 14 95 29 49 66 98
this example)
v Swapping if element in position j ishigher than element in position j+1
v Ends with 1 element in its correct
position
 80 95 29 49 66 98"
"position
 80 95 29 49 66 98
 80 29 95 49 66 98
 80 29 49 95 66 98
 80 29 49 66 95 98
q External loop: second iteration
q Internal loop from 0 to length-2 (5 in
the example)
v Swapping if element in position j ishigher than element in position j+1"
"v Ends with 2 elements in their correct
position"
"We are looking at an example of a bubble sort algorithm, with the goal of sorting numbers in ascending order, from the lowest to the highest.
The algorithm uses two loops: an internal loop and an external loop."
"The first part of the process shows the first iteration of the external loop, where the internal loop goes from 0 to length-1, which is 6 in this example."
"The algorithm works by swapping elements if the element in position J is higher than the element in position J+1.
This iteration ends with 1 element in its correct position: the highest number, 98, is now at the very end of the list."
"The image then shows the second iteration of the external loop, where the internal loop goes from 0 to length-2, which is 5 in this example.
Again, elements are swapped if the element in position J is higher than the element in position J+1."
"This iteration ends with 2 elements in their correct positions: 95 and 98.
The values in the list are: 80, 95, 14, 98, 29, 49, and 66."
"The values in the list are: 80, 95, 14, 98, 29, 49, and 66.
Each line shows the state of the list as the algorithm iterates through it, with arrows indicating which numbers are being compared and swapped."
"The final state of the list after these two iterations is: 14, 80, 29, 49, 66, 95, 98."
"Bubble Sort. Example (II)
• Ascending order (from the lowest to the highest)
 80 29 49 66 95 98
 29 80 49 66 95 98
 29 49 80 66 95 98
 29 49 66 80 95 98
q External loop: third iteration
q Internal loop from 0 to length-3 (4 in
the example)
v …"
"q Internal loop from 0 to length-3 (4 in
the example)
v …
v 3 elements in the correct position
 29 49 66 80 95 98
 29 49 66 80 95 98
q External: fourth iteration.q Internal: from 0 to length-4
q External: fifth iteration.q Internal: from 0 to length-5"
"q External: fifth iteration.q Internal: from 0 to length-5
 29 49 66 80 95 98
q External: sixth iteration.q Internal: from 0 to length-6
v In the example with six iterations ofthe external loop all the elements arein their correct position"
"The image shows an example of a bubble sort algorithm in ascending order, from the lowest to the highest value. The initial array is: 14, 80, 29, 49, 66, 95, 98."
"The algorithm iterates through the array multiple times. In each iteration, it compares adjacent elements and swaps them if they are in the wrong order"
". The largest element in the unsorted part of the array ""bubbles"" up to its correct position at the end of each iteration."
"The image shows seven steps of the algorithm, each step representing an iteration. The numbers being compared are highlighted with a blue arrow. The numbers already in their correct position are shown in red."
"The first iteration compares and swaps the first two elements (14 and 80), then the second and third (80 and 29), and so on. After the first iteration, the largest number, 98, is in its correct position at the end of the array."
"The algorithm continues iterating, and with each iteration, one more element reaches its correct position. The internal loop iterates from 0 to length-n, where n is the iteration number"
". For example, in the third iteration, the internal loop iterates from 0 to length-3, which is 4 in this example."
"The image also shows that after three iterations, three elements (80, 95, and 98) are in their correct positions. After six iterations, all the elements are in their correct positions, and the array is sorted."
"Bubble Sort. Two loops
• External loop:
o Number of iterations: length of array - 1 (in each iteration one element is
sorted, except for the last one in which two elements are sorted)
•
Range of the index in the external loop [0, length of array – 1)
•"
"•
Internal loop:
o
o
o
In the first iteration of the external (i=0), length of array - 1 iterations
In the second iteration of the external (i=1), length of array - 2 iterations"
"In the m-th iteration of the external (i=m-1), length of array - i - 1 iterat.
•
Range of the index in the internal loop [0,  length of array - 1 - i)
• After m-th iteration (i=m-1) of the external loop:"
"• After m-th iteration (i=m-1) of the external loop:
o Elements from 0 to length of array - 2 - i are unsorted
o Elements from length of array - 1 - i to length of array - 1 are sorted"
"Bubble Sort. Code
public static void bubbleSort (int[] a) {
for (int i=0; i<a.length-1; i++) {
for (int j=0; j<a.length-1-i; j++) {
if (a[j]>a[j+1]){
swap(a, j, j+1);
}
}
}
}
q Alternative:"
"if (a[j]>a[j+1]){
swap(a, j, j+1);
}
}
}
}
q Alternative:
v External loop from 1 to a.length and   Internal loop from 0 to a.length-i
v Descending order a[j]<a[j+1]
public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
"The image shows code for a bubble sort algorithm in Java. The first function is called ""bubble sort"" and takes an integer array as input. It has two for loops. The outer loop iterates from 0 to the length of the array minus 1"
". The inner loop iterates from 0 to the length of the array minus 1 minus the outer loop index. Inside the inner loop, there is an if statement that checks if the element at index j is greater than the element at index j plus 1"
". If it is, the swap function is called with the array, j, and j plus 1 as parameters."
"The second function is called ""swap"" and takes an integer array and two integers, i and j, as input. It swaps the elements at indices i and j in the array"
". It swaps the elements at indices i and j in the array. It first assigns the value at index i to a variable called aux, then assigns the value at index j to index i, and finally assigns the value of aux to index j."
There is also a red text note that provides an alternative implementation of the algorithm. The alternative implementation uses an external loop from 1 to the length of the array and an internal loop from 0 to the length of the array minus i
. It also sorts the array in descending order by checking if the element at index j is less than the element at index j plus 1.
"Bubble Sort. Conclusions
• Advantages:
o Little additional memory is needed
o
o Efficient for arrays with few elements
Few lines of code
• Drawbacks:
o
Inefficient for arrays with many elements"
"• Drawbacks:
o
Inefficient for arrays with many elements
v O(n2) => quadratic order (two nested loops for an array of n elements)
v For a given array there are always the same number of iterations (even though"
"it is already sorted), even though there are no swaps
v Too many swaps"
"v Too many swaps
o Larger elements move faster to the end (they can reach the end in oneiteration of the external loop), but lower elements move slower to thebeginning (they gain one position per iteration)"
"v Improvement: Cocktail sort (double internal loop to pass from left to right23
and from right to left in each iteration of the external loop)"
"Exercise 4
• Using the sorting algorithm Bubble Sort, how
many swaps are needed to sort the following arrayfrom the highest element to the lowest element(descending order)?
{1,3,5,7,11,13}"
"We are asked to calculate how many swaps are needed to sort an array from highest to lowest using the bubble sort algorithm. The array is 1, 3, 5, 7, 11, 13."
"Selection Sort
•
•
o
o
In ascending order
o
o
Searches the minimum element and puts it in the first position (swap)
Searches the next minimum element and puts it in the second position(swap)"
"In general, searches the minimum element between i and the end of thedata structure and puts in the i-th position through swapping
In descending order
o
o
Searches the maximum element and puts it in the first position (swap)"
"Searches the next maximum element and puts it in the second position(swap)
In general, searches the maximum element between i and the end of thedata structure and puts in the i-th position through swapping"
"http://www.cs.armstrong.edu/liang/animation/web/SelectionSort.html
http://www.algostructure.com/sorting/selectionsort.php"
"The image describes the selection sort algorithm.
It can be implemented in ascending or descending order."
"In ascending order, the algorithm searches for the minimum element and puts it in the first position by swapping it with the element currently in that position"
". Then it searches for the next minimum element and puts it in the second position, also by swapping"
". In general, the algorithm searches for the minimum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping."
"In descending order, the algorithm searches for the maximum element and puts it in the first position by swapping it with the element currently in that position"
". Then it searches for the next maximum element and puts it in the second position, also by swapping"
". In general, the algorithm searches for the maximum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping."
"Selection Sort. Example (I)
• Ascending order (from the lowest to the highest)
 95 14 98 29 49 66 q Two loops: internal and external
 is the minimum unsorted element: swapping with element in position 0
 95 14 98 29 49 66
 95 80 98 29 49 66"
"95 14 98 29 49 66
 95 80 98 29 49 66
 is the minimum unsorted element: swapping with element in position 1
 95 80 98 29 49 66
 29 80 98 95 49 66
 is the minimum unsorted element: swapping with element in position 2
 29 80 98 95 49 66
 29 49 98 95 80 66"
"29 80 98 95 49 66
 29 49 98 95 80 66
q External loop: sorts the first position.
As part of this loop there is a swappingbetween the element in position i andthe minimum unsorted element
q Internal loop: searches the minimum"
"q Internal loop: searches the minimum
element from position i until the end ofthe data structure"
The image describes the ascending selection sort algorithm. The algorithm uses two loops: an external loop and an internal loop. The external loop sorts the first position of the data structure
". As part of this loop, there is a swapping between the element in position i and the minimum unsorted element. The internal loop searches the minimum element from position i until the end of the data structure."
"The image shows an example of the algorithm with the following data structure: 80, 95, 14, 98, 29, 49, 66. The algorithm starts by finding the minimum element in the data structure, which is 14"
". The element 14 is then swapped with the element in the first position, which is 80. The data structure is now: 14, 95, 80, 98, 29, 49, 66. The algorithm then finds the minimum element in the remaining unsorted part of the data structure, which is 29"
". The element 29 is then swapped with the element in the second position, which is 95. The data structure is now: 14, 29, 80, 98, 95, 49, 66. The algorithm continues in this way until the entire data structure is sorted."
"Selection Sort. Example (II)
• Ascending order (from the lowest to the highest)
 is the minimum unsorted element: swapping with element in position 3
 29 49 98 95 80 66
 29 49 66 95 80 98"
"29 49 98 95 80 66
 29 49 66 95 80 98
 is the minimum unsorted element: swapping with element in position 4
 29 49 66 95 80 90
 29 49 66 80 95 98
 is the minimum unsorted element. It is in the correct position. No swapping.
 29 49 66 80 95 98"
"29 49 66 80 95 98
 is the minimum unsorted element. It is in the correct position. No swapping.
 29 49 66 80 95 98"
"The image describes the ascending selection sort algorithm with an example. The input is a list of the following numbers: 14, 29, 49, 98, 95, 80, 66."
"The algorithm iterates over the list, and for each iteration, it identifies the minimum element in the unsorted sublist and swaps it with the element at the current position."
"The first iteration starts by considering the whole list as unsorted. The minimum element is 66, which is in the 7th position. The algorithm swaps the element in the first position (14) with the element in the 7th position (66)"
". The list becomes: 66, 29, 49, 98, 95, 80, 14."
"The second iteration starts considering the sublist from the second position. The minimum element is 80, which is in the 6th position. The algorithm swaps the element in the second position (29) with the element in the 6th position (80)"
". The list becomes: 66, 80, 49, 98, 95, 29, 14."
"The third iteration starts considering the sublist from the third position. The minimum element is 80, which is in the second position. Since the minimum element is already in the correct position, no swap is performed"
". The list remains: 66, 80, 49, 98, 95, 29, 14."
"The fourth iteration starts considering the sublist from the fourth position. The minimum element is 14, which is in the 7th position. The algorithm swaps the element in the fourth position (98) with the element in the 7th position (14)"
". The list becomes: 66, 80, 49, 14, 95, 29, 98."
"The fifth iteration starts considering the sublist from the fifth position. The minimum element is 29, which is in the 6th position. The algorithm swaps the element in the fifth position (95) with the element in the 6th position (29)"
". The list becomes: 66, 80, 49, 14, 29, 95, 98."
"The sixth iteration starts considering the sublist from the sixth position. The minimum element is 95, which is in the sixth position. Since the minimum element is already in the correct position, no swap is performed"
". The list remains: 66, 80, 49, 14, 29, 95, 98."
"The seventh iteration starts considering the sublist from the seventh position. The minimum element is 98, which is in the seventh position. Since the minimum element is already in the correct position, no swap is performed"
". The list remains: 66, 80, 49, 14, 29, 95, 98."
"The final sorted list is: 14, 29, 49, 66, 80, 95, 98."
"Selection Sort. Two loops
• External loop:
o Number of iterations: length of array (in each iteration one element is
sorted, although the last iteration is not strictly needed)
•
Range of the index in the external loop [0, length of array - 1]
•"
"•
Internal loop (searching the minimum / maximum):
o
o
o
In the first iteration of the external loop (i=0), length of array - 1 iterat.
In the second iteration of the external loop (i=1), length of array - 2 iterat."
"In the m-th iteration of the external loop (i=m-1), length of array - i iterat.
•
Range of the index in the internal loop [i, length of array - 1]
• After m-th iteration (i=m-1) of the external loop :
o Elements from 0 to i are sorted"
"o Elements from 0 to i are sorted
o Elements from i+1 to length of array - 1 are unsorted"
"Selection Sort. Code
public static void selectionSort (int[] a) {
for (int i=0; i<a.length; i++) {
int m = i;
for (int j=i; j<a.length; j++) {
if (a[j]<a[m]){
m = j;
q Alternative:
}
}
swap(a, i, m);
}
}
v External loop to a.length - 1"
"}
}
swap(a, i, m);
}
}
v External loop to a.length - 1
v Internal loop from j+1 to a.length saves one
unnecessary comparison
v Descending order a[j]>a[m]
v Avoid unnecessary swaps adding if(i!=m)
before swap(a,i,m)"
"v Avoid unnecessary swaps adding if(i!=m)
before swap(a,i,m)
public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
We see the code for a selection sort algorithm in Java. The first function *selectionSort* takes an integer array as input. It iterates through the array with two nested for loops
". It iterates through the array with two nested for loops. The outer loop iterates through each element of the array, while the inner loop iterates through the remaining unsorted subarray to find the minimum element"
". The index of the minimum element is stored in the variable *m*. After the inner loop completes, the function swaps the element at index *i* with the element at index *m*."
The second function *swap* takes an integer array and two integer indices as input. It swaps the elements at the given indices using an auxiliary variable *aux*.
There are some alternative implementations for this algorithm listed on the slide. The external loop could iterate up to the second to last element of the array
". The internal loop could iterate from *j+1* to the end of the array, which would save one unnecessary comparison. The algorithm could be modified to sort in descending order by changing the comparison in the if statement to *a[j] > a[m]*"
". Finally, unnecessary swaps could be avoided by adding a condition to the swap function to only swap if *i* is not equal to *m*."
"Selection Sort. Conclusions
• Advantages:
o Little additional memory is needed
o
o Efficient for arrays with few elements
Few lines of code
• Drawbacks:
o
Inefficient for arrays with many elements"
"• Drawbacks:
o
Inefficient for arrays with many elements
v O(n2) => quadratic order (two nested loops for an array of n elements)
v For a given array there are always the same number of iterations (even though"
"it is already sorted), even though there are no swaps
ü But much less swaps than with Bubble Sort
• Variant:
o
Placing the maximum/minimum at the end, instead of placing themaximum/minimum at the beginning"
"Exercise 5
• Using the sorting algorithm Selection Sort, how"
"many swaps are needed to sort the following arrayfrom the highest element to the lowest element(descending order)? Use the algorithm we saw inthe class, which swaps the maximum with the firstunsorted element.
{1,3,5,7,11,13}"
"We are asked to calculate how many swaps are needed to sort the array {1, 3, 5, 7, 11, 13} from highest to lowest element using the Selection Sort algorithm. The algorithm should swap the maximum with the first unsorted element."
"Insertion Sort
• The data structure is divided in two parts:
the first part (e.g., left side) is already sorted,
the second part (e.g., right side) is unsorted.
o
o
o At the beginning the first part is empty and the second part full"
"• We extract the first element of the second part, inserting it in
its correct position in the first part (sorted)
• This step is repeated until all the elements are (sorted) in the
first part."
"first part.
http://www.cs.armstrong.edu/liang/animation/web/InsertionSort.html
http://www.algostructure.com/sorting/insertionsort.php"
"The data structure is divided into two parts: the first part is already sorted and the second part is unsorted. At the beginning, the first part is empty and the second part is full"
". We extract the first element of the second part, inserting it in its correct position in the first part. This step is repeated until all the elements are sorted in the first part."
"The first diagram shows the sorted partial result on the left, with elements less than x, then elements greater than x. The first element of the unsorted data, x, is about to be inserted into the sorted partial result"
. The second diagram shows the result after the insertion. The element x has been inserted into the correct position in the sorted partial result.
"Insertion Sort. Example (I)
• Ascending order (from the lowest to the highest)
 95 14 98 29 49 66
q Two loops: internal and external
We take 80 from the unsorted part and insert it in its correct position in the sorted part
 95 14 98 29 49 66"
"95 14 98 29 49 66
 95 14 98 29 49 66
We take 95 from the unsorted part and insert it in its correct position in the sorted part.
 95 14 98 29 49 66
 95 14 98 29 49 66"
"95 14 98 29 49 66
 95 14 98 29 49 66
We take 14 from the unsorted part and insert it in its correct position in the sorted part.
Additionally, 80 and 95 are moved one position to the right to fill the gap left by 14
 95 14 98 29 49 66
 80 95 98 29 49 66"
"95 14 98 29 49 66
 80 95 98 29 49 66
q External loop: it traverses"
"the array, leaving sortedwhat is behind position i"
. Aspart of the external loop theelement to be sorted ismoved to its right positionq Internal loop: it moves oneposition to the right all theelements that are locatedbetween where the newsorted element is insertedand the position it left in theunsorted
element is insertedand the position it left in theunsorted part of the array(now that position is sorted)
"The image describes the Insertion Sort algorithm with an example.
The algorithm sorts an array of numbers in ascending order, from the lowest to the highest."
"The example shows the different steps of the algorithm, starting with the unsorted array: 80 95 14 98 29 49 66
The algorithm uses two loops: an external loop and an internal loop."
"The external loop traverses the array, leaving sorted what is behind position i. As part of the external loop, the element to be sorted is moved to its right position."
The internal loop moves one position to the right all the elements that are located between where the new sorted element is inserted and the position it left in the unsorted part of the array (now that position is sorted).
The example shows how the algorithm works by moving the elements of the array to their correct position in each step.
"For example, in the first step, the algorithm takes the element 80 from the unsorted part and inserts it in its correct position in the sorted part."
"In the second step, the algorithm takes the element 95 from the unsorted part and inserts it in its correct position in the sorted part.
The algorithm continues in this way until the entire array is sorted."
"Insertion Sort. Example (II)
• Ascending order (from the lowest to the highest)
We take 98 from the unsorted part and insert it in its correct position in the sorted part
 80 95 98 29 49 66
 80 95 98 29 49 66"
"80 95 98 29 49 66
 80 95 98 29 49 66
We take 29 from the unsorted part and insert it in its correct position in the sorted part.
Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 29
 80 95 98 29 49 66"
"80 95 98 29 49 66
 29 80 95 98 49 66"
"The image illustrates the insertion sort algorithm, specifically focusing on arranging numbers in ascending order."
"Initially, we have the sequence: 14, 80, 95, 98, 29, 49, and 66. The algorithm proceeds by progressively building a sorted sub-sequence on the left."
"First, the number 98 is selected. Since it's already in its correct position relative to the preceding element (95), no changes are made."
"Next, the number 29 is considered. To place it correctly, 80, 95, and 98 are shifted one position to the right, creating space for 29 to occupy the second position in the sequence. This results in the updated sequence: 14, 29, 80, 95, 98, 49, and 66."
"Insertion Sort. Example (III)
• Ascending order (from the lowest to the highest)
We take 49 from the unsorted part and insert it in its correct position in the sorted part."
"Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49
 29 80 95 98 49 66
 29 49 80 95 98 66
We take 66 from the unsorted part and insert it in its correct position in the sorted part."
"Additionally, 80, 95 and 96 are moved one position to the right to fill the gap left by 66
 29 49 80 95 98 66
 29 49 66 80 95 98"
"We are looking at an example of insertion sort in ascending order, from the lowest to the highest number."
"The first step shows the numbers 14, 29, 80, 95, 98, 49 and 66. The algorithm takes the number 49 from the unsorted part and inserts it in its correct position in the sorted part"
". Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49. The resulting sequence is 14, 29, 49, 80, 95, 98 and 66."
"The second step takes the number 66 from the unsorted part and inserts it in its correct position in the sorted part. Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 66"
". The resulting sequence is 14, 29, 49, 66, 80, 95 and 98."
"Insertion Sort. Two loops
• External loop:
o Number of iterations: length of array (in each iteration one element is
sorted, including in the last iteration)
•
Range of the index in the external loop [0, length of array - 1]
•"
"•
Internal loop (finding the correct position to insert):
o The number of iterations depends on the position “advanced” by the
o
element which is inserted"
"o
element which is inserted
If the element inserted moves k positions to the left, then there are kelements that are moved one position to the right
• After m-th iteration (i=m-1) of the external loop:
o Elements from 0 to i are sorted"
"o Elements from 0 to i are sorted
o Elements from i+1 to length of array - 1 are unsorted"
"Insertion Sort. Code
public static void insertionSort (int[] a){
for (int i=0; i<a.length; i++){
int tmp=a[i];
int j=i;
while (j>0 && tmp<a[j-1]){
a[j]=a[j-1];
j--;
}
a[j]=tmp;
}
}
q Alternative:"
"a[j]=a[j-1];
j--;
}
a[j]=tmp;
}
}
q Alternative:
v External loop from i=1, since the firstelement always stays in the sameposition
v Descending order tmp>a[j-1]"
"The image shows a code snippet for the Insertion Sort algorithm in Java.
The code defines a public static method called ""insertionSort"" that takes an integer array ""a"" as input."
"The algorithm iterates through the array ""a"" from the second element (index 1) to the last element. For each element at index ""i"", it stores the value in a temporary variable ""tmp"" and initializes an index ""j"" to ""i""."
"Then, it enters a while loop that continues as long as ""j"" is greater than 0 and the value of ""tmp"" is less than the element at index ""j-1"""
". Inside the loop, it shifts the element at index ""j-1"" one position to the right (to index ""j"") and decrements ""j"" by 1. This process creates a space for the element at ""tmp"" to be inserted in its correct sorted position."
"Once the while loop terminates, the element at ""tmp"" is inserted at index ""j""."
The code also provides an alternative implementation in a note. The note suggests that the external loop can start from index 1 instead of 0 because the first element is always in its correct sorted position
". It also mentions that the code can be modified to sort the array in descending order by changing the comparison in the while loop from ""tmp < a[j-1]"" to ""tmp > a[j-1]""."
"Insertion Sort. Code with auxiliary method
public static void insertionSort (int[] a) {
for (int i=0; i<a.length; i++) {
insert (a, i);
}
}
private static void insert (int[] a, int i) {
int tmp=a[i];
int j=i;
while (j>0 && tmp<a[j-1]){
a[j]=a[j-1];
j--;
}"
"int j=i;
while (j>0 && tmp<a[j-1]){
a[j]=a[j-1];
j--;
}
a[j]=tmp;
}
v Auxiliary method insert(int[a], int i),inserts the element at position i in theappropriate place of a, moving theneeded elements one position to the right"
"The image shows two code snippets of a Java implementation of the insertion sort algorithm using an auxiliary method. The first snippet shows the method signature of the main sorting function called ""insertionSort"""
". This method takes an integer array as input. Inside the method, there is a for loop that iterates over the input array and calls the auxiliary method ""insert"" for each element. The second snippet shows the method signature of the ""insert"" method"
. This method takes as input an integer array and an integer. The integer represents the index of the element to be inserted in its correct position
". The ""insert"" method iterates over the array from the given index down to the first element, shifting the elements to the right until it finds the correct position for the element to be inserted. Finally, the element is inserted in its correct position"
". Finally, the element is inserted in its correct position. There is also a comment explaining that the ""insert"" method inserts the element at the given position in the array, moving the needed elements one position to the right."
"Insertion Sort. Conclusions
• Advantages:
Few lines of code
o Little additional memory is needed
o
o Efficient for arrays with few elements
o More efficient than Selection Sort for (partially) sorted arrays"
"v For a given array there are always the same number of iterations in the external
loop (even though it is already sorted), but the internal loop is adaptable
• Drawbacks:
o
o
Inefficient for arrays with many elements"
"• Drawbacks:
o
o
Inefficient for arrays with many elements
v O(n2) => quadratic order (two nested loops for an array of n elements)
Inefficient when the array to sort in the reverse sorted order"
"Exercise 6
• Using the sorting algorithm Insertion Sort, how
many swaps are needed to sort the following arrayfrom the highest element to the lowest element(descending order)?
{1,3,5,7,11,13}"
"{1,3,5,7,11,13}
• Of the three algorithms seen so far, which was themost efficient one for this array? Try with otherarrays with different values and lengths"
"We are asked to determine how many swaps are needed to sort the array {1, 3, 5, 7, 11, 13} from highest to lowest using the Insertion Sort algorithm."
The second question asks us to compare the efficiency of the three sorting algorithms we have seen so far using this array and other arrays with different values and lengths.
"Advanced sorting algorithms
• Heap Sort
• Merge Sort
• Quick Sort

- Heap Sort
- Merge Sort
- Quick Sort"
"Heap Sort
Improved version of Selection Sort.
•
• Two steps:
(In ascending order from low to high)
o
o Build a heap
§
§
§
§
Binary tree, complete, key of the parent is higher than that of the children
Parent with index i
Left child with index 2*i +1"
"Parent with index i
Left child with index 2*i +1
Right child with index 2*i+2
o The highest element of the heap is removed (root) and is inserted at theend of the array. The heap must be updated after the removal of the root."
"https://www.cs.usfca.edu/~galles/visualization/HeapSort.html
http://www.algostructure.com/sorting/heapsort.php
http://www.cs.armstrong.edu/liang/animation/web/Heap.html"
Heap sort is an improved version of selection sort. It has two steps. The first step is to build a heap
". It has two steps. The first step is to build a heap. A heap is a binary tree that is complete, meaning that all levels of the tree are filled except for possibly the last level, which is filled from left to right"
". The key of the parent node is always higher than the keys of its children. The parent node has index i, the left child has index 2*i+1, and the right child has index 2*i+2"
". The second step is to repeatedly remove the highest element of the heap, which is always the root, and insert it at the end of the array. The heap must be updated after the removal of the root to maintain the heap property."
"Heap Sort. Example (I)
• Ascending order (from the lowest to the highest) (max-heap)
 95 14 98 29 49 66

q Build the heap from the array
q Root in position i (starting from 0)
q Left (child) node: 2*i + 1
q Right (child) node: 2*i + 2"
"The image shows an example of a heap sort algorithm. The goal is to sort the following numbers in ascending order: 80, 95, 14, 98, 29, 49, 66. The first step is to build a max-heap from the array"
". The first step is to build a max-heap from the array. The root of the heap is at position 0, which is 80 in this case. The left child of the root is at position 1, which is 95, and the right child is at position 2, which is 14"
". The left child of 95 is at position 3, which is 98, and the right child is at position 4, which is 29. The left child of 14 is at position 5, which is 49, and the right child is at position 6, which is 66"
".The heap is represented as a binary tree, with the root at the top. The numbers are shown inside circles, and the lines connecting the circles represent the parent-child relationships. The arrows indicate the direction of the sorting process"
". The arrows indicate the direction of the sorting process.The algorithm starts by comparing the root node with its children. If the root node is smaller than any of its children, it is swapped with the larger child"
. This process is repeated until the root node is larger than both of its children. The algorithm then moves to the next node in the array and repeats the process. This continues until the entire array is sorted
". This continues until the entire array is sorted.In this example, the first step is to compare 80 with its children, 95 and 14. Since 95 is larger than 80, they are swapped. The algorithm then moves to the next node, which is 95"
". The algorithm then moves to the next node, which is 95. 95 is compared with its children, 98 and 29. Since 98 is larger than 95, they are swapped. The algorithm then moves to the next node, which is 98"
". The algorithm then moves to the next node, which is 98. 98 is compared with its children, but since it is already the largest element in the array, no swaps are made. The algorithm continues in this manner until the entire array is sorted."
"Heap Sort. Example (II)
•
Step 1: Ordering the heap (root is higher than children)
•
Starting from the penultimate row to the right, check if the children is higher thanthe parent
Nodes go down to their corresponding position
Swapping 66 and 14"
"Swapping 66 and 14
Swapping 98 and 95
Swapping 98 and 80
Swapping 95 and 80
•
.
.
.
."
"95 66 80 29 49 14
-4"
"The image describes the first step of ordering a heap, where the root needs to be higher than the children.
Starting from the penultimate row to the right, we need to check if the children are higher than the parent."
"The nodes will go down to their corresponding position.
There is a visual representation of a binary tree with the values 80, 95, 14, 98, 29, 49 and 66.
The values are being swapped until the highest value, 98, becomes the root."
"The values are also represented in an array in the following order: 98, 95, 66, 80, 29, 49, 14."
"The swaps are visually indicated by arrows. The first swap is between 66 and 14, the second swap is between 98 and 95, the third swap is between 98 and 80 and the last swap is between 95 and 80."
"Heap Sort. Example (III)
•
Step 2: Extracting the root and reordering the heap
Taking 98 and placing it at the end (sorted). The root becomes 14.
.
Replacing 14 by the highest element of the array (95) and reordering the heap
."
"the second step of extracting the root and reordering the heap in a heap sort example. The first action is taking the root node with value 98 and placing it at the end of the array, which is the sorted section"
". The second action is replacing the root node with the highest element of the array, which is 95, and reordering the heap. Two diagrams illustrate the heap before and after the second step"
". The first diagram shows a binary tree representation of the heap before the second step. The root node is 14, and its children are 95 and 66. The left and right children of 95 are 80 and 29, respectively"
". The left and right children of 95 are 80 and 29, respectively. The left and right children of 66 are 49 and 98, respectively. The second diagram shows the binary tree representation of the heap after the second step"
". The root node is 95, and its children are 80 and 66. The left and right children of 80 are 14 and 29, respectively. The left and right children of 66 are 49 and 98, respectively. The array representation of the heap is shown above each diagram"
". The last element of each array, 98, is marked in red, indicating that it is already sorted."
"Heap Sort. Example (IV)
•
Step 2: Extracting the root and reordering the heap
Taking 95 and placing it at the end (sorted). The root becomes 49.
.
Replacing 49 by the highest element of the array (80) and reordering the heap
."
"The image illustrates step 2 of a heap sort algorithm, which involves extracting the root and reordering the heap."
"The first point explains that we will take the value 95 and place it at the end of the array, which is considered the sorted portion. The root of the heap then becomes 49."
"The second point explains that we will replace 49 with the highest element in the array, which is 80, and then reorder the heap."
"Two diagrams illustrate this process. Both diagrams represent the heap as a binary tree, with the root at the top. The left diagram shows the heap before the operation, and the right diagram shows the heap after the operation."
"In the left diagram, the root node is 95, and its children are 49 and 66. The left child of 49 is 80, and the right child of 49 is 29. The left child of 66 is 14, and the right child of 66 is 98."
"The first step is to extract the root node, which is 95. This is indicated by a red line separating 95 from the rest of the array: 49 80 66 14 29 | 95 98."
"The second step is to replace the root node with the highest element in the array, which is 80. This is indicated by a black arrow pointing from 80 to the root position."
"The third step is to reorder the heap. This is done by comparing the new root node, 80, with its children, 49 and 66. Since 80 is greater than both of its children, the heap is already in order."
"The right diagram shows the final state of the heap after step 2. The root node is now 80, and its children are 49 and 66. The left child of 49 is 14, and the right child of 49 is 29. The right child of 66 is 98."
The numbers 1 and 2 below the diagrams indicate the order in which the two heaps are shown.
"Heap Sort. Example (V)
•
Step 2: Extracting the root and reordering the heap
Taking 80 and placing it at the end (sorted). The root becomes 29.
.
Replacing 29 by the highest element of the array (66) and reordering the heap
."
The image describes step 2 of extracting the root and reordering the heap in a heap sort example.
"We start with an array with the following values: 29, 49, 66, 14, 80, 95, 98. The array is visualized as a binary tree. The root of the tree has the value 29, its left child has the value 49 and its right child has the value 66"
. The left and right children of 49 have the values 14 and 80 respectively. The left and right children of 66 have the values 95 and 98 respectively.
"The first step is to take the root of the tree, which has the value 80, and place it at the end of the array. The array now has the following values: 29, 49, 66, 14, 80, 95, 80. The root of the tree now has the value 29."
"The second step is to replace the root of the tree with the highest element of the array, which is 66. The array now has the following values: 66, 49, 29, 14, 80, 95, 80. The root of the tree now has the value 66"
. The root of the tree now has the value 66. The left child of the root is 49 and the right child is 29. The left and right children of 49 are 14 and 80 respectively. The left and right children of 29 are 95 and 80 respectively.
"Heap Sort. Example (VI)
•
Step 2: Extracting the root and reordering the heap
Taking 66 and placing it at the end (sorted). The root becomes 14.
.
Replacing 14 by the highest element of the array (49) and reordering the heap
."
"The image illustrates step 2 of a heap sort algorithm, extracting the root and reordering the heap. The process involves two steps: first, taking the root node with value 66 and placing it at the end of the array, which is the sorted portion"
". The root node now becomes 14. Second, replacing 14 with the highest element of the array, which is 49, and reordering the heap. The image shows two trees representing the heap before and after the reordering"
". The first tree has 14 as the root, with 49 as its left child and 29 as its right child. The second tree has 49 as the root, with 14 as its left child and 29 as its right child"
". The array representation of the heap is shown above each tree, with a vertical red line separating the sorted portion from the unsorted portion. The sorted portion is on the right side of the red line"
". The sorted portion is on the right side of the red line. The numbers in the array are the same as the values in the corresponding nodes of the tree. The number 1 is below the left tree and the number 2 is below the right tree, indicating the step number."
"Heap Sort. Example (VII)
•
Step 2: Extracting the root and reordering the heap
•
Taking 49 and placing it at the end (sorted). The root becomes 29.
•
Taking 29 and placing it at the end (sorted). The root becomes 14.
•
Taking 14. The heap is empty"
"•
Taking 14. The heap is empty
 29 49 66 80 95 98"
"The image illustrates step 2 of the heap sort algorithm, extracting the root and reordering the heap. The process involves three sub-steps:"
". **Taking 49 and placing it at the end (sorted). The root becomes 29.** This is depicted in the first array: 29 14 49 66 80 95 98. The number 49 is highlighted in red, indicating its removal from the heap and placement at the end of the array"
". The root node now contains the value 29, shown in a red circle with an arrow pointing to the new root, 14."
". **Taking 29 and placing it at the end (sorted). The root becomes 14.** The second array shows this step: 14 29 49 66 80 95 98. Similar to the previous step, 29 is highlighted in red, signifying its move to the sorted section"
". The root now holds the value 14, displayed in a red circle."
". **Taking 14. The heap is empty.** The final array illustrates the last step: 14 29 49 66 80 95 98. The number 14 is highlighted, indicating its removal, leaving an empty heap."
"Heap Sort. Two external loops
• External loop 1 (Step 1): Building the heap
For each node, checking that the children are smaller
o
o Number of iterations: half the length of the array
•
•"
"o
o Number of iterations: half the length of the array
•
•
Traversing all the nodes except for the leaves (they do not have children)
Range of the index of external loop 1 [0, length of array - 2)/2]"
"• External loop 2 (Step 2): Extracting the root and reordering
o The root is extracted, placed at the end of the data structure, and the heap is
reordered
o Number of iterations: length of array
•"
"reordered
o Number of iterations: length of array
•
Range of the index of external loop 2 [0, length of array - 1]
• After m-th iteration (i=m-1) of the external loop 2:
o Elements from 0 to length of array - 2 - i are unsorted"
"o Elements from 0 to length of array - 2 - i are unsorted
o Elements from length of array - 1 - i to length of array - 1 are sorted50
The image describes the Heap Sort algorithm, which uses two external loops."
"The first loop builds the heap. For each node, the algorithm checks that the children are smaller than the parent node. This loop iterates over half the length of the array, traversing all the nodes except for the leaves, which do not have children"
. The range of the index of this external loop is from 0 to (length of the array - 2) / 2.
"The second loop extracts the root and reorders the heap. The root is extracted and placed at the end of the data structure, and the heap is reordered. This loop iterates over the length of the array"
. This loop iterates over the length of the array. The range of the index of this external loop is from 0 to length of the array - 1.
"After m-th iteration (i=m-1) of the external loop 2:
- Elements from 0 to length of array - 2 - i are unsorted.
- Elements from length of array - 1 - i to length of array - 1 are sorted."
"Heap Sort. Code
public static void heapSort(int[] a) {
for (int i=(a.length-2)/2; i>=0; i--)
heapify(a,i,a.length-1);
for (int i=a.length-1; i>=0; i--) {
swap(a,0,i);
heapify(a,0,i-1);
}
}
public static void swap (int[] a, int i, int j) {
int aux=a[i];"
"public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
The image shows a code snippet for the Heap Sort algorithm in an unknown programming language.
The first function `heapSort` takes an integer array `a` as input. It first builds a max heap from the input array by calling the `heapify` function repeatedly on the first half of the array
". Then, it iterates through the array from the last element to the second element, swapping the first element (the maximum element) with the current element, and then calling `heapify` on the remaining heap (excluding the last element"
", which is now in its sorted position)"
.
The second function `swap` takes an integer array `a` and two integer indices `i` and `j` as input. It swaps the elements at indices `i` and `j` in the array using an auxiliary variable `aux`.
"Heap Sort. Code (II)
private static void heapify(int[] a, int i, int m) {
int j;
while(2*i+1<=m) {
j=2*i+1;
if(j<m) {
i is the index of the parent
•
• m is the index of the last unsorted node of the heap
•
j is the index of the left child (if any)"
"•
j is the index of the left child (if any)
if(a[j]<a[j+1])
j++;
}
if(a[i]<a[j]) {
swap(a,i,j);
i=j;
} else
i=m;
• Getting the index of the child with highest value
•"
"i=m;
• Getting the index of the child with highest value
•
If the child’s value is higher than that of theparent, then we need to swap, and then checkagain with its new children
• Otherwise we are done
}
}"
"The image shows a code snippet of a private static void heapify function written in Java. The function takes as input an integer array a, an integer i and an integer m. The function iterates over the array a from index i to m"
". The function iterates over the array a from index i to m. For each index i, the function checks if the value at index i is smaller than the value at index j, where j is the index of the child with the highest value"
". If the value at index i is smaller than the value at index j, the function swaps the values at indices i and j. The function then sets i to j and continues iterating"
". The function then sets i to j and continues iterating. If the value at index i is not smaller than the value at index j, the function sets i to m and exits the loop"
".The comments on the right side of the code snippet explain the meaning of the variables i, m and j. The variable i is the index of the parent, m is the index of the last unsorted node of the heap and j is the index of the left child"
". The comments also explain that the code snippet is getting the index of the child with the highest value and that if the child's value is higher than that of the parent, then we need to swap and then check again with its new children"
". Otherwise, we are done."
"Heap Sort. Conclusions
• Advantages:
o Efficient for arrays with many elements, even in the
worse case
v O(n log n)
o Little additional memory is needed
• Drawbacks:
o Complex code"
"Exercise 7
• Using the sorting algorithm Heap Sort, how manyswaps are needed to sort the following array fromthe lowest element to the highest element(ascending order)?
{7,3,13,1,11,5}"
"We are asked to calculate how many swaps are needed to sort an array using the Heap Sort algorithm. The array to be sorted is 7, 3, 13, 1, 11, 5. The sorting should result in ascending order."
"Merge Sort
. Divide the array in two subarraysof approximately the same length(half the original array)
. Divide each subarray recursivelyuntil we have subarrays of length1, in which case that array isreturned
. Merge the two subarrays in a"
". Merge the two subarrays in a
new sorted subarray recursively
http://www.algostructure.com/sorting/mergesort.php
http://www.cs.armstrong.edu/liang/animation/web/MergeList.html"
"The image describes the  algorithm.
The algorithm consists of 3 steps:
. Divide the array in two subarrays of approximately the same length (half the original array)"
". Divide each subarray recursively until we have subarrays of length 1, in which case that array is returned
. Merge the two subarrays in a new sorted subarray recursively"
". Merge the two subarrays in a new sorted subarray recursively
The diagram shows an example of the algorithm with an array of 10 numbers: 38, 27, 43, 3, 9, 82, 10."
"The first step is to divide the array in two subarrays of 5 numbers each: 38, 27, 43, 3, 9 and 82, 10.
The second step is to divide each subarray recursively until we have subarrays of length 1."
"The third step is to merge the two subarrays in a new sorted subarray recursively.
The final sorted array is: 3, 9, 10, 27, 38, 43, 82."
"Merge Sort. Example (I)
• Ascending order (from the lowest to the highest)
 95 14 98 29 49 66
 95 14 98
 49 66
 95
 98
 49"
"This example shows the steps to sort the following list of numbers in ascending order using the Merge Sort algorithm: 80, 95, 14, 98, 29, 49, 66."
"The algorithm recursively divides the list into sub-lists until each sub-list contains a single element. Then, it repeatedly merges the sub-lists to produce new sorted sub-lists until there is only one sorted list remaining."
The steps are illustrated in a tree diagram where each node represents a sub-list and the arrows indicate the merging process.
"Merge Sort. Example (II)






 95
 98
 49


 80 95 98
 49 66
 29 49 66 80 95 98"
"The image shows a diagram illustrating the merge sort algorithm. The input is a list of numbers: 80, 95, 14, 98, 29, 49, 66."
"The diagram depicts the steps of the merge sort algorithm. First, the list is divided into sub-lists until each sub-list contains only one element. Then, the sub-lists are merged pairwise, sorting the elements during the merge operation"
. This process is repeated recursively until the entire list is sorted.
"The diagram visually represents the merging process with arrows connecting the sub-lists being merged. The final sorted list is: 14, 29, 49, 66, 80, 95, 98."
"Merge Sort. Recursive division andmerging with auxiliary array
•
•
Step 1: Recursive division
o Given an array (or part of it) with l the first position, r the last position and
m the half position ((l+r)/2)"
"m the half position ((l+r)/2)
o Divide the array recursively in two until l and r are equal
•
•
From l to m
From m+1 to r
Step 2: Sorting by merging subarrays
o Create an auxiliary array containing the two subarrays to sort"
"o Compare the elements to sort of each subarray
• Elements are not in their final correct position until we finish
merging subarray"
"Merge Sort. Code (I)
public static void mergeSort (int[] a) {
mSort(a, 0, a.length-1);
}
public static void mSort (int[] a, int l, int r) {
if (l>=r){
return;
}
int m = (l+r)/2;
mSort(a, l, m);
mSort(a, m+1, r);
merge(a, l, m, r);
}"
"We see two code snippets. The first one is a function definition for merge sort that takes an integer array a as an argument. It calls the mSort function with the array, 0, and the length of the array minus 1"
". The second snippet is a function definition for mSort that takes an integer array a, an integer l, and an integer r as arguments. It checks if l is greater than or equal to r. If so, it returns"
". If so, it returns. Otherwise, it calculates an integer m as the average of l and r. It then calls mSort with the array, l, and m, and then calls mSort again with the array, m plus 1, and r. Finally, it calls the merge function with the array, l, m, and r"
.
"Merge Sort. Code (II). Merging (Option 1)
public static void merge (int[] a, int l, int m, int r){
if (m+1>r){ return; }
int[] b = new int[a.length];
for (int i=l; i<m+1; i++) {
Option 1:
• The left subarray is copied as it is in the auxiliary
b[i] = a[i];"
"b[i] = a[i];
array
}
for (int i=m+1; i<r+1; i++){
b[i] = a[r+m+1-i];
}
int k=l;
int j=r;
for (int i=l; i<r+1; i++) {
if (b[k] <= b[j]){
a[i] = b[k];
k++;
} else {
a[i] = b[j];
j--;
}
}
}
• The right subarray is copied in the auxiliary array"
"}
}
}
• The right subarray is copied in the auxiliary array
in reverse order
• The merging starts from the two ends of the
auxiliary array, which contain the elements withthe lowest values of each subarray"
The image shows a code snippet for the merge function used in the merge sort algorithm. This particular implementation uses Option 1 for merging.
"The code first checks if the starting index of the second sub-array (m+1) is greater than the ending index of the second sub-array (r). If it is, the function returns, as this indicates that the sub-arrays are already sorted."
"If not, a new array 'b' is created with the same size as the input array 'a'. The first loop iterates through the left sub-array (from index 'l' to 'm') and copies its elements to the auxiliary array 'b'."
The second loop iterates through the right sub-array (from index 'm+1' to 'r') in reverse order and copies its elements to the auxiliary array 'b'. This reverse order copying is specific to Option 1.
"Two index variables, 'k' and 'j', are initialized to point to the beginning and end of the auxiliary array 'b' respectively. The final loop iterates through the merged array 'a' and compares the elements at indices 'k' and 'j' in the auxiliary array 'b'"
". The smaller element is copied to the merged array 'a', and the corresponding index ('k' or 'j') is incremented or decremented accordingly."
This process continues until all elements from both sub-arrays are placed in the merged array 'a' in sorted order. The three bullet points on the right side of the image provide a textual description of the code's functionality
". They explain that the left sub-array is copied as is, the right sub-array is copied in reverse order, and the merging process starts from the two ends of the auxiliary array, comparing and placing the smallest elements first."
"Merge Sort. Code (III). Merging (Option 2)
public static void merge (int[] a, int l, int m, int r){
if (m+1>r){ return; }
int[] b = new int[a.length];
for (int i=l; i<r+1; i++) {
b[i] = a[i];
}
int k=l;
int j=m+1;
int i=l;
while(k<m+1 && j<r+1){"
"}
int k=l;
int j=m+1;
int i=l;
while(k<m+1 && j<r+1){
if (b[k] <= b[j]){
a[i] = b[k];
k++;
} else {
a[i] = b[j];
j++;
}
i++;
}
while(k<m+1) {
a[i] = b[k];
k++;i++;
}
while (j<r+1) {
a[i] = b[j];
j++;i++;
}
}
Option 2:"
"k++;i++;
}
while (j<r+1) {
a[i] = b[j];
j++;i++;
}
}
Option 2:
• The two subarrays are copied as they are in
the auxiliary array
• The elements to merge are compared starting
from the left side of each subarray"
"from the left side of each subarray
• The last elements of the left subarray, whichmay have not been merged yet, are added
• The last elements of the right subarray, whichmay have not been merged yet, are added"
"the code for the merging step of the merge sort algorithm, specifically option 2."
"The code is a function called ""merge"" that takes as input an array of integers ""a"", and three integers: ""l"", ""m"", and ""r"". The function first checks if m+1 is greater than r. If it is, the function returns"
". If it is, the function returns. Otherwise, it creates a new array of integers ""b"" with the same length as ""a"". It then copies the elements of ""a"" from index 1 to index r to ""b""."
"The function then initializes three integer variables: ""k"" to 1, ""j"" to m+1, and ""i"" to 1. It then enters a while loop that continues as long as both k is less than m+1 and j is less than r+1"
". Inside the loop, it compares the element at index k of ""b"" with the element at index j of ""b"""
". If the element at index k is less than or equal to the element at index j, the element at index i of ""a"" is set to the element at index k of ""b"", k is incremented, and i is incremented"
". Otherwise, the element at index i of ""a"" is set to the element at index j of ""b"", j is incremented, and i is incremented."
"After the while loop, the function enters another while loop that continues as long as k is less than m+1. Inside the loop, the element at index i of ""a"" is set to the element at index k of ""b"", k is incremented, and i is incremented."
"After the second while loop, the function enters a third while loop that continues as long as j is less than r+1. Inside the loop, the element at index i of ""a"" is set to the element at index j of ""b"", j is incremented, and i is incremented."
"On the right side of the slide, we have a description of the code. The first bullet point states that in option 2, the two subarrays are copied as they are in the auxiliary array"
". The second bullet point states that the elements to merge are compared starting from the left side of each subarray. The third bullet point states that the last elements of the left subarray, which may have not been merged yet, are added"
". The fourth bullet point states that the last elements of the right subarray, which may have not been merged yet, are added."
"Merge Sort. Conclusions
• Advantages:
o Efficient for arrays with many elements, even in the
worse case
v O(n log n)
o Highly parallelizable
• Drawbacks:
o Complex code
o Requires more memory space to store moreauxiliary variables (e.g., auxiliary array)"
"Exercise 8
• Using the sorting algorithm Merge Sort, describethe process needed to sort the following array inascending order.
{7,3,13,1,11,5}
• Unlike in other cases, with Merge Sort there are no
swapping in the arrays, as we are using anauxiliary array"
"We are asked to describe the process of sorting an array using the merge sort algorithm. The array to be sorted is 7, 3, 13, 1, 11, 5"
". The array to be sorted is 7, 3, 13, 1, 11, 5.  It is important to note that unlike other sorting algorithms, merge sort does not involve swapping elements within the array. Instead, an auxiliary array is used during the sorting process."
"Quick Sort
• Choose an element: the pivot
• Reorder the data structure so that
o elements lower than the pivot are on its lefto elements higher than the pivot are on its right
• Sort recursively
o the part whose elements are lower than the pivot"
"o the part whose elements are lower than the pivot
o the part whose elements are higher than the pivot
http://www.algostructure.com/sorting/quicksort.php
http://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html"
"- Choose an element: the pivot
- Reorder the data structure so that - elements lower than the pivot are on its left
 - elements higher than the pivot are on its right
- Sort recursively
 - the part whose elements are lower than the pivot"
"- the part whose elements are lower than the pivot
 - the part whose elements are higher than the pivot"
"- the part whose elements are higher than the pivot
Two URLs are provided as reference: http://www.algostructure.com/sorting/quicksort.php and http://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html."
"Quick Sort. Example (I)
• Ascending order (from the lowest to the highest)
 95 14 98 29 49 66
 95 14 98 29 49 66
>80 (change side)
 95 14 98 29 49 66
<80 (time to swap,and then change side)
q 80 is the pivot"
"<80 (time to swap,and then change side)
q 80 is the pivot
q Move forward from the leftuntil a value is higher than80
q Move forward from the
right until a value is lowerthan 80
 66 14 98 29 49 95
q Swap the two values
q Repeat until converging"
"The image illustrates an example of a quick sort algorithm. The goal is to sort the following numbers in ascending order: 80, 95, 14, 98, 29, 49, and 66."
"The first step is to choose a pivot, which in this case is 80. The algorithm then iterates through the list, comparing each number to the pivot. If a number is greater than the pivot, it is moved to the right"
". If a number is less than the pivot, it is moved to the left."
"In this example, the algorithm first compares 95 to 80. Since 95 is greater than 80, it is moved to the right. The algorithm then compares 14 to 80. Since 14 is less than 80, it is moved to the left"
". Since 14 is less than 80, it is moved to the left. This process continues until the algorithm reaches the end of the list."
"At this point, the list is divided into two sub-lists: one containing all the numbers less than the pivot (14, 29, 49, 66) and one containing all the numbers greater than the pivot (95, 98). The algorithm then recursively sorts the two sub-lists."
"The final step is to swap the pivot (80) with the first element of the right sub-list (95). This results in the following sorted list: 14, 29, 49, 66, 80, 95, 98."
"Quick Sort. Example (II)
 66 14 98 29 49 95
 > 80 (change side)
 66 14 98 29 49 95
 < 80 (time to swap,and then change side)
 66 14 49 29 98 95
 66 14 49 29 98 95
 > 80 (change side)"
"The figure shows four steps in a Quick Sort example. The numbers to be sorted are 80, 66, 14, 98, 29, 49, and 95. The first element, 80, is chosen as the pivot. The algorithm starts by comparing the pivot to the last element, 95"
". Since 98 is greater than 80, the algorithm moves to the next element. The algorithm compares the pivot to the second to last element, 49. Since 48 is less than 80, the algorithm swaps the pivot and the second to last element"
. The algorithm then changes the direction of comparison and continues comparing the pivot to the remaining elements.
"Quick Sort. Example (III)
 66 14 49 29 98 95
 < 80 (after converging,place the pivot in its correctlocation with a swap)
 66 14 49 80 98 95
< 80
> 80
q Repeat recursively for theleft and right partitions"
"We see two arrays of numbers. The first array is: 80, 66, 14, 49, 29, 98, 95. The second array is the same as the first, except that the numbers 29 and 80 have been swapped"
". There is a red arrow pointing from the 29 in the first array to the space between the 49 and the 80 in the second array. There is text that says: ""29 < 80 (after converging, place the pivot in its correct location with a swap)"""
". There are red lines below both arrays, with ""< 80"" below the line on the left and ""> 80"" below the line on the right. Below the arrays, there is text that says: ""Repeat recursively for the left and right partitions""."
"Quick Sort. Recursive partition andsorting by swapping
•
•
Step 1: Recursive partition
o Given an array (or part of it) with l the first position, and r the
last position"
"last position
o We have to run an algorithm that tell us where to do the partition(elements on the left lower than the pivot, and elements on theright higher than the pivot)
The next partition is computed recursively
o
Step 2: Sorting by swapping"
"o
Step 2: Sorting by swapping
o Moving forward from the left, and from the right, comparting
with the pivot and swapping as needed
Placing the pivot in its correct location
o
•
Pivots are always placed in their final sorted position"
"Quick Sort. Code (I)
public static void quickSort (int[] a) {
qSort(a, 0, a.length-1);
}
public static void qSort (int[] a, int l, int r) {
if (l>=r){
return;
}
int m = partition(a, l, r);
qSort(a,l,m-1);
qSort(a,m+1,r);
}"
"The image shows two code snippets. The first one is a function definition for ""quickSort"" which takes an integer array ""a"" as input. It calls the function ""qSort"" with the array ""a"", 0 and the length of the array minus 1 as input."
"The second snippet shows the function definition of ""qSort"". It takes as input an integer array ""a"", and two integers ""l"" and ""r"". If ""l"" is greater or equal than ""r"" the function returns"
". If ""l"" is greater or equal than ""r"" the function returns. Otherwise, it calls the function ""partition"" with the array ""a"", ""l"" and ""r"" as input and stores the result in the integer ""m"""
". Then it calls the function ""qSort"" two times, the first time with the array ""a"", ""l"" and ""m"" minus 1 as input, and the second time with the array ""a"", ""m"" plus 1 and ""r"" as input."
"Quick Sort. Code (II)
public static int partition (int[] a, int l, int r) {
int i=l+1; // left
int j=r; // right
int p=a[l]; // pivot
while (i<=j) {
if (a[i]<=p){
i++;
} else if (a[j]>p){
j--;
} else{"
"if (a[i]<=p){
i++;
} else if (a[j]>p){
j--;
} else{
• Comparing with a[i]. When we find anelement higher than a[i] on the left, andan element lower than a[i] on the right:swap(a,i,j)
• Before finishing the pivot must be placed
swap(a,i,j);"
"• Before finishing the pivot must be placed
swap(a,i,j);
its the correct location: swap(a,l,j)
}
}swap(a,l,j);
return j;
}
public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
The image shows a code snippet for the Quick Sort algorithm in Java. The code defines two methods: `partition` and `swap`.
"The `partition` method takes three arguments: an integer array `a`, and two integers `l` and `r` representing the left and right indices of the subarray to be partitioned"
". The method first initializes three integer variables: `i` to `l+1`, `j` to `r`, and `p` to `a[l]`. The variable `p` represents the pivot element. The method then enters a `while` loop that continues as long as `i` is less than or equal to `j`"
". Inside the loop, the method compares the value of `a[i]` with `p`. If `a[i]` is less than or equal to `p`, the method increments `i`. Otherwise, it compares `a[j]` with `p`. If `a[j]` is greater than `p`, the method decrements `j`"
". If `a[j]` is greater than `p`, the method decrements `j`. If neither of these conditions is true, the method swaps the elements at indices `i` and `j` using the `swap` method and then increments `i` and decrements `j`"
". After the loop completes, the method swaps the elements at indices `l` and `j` using the `swap` method and then returns the value of `j`."
"The `swap` method takes three arguments: an integer array `a`, and two integers `i` and `j` representing the indices of the elements to be swapped. The method first declares an integer variable `aux` and assigns it the value of `a[i]`"
. The method then assigns the value of `a[j]` to `a[i]` and the value of `aux` to `a[j]`.
The code also includes two comments that explain the logic of the `partition` method. The first comment explains that the method compares the elements of the array with the pivot element `a[l]`
". When the method finds an element that is higher than the pivot element on the left side of the array and an element that is lower than the pivot element on the right side of the array, it swaps these two elements"
". The second comment explains that before the method finishes, the pivot element must be placed in its correct location, which is done by swapping the elements at indices `l` and `j`."
"Quick Sort. Conclusions
• Advantages:
o Very efficient for arrays with many elements
v O(n log n)
v But the worse case is O(n2)!
o Little additional memory
o Highly parallelizable
• Drawbacks:
o Complex code"
"Exercise 9
• Using the sorting algorithm Quick Sort, how manyswaps are needed to sort the following array fromthe lowest element to the highest element(ascending order)?
{7,3,13,1,11,5}"
"Using the sorting algorithm Quick Sort, how many swaps are needed to sort the following array from the lowest element to the highest element (ascending order)?
{7, 3, 13, 1, 11, 5}"
"Summary
• Basic algorithms (Bubble, Insertion, Selection)
o Average complexity O(n2)
o
Inefficient with many elements
o Simple code
o Little use of memory
• Advanced algorithms (Heap, Merge, Quick)
o Average complexity O(n log n)"
"o Average complexity O(n log n)
o Efficient with many elements
o Complex code
o Little use of memory (except Merge Sort)
https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html
https://www.cs.usfca.edu/~galles/visualization/HeapSort.html"
"There are two types of sorting algorithms: basic algorithms and advanced algorithms. Basic algorithms include bubble sort, insertion sort, and selection sort"
". These algorithms have an average complexity of O(n^2), which means that they are inefficient with many elements. However, they are simple to code and use little memory. Advanced algorithms include heap sort, merge sort, and quick sort"
". These algorithms have an average complexity of O(n log n), which means that they are efficient with many elements. However, they are more complex to code. With the exception of merge sort, they use little memory."
"Bubble Sort. Two loops
The image describes the Bubble Sort algorithm, which uses two loops."
"The external loop iterates length of array - 1 times. In each iteration, one element is sorted, except for the last one in which two elements are sorted. The range of the index in the external loop is from 0 to length of array - 1."
"The internal loop iterates a different number of times depending on the iteration of the external loop. In the first iteration of the external loop, the internal loop iterates length of array - 1 times"
". In the second iteration of the external loop, the internal loop iterates length of array - 2 times. In the m-th iteration of the external loop, the internal loop iterates length of array - i - 1 times"
. The range of the index in the internal loop is from 0 to length of array - 1 - i.
"After the m-th iteration of the external loop, the elements from index 0 to length of array - 2 - i are unsorted, and the elements from length of array - 1 - i to length of array - 1 are sorted."
"Bubble Sort. Conclusions
The image shows a slide titled ""Bubble Sort. Conclusions"" that lists the advantages and drawbacks of the bubble sort algorithm.
Advantages:
- Little additional memory is needed
- Few lines of code"
"- Little additional memory is needed
- Few lines of code
- Efficient for arrays with few elements
Drawbacks:
- Inefficient for arrays with many elements
  - O(n²) => quadratic order (two nested loops for an array of n elements)"
"- For a given array there are always the same number of iterations (even though it is already sorted), even though there are no swaps
  - Too many swaps"
"- Too many swaps
- Larger elements move faster to the end (they can reach the end in one iteration of the external loop), but lower elements move slower to the beginning (they gain one position per iteration)"
- Improvement: Cocktail sort (double internal loop to pass from left to right and from right to left in each iteration of the external loop)
Selection Sort. Two loops
"We are going to see how the selection sort algorithm works. This algorithm uses two loops. The external loop iterates over the array, and in each iteration, one element is sorted"
". The number of iterations is equal to the length of the array, although the last iteration is not strictly needed. The range of the index in the external loop goes from zero to the length of the array minus one"
". The internal loop searches for the minimum or maximum value in the array. In the first iteration of the external loop, the internal loop iterates from zero to the length of the array minus one"
". In the second iteration of the external loop, the internal loop iterates from one to the length of the array minus two, and so on. In the m-th iteration of the external loop, the internal loop iterates from m minus one to the length of the array minus m"
". The range of the index in the internal loop goes from i, the index of the external loop, to the length of the array minus one"
". After the m-th iteration of the external loop, the elements from zero to i are sorted, and the elements from i plus one to the length of the array minus one are unsorted."
"Selection Sort. Conclusions
 the advantages, drawbacks and variants of the Selection Sort algorithm.
The advantages are:
- Little additional memory is needed
- Few lines of code
- Efficient for arrays with few elements
The drawbacks are:"
"- Efficient for arrays with few elements
The drawbacks are:
- Inefficient for arrays with many elements
- O(n^2) which means it's quadratic order because it uses two nested loops for an array of n elements"
"- For a given array there are always the same number of iterations, even though it is already sorted and even though there are no swaps
- However, there are much less swaps than with Bubble Sort
Variant:"
"Variant:
- Placing the maximum or minimum at the end, instead of placing the maximum or minimum at the beginning"
Insertion Sort. Two loops
"the two loops used in insertion sort. The external loop iterates over the array, with the number of iterations equal to the length of the array. In each iteration, one element is sorted, including the last iteration"
. The range of the index in the external loop is from 0 to the length of the array minus 1. The internal loop finds the correct position to insert the element
". The number of iterations in the internal loop depends on the position ""advanced"" by the element which is inserted. If the element inserted moves k positions to the left, then there are k elements that are moved one position to the right"
". After the m-th iteration (i=m-1) of the external loop, the elements from 0 to i are sorted and the elements from i+1 to the length of the array minus 1 are unsorted."
"Insertion Sort. Conclusions
The image shows a slide titled ""Insertion Sort. Conclusions"" about the advantages and disadvantages of using insertion sort.
Advantages:
- Little additional memory is needed
- Few lines of code"
"- Little additional memory is needed
- Few lines of code
- Efficient for arrays with few elements"
"- More efficient than Selection Sort for partially sorted arrays because for a given array there are always the same number of iterations in the external loop, even though it is already sorted, but the internal loop is adaptable.
Drawbacks:"
"Drawbacks:
- Inefficient for arrays with many elements because its time complexity is O(n^2), which means it has a quadratic order with two nested loops for an array of n elements.
- Inefficient when the array to sort is in reverse sorted order."
"Heap Sort. Conclusions
We can see the advantages and drawbacks of using heap sort.
Heap sort is efficient for arrays with many elements, even in the worst case, with O(n log n) complexity.
Also, little additional memory is needed."
"Also, little additional memory is needed.
On the other hand, heap sort has a complex code."
"Merge Sort. Recursive division and merging with auxiliary array
The image describes the Merge Sort algorithm."
"The first step of the algorithm is the recursive division: Given an array, or part of it, with *l* as the first position, *r* as the last position, and *m* as the half position calculated as *(l+r)/2*"
", and *m* as the half position calculated as *(l+r)/2*, divide the array recursively in two until *l* and *r* are equal"
. The two parts are from *l* to *m* and from *m+1* to *r*.
"The second step is sorting by merging subarrays: Create an auxiliary array containing the two subarrays to sort, then compare the elements to sort each subarray."
"Finally, it is important to note that elements are not in their final correct position until we finish merging subarrays."
"Merge Sort. Conclusions
There are two main advantages of using merge sort: it is efficient for arrays with many elements, even in the worst case, with a time complexity of O(n log n), and it is highly parallelizable."
"The drawbacks are that it requires complex code and more memory space to store auxiliary variables, such as an auxiliary array."
"Quick Sort. Recursive partition and sorting by swapping
The image describes the Quick Sort algorithm, which uses recursive partition and sorting by swapping."
"Step 1: Recursive partition. Given an array, or part of it, with *l* the first position and *r* the last position, we have to run an algorithm that tells us where to do the partition"
". The elements on the left should be lower than the pivot, and the elements on the right should be higher than the pivot. The next partition is computed recursively."
"Step 2: Sorting by swapping. Moving forward from the left, and from the right, comparing with the pivot and swapping as needed. Placing the pivot in its correct location.
Finally, it states that pivots are always placed in their final sorted position."
"Quick Sort. Conclusions
We can see a list of advantages and drawbacks of the Quick Sort algorithm."
"Advantages are: it is very efficient for arrays with many elements, its performance is O(n log n), although the worst case is O(n^2). It requires little additional memory and it is highly parallelizable.
The main drawback is that it requires complex code."
"Systems Programming
First steps in Java
Department of Telematic Engineering
CONTENTS ARE MOSTLY BASED ON THE WORK BY:
M. Carmen Fernández Panadero and Natividad Martínez Madrid"
"Java Language Code Structure
Department of Telematic Engineering
Contents are mostly based on the work by: M. Carmen Fernández Panadero and Natividad Martínez Madrid
Imperative Java
Department of Telematic Engineering"
"Imperative Java
Department of Telematic Engineering
Contents are mostly based on the work by M. Carmen Fernández Panadero and Natividad Martínez Madrid"
"Scenario I:Install and configure the environment
• Today is your first day at work in the programming departmentof PROTEL. Your department has to update an old applicationwith new functionality"
"• You are provided with a laptop to work and a URL from where to
download the code developed up to date
• Objective: Be able to edit, compile execute and debug an
existing program.
• Workplan: Download, install and configure the software in order"
"to test (edit, compile, execute and debug) the application"
"Development
Architecture
Step I: Edit
Step II: Compile
Editors
Compilers
IDEs
Grasp
• Eclipse
• Netbeans
• J Builder
• Visual Café
• Java Workshop
• Visual Age
• J++
Notepad
EditPlus
Others
JDK
Others
Java
code
file.java
javac file.java
Bytecode
file.class"
"Others
Java
code
file.java
javac file.java
Bytecode
file.class"
"Execution
Architecture
Step III: Load
Step IV: Verify
Step V: Execute
e
n
i
h
c
a
M
l
a
u
t
r
i
V
a
v
a
J
Applets or Aplications in Bytecode format
Class Loader
Bytecode Verifier
Java Class Libraries
(Java extension APIs)
Java Class Libraries"
"Java Class Libraries
(Java extension APIs)
Java Class Libraries
(Java Base APIs)
Java Interpreter
JIT (Just in Time Compiler)
Java Runtime
Operating System
Hardware
java file"
"What can go wrong?
• Compile
• Load
• Verify
• Execute
“Syntax Error”
“Class not found Exception”
“Security Exception”
“Null Pointer Exception”"
"We have a list of four possible software execution stages and the corresponding errors that can occur. During compilation we can have a ""Syntax Error"". During load, we can have a ""Class not found Exception"""
". During load, we can have a ""Class not found Exception"". During verification, we can have a ""Security Exception"". Finally, during execution, we can have a ""Null Pointer Exception""."
"Where do I start?
• Development environment: JDK
http://www.oracle.com/technetwork/Java/index.html
• Editor: Eclipse
http://www.eclipse.org
• Documentation: Java API
http://docs.oracle.com/Javase/8/docs/api/"
"To start developing in Java, you need a development environment, an editor, and documentation. The recommended development environment is the Java Development Kit (JDK), available at http://www.oracle.com/technetwork/Java/index.html"
".oracle.com/technetwork/Java/index.html. The suggested editor is Eclipse, which can be found at http://www.eclipse.org. For documentation, refer to the Java API at http://docs.oracle.com/Javase/8/docs/api/."
"Config (if needed)
• Configuration:
– CLASSPATH: Set of directories containing the files.class
you  want to execute (not necessary since v1.2).It must contain, at least, $JAVA_HOME/lib/files.class
– PATH: Directories to search for executable files"
"– PATH: Directories to search for executable files
It must contain, at least, $JAVA_HOME/bin"
We are going to talk about the configuration. There are two important variables: CLASSPATH and PATH. The CLASSPATH variable is a set of directories containing the files.class you want to execute. This is not necessary since version 1.2
". This is not necessary since version 1.2. It must contain, at least, the directory $JAVA\_HOME/lib/files.class. The PATH variable contains the directories to search for executable files. It must contain, at least, $JAVA\_HOME/bin."
"How to configureEnvironment Variables
Windows 7, 8, 8.1
– Start – Control panel – System and Security – system
– System advanced configuration – Advanced options – Environment
variables"
"variables
Linux (Type in a terminal prompt  or modify in .bash file to make it permanent:
PATH=$JAVA_HOME/bin:/usr/bin
CLASSPATH=$JAVA_HOME/lib/classes.zip:.
Preserving the old value of environment variables :
PATH=$JAVA_HOME/Java/bin:$PATH"
"PATH=$JAVA_HOME/Java/bin:$PATH
CLASSPATH=$JAVA_HOME/lib/classes.zip:$CLASSPATH"
"Systems Programming
Java Language Code Structure
Department of Telematic Engineering
CONTENTS ARE MOSTLY BASED ON THE WORK BY:
M. Carmen Fernández Panadero and Natividad Martínez Madrid"
"Java Language Code Structure
Department of Telematic Engineering
Contents are mostly based on the work by: M. Carmen Fernández Panadero and Natividad Martínez Madrid
Imperative Java
Department of Telematic Engineering"
"Imperative Java
Department of Telematic Engineering
Contents are mostly based on the work by M. Carmen Fernández Panadero and Natividad Martínez Madrid"
"Scenario II:Understanding Java code
• Your first meeting as a programmer will be in an hour. By thistime, you must have reviewed the code and you must haveunderstood how the application works.
• Objective: Be fluent in reading Java structures related with"
"• Objective: Be fluent in reading Java structures related with
classes, attributes and methods. Understand, at a glance, acomplex Java program with several files
• Work plan:"
"• Work plan:
– Review Java syntax (identifiers, reserved words, etc.) in order to distinguish between
words from Java language and naming for a specific application
– Identify language structures related with class declaration, attribute declaration"
"(basic and reference types) and method declaration
– Draw class diagrams to represent a set of Java files in order to identify object types,
their characteristics (attributes) and behaviors (methods)"
"their characteristics (attributes) and behaviors (methods)
– Understand and explain the main method (if it exists) to see the order in which
objects are created, methods are called, and sentences are executed"
"Code Structure
Program
Members
Classes (files.java)
Attributes
Methods
Primitive
Type
ReferenceType
Normal
Methods
Special
methods
Object
Arrays
Constructor Main
String"
"A diagram illustrating the structure of code. At the top level, we have a ""Program"". A program consists of ""Classes"", which are represented as files with the "".java"" extension"
".java"" extension. Each class has ""Members"", which are further categorized into ""Attributes"" and ""Methods""."
"Attributes can be of ""Primitive Type"" or ""Reference Type"". Examples of primitive types include ""String"". Reference types encompass ""Object"" and ""Arrays""."
"Methods are categorized as ""Normal Methods"" and ""Special methods"". Special methods consist of ""Constructor"" and ""Main""."
"How to represent classesand objects in Java
• Class declaration
• Attribute declaration
OO
(constants or variables)
• Method declaration
• Object creation
• Identifiers
• Reserved words
• Primitive and reference types in Java
Java"
"Identifiers
•
Identifiers are used to give a name to variables,methods, classes, objects, and everything that theprogrammer needs to identify
• Starting with a letter, an underscore or a $ sign
• Case-sensitive, no maximum length
• By convention:"
"• Case-sensitive, no maximum length
• By convention:
– Names of variables, methods and objects begin with
lowercase.
– Class names begin with uppercase
– If there are several words, use camelCase
likeInThisExample (avoid spaces, underscores andhyphens)"
"likeInThisExample (avoid spaces, underscores andhyphens)
Identifiers cannot be reserved words"
"are used to give a name to variables, methods, classes, objects, and everything that the programmer needs to identify. They start with a letter, an underscore, or a dollar sign. They are case-sensitive and have no maximum length"
". They are case-sensitive and have no maximum length. By convention, names of variables, methods, and objects begin with lowercase. Class names begin with uppercase. If there are several words, use camel case, like ""likeInThisExample"""
". Avoid spaces, underscores, and hyphens.  cannot be reserved words."
"Reserved words
i nt
i nt er f ac e
l ong
nat i v e
new
nul l
pac k age
pr i v at e
pr ot ec t ed
Reserved:
abs t r ac t
bool ean
br eak
by t e
c as e
c at c h
c har
c l as s
c ons t   *
c ont i nue
def aul t
do
Reserved (although not used):
c as t"
"c ont i nue
def aul t
do
Reserved (although not used):
c as t
oper at or
doubl e
el s e
ex t ends
f i nal
f i nal l y
f l oat
f or
got o
i f
i mpl ement s publ i c
r et ur n
i mpor t
s hor t
i ns t anc eOf
gener i c
r es t
f ut ur e
out er
s t at i c"
"i ns t anc eOf
gener i c
r es t
f ut ur e
out er
s t at i c
s uper
s wi t c h
s y nc hr oni z ed
t hi s
t hr ow
t hr ows
t r ans i ent *
t r y
v oi d
v ol at i l e
whi l e
i nner
v ar"
"The image shows a table of reserved words in Java. The table is divided into two sections: ""Reserved"" and ""Reserved (although not used)"". The ""Reserved"" section lists keywords that cannot be used as identifiers in a Java program"
". The ""Reserved (although not used)"" section lists keywords that are reserved but not currently used by the Java language."
"The ""Reserved"" section of the table lists the following keywords:
* abstract
* boolean
* break
* byte
* case
* catch
* char
* class
* const *
* continue
* default
* do
* double
* else
* extends
* final
* finally
* float
* for
* goto
* if
* implements"
"* final
* finally
* float
* for
* goto
* if
* implements
* import
* instanceof
* int
* interface
* long
* native
* new
* null
* package
* private
* protected
* public
* return
* short
* static
* super
* switch
* synchronized
* this
* throw
* throws"
"* super
* switch
* synchronized
* this
* throw
* throws
* transient *
* try
* void
* volatile
* while
The ""Reserved (although not used)"" section of the table lists the following keywords:
* cast
* future
* generic
* inner
* operator
* outer
* rest
* var"
"Comments
Three types:
// Implementation comment (1 line)
/* Implementation block comment.
continuefinish */
For classesand methods
optional
For classes
For methods
/**Documentation comment to generate javadoc
@see ref to other class or method"
"@see ref to other class or method
@version information about version number
@author author name
@since Date since code is available
@param Parameters received by the method
@return Information and data type returned by the method"
"@return Information and data type returned by the method
@throws Exceptions that are thrown by this method
@deprecated The method is old and shall not be used
*/"
"the three types of comments in Java.
- Implementation comment: A single-line comment, marked by ""//"" at the beginning.
- Implementation block comment: A multi-line comment, starting with ""/*"" and ending with ""*/""."
"- Documentation comment: A multi-line comment used to generate Javadoc documentation. It starts with ""/**"" and ends with ""*/"""
". It starts with ""/**"" and ends with ""*/"". This type of comment includes special tags like ""@see"", ""@version"", ""@author"", ""@since"", ""@param"", ""@return"", ""@throws"", and ""@deprecated"" to provide specific information about the code"
.  - @see provides a reference to another class or method.
"- @version includes information about the version number.
  - @author specifies the author's name.
  - @since indicates the date since the code is available.
  - @param describes the parameters received by the method."
"- @param describes the parameters received by the method.
  - @return specifies the information and data type returned by the method.
  - @throws lists the exceptions that are thrown by the method."
"- @throws lists the exceptions that are thrown by the method.
  - @deprecated indicates that the method is old and should not be used."
"specifies that documentation comments can be used for both classes and methods, while the other two types are generally used for methods. However, it does mention that documentation comments can be optionally used for classes as well."
"Class declaration
public class Car {
// Attribute declaration
//  (color, speed, etc.)
// Method declaration
//  (start, stop, etc.)
}
Syntax
(modifiers) class className {
// class implementation
}"
"Syntax
(modifiers) class className {
// class implementation
}
Breaking this rule is considered in many compilers as asyntax error
Car.java
Style
• File name = class name
• 1st letter capitalized
• No blanks or hyphens
• CamelCase:e.g. MyFirstClass"
"• No blanks or hyphens
• CamelCase:e.g. MyFirstClass
• Indentation"
"how to declare a class in Java, both the syntax and the style.
The syntax is as follows: first the modifiers, then the keyword ""class"", then the class name followed by curly braces. Inside the curly braces we have the class implementation."
"When choosing a class name, make sure that the file name matches the class name, the first letter is capitalized, there are no blanks or hyphens in the name and camel case is used. For example, ""MyFirstClass"". Finally, remember to indent the code."
"Variable Declaration
public class Car{
//Atribute declaration
String color;
int speed;
//Method declaration
// (start, stop, etc.)
}
Syntax
type name;
type name1, name2, name3;
type name = value;
Initializing the variable
Car.java
Style
• Intuitive names"
"Initializing the variable
Car.java
Style
• Intuitive names
• 1st letter capitalized
• No blanks
• CamelCase:
e.g. myVariable
• Indentation"
"We have a code snippet illustrating variable declaration in Java. The code defines a class named ""Car"" with attributes for ""color"" of type ""String"" and ""speed"" of type ""int"""
".  There's a comment indicating the area for method declarations, taking parameters like ""start"" and ""stop""."
"The syntax for variable declaration is shown as ""type name;"" for a single variable and ""type name1, name2, name3;"" for multiple variables declared together. Initializing a variable during declaration is shown as ""type name = value;""."
"good coding style with intuitive names, camel case for variable names, indentation, and no blanks in variable names."
"Variables
• Variables are fields in which programs store
information
• “To declare a variable” means to specify its
name and type
• We can find variables:
– As members of a class: Instance and class variables
(within a class)"
"(within a class)
– As  local variables (within a method)– As parameters (within a method declaration)"
"are fields in which programs store information.
To declare a variable means to specify its name and type."
"To declare a variable means to specify its name and type.
We can find variables as members of a class: Instance and class variables within a class, as local variables within a method, and as parameters within a method declaration."
"There are three types of variables: instance variables, class variables, and local variables."
"can be initialized in the declaration or may be declared uninitialized. If they are not initialized, they will have a default value, except for local variables. The default values are: 0 for numbers, false for booleans, and null for references."
"Constants are variables that cannot be modified. They are declared using the reserved word ""final"" and must be initialized in the declaration."
"Variables
• Three types:
– Instance variables– Class variables– Local variables
• Variables
Default values:
numbers = 0
booleans = false
references = null
– can be initialized in the declaration
– may be declared uninitialized"
"– may be declared uninitialized
• when have been not initialized they have a default
value (except local variables)
• Constants (variables that cannot be modified):
– Use reserved word: final
– Mandatory to initialize it in declaration"
"are fields in which programs store information.
To declare a variable means to specify its name and type."
"To declare a variable means to specify its name and type.
We can find variables as members of a class: Instance and class variables within a class, as local variables within a method, and as parameters within a method declaration."
"There are three types of variables: instance variables, class variables, and local variables."
"can be initialized in the declaration or may be declared uninitialized. If they are not initialized, they will have a default value, except for local variables. The default values are: 0 for numbers, false for booleans, and null for references."
"Constants are variables that cannot be modified. They are declared using the reserved word ""final"" and must be initialized in the declaration."
"Scope
•
• The scope of a variable is the part of the programover which the variable name can be referenced
Instance or class variables can be referencedinside the body of the class {} or from other classesdepending on the permissions set:– private"
"– protected
– public
– friendly (package)
• Local variables can be referenced inside a statementblock in braces {}, such as inside a method or insidea while or for loops
• Parameters can be referenced only inside the body
of the method {}"
The scope of a variable is the part of the program over which the variable name can be referenced
". Instance or class variables can be referenced inside the body of the class or from other classes depending on the permissions set, which are private, protected, public, and friendly package"
". Local variables can be referenced inside a statement block in braces, such as inside a method or inside a while or for loops. Parameters can be referenced only inside the body of the method."
"Data Types in Java
• All variables belong to a data type
• The data type determines:
– The values that the variable can take
– The operators  that can be used
• We will study:
– Primitive types
– Reference types (objects and arrays)"
"All variables belong to a data type. The data type determines the values that the variable can take and the operators that can be used. We will study primitive types and reference types, which include objects and arrays."
"Primitive types
 basic primitive types
type
literal
Real
Integer
doubl e
f l oat
l ong
i nt
shor t
byt e
Character char
Boolean
bool ean
num of bits
-bits32-bits
-bits
 bits
 bits
 bits
Unicode (16 bits)
 bit
doubl e
X
X
X
X
X
X
X
f l oat"
"bits
Unicode (16 bits)
 bit
doubl e
X
X
X
X
X
X
X
f l oat
l ong i nt shor t byt e char
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X"
"This table describes 4 basic primitive types.
The first type is **Real**, which can be represented as a **double** or a **float**. A **double** uses 64 bits and a **float** uses 32 bits."
"The second type is **Integer**, which can be represented as an **int**, **short**, or **byte**. An **int** uses 32 bits, a **short** uses 16 bits, and a **byte** uses 8 bits."
"The third type is **Character**, which is represented as a **char** and uses Unicode (16 bits).
The fourth type is **Boolean**, which is represented as a **boolean** and uses 1 bit."
"The last 7 columns indicate whether each type can be represented as a **double**, **float**, **long**, **int**, **short**, **byte**, or **char**. An ""X"" indicates that the type can be represented in that way."
"StringsDeclaration, concatenation
• Sequence of characters implemented in a class
named String (in java.lang package)
• Strings creation
String emptyS = new String();
String emptyS = “”;
String message = “hello”
String messageCopy = message;"
"String message = “hello”
String messageCopy = message;
• Strings concatenation
– String concatenation uses the overloaded + operator
“this” + “that”        // result: “thisthat”
“abc” + 5
// result: “abc5”
“a” + “b” + “c”
// result: “abc”
“a” + 1 + 2"
"// result: “abc5”
“a” + “b” + “c”
// result: “abc”
“a” + 1 + 2
 + 2 + “a”
// result: “a12”
// result: “3a”
 + (2 + “a”)
// result: “12a”"
"Strings
Comparison
• You must not use relational (<, >, <=, <=) and
equality (==, !=) operators with Strings
– These operators compare the object, not the content
• There are specific methods to compare in the
String class
– Method: equals"
"String class
– Method: equals
leftSide.equals(rightSide)
• true, if leftSide and rightSide are identical
– Method compareTo
leftSide.compareTo(rightSide)
• negative int value, if leftSide is lower than rightSide
• 0, if leftSide is equal to rightSide"
"• 0, if leftSide is equal to rightSide
• positive int value, if leftSide is higher than rightSide"
"useful methods of the String class.
The first method is length(). This method returns the length of a string. It's important to remember to include the parentheses after the method name, as this is how Java knows that it is a method call."
The next method is charAt(). This method allows you to access individual characters inside a string. You pass in the position of the character you want to access as an argument to the method. The first position in a string is 0.
The final method discussed is substring(). This method returns a reference to a new string that is a substring of the original string
. The substring() method takes two arguments: the first position included in the substring and the first position excluded from the substring.
"provides some example code that demonstrates how to use these methods. The code first creates a string called ""greeting"" and sets it equal to ""hello"""
". Then, the code uses the length() method to get the length of the string and stores it in a variable called ""len"". The code then uses the charAt() method to get the character at position 1 of the string and stores it in a variable called ""ch"""
". Finally, the code uses the substring() method to get the substring of ""greeting"" from position 2 to position 4 and stores it in a variable called ""sub"""
. The code then includes comments that indicate what the values of each variable will be after the code is executed.
"Conversion between String and primitive types
- Use calls to wrapper classes in java.lang
  - They are called wrappers because they wrap the primitive types: Integer, Double, Float, Double, Character, ...
  - String conversion"
"- String conversion
    - Methods: toString(...), doubleValue()
  - String conversion to a primitive type
    - Methods: parseInt(...), parseFloat(...)
  - String conversion to an object of the wrapper class
    - valueOf(...)"
"- valueOf(...)
  - Conversion from an object of the wrapper class to a primitive value
    - doubleValue(), intValue()
Here is an example:
```java
System.out.println(Integer.toString(55, 2));
int x = Integer.parseInt(""75"");"
"int x = Integer.parseInt(""75"");
Double y = Double.valueOf(""3.14"").doubleValue();
```"
"StringsUseful methods of String class
• Length of a String– Method: length()
– Do not forget parenthesis because it is a method
• Accessing individual characters inside a String
– Method: charAt(position),  • The first position is 0
• SubStrings"
"• SubStrings
– Method substring(1stPosIncluded, 1stPosExcluded)
• Returns the reference to a new String
• Parameters: 1st position included and 1st position excluded
String greeting = “hello”;
int len = greeting.length();
char ch = greeting.charAt(1);"
"int len = greeting.length();
char ch = greeting.charAt(1);
// len is 5
// ch is ‘e’
String sub = greeting.substring(2,4); // sub is “ll”"
"Strings
Conversion between String and primitive types
• Use calls to wrapper classes in java.lang
– They are called wrappers because they wrap the primitive types:
Integer, Double, Float, Double, Character, …
– String conversion"
"– String conversion
• Methods: toString(…), doubleValue()
– String conversion to a primitive type
• Methods: parseInt(…), parseFloat(…)
– String conversion to an object of the wrapper class
• valueOf(…)"
"• valueOf(…)
– Conversion from an object of the wrapper class to a primitive
value
• doubleValue(), intValue()
System.out.println(Integer.toString(55, 2));
int x = Integer.parseInt(“75”);
Double y = Double.valueOf(“3.14”).doubleValue();"
"useful methods of the String class.
The first method is length(). This method returns the length of a string. It's important to remember to include the parentheses after the method name, as this is how Java knows that it is a method call."
The next method is charAt(). This method allows you to access individual characters inside a string. You pass in the position of the character you want to access as an argument to the method. The first position in a string is 0.
The final method discussed is substring(). This method returns a reference to a new string that is a substring of the original string
. The substring() method takes two arguments: the first position included in the substring and the first position excluded from the substring.
"provides some example code that demonstrates how to use these methods. The code first creates a string called ""greeting"" and sets it equal to ""hello"""
". Then, the code uses the length() method to get the length of the string and stores it in a variable called ""len"". The code then uses the charAt() method to get the character at position 1 of the string and stores it in a variable called ""ch"""
". Finally, the code uses the substring() method to get the substring of ""greeting"" from position 2 to position 4 and stores it in a variable called ""sub"""
. The code then includes comments that indicate what the values of each variable will be after the code is executed.
"Conversion between String and primitive types
- Use calls to wrapper classes in java.lang
  - They are called wrappers because they wrap the primitive types: Integer, Double, Float, Double, Character, ...
  - String conversion"
"- String conversion
    - Methods: toString(...), doubleValue()
  - String conversion to a primitive type
    - Methods: parseInt(...), parseFloat(...)
  - String conversion to an object of the wrapper class
    - valueOf(...)"
"- valueOf(...)
  - Conversion from an object of the wrapper class to a primitive value
    - doubleValue(), intValue()
Here is an example:
```java
System.out.println(Integer.toString(55, 2));
int x = Integer.parseInt(""75"");"
"int x = Integer.parseInt(""75"");
Double y = Double.valueOf(""3.14"").doubleValue();
```"
"Constants defined by user
Invariant values of basic types (primitives + String)
•
• Constants use the final modifier (and sometimes the static too)
– static: Indicates global or class variable. This means that it is stored only"
"once. Objects can access this variable using the dot notation,ClassName.variableName
– final: This modifier indicates that the value never changes.
– Constants can be public, private or protected"
"– Constants can be public, private or protected
• Depending on the degree of accessibility the programmer prefers
– Style: All the characters in  UPPERCASE
class Circle {
private static final float PI = 3.14159;
private float radio;
private float area;"
"private float radio;
private float area;
public Circle (float radio) {
area = 2 * PI * radio;
} //constructor
} //class Circle"
"- Invariant values of basic types primitives plus String
- Constants use the final modifier and sometimes the static too"
"- Constants use the final modifier and sometimes the static too
  - Static indicates global or class variable. This means that it is stored only once. Objects can access this variable using the dot notation, ClassName dot variableName"
"- Final: this modifier indicates that the value never changes
- Constants can be public, private, or protected
  - Depending on the degree of accessibility the programmer prefers
- Style: all the characters in uppercase
There is a code example:
```java"
"There is a code example:
```java
class Circle {
  private static final float PI = 3.14159;
  private float radio;
  private float area;
  public Circle (float radio) {
    area = 2 * PI * radio;
  } //constructor
} //class Circle
```"
"Reference types
• The value is a reference (pointer) to the
value represented by the variable.
• Some examples of reference types:
– Arrays– Classes
– Interfaces"
"The value is a reference, or pointer, to the value represented by the variable. Some examples of reference types are: arrays, classes, and interfaces."
"An object as an attributeObject declaration
public class Car{
//Attribute declaration
String color;
int speed;
Equipment standardEquipment;
//method declaration
// (start, stop, etc.)
}
Syntax
Car.java
Style"
"// (start, stop, etc.)
}
Syntax
Car.java
Style
• Remember that classes(type) start with capitalletter, while identifiers(objectName) use lower-
case
ClassName name;
ClassName name1, name2;
ClassName name  =  new Equipment();
Object declaration"
"ClassName name  =  new Equipment();
Object declaration
similar to variable declaration, where we putthe type, now we put the name of the class
Object creation
Variables are initialized,but Objects are created!!"
"Objects
Declaration, creation, initialization
• Objects are created with the reserved word new and a
call to the constructor
• Once the object is created, the reference to the object isreassigned to the memory location where the object islocated"
"Student student1;
student1 = new Student();
null
student1
student1
Student"
"Declaration, creation, initialization
-  are created with the reserved word ""new"" and a call to the constructor
- Once the object is created, the reference to the object is reassigned to the memory location where the object is located"
"The first diagram shows a yellow box with the text ""Student student1;"". To the right, there is an orange box with the text ""null"" and below it ""student1"". An arrow points from the orange box to a black dot."
"The second diagram shows a blue box with the text ""student1 = new Student();"". To the right, there is an orange box with the text ""student1"" below it. An arrow points from the orange box to a green box with the text ""Student"" inside."
"Objects
Null reference
•
It may happen that a reference to an object has no instance assigned– Then the special value null is used
• Example:
Student student1;           // null by default
Student student2;
Student student3;"
"Student student2;
Student student3;
student1 = new Student();   // value != null
student2 = new Student();   // value != null
student3 = null;            // value null by assignment
Student
Student
student1
student2
null
student3"
"Declaration, creation, initialization
-  are created with the reserved word ""new"" and a call to the constructor
- Once the object is created, the reference to the object is reassigned to the memory location where the object is located"
"The first diagram shows a yellow box with the text ""Student student1;"". To the right, there is an orange box with the text ""null"" and below it ""student1"". An arrow points from the orange box to a black dot."
"The second diagram shows a blue box with the text ""student1 = new Student();"". To the right, there is an orange box with the text ""student1"" below it. An arrow points from the orange box to a green box with the text ""Student"" inside."
"Objects
Alias
• An object can have several references, known as alias
Student delegate;
delegate = student1;
• What would be the result of comparing the different
references in the figure?
Student
Juan
student1
delegate
null
student2
null
student3
student5"
"Juan
student1
delegate
null
student2
null
student3
student5
Student
Juan
student4
Student
Clara"
"Declaration, creation, initialization
-  are created with the reserved word ""new"" and a call to the constructor
- Once the object is created, the reference to the object is reassigned to the memory location where the object is located"
"The first diagram shows a yellow box with the text ""Student student1;"". To the right, there is an orange box with the text ""null"" and below it ""student1"". An arrow points from the orange box to a black dot."
"The second diagram shows a blue box with the text ""student1 = new Student();"". To the right, there is an orange box with the text ""student1"" below it. An arrow points from the orange box to a green box with the text ""Student"" inside."
"ArraysWhat is an array?
• It is a set of elements belonging to the same
data type and stored in one place
• The index [ ] operator is used to retrieve
individual elements from the array
• The length (attribute) returns the number of"
"• The length (attribute) returns the number of
elements in the array.(not be confused with the method length() of the String class)
• Range of index
– From 0 to length – 1
– Be careful! Don’t exceed the maximum length"
"– Be careful! Don’t exceed the maximum length
• Exception: IndexOutOfBoundsException"
"An Array as an Attribute
Array declaration
public class Car{
//Array declaration
String equipment[] = new String [10];
// ...
Syntaxis
}
Ways to declare an array
type ArrayName[];
type [] ArrayName;
type ArrayName[] = new type [arraySize];
Array creation"
"type ArrayName[] = new type [arraySize];
Array creation
When you create an array youmust specify its capacity!
Array creation
Variables are initialized,but Arrays (like objects)are created!"
"Array declaration
 how to declare and create arrays in a Java-like programming language.
We see a code snippet that shows the declaration of an array named ""equipment"" inside a class named ""Car"". The array is of type ""String"" and has a size of 10."
"presents three different ways to declare an array:
- ""type ArrayName[];""
- ""type [] ArrayName;""
- ""type ArrayName[] = new type [arraySize];"""
"- ""type ArrayName[] = new type [arraySize];""
The last one is highlighted in red because it's also showing how to create an array, by using the ""new"" keyword and specifying the array size.
Finally,  the difference between variable and array creation:"
"Finally,  the difference between variable and array creation:
- Variables are initialized when they are declared.
- Arrays, like objects, are created when they are declared, and their initial values depend on the array type."
"ArraysDeclaration, Creation, Initialization
• Declaration: To assign an identifier to the array and specify
the data type of the elements that will be stored
– It can be done in two ways:
Type ArrayName[];
Type[] ArrayName;"
"Type ArrayName[];
Type[] ArrayName;
– No memory to store the array is allocated in the declaration.
Therefore, you can not access its contents yet
• Creation: it consists on allocating memory
for the array
– You must use the reserved word new and"
"for the array
– You must use the reserved word new and
specify the array size
Default values:
int, short, long  = 0
float, double = 0.0
booleans = false
String = null
Object = null
arrayName[] = new type[arraySize];"
"String = null
Object = null
arrayName[] = new type[arraySize];
– Once the array is created, its elements havedefault values until the array is initialized"
"ArraysDeclaration, Creation, Initialization
• Initialization: To assign values to each of the
elements of the array. It can be done in several ways:
– Element by element
arrayName[0] = element0;
arrayName[1] = element1;
...
– Using a Loop"
"arrayName[1] = element1;
...
– Using a Loop
for(int i = 0; i < arrayName.length; i++){
arrayName[i] = element-i;
}
– Direct assignment
arrayName = {elem1, elem2, elem3, ...};"
"Arrays
Index 1st element = 0
Index last element= length - 1
c[0]
c[1]
c[2]
c[3]
c[4]
c[5]
c[6]
c[7]
c[8]
c[9]
-7




-4




Array length= 10
Index nth element = n - 1
Index : integer expression: 0 <= index <= length - 1"
What is an array?
"An array is a set of elements belonging to the same data type and stored in one place. The index operator, represented by square brackets, is used to retrieve individual elements from the array"
. The length attribute returns the number of elements in the array. It's important to note that this should not be confused with the length method of the String class.
"The range of the index starts from 0 and goes up to length minus 1. It's crucial to be careful not to exceed the maximum length of the array, as doing so will result in an IndexOutOfBoundsException.
Declaration, Creation, Initialization"
"Declaration, Creation, Initialization
 how to declare, create, and initialize arrays."
"how to declare, create, and initialize arrays.
Declaration is the process of assigning an identifier to the array and specifying the data type of the elements that will be stored. This can be done in two ways:- Type ArrayName();
- Type [] ArrayName;"
"- Type [] ArrayName;
No memory is allocated to store the array during the declaration. Therefore, you cannot access its contents yet."
"Creation consists of allocating memory for the array. You must use the reserved word ""new"" and specify the array size. For example:
arrayName [] = new type [arraySize];"
"arrayName [] = new type [arraySize];
Once the array is created, its elements have default values until the array is initialized. The default values are as follows:
- int, short, long = 0
- float, double = 0.0
- booleans = false
- String = null"
"- float, double = 0.0
- booleans = false
- String = null
- Object = null"
how arrays work. The index of the first element in an array is zero. The index of the last element in an array is the array length minus one. The index can be any integer expression that evaluates to a value between zero and the array length minus one
". The example array has ten elements. The values of the elements are: -7, 0, 3, 8, 5, -4, 6, 6, 1, and 2."
"Memory usage in array declaration
We have two arrays declared: an array of integers and an array of points. Both arrays are declared but not initialized."
"On the right, we see the memory representation for each array. The stack memory contains the array variables ""integers"" and ""points,"" which are currently set to null. The heap memory, on the other hand, is currently empty."
"There is also a code snippet defining a class called ""Point."" This class has two integer members, x and y, and a constructor that initializes these members.
Memory usage in array creation"
"Memory usage in array creation
We have two code snippets and a diagram that illustrates memory allocation for arrays in stack and heap memory."
"The first code snippet shows the declaration of an integer array named ""integers"" with a size of 3. In the stack memory, we have a reference to this array named ""integers"". The actual array is allocated in the heap memory"
". The actual array is allocated in the heap memory. It has a length of 3 and contains three integer values: 0, 0, and 0, corresponding to the indices 0, 1, and 2."
"The second code snippet declares an array named ""points"" of type ""Point"" with a size of 2. Similar to the previous example, the stack memory holds a reference ""points"" to the array allocated in the heap"
". The array in the heap has a length of 2 and contains two ""Point"" objects, both initialized to null."
"There's a note stating that the ""new Point[2]"" expression does not invoke a constructor. This emphasizes that creating an array of objects only allocates memory for the objects but doesn't automatically call their constructors."
"Memory usage in array initialization
 memory allocation for arrays in stack and heap memory."
"On the left, we have two code snippets. The first one initializes the first element of an integer array named ""integers"" with the value 7"
". The second snippet creates a new Point object with coordinates (1, 2) and assigns it to the first element of an array named ""points""."
"On the right side, we see the memory representation of these arrays. The ""integers"" array, with a length of 3, is stored in the heap memory. It contains three elements, with the first element initialized to 7 and the remaining two initialized to 0."
"The ""points"" array, with a length of 2, is also stored in the heap memory. The first element points to a Point object, which is stored separately in the heap memory and contains the values x=1 and y=2"
". The second element of the ""points"" array is initialized to null."
"The stack memory stores the references to these arrays, namely ""integers"" and ""points""."
"Arrays
Memory usage in array declaration
int[] integers;
integers null
Stack memory
Heap memory
Point[] points;
points null
class Point {
int x;
int y;
Point (int x, int y){
this.x = x;
this.y = y;
}
}"
What is an array?
"An array is a set of elements belonging to the same data type and stored in one place. The index operator, represented by square brackets, is used to retrieve individual elements from the array"
. The length attribute returns the number of elements in the array. It's important to note that this should not be confused with the length method of the String class.
"The range of the index starts from 0 and goes up to length minus 1. It's crucial to be careful not to exceed the maximum length of the array, as doing so will result in an IndexOutOfBoundsException.
Declaration, Creation, Initialization"
"Declaration, Creation, Initialization
 how to declare, create, and initialize arrays."
"how to declare, create, and initialize arrays.
Declaration is the process of assigning an identifier to the array and specifying the data type of the elements that will be stored. This can be done in two ways:- Type ArrayName();
- Type [] ArrayName;"
"- Type [] ArrayName;
No memory is allocated to store the array during the declaration. Therefore, you cannot access its contents yet."
"Creation consists of allocating memory for the array. You must use the reserved word ""new"" and specify the array size. For example:
arrayName [] = new type [arraySize];"
"arrayName [] = new type [arraySize];
Once the array is created, its elements have default values until the array is initialized. The default values are as follows:
- int, short, long = 0
- float, double = 0.0
- booleans = false
- String = null"
"- float, double = 0.0
- booleans = false
- String = null
- Object = null"
how arrays work. The index of the first element in an array is zero. The index of the last element in an array is the array length minus one. The index can be any integer expression that evaluates to a value between zero and the array length minus one
". The example array has ten elements. The values of the elements are: -7, 0, 3, 8, 5, -4, 6, 6, 1, and 2."
"Memory usage in array declaration
We have two arrays declared: an array of integers and an array of points. Both arrays are declared but not initialized."
"On the right, we see the memory representation for each array. The stack memory contains the array variables ""integers"" and ""points,"" which are currently set to null. The heap memory, on the other hand, is currently empty."
"There is also a code snippet defining a class called ""Point."" This class has two integer members, x and y, and a constructor that initializes these members.
Memory usage in array creation"
"Memory usage in array creation
We have two code snippets and a diagram that illustrates memory allocation for arrays in stack and heap memory."
"The first code snippet shows the declaration of an integer array named ""integers"" with a size of 3. In the stack memory, we have a reference to this array named ""integers"". The actual array is allocated in the heap memory"
". The actual array is allocated in the heap memory. It has a length of 3 and contains three integer values: 0, 0, and 0, corresponding to the indices 0, 1, and 2."
"The second code snippet declares an array named ""points"" of type ""Point"" with a size of 2. Similar to the previous example, the stack memory holds a reference ""points"" to the array allocated in the heap"
". The array in the heap has a length of 2 and contains two ""Point"" objects, both initialized to null."
"There's a note stating that the ""new Point[2]"" expression does not invoke a constructor. This emphasizes that creating an array of objects only allocates memory for the objects but doesn't automatically call their constructors."
"Memory usage in array initialization
 memory allocation for arrays in stack and heap memory."
"On the left, we have two code snippets. The first one initializes the first element of an integer array named ""integers"" with the value 7"
". The second snippet creates a new Point object with coordinates (1, 2) and assigns it to the first element of an array named ""points""."
"On the right side, we see the memory representation of these arrays. The ""integers"" array, with a length of 3, is stored in the heap memory. It contains three elements, with the first element initialized to 7 and the remaining two initialized to 0."
"The ""points"" array, with a length of 2, is also stored in the heap memory. The first element points to a Point object, which is stored separately in the heap memory and contains the values x=1 and y=2"
". The second element of the ""points"" array is initialized to null."
"The stack memory stores the references to these arrays, namely ""integers"" and ""points""."
"Arrays
Memory usage in array creation
integers = new int[3];
integers
Stack memory
Heap memory
points = new Point[2];
points
Watch out! This isnot a constructorcall
length 3
integers[0] 0
integers[1] 0
integers[2] 0
length 2
points[0] null
points[1] null"
What is an array?
"An array is a set of elements belonging to the same data type and stored in one place. The index operator, represented by square brackets, is used to retrieve individual elements from the array"
. The length attribute returns the number of elements in the array. It's important to note that this should not be confused with the length method of the String class.
"The range of the index starts from 0 and goes up to length minus 1. It's crucial to be careful not to exceed the maximum length of the array, as doing so will result in an IndexOutOfBoundsException.
Declaration, Creation, Initialization"
"Declaration, Creation, Initialization
 how to declare, create, and initialize arrays."
"how to declare, create, and initialize arrays.
Declaration is the process of assigning an identifier to the array and specifying the data type of the elements that will be stored. This can be done in two ways:- Type ArrayName();
- Type [] ArrayName;"
"- Type [] ArrayName;
No memory is allocated to store the array during the declaration. Therefore, you cannot access its contents yet."
"Creation consists of allocating memory for the array. You must use the reserved word ""new"" and specify the array size. For example:
arrayName [] = new type [arraySize];"
"arrayName [] = new type [arraySize];
Once the array is created, its elements have default values until the array is initialized. The default values are as follows:
- int, short, long = 0
- float, double = 0.0
- booleans = false
- String = null"
"- float, double = 0.0
- booleans = false
- String = null
- Object = null"
how arrays work. The index of the first element in an array is zero. The index of the last element in an array is the array length minus one. The index can be any integer expression that evaluates to a value between zero and the array length minus one
". The example array has ten elements. The values of the elements are: -7, 0, 3, 8, 5, -4, 6, 6, 1, and 2."
"Memory usage in array declaration
We have two arrays declared: an array of integers and an array of points. Both arrays are declared but not initialized."
"On the right, we see the memory representation for each array. The stack memory contains the array variables ""integers"" and ""points,"" which are currently set to null. The heap memory, on the other hand, is currently empty."
"There is also a code snippet defining a class called ""Point."" This class has two integer members, x and y, and a constructor that initializes these members.
Memory usage in array creation"
"Memory usage in array creation
We have two code snippets and a diagram that illustrates memory allocation for arrays in stack and heap memory."
"The first code snippet shows the declaration of an integer array named ""integers"" with a size of 3. In the stack memory, we have a reference to this array named ""integers"". The actual array is allocated in the heap memory"
". The actual array is allocated in the heap memory. It has a length of 3 and contains three integer values: 0, 0, and 0, corresponding to the indices 0, 1, and 2."
"The second code snippet declares an array named ""points"" of type ""Point"" with a size of 2. Similar to the previous example, the stack memory holds a reference ""points"" to the array allocated in the heap"
". The array in the heap has a length of 2 and contains two ""Point"" objects, both initialized to null."
"There's a note stating that the ""new Point[2]"" expression does not invoke a constructor. This emphasizes that creating an array of objects only allocates memory for the objects but doesn't automatically call their constructors."
"Memory usage in array initialization
 memory allocation for arrays in stack and heap memory."
"On the left, we have two code snippets. The first one initializes the first element of an integer array named ""integers"" with the value 7"
". The second snippet creates a new Point object with coordinates (1, 2) and assigns it to the first element of an array named ""points""."
"On the right side, we see the memory representation of these arrays. The ""integers"" array, with a length of 3, is stored in the heap memory. It contains three elements, with the first element initialized to 7 and the remaining two initialized to 0."
"The ""points"" array, with a length of 2, is also stored in the heap memory. The first element points to a Point object, which is stored separately in the heap memory and contains the values x=1 and y=2"
". The second element of the ""points"" array is initialized to null."
"The stack memory stores the references to these arrays, namely ""integers"" and ""points""."
"Arrays
Memory usage in array initialization
integers[0] = 7;
integers
Stack memory
Heap memory
points[0] = new Point(1,2);
points
length 3
integers[0] 7
integers[1] 0
integers[2] 0
length 2
points[0]
points[1] null
x 1
y 2"
What is an array?
"An array is a set of elements belonging to the same data type and stored in one place. The index operator, represented by square brackets, is used to retrieve individual elements from the array"
. The length attribute returns the number of elements in the array. It's important to note that this should not be confused with the length method of the String class.
"The range of the index starts from 0 and goes up to length minus 1. It's crucial to be careful not to exceed the maximum length of the array, as doing so will result in an IndexOutOfBoundsException.
Declaration, Creation, Initialization"
"Declaration, Creation, Initialization
 how to declare, create, and initialize arrays."
"how to declare, create, and initialize arrays.
Declaration is the process of assigning an identifier to the array and specifying the data type of the elements that will be stored. This can be done in two ways:- Type ArrayName();
- Type [] ArrayName;"
"- Type [] ArrayName;
No memory is allocated to store the array during the declaration. Therefore, you cannot access its contents yet."
"Creation consists of allocating memory for the array. You must use the reserved word ""new"" and specify the array size. For example:
arrayName [] = new type [arraySize];"
"arrayName [] = new type [arraySize];
Once the array is created, its elements have default values until the array is initialized. The default values are as follows:
- int, short, long = 0
- float, double = 0.0
- booleans = false
- String = null"
"- float, double = 0.0
- booleans = false
- String = null
- Object = null"
how arrays work. The index of the first element in an array is zero. The index of the last element in an array is the array length minus one. The index can be any integer expression that evaluates to a value between zero and the array length minus one
". The example array has ten elements. The values of the elements are: -7, 0, 3, 8, 5, -4, 6, 6, 1, and 2."
"Memory usage in array declaration
We have two arrays declared: an array of integers and an array of points. Both arrays are declared but not initialized."
"On the right, we see the memory representation for each array. The stack memory contains the array variables ""integers"" and ""points,"" which are currently set to null. The heap memory, on the other hand, is currently empty."
"There is also a code snippet defining a class called ""Point."" This class has two integer members, x and y, and a constructor that initializes these members.
Memory usage in array creation"
"Memory usage in array creation
We have two code snippets and a diagram that illustrates memory allocation for arrays in stack and heap memory."
"The first code snippet shows the declaration of an integer array named ""integers"" with a size of 3. In the stack memory, we have a reference to this array named ""integers"". The actual array is allocated in the heap memory"
". The actual array is allocated in the heap memory. It has a length of 3 and contains three integer values: 0, 0, and 0, corresponding to the indices 0, 1, and 2."
"The second code snippet declares an array named ""points"" of type ""Point"" with a size of 2. Similar to the previous example, the stack memory holds a reference ""points"" to the array allocated in the heap"
". The array in the heap has a length of 2 and contains two ""Point"" objects, both initialized to null."
"There's a note stating that the ""new Point[2]"" expression does not invoke a constructor. This emphasizes that creating an array of objects only allocates memory for the objects but doesn't automatically call their constructors."
"Memory usage in array initialization
 memory allocation for arrays in stack and heap memory."
"On the left, we have two code snippets. The first one initializes the first element of an integer array named ""integers"" with the value 7"
". The second snippet creates a new Point object with coordinates (1, 2) and assigns it to the first element of an array named ""points""."
"On the right side, we see the memory representation of these arrays. The ""integers"" array, with a length of 3, is stored in the heap memory. It contains three elements, with the first element initialized to 7 and the remaining two initialized to 0."
"The ""points"" array, with a length of 2, is also stored in the heap memory. The first element points to a Point object, which is stored separately in the heap memory and contains the values x=1 and y=2"
". The second element of the ""points"" array is initialized to null."
"The stack memory stores the references to these arrays, namely ""integers"" and ""points""."
"Arrays (examples)Declaration, Creation, Initialization
Arrays with primitive types
int a[];              //declaration
a = new int[3]  //creation
a[0]=1;            //initialization
a[1]=2;
a[2]=3;
int a[] = new int[3]  //declaration, creation"
"a[1]=2;
a[2]=3;
int a[] = new int[3]  //declaration, creation
a[0]=1;                   //initialization
a[1]=2;
a[2]=3;
int a[] = new int[3]  // declaration, creation
for(int i=0; i<a.length;i++){ //initialization
a[i]=i+1;
}"
"for(int i=0; i<a.length;i++){ //initialization
a[i]=i+1;
}
int a[] = {1, 2, 3};  / /Declaration, creation, initialization
Arrays with objects (reference types)
MyClass a[];      //declaration
a = new MyClass[3] //creation
a[0]=new MyClass(param1);"
"a = new MyClass[3] //creation
a[0]=new MyClass(param1);
a[1]=new MyClass(param2);
a[2]=new MyClass(param3);
MyClass a[] = new MyClass[3]//initialization
a[0]=new MyClass(param1);
a[1]=new MyClass(param2);
a[2]=new MyClass(param3);"
"a[1]=new MyClass(param2);
a[2]=new MyClass(param3);
MyClass a[] = new MyClass[3]
//initialization
for(int i=0; i<a.length;i++){
a[i]=new MyClass(param-i);
}
MyClass[] a = {new MyClass(param1), new MyClass(param2), new myClass(param3)};"
"Arrays (common errors):Declaration, Creation, Initialization
public class ArrayExamples{
public static void main(String args[]){
double myArray[];
Syntaxis
System.out.println(myArray[0]);
WRONG
}
}
variable myArray may not have been initialized
compile"
"}
}
variable myArray may not have been initialized
compile
Compilationfailure
When an array has been declared but not created orinitialized, you have no access to its elements. The programdoes not compile and prints an error message"
"Arrays (Common errors):
Declaration, creation, inicialization
public class ArrayExamples2{
public static void main(String args[]){
int myArrayOfIntegers[] = new int[10];
float myArrayOfReals[]= new float[10];
boolean myArrayOfBooleans[] = new boolean[10];"
"boolean myArrayOfBooleans[] = new boolean[10];
char myArrayOfCharacters[] = new char[10];
String myArrayOfStrings[] = new String[10];
Object myArrayOfObjects[] = new Object[10];System.out.println(“Integer by default: "" + myArrayOfIntegers[0]);"
"System.out.println(""Real by default : "" + myArrayOfReals[0]);
System.out.println(""Boolean by default : "" + myArrayOfBooleans[0]);
System.out.println(“Character by default : "" + myArrayOfCharacters[0]);
compile
Execute"
"compile
Execute
System.out.println(""String by default : "" + myArrayOfStrings[0]);
System.out.println(""Object by default : "" + myArrayOfObjects[0]);
}
When the array has been declared and created
}"
"}
When the array has been declared and created
}
but not initialized we can retrieve its elements butthey have their default value
Integer by default: 0
Real by default : 0.0
Boolean by default : false
Character by default :
String by default : null"
"Character by default :
String by default : null
Object by default : null"
"N-dimensional Arrays
• When we need more than one index to
retrieve the elements of an array






A B C
D E F
G H I
a[0][2]=‘C’

r


j
a
k
b
s

l
c
a
d
b
e
c
f



t
c
f

t
l
ñ
q
w
z
i
i
h
g"
"a[0][2][1]=‘l’
char a[][];                   //declaration
a = new char[3][3]     //creation
a[0][0]=‘A’;                 //initialization
...
char a[][][];                   //declaration
a = new char[3][3][3]   //creation"
"a = new char[3][3][3]   //creation
a[0][0][0]=‘a’                // initialization
..."
"When we need more than one index to retrieve the elements of an array, we can use N-dimensional arrays. For example, a 2-dimensional array can be visualized as a table with rows and columns"
". The element in the first row and third column can be accessed using the indices [0][2]. Similarly, a 3-dimensional array can be visualized as a cube, where each element is identified by three indices: row, column, and depth"
". The element in the first row, third column, and second depth can be accessed using the indices [0][2][1]."
"The code snippets show how to declare, create, and initialize 2-dimensional and 3-dimensional arrays in a programming language"
". For instance, ""char a[][]"" declares a 2-dimensional array of characters, ""a = new char[3][3]"" creates a 3x3 array, and ""a[0][0]='A'"" assigns the character 'A' to the first element"
". Similarly, for a 3-dimensional array, ""char a[][][]"" declares it, ""a = new char[3][3][3]"" creates a 3x3x3 array, and ""a[0][0][0]='a'"" initializes the first element with 'a'."
"N-dimensional Arrays
Examples
Direct declaration and creation
null
//Declaration and creation
String [][]myArray = new String[3][4]
null
Declaration and creation step by step
null
null
null
null
null
null
null
null
null
null"
"null
null
null
null
null
null
null
null
null
null
int [][] myArray ;                       myArray = new int[numRows][];for(int i=0; i<numRows; i++)    
myArray[i]= new int[numColumns];
// Array declaration
// Creating the reference array for rows"
"// Array declaration
// Creating the reference array for rows
// Allocating memory for rows
Other examples
// Array 3x3 initialized to 0
int [][] a= new int[3][3];
int [][] b= {{1, 2, 3},
{4, 5, 6}};"
"int [][] c = new[3][];
c[0] = new int[5];
c[1] = new int[4];
c[2] = new int[3];"
"When we need more than one index to retrieve the elements of an array, we can use N-dimensional arrays. For example, a 2-dimensional array can be visualized as a table with rows and columns"
". The element in the first row and third column can be accessed using the indices [0][2]. Similarly, a 3-dimensional array can be visualized as a cube, where each element is identified by three indices: row, column, and depth"
". The element in the first row, third column, and second depth can be accessed using the indices [0][2][1]."
"The code snippets show how to declare, create, and initialize 2-dimensional and 3-dimensional arrays in a programming language"
". For instance, ""char a[][]"" declares a 2-dimensional array of characters, ""a = new char[3][3]"" creates a 3x3 array, and ""a[0][0]='A'"" assigns the character 'A' to the first element"
". Similarly, for a 3-dimensional array, ""char a[][][]"" declares it, ""a = new char[3][3][3]"" creates a 3x3x3 array, and ""a[0][0][0]='a'"" initializes the first element with 'a'."
"Arrays
Homework
• Write a program that multiplies twobi-dimensional arrays of integers"
What is an array?
"An array is a set of elements belonging to the same data type and stored in one place. The index operator, represented by square brackets, is used to retrieve individual elements from the array"
. The length attribute returns the number of elements in the array. It's important to note that this should not be confused with the length method of the String class.
"The range of the index starts from 0 and goes up to length minus 1. It's crucial to be careful not to exceed the maximum length of the array, as doing so will result in an IndexOutOfBoundsException.
Declaration, Creation, Initialization"
"Declaration, Creation, Initialization
 how to declare, create, and initialize arrays."
"how to declare, create, and initialize arrays.
Declaration is the process of assigning an identifier to the array and specifying the data type of the elements that will be stored. This can be done in two ways:- Type ArrayName();
- Type [] ArrayName;"
"- Type [] ArrayName;
No memory is allocated to store the array during the declaration. Therefore, you cannot access its contents yet."
"Creation consists of allocating memory for the array. You must use the reserved word ""new"" and specify the array size. For example:
arrayName [] = new type [arraySize];"
"arrayName [] = new type [arraySize];
Once the array is created, its elements have default values until the array is initialized. The default values are as follows:
- int, short, long = 0
- float, double = 0.0
- booleans = false
- String = null"
"- float, double = 0.0
- booleans = false
- String = null
- Object = null"
how arrays work. The index of the first element in an array is zero. The index of the last element in an array is the array length minus one. The index can be any integer expression that evaluates to a value between zero and the array length minus one
". The example array has ten elements. The values of the elements are: -7, 0, 3, 8, 5, -4, 6, 6, 1, and 2."
"Memory usage in array declaration
We have two arrays declared: an array of integers and an array of points. Both arrays are declared but not initialized."
"On the right, we see the memory representation for each array. The stack memory contains the array variables ""integers"" and ""points,"" which are currently set to null. The heap memory, on the other hand, is currently empty."
"There is also a code snippet defining a class called ""Point."" This class has two integer members, x and y, and a constructor that initializes these members.
Memory usage in array creation"
"Memory usage in array creation
We have two code snippets and a diagram that illustrates memory allocation for arrays in stack and heap memory."
"The first code snippet shows the declaration of an integer array named ""integers"" with a size of 3. In the stack memory, we have a reference to this array named ""integers"". The actual array is allocated in the heap memory"
". The actual array is allocated in the heap memory. It has a length of 3 and contains three integer values: 0, 0, and 0, corresponding to the indices 0, 1, and 2."
"The second code snippet declares an array named ""points"" of type ""Point"" with a size of 2. Similar to the previous example, the stack memory holds a reference ""points"" to the array allocated in the heap"
". The array in the heap has a length of 2 and contains two ""Point"" objects, both initialized to null."
"There's a note stating that the ""new Point[2]"" expression does not invoke a constructor. This emphasizes that creating an array of objects only allocates memory for the objects but doesn't automatically call their constructors."
"Memory usage in array initialization
 memory allocation for arrays in stack and heap memory."
"On the left, we have two code snippets. The first one initializes the first element of an integer array named ""integers"" with the value 7"
". The second snippet creates a new Point object with coordinates (1, 2) and assigns it to the first element of an array named ""points""."
"On the right side, we see the memory representation of these arrays. The ""integers"" array, with a length of 3, is stored in the heap memory. It contains three elements, with the first element initialized to 7 and the remaining two initialized to 0."
"The ""points"" array, with a length of 2, is also stored in the heap memory. The first element points to a Point object, which is stored separately in the heap memory and contains the values x=1 and y=2"
". The second element of the ""points"" array is initialized to null."
"The stack memory stores the references to these arrays, namely ""integers"" and ""points""."
"Method declaration
public class Car{
//Attribute declaration
private String color;
private int speed;
//Method declaration
public void start(){
//implementation
}
public void goForward(int speed){
//implementation
}
public String getColor(){"
"//implementation
}
public String getColor(){
//implementation
return color;
}
}
Car.java
Car.java
Style
• Intuitive names
• 1st letter lower-case
• No blanks
• Camel-case myMethod()
• Indentation"
"how to declare methods in Java, using a code example of a class named ""Car"".
The code shows the structure of a class with attributes and methods.
There are two attributes declared as private: ""color"" of type String and ""speed"" of type int."
"There are also three methods declared as public: ""start"" which takes no arguments and returns nothing, ""goForward"" which takes an integer ""speed"" as argument and returns nothing, and ""getColor"" which takes no arguments and returns a String."
"The implementation of each method is marked as a comment ""//implementation""."
"The code style recommendations for Java are listed on the right side of the slide: use intuitive names, start variable and method names with a lowercase letter, use camel case for names with multiple words, do not include blanks in names"
", do not include blanks in names, and use indentation"
.
"We see a code snippet with a method declaration. The method is called goForward, it takes an integer called speed as input and returns nothing. The method is declared inside a class called Car."
"The general syntax for a method declaration is: first the modifiers, then the return type, then the method name, then the parameters in parenthesis, and finally the implementation in curly braces."
"We see a code snippet showing the declaration of a method in Java. The method is named ""getColor"", it is public and returns a String. It takes no parameters"
". It takes no parameters. The implementation is not shown in this example, but we see a comment indicating where it should be. A diagram shows the concept of a method: it receives parameters as input and returns a result"
". The syntax of a method declaration is shown below the code: it consists of modifiers, a return type, a name, parameters in parentheses and a body in curly braces."
"Methods have zero, one, or more arguments, also called parameters. They define the data type of the result in their declaration, except for constructors. They can have local variables, which are not initialized by default."
"A method cannot contain other methods inside its body.
If one method produces a result, the last sentence of its execution must be a return sentence."
"Method declaration
public class Car{
//...
public void goForward(int speed){
//implementation
}
//...
}
parameters
(param1, param2)
Method
Car.java
(modifiers) void methodName(type1 param1, type2 param2){
// implementation
}"
"how to declare methods in Java, using a code example of a class named ""Car"".
The code shows the structure of a class with attributes and methods.
There are two attributes declared as private: ""color"" of type String and ""speed"" of type int."
"There are also three methods declared as public: ""start"" which takes no arguments and returns nothing, ""goForward"" which takes an integer ""speed"" as argument and returns nothing, and ""getColor"" which takes no arguments and returns a String."
"The implementation of each method is marked as a comment ""//implementation""."
"The code style recommendations for Java are listed on the right side of the slide: use intuitive names, start variable and method names with a lowercase letter, use camel case for names with multiple words, do not include blanks in names"
", do not include blanks in names, and use indentation"
.
"We see a code snippet with a method declaration. The method is called goForward, it takes an integer called speed as input and returns nothing. The method is declared inside a class called Car."
"The general syntax for a method declaration is: first the modifiers, then the return type, then the method name, then the parameters in parenthesis, and finally the implementation in curly braces."
"We see a code snippet showing the declaration of a method in Java. The method is named ""getColor"", it is public and returns a String. It takes no parameters"
". It takes no parameters. The implementation is not shown in this example, but we see a comment indicating where it should be. A diagram shows the concept of a method: it receives parameters as input and returns a result"
". The syntax of a method declaration is shown below the code: it consists of modifiers, a return type, a name, parameters in parentheses and a body in curly braces."
"Methods have zero, one, or more arguments, also called parameters. They define the data type of the result in their declaration, except for constructors. They can have local variables, which are not initialized by default."
"A method cannot contain other methods inside its body.
If one method produces a result, the last sentence of its execution must be a return sentence."
"Method declaration
public class Car{
//...
public String getColor(){
//implementation
return color;
}
//...
}
Car.java
parameters
(param1, param2)
Method
Result
(modifiers) returnType methodName(type1 param1, type2 param2){
//implementation"
"//implementation
return expression;
}"
"how to declare methods in Java, using a code example of a class named ""Car"".
The code shows the structure of a class with attributes and methods.
There are two attributes declared as private: ""color"" of type String and ""speed"" of type int."
"There are also three methods declared as public: ""start"" which takes no arguments and returns nothing, ""goForward"" which takes an integer ""speed"" as argument and returns nothing, and ""getColor"" which takes no arguments and returns a String."
"The implementation of each method is marked as a comment ""//implementation""."
"The code style recommendations for Java are listed on the right side of the slide: use intuitive names, start variable and method names with a lowercase letter, use camel case for names with multiple words, do not include blanks in names"
", do not include blanks in names, and use indentation"
.
"We see a code snippet with a method declaration. The method is called goForward, it takes an integer called speed as input and returns nothing. The method is declared inside a class called Car."
"The general syntax for a method declaration is: first the modifiers, then the return type, then the method name, then the parameters in parenthesis, and finally the implementation in curly braces."
"We see a code snippet showing the declaration of a method in Java. The method is named ""getColor"", it is public and returns a String. It takes no parameters"
". It takes no parameters. The implementation is not shown in this example, but we see a comment indicating where it should be. A diagram shows the concept of a method: it receives parameters as input and returns a result"
". The syntax of a method declaration is shown below the code: it consists of modifiers, a return type, a name, parameters in parentheses and a body in curly braces."
"Methods have zero, one, or more arguments, also called parameters. They define the data type of the result in their declaration, except for constructors. They can have local variables, which are not initialized by default."
"A method cannot contain other methods inside its body.
If one method produces a result, the last sentence of its execution must be a return sentence."
"Method declaration
• Methods
– Have 0, 1 or more arguments (parameters)
– Define the data type of the result in their declaration
(except constructors)
– Can have local variables. These variables are not
initialized by default"
"initialized by default
• A method cannot contain other methods inside
its body
• If one method produces a result, the last
sentence of its execution must be a returnsentence"
"how to declare methods in Java, using a code example of a class named ""Car"".
The code shows the structure of a class with attributes and methods.
There are two attributes declared as private: ""color"" of type String and ""speed"" of type int."
"There are also three methods declared as public: ""start"" which takes no arguments and returns nothing, ""goForward"" which takes an integer ""speed"" as argument and returns nothing, and ""getColor"" which takes no arguments and returns a String."
"The implementation of each method is marked as a comment ""//implementation""."
"The code style recommendations for Java are listed on the right side of the slide: use intuitive names, start variable and method names with a lowercase letter, use camel case for names with multiple words, do not include blanks in names"
", do not include blanks in names, and use indentation"
.
"We see a code snippet with a method declaration. The method is called goForward, it takes an integer called speed as input and returns nothing. The method is declared inside a class called Car."
"The general syntax for a method declaration is: first the modifiers, then the return type, then the method name, then the parameters in parenthesis, and finally the implementation in curly braces."
"We see a code snippet showing the declaration of a method in Java. The method is named ""getColor"", it is public and returns a String. It takes no parameters"
". It takes no parameters. The implementation is not shown in this example, but we see a comment indicating where it should be. A diagram shows the concept of a method: it receives parameters as input and returns a result"
". The syntax of a method declaration is shown below the code: it consists of modifiers, a return type, a name, parameters in parentheses and a body in curly braces."
"Methods have zero, one, or more arguments, also called parameters. They define the data type of the result in their declaration, except for constructors. They can have local variables, which are not initialized by default."
"A method cannot contain other methods inside its body.
If one method produces a result, the last sentence of its execution must be a return sentence."
"Constructor methods
• When an object is created, its members are initialized with a
constructor method
• Constructor methods:
– Have the same name as their container class
– Do not have a returned data type in their declaration"
"– Do not have a returned data type in their declaration
• There should be at least one constructor per class
• There may be several constructors, which will be distinguished
•
•
by the parameters accepted (overload)"
"•
•
by the parameters accepted (overload)
If there are no declared constructors, a default constructor iscreated and this default constructor initializes all variables totheir own default value"
"If the class has a constructor, the default constructor does notexists, but the programmer can declare a constructor withoutparameters with the same function than the default one."
"- When an object is created, its members are initialized with a constructor method.
- :
    - Have the same name as their container class.
    - Do not have a returned data type in their declaration.
- There should be at least one constructor per class."
"- There should be at least one constructor per class.
- There may be several constructors, which will be distinguished by the parameters accepted (overload)."
"- If there are no declared constructors, a default constructor is created and this default constructor initializes all variables to their own default value."
"- If the class has a constructor, the default constructor does not exist, but the programmer can declare a constructor without parameters with the same function than the default one."
"The main method
• It is the first  method that the runtime system
calls to execute an application.
• The parameters of the main (String args[ ])"
"• The parameters of the main (String args[ ])
represent an array of Strings that stores thearguments that are written in the commandline to run the application
java HelloWorld arg1 arg2...
• void indicates that there are no return values"
"• void indicates that there are no return values
• static indicates that it is a global method. Thismethod is the same for every instance of theclass"
- The first method that the runtime system calls to execute an application is the main method.- The parameters of the main method are enclosed in parentheses after the word main
". This is an array of Strings that stores the arguments that are written in the command line to run the application. For example, ""java HelloWorld arg1 arg2..."""
"- The word void before the main method indicates that there are no return values.
- The word static indicates that it is a global method. This method is the same for every instance of the class."
"Systems Programming
Imperative Java
Department of Telematic Engineering
CONTENTS ARE MOSTLY BASED ON THE WORK BY:
M. Carmen Fernández Panadero and Natividad Martínez Madrid"
"Java Language Code Structure
Department of Telematic Engineering
Contents are mostly based on the work by: M. Carmen Fernández Panadero and Natividad Martínez Madrid
Imperative Java
Department of Telematic Engineering"
"Imperative Java
Department of Telematic Engineering
Contents are mostly based on the work by M. Carmen Fernández Panadero and Natividad Martínez Madrid"
Scenario  III:Method implementation
"• Once the programmers’ meeting has finished, you have to showyour expertise before joining the team. Your boss asks you toimplement several methods"
". Your boss asks you toimplement several methods. As your first task, the methods aresimple and work independently (do not invoke other attributes ormethods)"
"• Objective:
– Be able to decompose a problem in order to identify the basic steps for
solving it (algorithms design and representation)
– Use the basic structures of a programming language, variables, operators"
"and flow control statements (loops, conditionals) to implement an algorithm
• Work plan:
– Train yourself in the design of algorithms and their representation. Break problems in
small steps in order to solve them without using code."
"small steps in order to solve them without using code.
– Memorize the syntax of Java in terms of (operators, loops and conditionals)
– Train in use Java to implement previously designed algorithms"
"– Train in use Java to implement previously designed algorithms
– Get implementing ease and speed. Resolve typical problems (e.g.: in arrays, print all
its elements, retrieve an specific element, swap elements between two positions, sorting)"
"Step I: Thinking of the algorithmWhat tools do we have to represent algorithms?
• Once we have thought about thealgorithm structure, we need torepresent the steps to solve it:
– Pseudocode
– Flowcharts, organigrams
• Figures: representing sentences"
"– Flowcharts, organigrams
• Figures: representing sentences
• Flow lines: representing the order in which
they are executed"
Step I: Thinking of the algorithmFlowcharts vs Pseudocode
"Step II: Algorithm implementation
What kind of expressions can we use in the method body?
• Variables
• Operators
– By type
• Assignment
• Arithmetical
• Relational• Logical
• Conditional
– By number of operands
• Unary
• Binary"
"• Conditional
– By number of operands
• Unary
• Binary
• Operations with objects(not for this scenario)
– Object creation
– Attribute and method
invocation
• Flow control structures(can be stacked and nested)
– Sequence
– Iteration (loops)
• For
• While"
"– Sequence
– Iteration (loops)
• For
• While
• Do-while
– Selection (conditionals)
•
•
If
If-else
• Switch
• Breaking up the flow of
execution
• Break
• Continue
• Exception (not in this scenario)"
"the different types of expressions that can be used in a method body.
It is structured in 4 sections: Variables, Operators, Operations with objects, and Flow control structures."
"Variables and Operators are not detailed, it is simply stated that they can be used.
Operations with objects are not considered for this specific scenario, but  Object creation as well as Attribute and method invocation."
"Finally, Flow control structures, which can be stacked and nested, are listed as follows:
- Sequence
- Iteration (loops): For, While, Do-while
- Selection (conditionals): If, If-else, Switch"
"- Selection (conditionals): If, If-else, Switch
- Breaking up the flow of execution: Break, Continue, Exception (not in this scenario)"
"Operators
• By number of operands
– Unary (one operand e.g.: ++, --)
– Binary (two operands e.g.: &&, %)
• By type of operator
– Assignment (=)
– Arithmetical (+, -, *, /, %)
– Relational (>, >=, <, <=, ==, !=)
– Logical (&&, II, !)"
"– Relational (>, >=, <, <=, ==, !=)
– Logical (&&, II, !)
– Conditional operator (condition?sentence1:sentence2)
System.out.println( studentGrade >= 5 ? “pass” : “not pass” );"
"different types of operators.
 can be classified by the number of operands:
- Unary operators: they take one operand, for example: ++, --
- Binary operators: they take two operands, for example: &&, %
 can also be classified by type:
- Assignment: ="
"can also be classified by type:
- Assignment: =
- Arithmetical: +, -, *, /, %
- Relational: >, >=, <, <=, ==, !=
- Logical: &&, ||, !
- Conditional: condition ? sentence1 : sentence2
There is an example of a conditional operator:"
"There is an example of a conditional operator:
System.out.println( studentGrade >= 5 ? ""pass"" : ""not pass"");
Notes to remember
- Unary operators:  -  ""i++"" first evaluates then increments.
  - ""++i"" first increments then evaluates."
"- ""++i"" first increments then evaluates.
  - Example: if i equals 3, ""a equals i++"" results in a equals 3, while ""a equals ++i"" results in a equals 4.
- Binary operators can be abbreviated: ""x+=3"" equals to ""x = x+3"".
- Assignment vs. comparison:"
"- Assignment vs. comparison:
  - The ""="" operator assigns a value. Example: ""var = 5"" assigns 5 to the variable var.
  - The ""=="" operator compares. Example: ""var == 5"" returns true after the previous assignment."
- The conditional operator is harder to understand than a simple if-else statement. Try not to use it.
"Operators
Notes to remember
• Unary
– i++ (first evaluates then increments)
– ++i (first increments then evaluate)
– E.g. if i=3
• a = i++ results in a = 3
• a = ++i result in a = 4
• Binary (can be abbreviated)
– x+=3 equals to  x= x+3"
"• Binary (can be abbreviated)
– x+=3 equals to  x= x+3
• Assignment vs. comparison
– The “=” operator assigns a value
• E.g. var = 5, assigns 5 to  var
– The “ == “ operator compares
• E.g. var == 5, returns true (after the previous assignment)"
"• E.g. var == 5, returns true (after the previous assignment)
• The conditional operator is harder to understand than a simple
if-else. Try not to use it"
"different types of operators.
 can be classified by the number of operands:
- Unary operators: they take one operand, for example: ++, --
- Binary operators: they take two operands, for example: &&, %
 can also be classified by type:
- Assignment: ="
"can also be classified by type:
- Assignment: =
- Arithmetical: +, -, *, /, %
- Relational: >, >=, <, <=, ==, !=
- Logical: &&, ||, !
- Conditional: condition ? sentence1 : sentence2
There is an example of a conditional operator:"
"There is an example of a conditional operator:
System.out.println( studentGrade >= 5 ? ""pass"" : ""not pass"");
Notes to remember
- Unary operators:  -  ""i++"" first evaluates then increments.
  - ""++i"" first increments then evaluates."
"- ""++i"" first increments then evaluates.
  - Example: if i equals 3, ""a equals i++"" results in a equals 3, while ""a equals ++i"" results in a equals 4.
- Binary operators can be abbreviated: ""x+=3"" equals to ""x = x+3"".
- Assignment vs. comparison:"
"- Assignment vs. comparison:
  - The ""="" operator assigns a value. Example: ""var = 5"" assigns 5 to the variable var.
  - The ""=="" operator compares. Example: ""var == 5"" returns true after the previous assignment."
- The conditional operator is harder to understand than a simple if-else statement. Try not to use it.
"Selection sentences
(Conditionals)
•
•
If
if( condition) {
sentences1;
}
If-else
• switch
switch ( expression ) {
case value1:
sentences1;
break;
case value2:
sentences2;
break;
default:
sentences3;
}
if( condition) {
sentences1;
}else{
sentences2;
}"
"sentences3;
}
if( condition) {
sentences1;
}else{
sentences2;
}
if( condition) {
sentences1;
}else if(condition2){
sentences2;
}else{
sentences3;
}"
"Notes to remember for if and if-else
- Indenting the code contributes to its readability
- Braces { } fix the scope of every element declared between them
- No braces is like to put them only in the first sentence
We can see a code snippet:
```java"
"We can see a code snippet:
```java
if (studentGrade >= 5)
  System.out.println ( ""Pass"" );
else
  System.out.println(""Not pass"");
```"
"else
  System.out.println(""Not pass"");
```
This code snippet checks if the variable `studentGrade` is greater than or equal to 5. If it is, it prints ""Pass"" to the console. Otherwise, it prints ""Not pass"" to the console.
Notes to remember for switch"
"Notes to remember for switch
Valid expression types are: byte, short, int, long, char, String.
Some examples are: int num equals 5 and then switch num, char character equals 'z' switch character, String string equals ""myString"" switch myString."
"If you do not use breaks, all the following code blocks will be executed until a break or end of the switch is found.
It is not necessary to place the block code associated with each case between braces."
"Selection sentences
Notes to remember for if and if-else
Indenting the code contributes to its readability
•
• Braces { } fix the scope of every element declared
between them
• No braces { } is like to put them only in the first
sentence"
"• No braces { } is like to put them only in the first
sentence
if (studentGrade >= 5)
System.out.println ( “Pass” );
else
System.out.println (“Not pass”);"
"Notes to remember for if and if-else
- Indenting the code contributes to its readability
- Braces { } fix the scope of every element declared between them
- No braces is like to put them only in the first sentence
We can see a code snippet:
```java"
"We can see a code snippet:
```java
if (studentGrade >= 5)
  System.out.println ( ""Pass"" );
else
  System.out.println(""Not pass"");
```"
"else
  System.out.println(""Not pass"");
```
This code snippet checks if the variable `studentGrade` is greater than or equal to 5. If it is, it prints ""Pass"" to the console. Otherwise, it prints ""Not pass"" to the console.
Notes to remember for switch"
"Notes to remember for switch
Valid expression types are: byte, short, int, long, char, String.
Some examples are: int num equals 5 and then switch num, char character equals 'z' switch character, String string equals ""myString"" switch myString."
"If you do not use breaks, all the following code blocks will be executed until a break or end of the switch is found.
It is not necessary to place the block code associated with each case between braces."
"Selection sentences
Notes to remember for switch
• Valid expression types: byte, short, int, long,
char,  String
• Examples:
– int num=5; switch(num){}
– char character=‘z’ switch(character){}
– String string=“myString” switch(myString){}"
"– String string=“myString” switch(myString){}
If you do not use breaks, all the following code-blockswill be executed until a break or end of the switch isfound
It is not necessary to place the block-code associatedwith each case between braces { }
•
•"
"Notes to remember for if and if-else
- Indenting the code contributes to its readability
- Braces { } fix the scope of every element declared between them
- No braces is like to put them only in the first sentence
We can see a code snippet:
```java"
"We can see a code snippet:
```java
if (studentGrade >= 5)
  System.out.println ( ""Pass"" );
else
  System.out.println(""Not pass"");
```"
"else
  System.out.println(""Not pass"");
```
This code snippet checks if the variable `studentGrade` is greater than or equal to 5. If it is, it prints ""Pass"" to the console. Otherwise, it prints ""Not pass"" to the console.
Notes to remember for switch"
"Notes to remember for switch
Valid expression types are: byte, short, int, long, char, String.
Some examples are: int num equals 5 and then switch num, char character equals 'z' switch character, String string equals ""myString"" switch myString."
"If you do not use breaks, all the following code blocks will be executed until a break or end of the switch is found.
It is not necessary to place the block code associated with each case between braces."
"Iteration sentences
(Loops)
• For:
for( initialization;condition;update) {
sentences;
}
• While:
while( condition) {
sentences;
}
• Do-while:
do {
sentences;
}while(condition);"
Notes to remember
- When the loop has several sentences in initialization comparison or update they will be separated by commas An example of for loop with multiple statements is shown with the syntax for i equal to zero sum equals zero i less than or equal to n i plus
equal to zero sum equals zero i less than or equal to n i plus plus comma sum plus equal to n Inside the for loop body we have sentences and the for loop is closed
"- Nested loops Program slows down They are used to cover n dimensional arrays one loop per dimension
- The sentences in a while might never run in a do while sentences are executed at least once
- Avoid infinite loops always check termination condition"
"- Avoid infinite loops always check termination condition
- A for loop always can be converted into a while loop and vice versa
Comparative
 three different types of loops: for, while, and do-while."
"The table shows that the ""for"" loop is the only one that initializes variables and updates them within the loop definition. All three loops have a condition that determines whether the loop continues to execute"
". The ""do-while"" loop is the only one that is guaranteed to execute at least once, because the condition is checked at the end of the loop."
"The table also shows that the ""for"" loop is the most commonly used type of loop, followed by the ""while"" loop. The ""do-while"" loop is used less often.
Usage patterns
 when to use ""while"" and ""for"" loops."
"Usage patterns
 when to use ""while"" and ""for"" loops.
If the number of iterations is known, for example when iterating over an array, we should use a ""for"" loop.
If the number of iterations is unknown, we should use a ""while"" loop."
"If we need to increase variables in each cycle, we can use both ""for"" and ""while"" loops.
If we need to initialize variables, we can use both ""for"" and ""while"" loops.
 with two examples:
- Reading a file with a ""while"" loop."
"with two examples:
- Reading a file with a ""while"" loop.
- Covering an array with a ""for"" loop."
"Iteration sentences
(Examples: for)
• Examples
int i=0;
int i=0;
for (i =0;i<10;)
for (i=13;i<10; i++)
{ i=i+2;}
{ i=i+2;}
int i=4;
for (;i<10;)
{ i=i+2;}
int i=0;
for ( ; ; )
{ i=i+2;}
int i sum;
for (i =0, sum=5;i<10;sum+=i)
{ i=i+8;}"
"{ i=i+2;}
int i sum;
for (i =0, sum=5;i<10;sum+=i)
{ i=i+8;}
How many times are these loops executed?
What is the value of “i” in each example at the end of the loop?"
Notes to remember
- When the loop has several sentences in initialization comparison or update they will be separated by commas An example of for loop with multiple statements is shown with the syntax for i equal to zero sum equals zero i less than or equal to n i plus
equal to zero sum equals zero i less than or equal to n i plus plus comma sum plus equal to n Inside the for loop body we have sentences and the for loop is closed
"- Nested loops Program slows down They are used to cover n dimensional arrays one loop per dimension
- The sentences in a while might never run in a do while sentences are executed at least once
- Avoid infinite loops always check termination condition"
"- Avoid infinite loops always check termination condition
- A for loop always can be converted into a while loop and vice versa
Comparative
 three different types of loops: for, while, and do-while."
"The table shows that the ""for"" loop is the only one that initializes variables and updates them within the loop definition. All three loops have a condition that determines whether the loop continues to execute"
". The ""do-while"" loop is the only one that is guaranteed to execute at least once, because the condition is checked at the end of the loop."
"The table also shows that the ""for"" loop is the most commonly used type of loop, followed by the ""while"" loop. The ""do-while"" loop is used less often.
Usage patterns
 when to use ""while"" and ""for"" loops."
"Usage patterns
 when to use ""while"" and ""for"" loops.
If the number of iterations is known, for example when iterating over an array, we should use a ""for"" loop.
If the number of iterations is unknown, we should use a ""while"" loop."
"If we need to increase variables in each cycle, we can use both ""for"" and ""while"" loops.
If we need to initialize variables, we can use both ""for"" and ""while"" loops.
 with two examples:
- Reading a file with a ""while"" loop."
"with two examples:
- Reading a file with a ""while"" loop.
- Covering an array with a ""for"" loop."
"Iteration sentences
(Examples: for)
int i=0;
for (i =0;i<10;)
T h e   o n e 
{ i=i+2;}
t e n   u s e d int i=0;
l
)
l
  w i
t h a t
for (i=13;i<10; i++)
l e a r n (
f o r   ( i n t
  o f
  b e   m o s t
!
  b y   h e a r t
t
i"
"f o r   ( i n t
  o f
  b e   m o s t
!
  b y   h e a r t
t
i
i = 0 ;   i < 5 ;   i + + )   {
{ i=i+2;}
int i sum;
/ / s e n t e n c e s
for (i =0, sum=5;i<10;sum+=i)
int i=4;
for (;i<10;)
{ i=i+2;}
int i=0;
for ( ; ; )
{ i=i+2;}
}
{ i=i+8;}"
Notes to remember
- When the loop has several sentences in initialization comparison or update they will be separated by commas An example of for loop with multiple statements is shown with the syntax for i equal to zero sum equals zero i less than or equal to n i plus
equal to zero sum equals zero i less than or equal to n i plus plus comma sum plus equal to n Inside the for loop body we have sentences and the for loop is closed
"- Nested loops Program slows down They are used to cover n dimensional arrays one loop per dimension
- The sentences in a while might never run in a do while sentences are executed at least once
- Avoid infinite loops always check termination condition"
"- Avoid infinite loops always check termination condition
- A for loop always can be converted into a while loop and vice versa
Comparative
 three different types of loops: for, while, and do-while."
"The table shows that the ""for"" loop is the only one that initializes variables and updates them within the loop definition. All three loops have a condition that determines whether the loop continues to execute"
". The ""do-while"" loop is the only one that is guaranteed to execute at least once, because the condition is checked at the end of the loop."
"The table also shows that the ""for"" loop is the most commonly used type of loop, followed by the ""while"" loop. The ""do-while"" loop is used less often.
Usage patterns
 when to use ""while"" and ""for"" loops."
"Usage patterns
 when to use ""while"" and ""for"" loops.
If the number of iterations is known, for example when iterating over an array, we should use a ""for"" loop.
If the number of iterations is unknown, we should use a ""while"" loop."
"If we need to increase variables in each cycle, we can use both ""for"" and ""while"" loops.
If we need to initialize variables, we can use both ""for"" and ""while"" loops.
 with two examples:
- Reading a file with a ""while"" loop."
"with two examples:
- Reading a file with a ""while"" loop.
- Covering an array with a ""for"" loop."
"Iteration sentences
Notes to remember
• When the loop has several sentences (in initialization,
comparison or update), they will be separated by commas
for(i=0, sum=0;  i<=n;  i++, sum+=n)  {
sentences;
}
• Nested loops:
– Program slows down"
"sentences;
}
• Nested loops:
– Program slows down
– They are used to cover n-dimensional arrays (one loop per
dimension)
• The sentences in a while might never run; in a do-while
sentences are executed at least once"
"sentences are executed at least once
• Avoid infinite loops (always check termination condition)
• A  for loop always can be converted into a  while loop, and 
vice versa"
Notes to remember
- When the loop has several sentences in initialization comparison or update they will be separated by commas An example of for loop with multiple statements is shown with the syntax for i equal to zero sum equals zero i less than or equal to n i plus
equal to zero sum equals zero i less than or equal to n i plus plus comma sum plus equal to n Inside the for loop body we have sentences and the for loop is closed
"- Nested loops Program slows down They are used to cover n dimensional arrays one loop per dimension
- The sentences in a while might never run in a do while sentences are executed at least once
- Avoid infinite loops always check termination condition"
"- Avoid infinite loops always check termination condition
- A for loop always can be converted into a while loop and vice versa
Comparative
 three different types of loops: for, while, and do-while."
"The table shows that the ""for"" loop is the only one that initializes variables and updates them within the loop definition. All three loops have a condition that determines whether the loop continues to execute"
". The ""do-while"" loop is the only one that is guaranteed to execute at least once, because the condition is checked at the end of the loop."
"The table also shows that the ""for"" loop is the most commonly used type of loop, followed by the ""while"" loop. The ""do-while"" loop is used less often.
Usage patterns
 when to use ""while"" and ""for"" loops."
"Usage patterns
 when to use ""while"" and ""for"" loops.
If the number of iterations is known, for example when iterating over an array, we should use a ""for"" loop.
If the number of iterations is unknown, we should use a ""while"" loop."
"If we need to increase variables in each cycle, we can use both ""for"" and ""while"" loops.
If we need to initialize variables, we can use both ""for"" and ""while"" loops.
 with two examples:
- Reading a file with a ""while"" loop."
"with two examples:
- Reading a file with a ""while"" loop.
- Covering an array with a ""for"" loop."
"Iteration sentences
Comparative
• for vs. while vs do-while
MinExe

Upd Condition
Continue
Init
Yes
Yes
for
while
Not
Not
Continue
do-while Not
Not
Continue"
"•
Init: Initialize variables
• Upd: Update variables
• Condition: Continue or exit
• Min exe: minimum number of times the block of code is executed
• Usage: frequency of use of the control structure
Usage
High
High
Low"
Notes to remember
- When the loop has several sentences in initialization comparison or update they will be separated by commas An example of for loop with multiple statements is shown with the syntax for i equal to zero sum equals zero i less than or equal to n i plus
equal to zero sum equals zero i less than or equal to n i plus plus comma sum plus equal to n Inside the for loop body we have sentences and the for loop is closed
"- Nested loops Program slows down They are used to cover n dimensional arrays one loop per dimension
- The sentences in a while might never run in a do while sentences are executed at least once
- Avoid infinite loops always check termination condition"
"- Avoid infinite loops always check termination condition
- A for loop always can be converted into a while loop and vice versa
Comparative
 three different types of loops: for, while, and do-while."
"The table shows that the ""for"" loop is the only one that initializes variables and updates them within the loop definition. All three loops have a condition that determines whether the loop continues to execute"
". The ""do-while"" loop is the only one that is guaranteed to execute at least once, because the condition is checked at the end of the loop."
"The table also shows that the ""for"" loop is the most commonly used type of loop, followed by the ""while"" loop. The ""do-while"" loop is used less often.
Usage patterns
 when to use ""while"" and ""for"" loops."
"Usage patterns
 when to use ""while"" and ""for"" loops.
If the number of iterations is known, for example when iterating over an array, we should use a ""for"" loop.
If the number of iterations is unknown, we should use a ""while"" loop."
"If we need to increase variables in each cycle, we can use both ""for"" and ""while"" loops.
If we need to initialize variables, we can use both ""for"" and ""while"" loops.
 with two examples:
- Reading a file with a ""while"" loop."
"with two examples:
- Reading a file with a ""while"" loop.
- Covering an array with a ""for"" loop."
"Iteration sentences
Usage patterns
• When to use while or for
for while
The number of iterations is known (e.g. array) X
The number of iterations is unknown
Increase of variables in each cycle
Variable initialization
X
X
E.g.: reading a file with while"
"Variable initialization
X
X
E.g.: reading a file with while
E.g.: cover an array with for
X
X"
Notes to remember
- When the loop has several sentences in initialization comparison or update they will be separated by commas An example of for loop with multiple statements is shown with the syntax for i equal to zero sum equals zero i less than or equal to n i plus
equal to zero sum equals zero i less than or equal to n i plus plus comma sum plus equal to n Inside the for loop body we have sentences and the for loop is closed
"- Nested loops Program slows down They are used to cover n dimensional arrays one loop per dimension
- The sentences in a while might never run in a do while sentences are executed at least once
- Avoid infinite loops always check termination condition"
"- Avoid infinite loops always check termination condition
- A for loop always can be converted into a while loop and vice versa
Comparative
 three different types of loops: for, while, and do-while."
"The table shows that the ""for"" loop is the only one that initializes variables and updates them within the loop definition. All three loops have a condition that determines whether the loop continues to execute"
". The ""do-while"" loop is the only one that is guaranteed to execute at least once, because the condition is checked at the end of the loop."
"The table also shows that the ""for"" loop is the most commonly used type of loop, followed by the ""while"" loop. The ""do-while"" loop is used less often.
Usage patterns
 when to use ""while"" and ""for"" loops."
"Usage patterns
 when to use ""while"" and ""for"" loops.
If the number of iterations is known, for example when iterating over an array, we should use a ""for"" loop.
If the number of iterations is unknown, we should use a ""while"" loop."
"If we need to increase variables in each cycle, we can use both ""for"" and ""while"" loops.
If we need to initialize variables, we can use both ""for"" and ""while"" loops.
 with two examples:
- Reading a file with a ""while"" loop."
"with two examples:
- Reading a file with a ""while"" loop.
- Covering an array with a ""for"" loop."
"Breaking up the flow of execution:Break sentence
• break: causes to break the execution and exit the
structure in a while, for, do-while or switch
int j=0;
while(j<10){
j++;
break;
System.out.println(“This message is never printed”);
}"
"break;
System.out.println(“This message is never printed”);
}
System.out.println(“j = ”+j);
The loop runs only once and prints the message “j = 1”"
"Breaking up the flow of execution:Continue sentence
• continue: when continue appears in a while, for ordo-while block of code, it skips the rest of the sentencesof the loop and continues with the next iteration
int j=0
while(j<10){
j++;
continue;"
"int j=0
while(j<10){
j++;
continue;
System.out.println(“This message is never printed”);
}
The message is never printed"
"Implementing a method:Step 1.1: Think about the algorithm
• Problem: Write a program that calculates
whether a number n is prime
  2  3  4  .  .  .  n/2   .  .  .  n
• Step 1: Think about the algorithm (split the
problem into simpler steps)"
"problem into simpler steps)
– Starting by 2, we check for each number if it is an
integer divisor of n
– We only needs to repeat it until n/2
– Or until we find an integer divisor
– We will use a sentinel"
"– Or until we find an integer divisor
– We will use a sentinel
• Boolean variable that will help us control the loop"
"Implementing a method:Step 1.2: Represent the algorithm
divisor = 2
isPrime = true
Flowchart
false
divisor < n / 2
&&
isPrime
true
n % divisor == 0
true
isPrime= false
false
divisor++"
"Implementing a method:Step 2: Write the code
public boolean isAPrimeNumber (int number) {
int divisor =2;
boolean isPrime = true;
while ((divisor < number/2) && isPrime){
if (number % divisor == 0)
isPrime = false;
divisor++;
}"
"if (number % divisor == 0)
isPrime = false;
divisor++;
}
System.out.println(“The number “ +number);
if (isPrime)
System.out.println(“ is prime.”);
else
System.out.println(“ is not prime.”);
return isPrime;
}"
"Implementing a method:Examples: working with arrays
• Let’s practice
•
Imagine that you have to implements methods to:
– Print an array (practice loops)
– Retrieve a specific element in an array• Practice: conditionals and nested loops"
"• Practice comparison using different data types– Basic types (numbers, characters booleans)
– String comparison
– Object comparison
– Swap two elements in an array (practice auxiliary variables)
– Sort an array (copy elements between two arrays)"
"Review
Learning outcomes
• After this session you must be able to:"
"• After this session you must be able to:
– Install and configure an environment to work with Java– Understand a program with several files, be able to draw a classdiagram, and identify the first method that the runtime system callsto execute the program"
"– Identify basic structures associated with classes and objects
such as declarations of:
• Classes
• Members
– Attributes
» Basic types (primitives, String)
» Reference types (objects and arrays)
– Methods
» main
» constructors
» Regular methods"
"– Methods
» main
» constructors
» Regular methods
– Design and implement simple algorithms inside the body of a
method using operators and basic control structures (loops andconditionals)"
Learning outcomes
"After this session you must be able to install and configure an environment to work with Java, understand a program with several files, be able to draw a class diagram, and identify the first method that the runtime system calls to execute the program."
"You must also be able to identify basic structures associated with classes and objects such as declarations of: classes, members, attributes, basic types, reference types, methods, main, constructors, and regular methods."
"Finally, you must be able to design and implement simple algorithms inside the body of a method using operators and basic control structures such as loops and conditionals."
Scenario I: Install and configure the environment
"a scenario about installing and configuring an environment. The objective is to be able to edit, compile, execute, and debug an existing program"
". The work plan involves downloading, installing, and configuring the software in order to test the application. The scenario is as follows: It's your first day working in the programming department of a company named PROTEL"
. Your department needs to update an existing application with new functionality. You are provided with a laptop and a URL to download the existing code.
"Development Architecture
The image describes the two steps involved in developing software: editing and compiling."
"Several IDEs, or Integrated Development Environments, are listed for editing, including Eclipse, Netbeans, J Builder, Visual Cafe, Java Workshop, Visual Age, and J++.  Other editors, such as Grasp, Notepad, and EditPlus, can also be used."
"The code, saved as ""file.java"", is then compiled, in this example by JDK or other compilers. The output of the compilation process is ""bytecode"", saved as ""file.class""."
"Execution Architecture
The diagram illustrates the execution architecture of Java applets or applications.
At the bottom, a ""java file"" serves as the input. This file is processed by the Java Virtual Machine, which consists of several components."
"First, the ""Class Loader"" and ""Bytecode Verifier"" work together, loading the necessary ""Java Class Libraries"" (both extension and base APIs) and ensuring the bytecode's integrity."
"Next, the code can be executed by the ""Java Interpreter"" or the ""JIT (Just in Time Compiler)."" Both interact with the ""Java Runtime"" environment.
The ""Java Runtime"" further relies on the underlying ""Operating System"" and ""Hardware"" for execution."
"How to configure Environment Variables
 how to configure environment variables in Windows and Linux."
"In Windows 7, 8 and 8.1, you need to go to the Control Panel, then System and Security, then System, then Advanced system settings, and finally Advanced options. There, you will find the Environment Variables option."
"In Linux, you can type the commands in a terminal prompt or modify the bash file to make it permanent.
To set the PATH variable, you can use the following command:
```
PATH=$JAVA_HOME/bin:/usr/bin
```"
"```
PATH=$JAVA_HOME/bin:/usr/bin
```
To set the CLASSPATH variable, you can use the following command:
```
CLASSPATH=$JAVA_HOME/lib/classes.zip:.
```
To preserve the old value of environment variables, you can use the following commands:
```"
"```
PATH=$JAVA_HOME/Java/bin:$PATH
CLASSPATH=$JAVA_HOME/lib/classes.zip:$CLASSPATH
```
In these commands, $JAVA_HOME is the path to the directory where Java is installed."
"Scenario II: Understanding Java code
The objective of this scenario is to be fluent in reading Java structures related to classes, attributes, and methods. The goal is to be able to understand, at a glance, a complex Java program with several files."
"The work plan for this scenario is as follows:
- Review Java syntax, including identifiers, reserved words, etc., in order to distinguish between words from the Java language and naming conventions for a specific application."
"- Identify language structures related to class declaration, attribute declaration (both basic and reference types), and method declaration."
"- Draw class diagrams to represent a set of Java files in order to identify object types, their characteristics (attributes), and behaviors (methods)."
"- Understand and explain the main method (if it exists) to see the order in which objects are created, methods are called, and sentences are executed."
"This scenario involves a first meeting as a programmer in one hour. By that time, the code should be reviewed and understood, including how the application works."
How to represent classes and objects in Java
"the concepts related to classes and objects in Java. These concepts are: class declaration, attribute declaration, method declaration, object creation, identifiers, reserved words, primitive and reference types."
"Strings Declaration, concatenation
- A sequence of characters implemented in a class named String in java.lang package.
- Strings creation:
  - String emptyS = new String();
  - String emptyS = """";
  - String message = ""hello"""
"- String emptyS = """";
  - String message = ""hello""
  - String messageCopy = message;
- Strings concatenation:
  - String concatenation uses the overloaded + operator.
  - ""this"" + ""that"" // result: ""thisthat""
  - ""abc"" + 5 // result: ""abc5"""
"- ""abc"" + 5 // result: ""abc5""
  - ""a"" + ""b"" + ""c"" // result: ""abc""
  - ""a"" + 1 + 2 // result: ""a12""
  - 1 + 2 + ""a"" // result: ""3a""
  - 1 + (2 + ""a"") // result: ""12a"""
Strings Comparison
"- You must not use relational operators such as less than, greater than, less than or equal to, and greater than or equal to, nor the equality operators such as equal to and not equal to with Strings. These operators compare the object, not the content."
"- There are specific methods to compare in the String class.
    - Method: equals. leftSide.equals(rightSide) returns true if leftSide and rightSide are identical."
"- Method: compareTo. leftSide.compareTo(rightSide) returns a negative integer value if leftSide is lower than rightSide, 0 if leftSide is equal to rightSide, and a positive integer value if leftSide is higher than rightSide."
"An object as an attribute
Object declaration
The image shows a code snippet in Java that declares an object as an attribute."
"The code is for a class named ""Car"" that has attributes such as ""color"" of type String, ""speed"" of type int, and ""standardEquipment"" of type ""Equipment""."
"The code also includes a comment indicating the syntax for object declaration, which is ""ClassName name;"" for a single object and ""ClassName name1, name2;"" for multiple objects."
"The code then shows an example of object creation using the ""new"" keyword: ""ClassName name = new Equipment();""."
"There is a comment explaining that object declaration is similar to variable declaration, where the type is specified, but in object declaration, the name of the class is used."
"There is also a section on ""Style"" that reminds us that class names (type) should start with a capital letter, while identifiers (objectName) should use lowercase."
"Finally, there is a section on ""Object creation"" that explains that variables are initialized, but objects are created."
"Objects, null reference.
It may happen that a reference to an object has no instance assigned, in this case the special value null is used."
"For example, if we have three student objects, student1, student2 and student3, by default they will be null. Then we assign values to student1 and student2, but student3 is assigned to null."
"The diagram shows that student1 and student2 are pointing to Student objects, but student3 is pointing to a null object."
"Objects Alias
An object can have several references, known as aliases. For example, the code snippet ""Student delegate; delegate = student1;"" shows how a Student object can be referenced by both the ""delegate"" and ""student1"" variables."
"The figure illustrates this concept with a diagram of objects and their references. There are five reference variables: ""student1"", ""delegate"", ""student2"", ""student3"", and ""student5""."
"- ""student1"" and ""delegate"" both reference the same Student object, which contains the value ""Juan"".- ""student5"" references a different Student object, also containing the value ""Juan"".- ""student4"" references a Student object containing the value ""Clara"""
".- ""student2"" and ""student3"" do not reference any object, indicated by the ""null"" value and a black dot."
"This diagram demonstrates that multiple references can point to the same object, and that different objects can hold the same value."
"Arrays, Declaration, Creation, Initialization
 how to initialize an array in programming, which means assigning values to each element.
There are three ways to initialize an array: element by element, using a loop, or direct assignment."
"To initialize an array element by element, you would assign a value to each element individually"
". For example, to initialize the first two elements of an array named ""arrayName"", you would use the following code:""arrayName[0] = element0;"" and ""arrayName[1] = element1;""."
"To initialize an array using a loop, you would use a for loop to iterate through each element of the array and assign it a value. For example, the following code would initialize each element of the array ""arrayName"" to the value of ""element-i"":"
"""for(int i = 0; i < arrayName.length; i++) { arrayName[i] = element-i; }"""
"To initialize an array using direct assignment, you would enclose the values for each element in curly braces and assign them to the array"
". For example, the following code would initialize the array ""arrayName"" with the values ""elem1"", ""elem2"", ""elem3"", and so on:"
"""arrayName = {elem1, elem2, elem3, ...};"""
"Arrays (examples)
Declaration, Creation, Initialization
There are two code snippets, one for arrays with primitive types and one for arrays with objects, that show different ways to declare, create and initialize an array."
"The first snippet shows how to declare, create and initialize an array of integers"
".- The first example shows how to declare an array variable called ""a"" of type integer, then create an array of integers of size 3 and assign it to the variable ""a"", and finally initialize the elements of the array"
".- The second example shows how to declare an array variable called ""a"" of type integer and create an array of integers of size 3 and assign it to the variable ""a"" in the same line, and finally initialize the elements of the array"
".- The third example shows how to declare an array variable called ""a"" of type integer and create an array of integers of size 3 and assign it to the variable ""a"" in the same line, and finally initialize the elements of the array using a for loop"
".- The fourth example shows how to declare, create and initialize an array of integers in the same line."
"The second snippet shows how to declare, create and initialize an array of objects of type MyClass"
".- The first example shows how to declare an array variable called ""a"" of type MyClass, then create an array of MyClass of size 3 and assign it to the variable ""a"", and finally initialize the elements of the array"
".- The second example shows how to declare an array variable called ""a"" of type MyClass and create an array of MyClass of size 3 and assign it to the variable ""a"" in the same line, and finally initialize the elements of the array"
".- The third example shows how to declare an array variable called ""a"" of type MyClass and create an array of MyClass of size 3 and assign it to the variable ""a"" in the same line, and finally initialize the elements of the array using a for loop"
".- The fourth example shows how to declare, create and initialize an array of MyClass in the same line."
"Arrays (common errors): Declaration, Creation, Initialization
 a common error when working with arrays in Java."
"a common error when working with arrays in Java.
We see a code snippet with a common error: an array variable is declared but not initialized, and the code attempts to print the value of its first element."
"The code will not compile, as indicated by the diagram on the right, which shows the code going through a ""compile"" step that leads to ""Compilation failure""."
"Below the code, there is a green rectangle with the message ""variable myArray may not have been initialized""."
"Finally, a red rectangle at the bottom summarizes the error: ""When an array has been declared but not created or initialized, you have no access to its elements. The program does not compile and prints an error message""."
"Arrays (Common errors): Declaration, creation, inicialization"
"We have a code snippet that shows how to declare and create arrays in Java. The code first declares six arrays, one for each of the following data types: int, float, boolean, char, String, and Object. Each array is initialized with a size of 10"
". Each array is initialized with a size of 10. The code then prints the default value for each data type. The default value for an int is 0, for a float is 0.0, for a boolean is false, for a char is a space, for a String is null, and for an Object is null"
". The code then has a note that states that when an array has been declared and created but not initialized, we can retrieve its elements, but they will have their default value."
"N-dimensional Arrays Examples
The image shows examples of how to create N-dimensional arrays in Java."
"The first example shows how to declare and create a 2-dimensional array of Strings in one line. The array is called ""myArray"" and it's initialized with a new String array of size 3x4"
. The image shows a graphical representation of the array with all the values set to null.
"The second example shows how to declare and create a 2-dimensional array of ints step by step. First, the array ""myArray"" is declared. Then, the reference array for rows is created with size ""numRows"""
". Finally, the memory for each row is allocated in a for loop, where each row has size ""numColumns""."
"The last example shows three different ways to create 2-dimensional arrays of ints. The first one, ""a"", is a 3x3 array initialized to 0. The second one, ""b"", is initialized with the values 1, 2, 3 in the first row and 4, 5, 6 in the second row"
". The last one, ""c"", shows how to create a ragged array, where each row can have a different number of columns. In this case, the first row has 5 columns, the second row has 4 columns and the third row has 3 columns"
. The image shows a graphical representation of the three arrays.
"Arrays Homework
Write a program that multiplies two bi-dimensional arrays of integers."
Scenario III: Method implementation
"We have a scenario where after a programmers' meeting, the objective is to demonstrate expertise in method implementation. The first task involves implementing simple methods that function independently without invoking other attributes or methods."
"The objective is to be able to break down a problem to identify the basic steps for solving it, which is essentially algorithm design and representation"
". It also includes using the basic structures of a programming language like variables, operators, and flow control statements such as loops and conditionals to implement an algorithm."
The work plan suggests training in the design of algorithms and their representation. This involves breaking down problems into smaller steps to solve them without writing code
". It emphasizes memorizing the syntax of Java in terms of operators, loops, and conditionals. The focus is on practicing Java to implement previously designed algorithms, aiming for ease and speed in implementation"
". Finally, it recommends resolving typical problems related to arrays, such as printing all elements, retrieving a specific element, swapping elements between two positions, and sorting."
"Step I: Thinking of the algorithm
What tools do we have to represent algorithms?"
"Once we have thought about the algorithm structure, we need to represent the steps to solve it:  We can use Pseudocode, flowcharts and organigrams"
.  Flowcharts and organigrams use figures to represent sentences and flow lines to represent the order in which they are executed.
"Step I: Thinking of the algorithm Flowcharts vs Pseudocode
We can see two different ways of representing an algorithm: a flowchart on the left and pseudocode on the right.
The flowchart describes the steps to fix a lamp:"
"The flowchart describes the steps to fix a lamp:
- It starts with the question ""Lamp doesn't work?"".
- If the answer is yes, then it asks if the ""Lamp plugged in?"".
- If not, then ""Plug in lamp"".
- If yes, then it asks if the ""Bulb burned out?""."
"- If yes, then it asks if the ""Bulb burned out?"".
- If yes, then ""Replace bulb"".
- If not, then ""Repair lamp"".
The pseudocode describes the steps to play the game ""One Potato, Two Potato"":
- It starts with gathering all players in a circle."
"- It starts with gathering all players in a circle.
- Then, players put both fists in the circle.
- A player is chosen to be the counter.
- The counter begins chanting and repeats until one fist is left."
"- The counter repeats 8 times, hitting one fist at a time.
- If the count is 1-3 or 5-7, the counter says the count plus ""potato"".
- If the count is 4, the counter says ""Four!""."
"- If the count is 4, the counter says ""Four!"".
- If the count is 8, the counter says ""More!"", the current fist is taken out, the chant restarts on the next fist, and 1 is added to the count.
- If there is only one fist left, that player is ""it""."
"- If there is only one fist left, that player is ""it"".
- The game ends.
There is also a flowchart at the bottom center of the image. It describes an algorithm to calculate the factorial of a number:
- It starts with reading the input number N."
"- It starts with reading the input number N.
- Then, it initializes two variables: M=1 and F=1.
- It enters a loop that continues as long as M is not equal to N.
- In the loop, it multiplies F by M and stores the result in F.
- Then, it increments M by 1."
"- Then, it increments M by 1.
- Once the loop ends, it prints the value of F, which represents the factorial of N.
- Finally, the algorithm ends."
"Selection sentences (Conditionals)
We have three code snippets that show different conditional statements.
The first one is an ""if"" statement. If the condition is true, the sentences1 will be executed."
"The second one is an ""if-else"" statement. If the condition is true, the sentences1 will be executed. Otherwise, the sentences2 will be executed."
"The third one is a ""switch"" statement. It evaluates an expression and executes the sentences associated with the matching case value. If no case value matches the expression, the default sentences will be executed"
". Each case block should end with a ""break"" statement to prevent the execution from falling through to the next case."
"Iteration sentences (Loops)
We have three code snippets, all of them showing different loop syntax:
- The first one is a **for loop**:
```
for( initialization;condition;update) {
sentences;
}
```
- The second one is a **while loop**:
```"
"sentences;
}
```
- The second one is a **while loop**:
```
while( condition) {
sentences;
}
```
- The third one is a **do-while loop**:
```
do {
sentences;
}while(condition);
```"
"Iteration sentences (Examples: for)
There are 5 code snippets, each showing a for loop in C.
- The first snippet initializes an integer ""i"" to 0. The loop iterates as long as ""i"" is less than 10. In each iteration, ""i"" is incremented by 2."
"- The second snippet initializes an integer ""i"" to 0. The loop iterates as long as ""i"" is less than 10, incrementing ""i"" by 1 in each iteration. However, the initial value of ""i"" is 13, which is already greater than 10"
". Therefore, the loop will not execute."
"- The third snippet initializes an integer ""i"" to 4. The loop iterates as long as ""i"" is less than 10. In each iteration, ""i"" is incremented by 2."
"- The fourth snippet initializes an integer ""i"" to 0. The loop iterates indefinitely because there is no condition specified in the for loop. In each iteration, ""i"" is incremented by 2."
"- The fifth snippet initializes two integers, ""i"" to 0 and ""sum"" to 5. The loop iterates as long as ""i"" is less than 10. In each iteration, ""sum"" is incremented by the value of ""i"", and then ""i"" is incremented by 8."
"The question asks how many times each loop is executed and the value of ""i"" at the end of each loop."
Iteration sentences (Examples: for)
"The most often used iteration is the 'for' loop. The syntax is the following: 'for' open parenthesis, 'int' 'i' equals '0' semicolon, 'i' less than '5' semicolon, 'i' plus plus, close parenthesis. Then, between curly brackets, '//'sentences."
"Breaking up the flow of execution: Break sentence
 the break statement in programming.
- The break statement causes the execution to break and exit the structure in a while, for, do-while or switch statement."
"There is a code example that shows how the break statement works:
```java
int j=0;
while(j<10){
  j++;
  break;
  System.out.println(""This message is never printed"");
}
System.out.println(“j = ""+j);
```"
"}
System.out.println(“j = ""+j);
```
The loop runs only once and prints the message ""j = 1"" because the break statement is executed after the first iteration, which exits the loop."
"Breaking up the flow of execution: Continue sentence
 how to use the continue sentence in Java.
- The continue sentence can be used in while, for or do-while blocks of code."
"- When it is executed, it skips the rest of the sentences in the block and continues with the next iteration.
 a code example to illustrate this:
```java
int j=0
while(j<10){
  j++;
  continue;
  System.out.println(""This message is never printed"");
}
```"
"System.out.println(""This message is never printed"");
}
```
In this example, the message ""This message is never printed"" will never be printed because the continue sentence will always be executed before it.
 by stating that the message is never printed."
"Implementing a method: Step 1.1: Think about the algorithm
We are looking at the first step in implementing a method to determine if a number is prime. The first step is to think about the algorithm."
The problem is to write a program that calculates whether a number n is prime.
The first step in thinking about the algorithm is to split the problem into simpler steps. We start by checking if each number from 2 to n/2 is an integer divisor of n
". We only need to repeat this process until we find an integer divisor or until we reach n/2. To control the loop, we will use a sentinel, which is a Boolean variable."
Implementing a method: Step 1.2: Represent the algorithm
"The image shows a flowchart.- The first step is a rectangular box that sets the value of a variable named ""divisor"" to 2 and the value of a variable named ""isPrime"" to true"
".- Then, there is a diamond-shaped box that checks if the value of ""divisor"" is less than half the value of ""n"" and if ""isPrime"" is true"
".- If both conditions are true, the flow continues to another diamond-shaped box that checks if the remainder of the division of ""n"" by ""divisor"" is equal to 0.- If the remainder is 0, the flow continues to a rectangular box that sets ""isPrime"" to false"
".- If the remainder is not 0 or if either of the conditions in the first diamond-shaped box is false, the flow continues to a rectangular box that increments the value of ""divisor"" by 1"
".- Finally, the flow goes back to the first diamond-shaped box to repeat the process."
"Implementing a method:
Step 2: Write the code
 a code snippet of a method written in Java that determines if a given number is a prime number."
"The method is called ""Is A Prime Number"" and takes an integer called ""number"" as input. It initializes an integer variable called ""divisor"" to 2 and a boolean variable called ""isPrime"" to true."
"The code then enters a while loop that continues as long as the divisor is less than half of the number and isPrime is true. Inside the loop, it checks if the number is divisible by the divisor"
". If it is, it sets isPrime to false and increments the divisor."
"After the loop, the code prints the number to the console and then checks the value of isPrime. If it's true, it prints ""is prime"", otherwise it prints ""is not prime"". Finally, the method returns the value of isPrime."
"Implementing a method:
Examples: working with arrays"
several practice exercises related to implementing methods for working with arrays
". The exercises include: printing an array using loops, retrieving a specific element from an array using conditionals and nested loops, comparing elements in an array using different data types (numbers, characters, booleans, strings, and objects)"
", characters, booleans, strings, and objects), swapping two elements in an array using auxiliary variables, and sorting an array by copying elements between two arrays"
.
"Systems Programming
Object-BASED Programming
Departamento de IngenieríaTelemática
CONTENTS ARE MOSTLY BASED ON THE WORK BY:
M. Carmen Fernández Panadero, Raquel M. Crespo García"
"M. Carmen Fernández Panadero, Raquel M. Crespo García
Carlos Delgado Kloos, Natividad Martínez Madrid,                                       
Carlos Alario Hoyos, Julio Villena Román"
Object-ORIENTED programming (basic)
"The title of  """" and the subtitle is ""Object-ORIENTED programming (basic)"".  The name of the department is ""Departamento de Ingeniería Telemática"". The contents of  based on the work of M. Carmen Fernández Panadero, Raquel M"
". Carmen Fernández Panadero, Raquel M. Crespo García, Carlos Delgado Kloos, Natividad Martínez Madrid, Carlos Alario Hoyos, and Julio Villena Román. The logo of Universidad Carlos III de Madrid is displayed in the bottom left corner of the slide"
. The Creative Commons license logo is displayed in the top left corner of the slide.
Object-ORIENTED programming (advanced)
"The title of  """" with a subtitle ""Object-ORIENTED programming (advanced)"".  It seems to be part of a presentation for the Telematics Engineering Department as indicated in the smaller text"
.  The footnote indicates this presentation is based mostly on the work of six individuals.
"Key terms
• Object and Class
• State and Behavior
• Attribute and Method
• Data abstraction vs Functional abstraction
• Private / Public (attribute / method + class)
• Message passing
• Overloading (method)
• Constructor (method)"
"• Message passing
• Overloading (method)
• Constructor (method)
• Static (attribute / method)
• Get / Set (method)
• Package"
"The key terms are object and class, state and behavior, attribute and method, data abstraction versus functional abstraction, private/public attribute/method + class, message passing, overloading method, constructor method, static attribute/method"
", constructor method, static attribute/method, get/set method, and package"
.
"key terms related to inheritance. The terms are grouped into the following categories: naming, Java syntax, Java hierarchy, overriding, constructors, and polymorphism."
"The naming category lists the following terms: generalization versus specialization, superclass versus subclass, parent class versus child class, and base class versus derived class."
"The Java syntax category lists the following keywords: extends, super, protected, and final.
The remaining categories, Java hierarchy, overriding, constructors, and polymorphism, are listed as single terms."
"- Casting which can be upcasting vs downcasting or widening vs narrowing
- Abstract classes and methods, including inheritance and polymorphism
- Interfaces, including implements, inheritance and polymorphism"
"Scenario IV:Declare and implement a class
• Now that you know how to read code and implement your own
methods you will have to design a new class in order to create anew data type with its characteristics and behavior.
• Objective:"
"• Objective:
– Be able to declare a class with a set of characteristics (attributes) and
behavior (methods)
– Be able to create objects and modify or restrict access to their state and
their behavior
• Work plan:"
"their behavior
• Work plan:
– Memorize the basic nomenclature of the object-oriented programming– Practice modeling objects with simple examples to distinguish between a class, an
object, its state and behavior"
"object, its state and behavior
– Review the Java syntax for declaring classes, attributes, constructors and methods
– Review the mechanism and syntax for message passing between objects"
"Objectives
• Define basic concepts of object-based
programming
– Classes, objects
– Members (attributes, methods)
– Abstraction and Information hiding
• Describe the relationship between object
and class
• Create a simple object and be able to model:"
"and class
• Create a simple object and be able to model:
– its characteristics (with attributes)
– its behavior (with methods)"
"the objectives for a lesson on object-based programming. The first objective is to define basic concepts such as classes, objects, members which include attributes and methods, abstraction, and information hiding"
". The second objective is to describe the relationship between an object and a class. Finally, the third objective is to create a simple object and be able to model its characteristics with attributes and its behavior with methods."
"Contents
• Classes and Objects
• Object encapsulation
– Functional abstraction
– Data abstraction
• Class members (attributes and methods)
• Message passing
• Overloading
• Constructors
• Modifiers and access
• Packages"
"topics related to object-oriented programming: classes and objects, object encapsulation with functional and data abstraction, class members, message passing, overloading, constructors, modifiers and access, and packages.
- Basic inheritance concepts"
"- Basic inheritance concepts
- Inheritance hierarchy
- Overriding I: Attribute Hiding
- Overriding II: Method Overriding
- Constructors of derived classes
- Polymorphism
- The final modifier"
"What is an object?
• Objects are (simple/complex) (real/imagined)
representations of things: clock, airplane, bird, etc.
• Not everything can be considered as an object,
some things are simply characteristics or attributes"
"some things are simply characteristics or attributes
of the objects: color, speed, etc."
"Objects are simple or complex, real or imagined representations of things, for example, a clock, an airplane, or a bird. Not everything can be considered an object"
". Not everything can be considered an object. Some things are simply characteristics or attributes of the objects, for example, color or speed."
"We see a definition of an object, which is divided into two abstractions: functional abstraction and data abstraction."
"- Functional abstraction refers to the things that we know an object can do. For example, we know that cars can advance, stop, turn right, and turn left."
"- Data abstraction refers to the properties or attributes of an object. For example, a car has properties such as color, speed, and size."
"It is a way to group a set of data, called state, and functionality, called behavior, in the same block of code, which can then be referred to from other parts of a program.
The class to which the object belongs can be considered a new data type."
"What is an object?
• Functional abstraction
– Things that we know that
• Data abstraction
– Properties (attributes)
cars do:
q advance
q stop
q turn right
q turn left
q …
of a car:
q color
q speed
q size
q …"
"Objects are simple or complex, real or imagined representations of things, for example, a clock, an airplane, or a bird. Not everything can be considered an object"
". Not everything can be considered an object. Some things are simply characteristics or attributes of the objects, for example, color or speed."
"We see a definition of an object, which is divided into two abstractions: functional abstraction and data abstraction."
"- Functional abstraction refers to the things that we know an object can do. For example, we know that cars can advance, stop, turn right, and turn left."
"- Data abstraction refers to the properties or attributes of an object. For example, a car has properties such as color, speed, and size."
"It is a way to group a set of data, called state, and functionality, called behavior, in the same block of code, which can then be referred to from other parts of a program.
The class to which the object belongs can be considered a new data type."
"What is an object?
• It is a way to group a set of data (state)and functionality (behavior) in the sameblock of code, which can then bereferred to from other parts of aprogram
• The class to which the object belongscan be considered a new data type"
"Objects are simple or complex, real or imagined representations of things, for example, a clock, an airplane, or a bird. Not everything can be considered an object"
". Not everything can be considered an object. Some things are simply characteristics or attributes of the objects, for example, color or speed."
"We see a definition of an object, which is divided into two abstractions: functional abstraction and data abstraction."
"- Functional abstraction refers to the things that we know an object can do. For example, we know that cars can advance, stop, turn right, and turn left."
"- Data abstraction refers to the properties or attributes of an object. For example, a car has properties such as color, speed, and size."
"It is a way to group a set of data, called state, and functionality, called behavior, in the same block of code, which can then be referred to from other parts of a program.
The class to which the object belongs can be considered a new data type."
"Example
Class
Objects
Attributes
(state)
Special method:Constructor
Methods
(behavior)
• new operator to create instances
• this reference the the object of the current class
• public/private access modifiers"
"The image shows a slide with the title """" about object-oriented programming concepts, in particular classes and objects."
"On the left-hand side, we see an example of a class definition written in a programming language, likely Java. The class is named ""Car"" and it has three private attributes: ""color"" of type String, ""speed"" of type int, and ""size"" of type float"
". The class also has a constructor that takes the color, speed, and size as input and initializes the corresponding attributes"
". Additionally, the class has four public methods: ""advance"", ""stop"", ""turnLeft"", and ""turnRight"", all of which take no arguments and return void."
"On the right-hand side, we see three instances of the ""Car"" class, represented by images of cars in different colors: green, red, and yellow"
". These instances are created in the ""main"" method, which is a special method in Java that is executed when the program starts. The ""main"" method creates three ""Car"" objects: ""myCar"" with color ""green"", speed 80, and size 3"
".2f, ""yourCar"" with color ""red"", speed 120, and size 4.1f, and ""hisCar"" with color ""yellow"", speed 100, and size 3.4f."
"highlights three key concepts of object-oriented programming: the ""new"" operator is used to create instances of a class, the ""this"" keyword refers to the current object"
", the ""this"" keyword refers to the current object, and the ""public"" and ""private"" keywords are access modifiers that control the visibility and accessibility of class members"
.
"We have three classes: Car, Engine, and Wheel. The Car class has private attributes for color, speed, size, an array of wheels, and an engine. The constructor takes all of these attributes as arguments and initializes them"
. The advance method calls the injectFuel method on the engine and then calls the turn method on each wheel in the wheels array. The main method creates an array of wheels and a new car object with the specified attributes
. The Engine class has private attributes for type and horsepower. The constructor takes the type and horsepower as arguments and initializes them. The injectFuel method does not have any implementation yet
. The injectFuel method does not have any implementation yet. The Wheel class has private attributes for diameter and manufacturer. The constructor takes the diameter and manufacturer as arguments and initializes them
. The turn method does not have any implementation yet.
"Exercise 1
•"
"Implement the class Bicycle, which has threeattributes, speed, cadence and gear, of typeinteger and four methods speedUp(), brake(),setCadence(int newCadence), andsetGear(int newGear), where the first methoddoubles the current speed"
", where the first methoddoubles the current speed, the second method halves thecurrent speed, and the third and fourth methods set thecadence and gear according to the arguments received"
.The class must have a constructor which initializes allthe attributes.
"• Create two objects of this class: myBicycle and
yourBicycle"
"The exercise asks to implement a class named ""Bicycle"" with three attributes: ""speed"", ""cadence"", and ""gear"", all of which are integers"
". The class should also have four methods: ""speedUp"", which doubles the current speed, ""brake"", which halves the current speed, ""setCadence"", which takes an integer argument and sets the cadence to that value, and ""setGear"""
", and ""setGear"", which takes an integer argument and sets the gear to that value"
". The class should also have a constructor that initializes all the attributes. Finally, the exercise asks to create two objects of this class: ""myBicycle"" and ""yourBicycle""."
"Object encapsulation
• Encapsulation: explains the links between
behavior and state to a particular object
• Information hiding: Defines which parts of theobject are visible (the public interface) and whichparts are hidden (private)"
"• The ignition key is a public interface mechanism tostart a vehicle
• The implementation of how to really start a car is private. We only can access this information using theignition key
s
P r o"
"s
P r o
The object may change but its public interface remains compatiblewith the original. This fact facilitates code reuse"
"- Encapsulation: explains the links between behavior and state to a particular object
- Information hiding: Defines which parts of the object are visible (the public interface) and which parts are hidden (private)
There is an image of a key."
"There is an image of a key.
- The ignition key is a public interface mechanism to start a vehicle
- The implementation of how to really start a car is private. We only can access this information using the ignition key"
Pros: The object may change but its public interface remains compatible with the original. This fact facilitates code reuse
"Objects encapsulate attributes, allowing access to them only through methods.
- Attributes (Variables): Containers of values
- Methods: Containers of functions
An object has:
- State: represented by the values of its attributes"
"- State: represented by the values of its attributes
- Behavior: defined by its methods
Usually:
- Methods are public
- Attributes are private
- There can be private methods
- It is dangerous to have public attributes"
"There is a diagram representing an object with a circle containing dots. The dots represent the object's attributes. The circle represents the encapsulation of the attributes, which can only be accessed through the object's methods."
"Object encapsulation
CLASS MEMBERS
Objects encapsulate attributes, allowing access to them
only through methods
• Attributes (Variables): Containers of values
• Methods: Containers of functions
An object has:"
"• Methods: Containers of functions
An object has:
• State: represented by the values of its attributes
• Behavior: defined by its methods
Usually:
• Methods are public
•
•
•
Attributes are private
There can be private methods"
"•
•
•
Attributes are private
There can be private methods
It is dangerous to have public attributes"
"- Encapsulation: explains the links between behavior and state to a particular object
- Information hiding: Defines which parts of the object are visible (the public interface) and which parts are hidden (private)
There is an image of a key."
"There is an image of a key.
- The ignition key is a public interface mechanism to start a vehicle
- The implementation of how to really start a car is private. We only can access this information using the ignition key"
Pros: The object may change but its public interface remains compatible with the original. This fact facilitates code reuse
"Objects encapsulate attributes, allowing access to them only through methods.
- Attributes (Variables): Containers of values
- Methods: Containers of functions
An object has:
- State: represented by the values of its attributes"
"- State: represented by the values of its attributes
- Behavior: defined by its methods
Usually:
- Methods are public
- Attributes are private
- There can be private methods
- It is dangerous to have public attributes"
"There is a diagram representing an object with a circle containing dots. The dots represent the object's attributes. The circle represents the encapsulation of the attributes, which can only be accessed through the object's methods."
"Object Definition
Public Members
• Public members
(describe what anobject can do)
– What it can do
(methods)
– What it is (itsabstraction)
Private Members
• How the object does its
work (how it isimplemented)
– For example, the ignition key"
"work (how it isimplemented)
– For example, the ignition key
interacts with the electric circuitof the vehicle, the engine, etc.
– In pure object-oriented
systems, state is completelyprivate and can only bemodified through the publicinterface"
"– E.g.: public method brake()
can change the value of theprivate attribute speed"
"There are two types of members in object definition: public members and private members.
Public members describe what an object can do. This includes the methods of the object and its abstraction."
"Private members describe how the object does its work, or how it is implemented. For example, the ignition key interacts with the electric circuit of the vehicle, the engine, etc"
". In pure object-oriented systems, state is completely private and can only be modified through the public interface. For example, a public method brake() can change the value of the private attribute speed."
"Interactions between objects
• Object modeling describes:
– Objects and
– Their interrelations
• To do a task, an object can delegate some
work to another object, which can be a part ofitself, or any other object in the system"
"• Objects interact with each other by sending
messages"
"Object modeling describes objects and their interrelations. To do a task, an object can delegate some work to another object, which can be a part of itself, or any other object in the system. Objects interact with each other by sending messages."
"Message passing
e
c
a
f
r
e
t
n
i
c
i
l
b
u
P
Implementation
start
• An object sends a message to another object
By calling a method (method call / method invocation)
• Messages are handled by the public interface of the receiving object"
"We can only call methods from another object that are public or accessible fromthe calling object
• The receiving (called) object will react:
⎻ Changing its state, i.e., modifying its attributes, and/or"
"⎻ Changing its state, i.e., modifying its attributes, and/or
⎻ Sending other messages, i.e., calling other (public or private) methods from thesame object (from itself) or calling other methods from other objects (public oraccessible from that object)"
An object sends a message to another object by calling a method. Messages are handled by the public interface of the receiving object. We can only call methods from another object that are public or accessible from the calling object
". The receiving object will react by changing its state, i.e. modifying its attributes and/or sending other messages, i.e. calling other methods from the same object or calling other methods from other objects."
"There is a diagram showing the message passing process. On the left side of the image, there is a square labeled ""start"""
". An arrow goes from this square to the right, passing through a rectangle labeled ""Public interface"" and pointing to an oval labeled ""Implementation""."
"Example
Class Car
Class Engine
Class Wheel"
"The image shows a slide with the title """" about object-oriented programming concepts, in particular classes and objects."
"On the left-hand side, we see an example of a class definition written in a programming language, likely Java. The class is named ""Car"" and it has three private attributes: ""color"" of type String, ""speed"" of type int, and ""size"" of type float"
". The class also has a constructor that takes the color, speed, and size as input and initializes the corresponding attributes"
". Additionally, the class has four public methods: ""advance"", ""stop"", ""turnLeft"", and ""turnRight"", all of which take no arguments and return void."
"On the right-hand side, we see three instances of the ""Car"" class, represented by images of cars in different colors: green, red, and yellow"
". These instances are created in the ""main"" method, which is a special method in Java that is executed when the program starts. The ""main"" method creates three ""Car"" objects: ""myCar"" with color ""green"", speed 80, and size 3"
".2f, ""yourCar"" with color ""red"", speed 120, and size 4.1f, and ""hisCar"" with color ""yellow"", speed 100, and size 3.4f."
"highlights three key concepts of object-oriented programming: the ""new"" operator is used to create instances of a class, the ""this"" keyword refers to the current object"
", the ""this"" keyword refers to the current object, and the ""public"" and ""private"" keywords are access modifiers that control the visibility and accessibility of class members"
.
"We have three classes: Car, Engine, and Wheel. The Car class has private attributes for color, speed, size, an array of wheels, and an engine. The constructor takes all of these attributes as arguments and initializes them"
. The advance method calls the injectFuel method on the engine and then calls the turn method on each wheel in the wheels array. The main method creates an array of wheels and a new car object with the specified attributes
. The Engine class has private attributes for type and horsepower. The constructor takes the type and horsepower as arguments and initializes them. The injectFuel method does not have any implementation yet
. The injectFuel method does not have any implementation yet. The Wheel class has private attributes for diameter and manufacturer. The constructor takes the diameter and manufacturer as arguments and initializes them
. The turn method does not have any implementation yet.
"Classification of objects
• Class: Set of objects with similar states and
behaviors
– We can refer to the “Car” class (any instance in
the classification of cars)
• “myCar” is an object, i.e. a particular 
instance of the Car class"
"instance of the Car class
• The class to which the object belongs is
considered as a new data type"
"We have four cars: a red sports car, a police car, a yellow vintage car, and a red vintage car."
"A class is a set of objects with similar states and behaviors. We can refer to the ""Car"" class as any instance in the classification of cars. ""myCar"" is an object, that is, a particular instance of the Car class"
. The class to which the object belongs is considered as a new data type.
"Objects vs. Classes
It is a kind of data classification
A class is an abstract entity
•
• Defines the behavior and attributes of a group ofobjects with similar structure and similar behavior
Class car
Methods: start, advance, stop, ..."
"Class car
Methods: start, advance, stop, ...
Attributes: color , speed, etc.
Class name
Methods (functions)
Attributes (data)
An object is an instance of a class
• An object can be distinguished from other members of the class"
"by the value of its attributes
Object myFerrari
Belongs to theclass Car
Name: myFerrari
Methods: start, advance, stop, ...Attributes : color = “red”;
speed = 300Km/h
• A  class is declared, an object is created"
"A class is an abstract entity, it is a kind of data classification. It defines the behavior and attributes of a group of objects with similar structure and similar behavior."
An object is an instance of a class. An object can be distinguished from other members of the class by the value of its attributes.
"There is a diagram representing a class named ""car"" with its methods and attributes and an instance of that class which is an object named ""myFerrari"" with its own values for the attributes"
".The class ""car"" has the methods start, advance, stop and the attributes color, speed."
"The object ""myFerrari"" has the color red and the speed 300Km/h.
A class is declared, an object is created."
"Overloading
What is it?
• Two methods with the same name can be
defined in the same class if they havedifferent parameters
• It is widely used for constructors
• The method actually executed depends onthe parameters passed when it is called"
"What is it?
- Two methods with the same name can be defined in the same class if they have different parameters
- It is widely used for constructors
- The method actually executed depends on the parameters passed when it is called
What is it used for?"
"What is it used for?
We see the definition of a class named Car. This class has three private attributes: color of type String, speed of type int and size of type float."
"It also has a constructor that receives as parameters a String, an int and a float, and it assigns each parameter to the corresponding attribute."
"There are also three public methods named advance. The first one receives no parameters, the second one receives an int as a parameter, and the third one receives an int and another int."
"Finally, there are three public methods with no parameters: brake, turnLeft and turnRight.
On the right-hand side, we see an example of code that uses this class."
"We see the definition of the main method, where three instances of the class Car are created: myCar, yourCar and hisCar.
Each one is initialized with different values for the color, speed and size attributes."
"Then, the advance method is called on each of the objects.The first call doesn't have any arguments, the second one receives one argument, and the third one receives two arguments."
"Finally, there is a text explaining that although the three methods have the same name (advance), they are considered different methods because they have different parameters. This is called overloading."
"Overloading
What is it used for?
Class
Objects
Overload
Although they have equal names,      they are two different methods, becausethey have different parameters"
"What is it?
- Two methods with the same name can be defined in the same class if they have different parameters
- It is widely used for constructors
- The method actually executed depends on the parameters passed when it is called
What is it used for?"
"What is it used for?
We see the definition of a class named Car. This class has three private attributes: color of type String, speed of type int and size of type float."
"It also has a constructor that receives as parameters a String, an int and a float, and it assigns each parameter to the corresponding attribute."
"There are also three public methods named advance. The first one receives no parameters, the second one receives an int as a parameter, and the third one receives an int and another int."
"Finally, there are three public methods with no parameters: brake, turnLeft and turnRight.
On the right-hand side, we see an example of code that uses this class."
"We see the definition of the main method, where three instances of the class Car are created: myCar, yourCar and hisCar.
Each one is initialized with different values for the color, speed and size attributes."
"Then, the advance method is called on each of the objects.The first call doesn't have any arguments, the second one receives one argument, and the third one receives two arguments."
"Finally, there is a text explaining that although the three methods have the same name (advance), they are considered different methods because they have different parameters. This is called overloading."
"Exercise 2
•
In the class Bicycle, implement theoverloaded methods setCadence(), andsetGear(), which do not receive argumentsand change the values of cadence and gear toone value by default: 1."
"In the class Bicycle, implement the overloaded methods setCadence() and setGear(), which do not receive arguments and change the values of cadence and gear to one value by default: 1."
"Constructors
• When an object is created, its members are initialized
using a constructor method
• Constructors:
– Have the same name as the class
– They have no return type (not even void)
• At least one constructor should be defined per class"
"• At least one constructor should be defined per class
• Several constructors can exist, and they are distinguished
by their parameters (overloading)"
"• A default constructor without parameters, which initializesthe attributes to their default values, is created if no explicitconstructors are defined,If there is a constructor in the class, the default constructorno longer exits"
". In that case, if a constructor withoutparameters is desired, it needs to be explicitly declared"
•
"When an object is created, its members are initialized using a constructor method.  have the same name as the class. They have no return type, not even void. At least one constructor should be defined per class"
". At least one constructor should be defined per class. Several constructors can exist, and they are distinguished by their parameters, this is called overloading"
". A default constructor without parameters, which initializes the attributes to their default values, is created if no explicit constructors are defined. If there is a constructor in the class, the default constructor no longer exists"
". In that case, if a constructor without parameters is desired, it needs to be explicitly declared."
"The image shows an example of constructor overloading in Java.
On the left side, we see the definition of the class ""Car"". The class has three private attributes: ""color"" of type String, ""speed"" of type int, and ""size"" of type float."
"The class ""Car"" has four constructors:
- A constructor with no arguments.
- A constructor with one argument of type String, which sets the ""color"" attribute.
- A constructor with two arguments: a String for the ""color"" and an int for the ""speed""."
"- A constructor with three arguments: a String for the ""color"", an int for the ""speed"", and a float for the ""size""."
"The class also has four public methods: ""advance"", ""brake"", ""turnLeft"", and ""turnRight"". However, these methods are empty and do not contain any implementation."
"On the right side, we see an example of how to create an array of ""Car"" objects using the different constructors. The code defines a ""garage"" array of ""Car"" objects and initializes it with three ""Car"" objects:"
"- The first ""Car"" object is created using the constructor with one argument ""green"", which sets the color of the car to green.
- The second ""Car"" object is created using the constructor with two arguments: ""red"" for the color and 120 for the speed."
"- The third ""Car"" object is created using the constructor with three arguments: ""yellow"" for the color, 100 for the speed, and 3.4f for the size."
"The text ""Overload of constructors"" emphasizes the concept of having multiple constructors with different parameters in the same class."
"Constructors
Class Car
Array of objects of the Class Car
Overload ofconstructors"
"When an object is created, its members are initialized using a constructor method.  have the same name as the class. They have no return type, not even void. At least one constructor should be defined per class"
". At least one constructor should be defined per class. Several constructors can exist, and they are distinguished by their parameters, this is called overloading"
". A default constructor without parameters, which initializes the attributes to their default values, is created if no explicit constructors are defined. If there is a constructor in the class, the default constructor no longer exists"
". In that case, if a constructor without parameters is desired, it needs to be explicitly declared."
"The image shows an example of constructor overloading in Java.
On the left side, we see the definition of the class ""Car"". The class has three private attributes: ""color"" of type String, ""speed"" of type int, and ""size"" of type float."
"The class ""Car"" has four constructors:
- A constructor with no arguments.
- A constructor with one argument of type String, which sets the ""color"" attribute.
- A constructor with two arguments: a String for the ""color"" and an int for the ""speed""."
"- A constructor with three arguments: a String for the ""color"", an int for the ""speed"", and a float for the ""size""."
"The class also has four public methods: ""advance"", ""brake"", ""turnLeft"", and ""turnRight"". However, these methods are empty and do not contain any implementation."
"On the right side, we see an example of how to create an array of ""Car"" objects using the different constructors. The code defines a ""garage"" array of ""Car"" objects and initializes it with three ""Car"" objects:"
"- The first ""Car"" object is created using the constructor with one argument ""green"", which sets the color of the car to green.
- The second ""Car"" object is created using the constructor with two arguments: ""red"" for the color and 120 for the speed."
"- The third ""Car"" object is created using the constructor with three arguments: ""yellow"" for the color, 100 for the speed, and 3.4f for the size."
"The text ""Overload of constructors"" emphasizes the concept of having multiple constructors with different parameters in the same class."
"Exercise 3
•
In the class Bicycle, implement an additionalconstructor, which does not receive arguments,and that initializes the speed to 0, and thecadence and gear to 1."
"In the class ""Bicycle"", implement an additional constructor, which does not receive arguments, and that initializes the ""speed"" to 0, and the ""cadence"" and ""gear"" to 1."
"Modifiers and access
Static (static members)
• static modifier
• Static members exist only once per class,
independently of the number of instances (objects) ofthe class that have been created or even if there noinstances have been created yet."
"• The method or attribute behaves always in the
same way
• Static members can be accessed using the class
name.
• A static method cannot access non-static members
directly; an object must be created first."
"Static (static members)
- Static modifier
- Static members exist only once per class, independently of the number of instances (objects) of the class that have been created or even if there are no instances created yet"
"- The method or attribute behaves always in the same way
- Static members can be accessed using the class name
- A static method cannot access non-static members directly; an object must be created first
Static (static members)"
We have a code snippet that shows how to declare a static attribute in Java
". The example is a class named Car that has a private string attribute for color, a private int attribute for speed, a private float attribute for size, and a private static int attribute for the number of wheels. The static attribute is initialized to 4."
"There is another code snippet showing a static method. The example is the main method, which is declared as public static void. It takes a string array as an argument"
". It takes a string array as an argument. Inside the method, we see how to access the static attribute numberOfWheels using the class name Car followed by a dot and the attribute name."
"On the right-hand side, we see other examples of static members. We have the mathematical constant PI, the minimum value of an integer, and the maximum value of an integer."
"The last code snippet shows that the static method main can access other static members without creating instances of the class. In this case, we are using the static methods sqrt and cos from the Math class.
Static. Some rules"
"Static. Some rules
- Static members are invoked with ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
- Non static members require an instance (object) in order to be accessed: ""ClassName objectName = new ClassName();""."
"- Non static members are invoked with ""objectName.normalMethod();"" and ""objectName.normalAttribute;""."
"- When a static member is invoked (called) from inside the same class, the class name can be deleted. We can write ""staticMethod();"" and ""staticAttribute;"" instead of ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
Final"
"Final
- If we do not want that derived classes can modify (override) a method or attribute of the base class, then the final modifier shall be used.
Final
The final modifier can be applied to parameters, attributes, methods and classes."
"When applied to **parameters**, it means that their value cannot be changed inside the method. For example, in the code snippet 'public void myMethod(final int[] p1, int p2) { }', the values of p1 cannot be changed."
"When applied to **attributes**, it means that their value cannot be changed in the class. It is used together with 'static' to define constants. For example, in the code snippet 'public static final double PI = 3.14;', the value of PI cannot be changed."
"When applied to **methods**, it means that they cannot be overridden in derived classes. For example, in the code snippet 'public final void myMethod() { }', myMethod cannot be overridden."
"When applied to **classes**, it means that the class cannot be extended or inherited. For example, in the code snippet 'public final class myClass(){}', myClass cannot be extended."
"Modifiers and access
Static (static members)
Static attribute
…
static attribute
Other examples
=>  -231
=>  231-1
Static method: It has access to static attributes.
We do not need to create instances"
"We do not need to create instances
https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Math.html"
"Static (static members)
- Static modifier
- Static members exist only once per class, independently of the number of instances (objects) of the class that have been created or even if there are no instances created yet"
"- The method or attribute behaves always in the same way
- Static members can be accessed using the class name
- A static method cannot access non-static members directly; an object must be created first
Static (static members)"
We have a code snippet that shows how to declare a static attribute in Java
". The example is a class named Car that has a private string attribute for color, a private int attribute for speed, a private float attribute for size, and a private static int attribute for the number of wheels. The static attribute is initialized to 4."
"There is another code snippet showing a static method. The example is the main method, which is declared as public static void. It takes a string array as an argument"
". It takes a string array as an argument. Inside the method, we see how to access the static attribute numberOfWheels using the class name Car followed by a dot and the attribute name."
"On the right-hand side, we see other examples of static members. We have the mathematical constant PI, the minimum value of an integer, and the maximum value of an integer."
"The last code snippet shows that the static method main can access other static members without creating instances of the class. In this case, we are using the static methods sqrt and cos from the Math class.
Static. Some rules"
"Static. Some rules
- Static members are invoked with ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
- Non static members require an instance (object) in order to be accessed: ""ClassName objectName = new ClassName();""."
"- Non static members are invoked with ""objectName.normalMethod();"" and ""objectName.normalAttribute;""."
"- When a static member is invoked (called) from inside the same class, the class name can be deleted. We can write ""staticMethod();"" and ""staticAttribute;"" instead of ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
Final"
"Final
- If we do not want that derived classes can modify (override) a method or attribute of the base class, then the final modifier shall be used.
Final
The final modifier can be applied to parameters, attributes, methods and classes."
"When applied to **parameters**, it means that their value cannot be changed inside the method. For example, in the code snippet 'public void myMethod(final int[] p1, int p2) { }', the values of p1 cannot be changed."
"When applied to **attributes**, it means that their value cannot be changed in the class. It is used together with 'static' to define constants. For example, in the code snippet 'public static final double PI = 3.14;', the value of PI cannot be changed."
"When applied to **methods**, it means that they cannot be overridden in derived classes. For example, in the code snippet 'public final void myMethod() { }', myMethod cannot be overridden."
"When applied to **classes**, it means that the class cannot be extended or inherited. For example, in the code snippet 'public final class myClass(){}', myClass cannot be extended."
"Modifiers and access
Static. Some rules
• Static members are invoked with:
ClassName.staticMethod();
ClassName.staticAttribute;
• Non static members require an instance (object) in order to be
accessed.
ClassName objectName = new ClassName();"
"accessed.
ClassName objectName = new ClassName();
• Non static members are invoked with:
objectName.normalMethod();
objectName.normalAttribute;
• When a static member is invoked (called) from inside the same"
"• When a static member is invoked (called) from inside the same
class, the class name can be deleted. We can write:
instead of:
staticMethod();
staticAttribute;
ClassName.staticMethod();
ClassName.staticAttribute;"
"Static (static members)
- Static modifier
- Static members exist only once per class, independently of the number of instances (objects) of the class that have been created or even if there are no instances created yet"
"- The method or attribute behaves always in the same way
- Static members can be accessed using the class name
- A static method cannot access non-static members directly; an object must be created first
Static (static members)"
We have a code snippet that shows how to declare a static attribute in Java
". The example is a class named Car that has a private string attribute for color, a private int attribute for speed, a private float attribute for size, and a private static int attribute for the number of wheels. The static attribute is initialized to 4."
"There is another code snippet showing a static method. The example is the main method, which is declared as public static void. It takes a string array as an argument"
". It takes a string array as an argument. Inside the method, we see how to access the static attribute numberOfWheels using the class name Car followed by a dot and the attribute name."
"On the right-hand side, we see other examples of static members. We have the mathematical constant PI, the minimum value of an integer, and the maximum value of an integer."
"The last code snippet shows that the static method main can access other static members without creating instances of the class. In this case, we are using the static methods sqrt and cos from the Math class.
Static. Some rules"
"Static. Some rules
- Static members are invoked with ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
- Non static members require an instance (object) in order to be accessed: ""ClassName objectName = new ClassName();""."
"- Non static members are invoked with ""objectName.normalMethod();"" and ""objectName.normalAttribute;""."
"- When a static member is invoked (called) from inside the same class, the class name can be deleted. We can write ""staticMethod();"" and ""staticAttribute;"" instead of ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
Final"
"Final
- If we do not want that derived classes can modify (override) a method or attribute of the base class, then the final modifier shall be used.
Final
The final modifier can be applied to parameters, attributes, methods and classes."
"When applied to **parameters**, it means that their value cannot be changed inside the method. For example, in the code snippet 'public void myMethod(final int[] p1, int p2) { }', the values of p1 cannot be changed."
"When applied to **attributes**, it means that their value cannot be changed in the class. It is used together with 'static' to define constants. For example, in the code snippet 'public static final double PI = 3.14;', the value of PI cannot be changed."
"When applied to **methods**, it means that they cannot be overridden in derived classes. For example, in the code snippet 'public final void myMethod() { }', myMethod cannot be overridden."
"When applied to **classes**, it means that the class cannot be extended or inherited. For example, in the code snippet 'public final class myClass(){}', myClass cannot be extended."
"Access
get() and set() methods
• Attributes in a class are typically private to avoid their access
and modification from any other class.
• Sometimes we want some classes to access the attributes
• get() and set() methods to control access"
"get() and set() methods
Attributes in a class are typically private to avoid their access and modification from any other class. Sometimes we want some classes to access the attributes. get() and set() methods to control access."
"There is a code snippet defining a class named Car. The class Car has two private attributes: color of type String and speed of type int. The class also has four public methods: getColor, setColor, getSpeed and setSpeed"
. The method getColor returns the value of the attribute color. The method setColor assigns the input parameter color to the attribute color. The method getSpeed returns the value of the attribute speed
. The method getSpeed returns the value of the attribute speed. The method setSpeed assigns the input parameter speed to the attribute speed.
"Exercise 4
•
In the class Bicycle, implement thenecessary get() and set() methods whichallow accessing and modifying all theattributes."
"In the class Bicycle, implement the necessary get() and set() methods which allow accessing and modifying all the attributes."
"Packages
• A package groups classes (and interfaces)
• Hierarchies in a package correspond to the hierarchies
of folders in disk
• Dots are used for referring to subpackages, classes
(and interfaces) in a package
– E.g.: When we import mathematical classes"
"– E.g.: When we import mathematical classes
import java.math.BigDecimal;
– The BigDecimal class is in the java/math folder of the JDK
– We do not need to import all the classes: e.g., java/lang
• String
• Integer
• NullPointerException"
"• String
• Integer
• NullPointerException
• ArrayIndexOutOfBoundsException"
"A package groups classes and interfaces. Hierarchies in a package correspond to the hierarchies of folders in the disk. Dots are used for referring to subpackages, classes, and interfaces in a package"
". For example, when we import mathematical classes we use ""import java.math.BigDecimal;"". The BigDecimal class is in the java/math folder of the JDK. We do not need to import all the classes, for example, java/lang"
". Some of the classes in java/lang are: String, Integer, NullPointerException, and ArrayIndexOutOfBoundsException."
"- Creating my own packages
    - Save the classes in a folder named as the package
    - All classes belonging to the package must include the following sentence as the first one: `package myOwnPackage;`"
"- In the class using the package, the corresponding import sentence must be included before the class declaration
        - `import myOwnPackage.Class1;` // import one class
        - `import myOwnPackage.*;` // all the classes in the package"
"Packages
• Creating my own packages
– Save the classes in a folder named as the package
– All classes belonging to the package must include the following
sentence as the first one:
package myOwnPackage;"
"sentence as the first one:
package myOwnPackage;
– In the class using the package, the corresponding importsentence must be included before the class declaration
import myOwnPackage.Class1; // import one class"
"import myOwnPackage.Class1; // import one class
import myOwnPackage.*; // all the classes in the package"
"A package groups classes and interfaces. Hierarchies in a package correspond to the hierarchies of folders in the disk. Dots are used for referring to subpackages, classes, and interfaces in a package"
". For example, when we import mathematical classes we use ""import java.math.BigDecimal;"". The BigDecimal class is in the java/math folder of the JDK. We do not need to import all the classes, for example, java/lang"
". Some of the classes in java/lang are: String, Integer, NullPointerException, and ArrayIndexOutOfBoundsException."
"- Creating my own packages
    - Save the classes in a folder named as the package
    - All classes belonging to the package must include the following sentence as the first one: `package myOwnPackage;`"
"- In the class using the package, the corresponding import sentence must be included before the class declaration
        - `import myOwnPackage.Class1;` // import one class
        - `import myOwnPackage.*;` // all the classes in the package"
"Summary of elements in a program
Program
Classes (.java files)    (organized in packages)
Class members
Attributes
Methods
Primitivetype
Reference  
type
Regularmethods
Specialmethods
Objects
Arrays
Constructor Main
String"
"A diagram shows the elements of a program.  At the top is a box labeled ""Program"".  Below that is a box labeled ""Classes (.java files) (organized in packages)"".  Below that is a box labeled ""Class members"""
".  Below that is a box labeled ""Class members"".  Below that are two boxes, one labeled ""Attributes"" and the other labeled ""Methods"".  Below the ""Attributes"" box are three boxes: ""Primitive type"", ""Reference type"", and ""String"""
".  Below the ""Reference type"" box are two boxes: ""Objects"" and ""Arrays"".  Below the ""Methods"" box are three boxes: ""Regular methods"", ""Special methods"", and ""Constructor Main"".  The ""Special methods"" box is above the ""Constructor"" and ""Main"" boxes"
".  All boxes are connected with lines.  The ""Program"" box is connected to the ""Classes"" box.  The ""Classes"" box is connected to the ""Class members"" box.  The ""Class members"" box is connected to the ""Attributes"" and ""Methods"" boxes"
".  The ""Attributes"" box is connected to the ""Primitive type"", ""Reference type"", and ""String"" boxes.  The ""Reference type"" box is connected to the ""Objects"" and ""Arrays"" boxes"
".  The ""Methods"" box is connected to the ""Regular methods"", ""Special methods"", and ""Constructor Main"" boxes.  The ""Special methods"" box is connected to the ""Constructor"" and ""Main"" boxes."
"Summary of modifiers (so far)
MODIFIERS
class
method
attribute
public
(friendly)
private
static
a
c
c
e
s
s
o
t
h
e
r
Accessible from any other class
Accessible only to classes from the same package
Applied to inner classes
Accessible only inside the class"
"Applied to inner classes
Accessible only inside the class
Maximum level class.
It is the same for all theclass objects.
Use:
It is the same for all the classobjects.
Use:
ClassName.method ();
ClassName.attribute;"
"The table shows Java modifiers and their effect on classes, methods and attributes.The first modifier, public, can be applied to classes, methods and attributes and makes them accessible from any other class."
"The next modifier, friendly, can also be applied to classes, methods and attributes and makes them accessible only to classes from the same package."
"The private modifier, applicable to classes, methods and attributes, makes them accessible only inside the class."
"Finally, the static modifier can be applied to classes, methods and attributes. It defines the maximum level class. When applied to methods, it means that the method is the same for all the class objects and it can be used as ClassName.method();"
".method();. When applied to attributes, it means that the attribute is the same for all the class objects and it can be used as ClassName.attribute;"
"Systems Programming
Object-ORIENTED programming(basic)
Departamento de IngenieríaTelemática
CONTENTS ARE MOSTLY BASED ON THE WORK BY:
M. Carmen Fernández Panadero, Raquel M. Crespo García"
"M. Carmen Fernández Panadero, Raquel M. Crespo García
Carlos Delgado Kloos, Natividad Martínez Madrid,                                       
Carlos Alario Hoyos, Julio Villena Román"
Object-ORIENTED programming (basic)
"The title of  """" and the subtitle is ""Object-ORIENTED programming (basic)"".  The name of the department is ""Departamento de Ingeniería Telemática"". The contents of  based on the work of M. Carmen Fernández Panadero, Raquel M"
". Carmen Fernández Panadero, Raquel M. Crespo García, Carlos Delgado Kloos, Natividad Martínez Madrid, Carlos Alario Hoyos, and Julio Villena Román. The logo of Universidad Carlos III de Madrid is displayed in the bottom left corner of the slide"
. The Creative Commons license logo is displayed in the top left corner of the slide.
Object-ORIENTED programming (advanced)
"The title of  """" with a subtitle ""Object-ORIENTED programming (advanced)"".  It seems to be part of a presentation for the Telematics Engineering Department as indicated in the smaller text"
.  The footnote indicates this presentation is based mostly on the work of six individuals.
"Key terms
•
Inheritance
– Naming
q Generalization vs. specialization
q Superclass vs. subclass
q Parent class vs, child class
q Base class vs. derived class
– Java syntax
q extends
q super
q protected
q final
– Java Hierarchy
– Overriding
– Constructors"
"q final
– Java Hierarchy
– Overriding
– Constructors
– Polymorphism"
"The key terms are object and class, state and behavior, attribute and method, data abstraction versus functional abstraction, private/public attribute/method + class, message passing, overloading method, constructor method, static attribute/method"
", constructor method, static attribute/method, get/set method, and package"
.
"key terms related to inheritance. The terms are grouped into the following categories: naming, Java syntax, Java hierarchy, overriding, constructors, and polymorphism."
"The naming category lists the following terms: generalization versus specialization, superclass versus subclass, parent class versus child class, and base class versus derived class."
"The Java syntax category lists the following keywords: extends, super, protected, and final.
The remaining categories, Java hierarchy, overriding, constructors, and polymorphism, are listed as single terms."
"- Casting which can be upcasting vs downcasting or widening vs narrowing
- Abstract classes and methods, including inheritance and polymorphism
- Interfaces, including implements, inheritance and polymorphism"
"Some classes so far…
Car
Bicycle
Attributes
Attributes
Methods
Methods"
"Scenario V:Reusing code. Inheritance
• Once you can create your own classes, you are ready to work in teams"
"and reuse code developed by your colleagues. Your team will provide youwith a set of classes and you are required to create specializations orgeneralizations of them.
• Objective:"
"• Objective:
– Be able to create a derived class adding some characteristics (attributes) and
behavior (methods) to an existing class.
– Be able to extract all the common code from a set of similar classes in order to"
"group it into a new parent class so that the code is easier to maintain.
– Be able to create objects, and reference and access their attributes andmethods, depending on their position in the inheritance hierarchy and theirmodifiers.
• Work plan:"
"• Work plan:
– Memorize the naming related to inheritance
– Memorize the Java syntax related to inheritance (extends), to reference (super, this) and
to advanced access modifiers (protected)."
"to advanced access modifiers (protected).
– Know basic inheritance mechanisms, such as attribute hiding, overriding of methods, and
what they are used for and how they are used."
"Contents
• Basic inheritance concepts
• Inheritance hierarchy
• Overriding I: Attribute Hiding
• Overriding II: Method Overriding
• Constructors of derived classes
• Polymorphism
• The final modifier"
"topics related to object-oriented programming: classes and objects, object encapsulation with functional and data abstraction, class members, message passing, overloading, constructors, modifiers and access, and packages.
- Basic inheritance concepts"
"- Basic inheritance concepts
- Inheritance hierarchy
- Overriding I: Attribute Hiding
- Overriding II: Method Overriding
- Constructors of derived classes
- Polymorphism
- The final modifier"
"Inheritance
What is it? What is it for?
• Mechanism for software reuse
• Allows defining related classes from a given class
as a:
– Specialization of the given class. (e.g., “Car” class is a
specialization of the class “Vehicle”)"
"specialization of the class “Vehicle”)
• Scenario: We must implement a new class that is very similar to a previous
one, but it needs additional information (characteristics and behavior)"
"• Solution: Create a class that derives from the old one, and add it new
functionality without having to rewrite the common code
– Generalization of the given class (e.g., the “Vehicle” class
is a generalization of the “Car” class)"
"is a generalization of the “Car” class)
• Scenario: We have a set of similar classes with code that is repeated in everyclass and thus difficult to update and maintain (e.g., a letter should be added tothe serial number)"
• Solution: Move the code that is repeated to a single place (the parent class)
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
What is it?
N o in h erita n ce
Resource
• name
• description
• getName()
• getDescription()
Resource
• name
• description
• getName()
• getDescription()
I
n
h
e
rit
a
n
c
e
Classroom
• name
• description
• location
• getName()"
"a
n
c
e
Classroom
• name
• description
• location
• getName()
• getDescription()
• getLocation()
Computer
• name
• description
• operatingSystem
• getName()
• getDescription()
• getOS()
Classroom
• location
• getLocation()
Computer
• operatingSystem"
"Classroom
• location
• getLocation()
Computer
• operatingSystem
• getOS()
public class Classroom extends Resource
public class Computer extends Resource"
"public class Computer extends Resource
The attributes and methods that appear in blue in the parent class are repeated in thesubclasses. (Left picture)"
"It is not necessary to repeat the code, you only have to say that a class extends the other orinherits from it. (Right picture)"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
Naming
• If we define the Car class from the Vehicle class,
it is said that:
– Car inherits attributes and methods from Vehicle
– Car extends Vehicle
– Car is a subclass of Vehicle
Derived class
Child class
– Vehicle is a superclass of Car"
"Derived class
Child class
– Vehicle is a superclass of Car
Base class
Parent class
• Inheritance implements the is-a relation– A car is-a vehicle; a dog is-a mammal, etc."
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
Declaration of subclasses
• The syntax for declaring subclasses is:
class Subclass extends Superclass { ... }
Person
Student
Employee
class Person { ... }
class Student extends Person { ... }
class Employee extends Person { ... }"
"class Employee extends Person { ... }
class Professor extends Employee { ... }
class Secretary extends Employee { ... }
Professor
Secretary
Each class in a different file and declared as public"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
Subclass
Attributes
Methods
print
firstName
lastName
birthYear
Inherited from class Person
group
timetable
Class Student
setGroup
setTimetable
printGroup"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
How is it used?
public class Person {
protected String firstName;
protected String lastName;
protected int birthYear;
public Person () {
}
public Person (String firstName, String lastName,
int birthYear){
this.firstName = firstName;"
"int birthYear){
this.firstName = firstName;
this.lastName = lastName;
this.birthYear = birthYear;
}
public void print(){
System.out.print(""Personal data: "" + firstName
+ "" "" + lastName + "" (“
+ birthYear + "")"");
}
}
protectedaccessible fromsubclasses"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
How is it used?
public class Student extends Person {
protected String group;
protected char timetable;
public Student() {}
public Student(String firstName, String lastName,
int birthYear, String group, char timetable) {"
"int birthYear, String group, char timetable) {
super(firstName, lastName, birthYear);
setGroup(group);
setTimetable (timetable);
}
public void setGroup(String group){
if (group == null || group.length() == 0){
System.out.println (""Invalid group"");"
"System.out.println (""Invalid group"");
} else { this.group = group; }
}
public void setTimetable(char timetable){
if (timetable != 'M' && timetable != 'A'){
System.out.println (""Invalid group"");
} else { this.timetable = timetable; }
}"
"} else { this.timetable = timetable; }
}
public void printGroup(){
System.out.print("" Group "" + group + timetable);
}
}
superto access attributes ormethods from thesuperclass"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
How is it used?
public class Test {
public static void main (String[] args){   
Person neighbor = new Person (""Luisa"", ""Asenjo Martínez"", 1978);
Student aStudent = new Student (""Juan"", ""Ugarte López"", 1985, 
“65”, ‘A');
aStudent.setGroup(""66"");"
"“65”, ‘A');
aStudent.setGroup(""66"");
aStudent.setTimetable('M');    neighbor.print();
aStudent.print();
aStudent.printGroup();
}
}
Output on screen:
Personal data: Luisa Asenjo Martínez (1978)
Personal data: Juan Ugarte López (1985)
Group 66M"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
What if…?
• We define the attribute firstName of Person as
private.
⎻ We inherit it, but we cannot access it, unless we implement
methods to do so (e.g., getFirstName())
• We implement the constructor of the subclass"
"• We implement the constructor of the subclass
Student assigning the values directly to attributesinstead of calling to super
⎻ Not taking advantage of code reuse⎻ It is valid in this case because attributes are defined as"
"protected (but this is not always the case!!)
public Student(String firstName,    
public Student(String firstName,    
String lastName, int birthYear,   String group, char timetable){
String lastName, int birthYear,   String group, char timetable){"
"this.firstName = firstName; this.lastName = lastName;
this.birthYear = birthYear;
super(firstName, lastName, birthYear);
this.group = group;
this.timetable = timetable;
this.group = group;
this.timetable = timetable;
}
}"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
Consequences of extension of classes
•
•
Inheritance of the interface
⎻ The public part of the subclass contains the public
part of the superclass. The Student classcontains the method print()
Inheritance of the implementation"
"Inheritance of the implementation
⎻ The implementation of the subclass contains the
implementation of the superclass. When callingthe method of the superclass on an object of thesubclass (aStudent.print()) the expectedbehavior takes place"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Exercise 5
•
•
•
•"
"•
•
•
•
Starting from the class Bicycle, which has threeattributes, speed, cadence and gear, of type integerand four methods speedUp(), brake(),setCadence(int newCadence), andsetGear(int newGear), implement the classesMountainBike and TandemBike."
"MountainBike has an attribute suspension of typeinteger, and a method setSuspension(int
suspension)
TandemBike has an attribute numSeats of type integer.
Program the constructors of these classes to initialize alltheir attributes, making use of super"
"Starting from the class ""Bicycle"", which has three attributes: ""speed"", ""cadence"" and ""gear"" of type integer, and four methods: ""speedUp"", ""brake"", ""setCadence"" which takes an integer ""newCadence"" as input"
", ""setCadence"" which takes an integer ""newCadence"" as input, and ""setGear"" which takes an integer ""newGear"" as input, implement the classes ""MountainBike"" and ""TandemBike"""
.
"""MountainBike"" has an attribute ""suspension"" of type integer, and a method ""setSuspension"" which takes an integer ""suspension"" as input.
""TandemBike"" has an attribute ""numSeats"" of type integer."
"""TandemBike"" has an attribute ""numSeats"" of type integer.
Program the constructors of these classes to initialize all their attributes, making use of ""super""."
"Inheritance
Inheritance hierarchy in Java
• In Java, all classes are related through a
single inheritance hierarchy
• A class can:
⎻ Explicitly inherit from another class, or
⎻ Implicitly inherit from the Object class
(defined in the Java core)"
"(defined in the Java core)
• This is the case both for predefinedclasses and for user-defined classes"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
Inheritance hierarchy in Java
Object
Boolean
Character
Number
String
Person
…
Integer
Long
Float
Double
Student
Employee
Secretary
Professor
Integer i = new Integer(3); // Deprecated (Warning)
Integer i = 3; // Autoboxing"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Inheritance
Overriding
• Modification of the elements of the base
class inside the derived class
• The derived class can define:
– An attribute with the same name as one of
the base class → Attribute hiding"
"the base class → Attribute hiding
– A method with the same signature as oneof the base class → Method overriding
• The second case is more usual"
"What is it? What is it for?
- Mechanism for software reuse
- Allows defining related classes from a given class as a:
    - Specialization of the given class. (e.g., ""Car"" class is a specialization of the class ""Vehicle"")"
"- Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)"
"- Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code
    - Generalization of the given class (e.g., the ""Vehicle"" class is a generalization of the ""Car"" class)"
"- Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)"
"- Solution: Move the code that is repeated to a single place (the parent class)
Naming"
"Naming
If we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car."
"There is a list of terms: Derived class, Child class, Base class, Parent class.
 implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc.
Declaration of subclasses
The syntax for declaring subclasses is:"
"The syntax for declaring subclasses is:
""class"" Subclass ""extends"" Superclass { ... }
There is a diagram showing the inheritance hierarchy of some classes.
There is a base class ""Person"" from which two classes inherit: ""Student"" and ""Employee""."
"""Employee"" has two subclasses: ""Professor"" and ""Secretary"".
There is also a code snippet showing how to declare the classes:
""class"" Person { ... }
""class"" Student ""extends"" Person { ... }
""class"" Employee ""extends"" Person { ... }"
"""class"" Employee ""extends"" Person { ... }
""class"" Professor ""extends"" Employee { ... }
""class"" Secretary ""extends"" Employee { ... }
Finally, there is a note indicating that each class is in a different file and declared as public.
Subclass"
"We see a class diagram representing the concept of inheritance. The subclass ""Student"" inherits from the superclass ""Person"". The ""Person"" class has attributes: ""firstName"", ""lastName"", and ""birthYear"", and a method ""print"""
". The ""Student"" class inherits these attributes and method, and additionally has attributes: ""group"" and ""timetable"", and methods: ""setGroup"", ""setTimetable"", and ""printGroup""."
How is it used?
"We see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method"
". The print method outputs the text ""Personal data:"" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis."
"On the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method.
What if...?"
"What if...?
We are defining the attribute ""firstName"" of ""Person"" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: ""getFirstName""."
"We implement the constructor of the subclass ""Student"", assigning the values directly to attributes instead of calling to ""super"". This means we are not taking advantage of code reuse"
". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case."
"There are two code snippets, one on the left and one on the right, both showing the constructor of the subclass ""Student""."
"The code on the left shows the constructor ""Student"" with parameters ""firstName"", ""lastName"", ""birthYear"", ""group"" and ""timetable"". It then assigns each parameter to the corresponding attribute of the class."
"The code on the right shows the constructor ""Student"" with the same parameters as before. However, in this case, it calls the constructor of the superclass, ""super"", with parameters ""firstName"", ""lastName"" and ""birthYear"""
". Then, it assigns the parameters ""group"" and ""timetable"" to the corresponding attributes of the class."
"Finally, there is a big ""OK"" at the bottom right of the image.
Consequences of extension of classes
There are two bullet points on this slide, both discussing the consequences of class extension:  of the interface and  of the implementation."
"The first bullet point,  of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print()."
"The second bullet point,  of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent"
".print(), the expected behavior takes place."
"hierarchy in Java
In Java, all classes are related through a single inheritance hierarchy.
A class can:
- Explicitly inherit from another class, or
- Implicitly inherit from the **Object** class (defined in the Java core)"
"This is the case both for predefined classes and for user-defined classes.
 hierarchy in Java"
"We see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee"
". Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object."
"Below the diagram, we see two lines of code. The first line, ""Integer i = new Integer(3);"", is marked as deprecated with a warning. The second line, ""Integer i = 3;"", is an example of autoboxing.
Overriding"
"Overriding
- Modification of the elements of the base class inside the derived class
- The derived class can define:
  - An attribute with the same name as one of the base class, which is called attribute hiding"
"- A method with the same signature as one of the base class, which is called method overriding
- The second case, method overriding, is more usual"
"Overriding I (Shadowing)
Attribute hiding
• If we define an attribute (variable) in a
subclass with the same name and type thatanother attribute in the superclass, thevariable in the superclass remains hidden
• We can access one variable or the other"
"• We can access one variable or the other
using  this and super."
"Attribute hiding
- If we define an attribute (variable) in a subclass with the same name and type that another attribute in the superclass, the variable in the superclass remains hidden
- We can access one variable or the other using this and super."
"- We can access one variable or the other using this and super.
Attribute hiding
We have a class named Student that inherits from class Person.
There are 3 code snippets that instantiate objects of these classes and access the firstName attribute."
"The first one instantiates a Student object and accesses its firstName attribute.
The second one instantiates a Person object and accesses its firstName attribute."
"The third one assigns the Student object to a Person variable and accesses its firstName attribute.
Although the three snippets access an attribute with the same name, the type might be different."
"The Person class has the following attributes: firstName, lastName, and yearBirth, all inherited from the Person class. It also has a print method."
"The Student class has the following attributes: firstName, group, and timetable. It also has the following methods: setGroup, setTimetable, and printGroup.
Attribute hiding. Example
We see code illustrating attribute hiding in Java."
"We see code illustrating attribute hiding in Java.
There are three classes defined: Person, Student, and Test.
The Person class has a protected String attribute called firstName initialized to ""Juan""."
"The Student class extends Person and declares a protected int attribute also named firstName, initialized to 10003041. This demonstrates attribute hiding, where the Student class's firstName attribute shadows the Person class's firstName attribute."
"The Test class contains a main method. Inside the main method:
- A new Student object is created and assigned to variable 's'."
"- A new Student object is created and assigned to variable 's'.
- A Person variable 'p' is declared and assigned the value of 's'. This is valid due to polymorphism, as Student is a subclass of Person.
- Two print statements are called:"
"- Two print statements are called:
    - The first prints the value of p.firstName. Since 'p' is of type Person, it accesses the firstName attribute from the Person class, resulting in ""Juan"" being printed."
"- The second prints the value of s.firstName. As 's' is of type Student, it accesses the firstName attribute from the Student class, printing ""10003041""."
"This example highlights how attribute hiding can lead to different values being accessed depending on the object's reference type.
Attribute hiding"
"Attribute hiding
The image describes the concept of attribute hiding in object-oriented programming, specifically focusing on how to access hidden variables in a class hierarchy."
"There are three classes: ""Transport"", ""Vehicle"", and ""Car"". ""Transport"" is the parent class of ""Vehicle"", which in turn is the parent class of ""Car"". Each class has a ""name"" attribute"
". Each class has a ""name"" attribute. The ""Car"" class overrides the ""name"" attribute inherited from its parent classes."
"The image then lists different ways to access the hidden ""name"" variables:
* **name:** This refers to the ""name"" variable of the current class, which is ""Car"" in this case."
"* **this.name:** This also refers to the ""name"" variable of the current class, ""Car"".
* **super.name:** This refers to the ""name"" variable of the immediate parent class, ""Vehicle""."
"* **((Vehicle)this).name:** This explicitly casts the current object to the ""Vehicle"" type and accesses its ""name"" variable."
"* **super.super.name:** This is marked as WRONG because it attempts to access the ""name"" variable of the grandparent class, ""Transport"", which is not directly accessible."
"* **((Transport)this).name:** This explicitly casts the current object to the ""Transport"" type and accesses its ""name"" variable."
"The image also visually separates the accessible variables from the hidden ones. The ""name"" variables of the ""Car"" and ""Vehicle"" classes are grouped together and labeled as ""visible"" because they can be accessed directly"
". The ""name"" variable of the ""Transport"" class is labeled as ""hidden"" because it's not directly accessible from the ""Car"" class."
"Overriding I (Shadowing)
Attribute hiding
Attributes
Methods
Student s = new Student(...);
System.out.println(s.firstName);
print()
firstName
firstName
lastName
yearBirth
Person p1 = new Person(...);
System.out.println(p1.firstName);"
"Person p1 = new Person(...);
System.out.println(p1.firstName);
Inherited from class Person
Person p2 = s;
System.out.println(p2.firstName);
• Same name but the
type might be different
firstName
group
timetable
setGroup(String s)
setTimetable(char c)"
"group
timetable
setGroup(String s)
setTimetable(char c)
printGroup()
Class Student"
"Attribute hiding
- If we define an attribute (variable) in a subclass with the same name and type that another attribute in the superclass, the variable in the superclass remains hidden
- We can access one variable or the other using this and super."
"- We can access one variable or the other using this and super.
Attribute hiding
We have a class named Student that inherits from class Person.
There are 3 code snippets that instantiate objects of these classes and access the firstName attribute."
"The first one instantiates a Student object and accesses its firstName attribute.
The second one instantiates a Person object and accesses its firstName attribute."
"The third one assigns the Student object to a Person variable and accesses its firstName attribute.
Although the three snippets access an attribute with the same name, the type might be different."
"The Person class has the following attributes: firstName, lastName, and yearBirth, all inherited from the Person class. It also has a print method."
"The Student class has the following attributes: firstName, group, and timetable. It also has the following methods: setGroup, setTimetable, and printGroup.
Attribute hiding. Example
We see code illustrating attribute hiding in Java."
"We see code illustrating attribute hiding in Java.
There are three classes defined: Person, Student, and Test.
The Person class has a protected String attribute called firstName initialized to ""Juan""."
"The Student class extends Person and declares a protected int attribute also named firstName, initialized to 10003041. This demonstrates attribute hiding, where the Student class's firstName attribute shadows the Person class's firstName attribute."
"The Test class contains a main method. Inside the main method:
- A new Student object is created and assigned to variable 's'."
"- A new Student object is created and assigned to variable 's'.
- A Person variable 'p' is declared and assigned the value of 's'. This is valid due to polymorphism, as Student is a subclass of Person.
- Two print statements are called:"
"- Two print statements are called:
    - The first prints the value of p.firstName. Since 'p' is of type Person, it accesses the firstName attribute from the Person class, resulting in ""Juan"" being printed."
"- The second prints the value of s.firstName. As 's' is of type Student, it accesses the firstName attribute from the Student class, printing ""10003041""."
"This example highlights how attribute hiding can lead to different values being accessed depending on the object's reference type.
Attribute hiding"
"Attribute hiding
The image describes the concept of attribute hiding in object-oriented programming, specifically focusing on how to access hidden variables in a class hierarchy."
"There are three classes: ""Transport"", ""Vehicle"", and ""Car"". ""Transport"" is the parent class of ""Vehicle"", which in turn is the parent class of ""Car"". Each class has a ""name"" attribute"
". Each class has a ""name"" attribute. The ""Car"" class overrides the ""name"" attribute inherited from its parent classes."
"The image then lists different ways to access the hidden ""name"" variables:
* **name:** This refers to the ""name"" variable of the current class, which is ""Car"" in this case."
"* **this.name:** This also refers to the ""name"" variable of the current class, ""Car"".
* **super.name:** This refers to the ""name"" variable of the immediate parent class, ""Vehicle""."
"* **((Vehicle)this).name:** This explicitly casts the current object to the ""Vehicle"" type and accesses its ""name"" variable."
"* **super.super.name:** This is marked as WRONG because it attempts to access the ""name"" variable of the grandparent class, ""Transport"", which is not directly accessible."
"* **((Transport)this).name:** This explicitly casts the current object to the ""Transport"" type and accesses its ""name"" variable."
"The image also visually separates the accessible variables from the hidden ones. The ""name"" variables of the ""Car"" and ""Vehicle"" classes are grouped together and labeled as ""visible"" because they can be accessed directly"
". The ""name"" variable of the ""Transport"" class is labeled as ""hidden"" because it's not directly accessible from the ""Car"" class."
"Overriding I (Shadowing)
Attribute hiding. Example
class Person {
protected String firstName = ”Juan"";
}
class Student extends Person {
protected int firstName = 10003041;
}
class Test {
public static void main (String[] args) {
Student s = new Student();"
"Student s = new Student();
Person p = s;
System.out.println(p.firstName);
System.out.println(s.firstName);
}
prints “Juan”
prints10003041
}"
"Attribute hiding
- If we define an attribute (variable) in a subclass with the same name and type that another attribute in the superclass, the variable in the superclass remains hidden
- We can access one variable or the other using this and super."
"- We can access one variable or the other using this and super.
Attribute hiding
We have a class named Student that inherits from class Person.
There are 3 code snippets that instantiate objects of these classes and access the firstName attribute."
"The first one instantiates a Student object and accesses its firstName attribute.
The second one instantiates a Person object and accesses its firstName attribute."
"The third one assigns the Student object to a Person variable and accesses its firstName attribute.
Although the three snippets access an attribute with the same name, the type might be different."
"The Person class has the following attributes: firstName, lastName, and yearBirth, all inherited from the Person class. It also has a print method."
"The Student class has the following attributes: firstName, group, and timetable. It also has the following methods: setGroup, setTimetable, and printGroup.
Attribute hiding. Example
We see code illustrating attribute hiding in Java."
"We see code illustrating attribute hiding in Java.
There are three classes defined: Person, Student, and Test.
The Person class has a protected String attribute called firstName initialized to ""Juan""."
"The Student class extends Person and declares a protected int attribute also named firstName, initialized to 10003041. This demonstrates attribute hiding, where the Student class's firstName attribute shadows the Person class's firstName attribute."
"The Test class contains a main method. Inside the main method:
- A new Student object is created and assigned to variable 's'."
"- A new Student object is created and assigned to variable 's'.
- A Person variable 'p' is declared and assigned the value of 's'. This is valid due to polymorphism, as Student is a subclass of Person.
- Two print statements are called:"
"- Two print statements are called:
    - The first prints the value of p.firstName. Since 'p' is of type Person, it accesses the firstName attribute from the Person class, resulting in ""Juan"" being printed."
"- The second prints the value of s.firstName. As 's' is of type Student, it accesses the firstName attribute from the Student class, printing ""10003041""."
"This example highlights how attribute hiding can lead to different values being accessed depending on the object's reference type.
Attribute hiding"
"Attribute hiding
The image describes the concept of attribute hiding in object-oriented programming, specifically focusing on how to access hidden variables in a class hierarchy."
"There are three classes: ""Transport"", ""Vehicle"", and ""Car"". ""Transport"" is the parent class of ""Vehicle"", which in turn is the parent class of ""Car"". Each class has a ""name"" attribute"
". Each class has a ""name"" attribute. The ""Car"" class overrides the ""name"" attribute inherited from its parent classes."
"The image then lists different ways to access the hidden ""name"" variables:
* **name:** This refers to the ""name"" variable of the current class, which is ""Car"" in this case."
"* **this.name:** This also refers to the ""name"" variable of the current class, ""Car"".
* **super.name:** This refers to the ""name"" variable of the immediate parent class, ""Vehicle""."
"* **((Vehicle)this).name:** This explicitly casts the current object to the ""Vehicle"" type and accesses its ""name"" variable."
"* **super.super.name:** This is marked as WRONG because it attempts to access the ""name"" variable of the grandparent class, ""Transport"", which is not directly accessible."
"* **((Transport)this).name:** This explicitly casts the current object to the ""Transport"" type and accesses its ""name"" variable."
"The image also visually separates the accessible variables from the hidden ones. The ""name"" variables of the ""Car"" and ""Vehicle"" classes are grouped together and labeled as ""visible"" because they can be accessed directly"
". The ""name"" variable of the ""Transport"" class is labeled as ""hidden"" because it's not directly accessible from the ""Car"" class."
"Overriding I (Shadowing)
Attribute hiding
“Granny” class
Transport
String name = “ground""
Parent class
Train
Vehicle
String name = “car""
Child class
Scooter
Car
String name = ""Ferrari""
• How can I access hidden variables?
– name (Car name)"
"• How can I access hidden variables?
– name (Car name)
– this.name (Car name)
– super.name (Vehicle name)
– ((Vehicle)this).name (Vehicle name)
– super.super.name (WRONG)
– ((Transport)this).name (Transport name)
Variables
Child class:
visible
Variables"
"Variables
Child class:
visible
Variables
Parent class
hidden"
"Attribute hiding
- If we define an attribute (variable) in a subclass with the same name and type that another attribute in the superclass, the variable in the superclass remains hidden
- We can access one variable or the other using this and super."
"- We can access one variable or the other using this and super.
Attribute hiding
We have a class named Student that inherits from class Person.
There are 3 code snippets that instantiate objects of these classes and access the firstName attribute."
"The first one instantiates a Student object and accesses its firstName attribute.
The second one instantiates a Person object and accesses its firstName attribute."
"The third one assigns the Student object to a Person variable and accesses its firstName attribute.
Although the three snippets access an attribute with the same name, the type might be different."
"The Person class has the following attributes: firstName, lastName, and yearBirth, all inherited from the Person class. It also has a print method."
"The Student class has the following attributes: firstName, group, and timetable. It also has the following methods: setGroup, setTimetable, and printGroup.
Attribute hiding. Example
We see code illustrating attribute hiding in Java."
"We see code illustrating attribute hiding in Java.
There are three classes defined: Person, Student, and Test.
The Person class has a protected String attribute called firstName initialized to ""Juan""."
"The Student class extends Person and declares a protected int attribute also named firstName, initialized to 10003041. This demonstrates attribute hiding, where the Student class's firstName attribute shadows the Person class's firstName attribute."
"The Test class contains a main method. Inside the main method:
- A new Student object is created and assigned to variable 's'."
"- A new Student object is created and assigned to variable 's'.
- A Person variable 'p' is declared and assigned the value of 's'. This is valid due to polymorphism, as Student is a subclass of Person.
- Two print statements are called:"
"- Two print statements are called:
    - The first prints the value of p.firstName. Since 'p' is of type Person, it accesses the firstName attribute from the Person class, resulting in ""Juan"" being printed."
"- The second prints the value of s.firstName. As 's' is of type Student, it accesses the firstName attribute from the Student class, printing ""10003041""."
"This example highlights how attribute hiding can lead to different values being accessed depending on the object's reference type.
Attribute hiding"
"Attribute hiding
The image describes the concept of attribute hiding in object-oriented programming, specifically focusing on how to access hidden variables in a class hierarchy."
"There are three classes: ""Transport"", ""Vehicle"", and ""Car"". ""Transport"" is the parent class of ""Vehicle"", which in turn is the parent class of ""Car"". Each class has a ""name"" attribute"
". Each class has a ""name"" attribute. The ""Car"" class overrides the ""name"" attribute inherited from its parent classes."
"The image then lists different ways to access the hidden ""name"" variables:
* **name:** This refers to the ""name"" variable of the current class, which is ""Car"" in this case."
"* **this.name:** This also refers to the ""name"" variable of the current class, ""Car"".
* **super.name:** This refers to the ""name"" variable of the immediate parent class, ""Vehicle""."
"* **((Vehicle)this).name:** This explicitly casts the current object to the ""Vehicle"" type and accesses its ""name"" variable."
"* **super.super.name:** This is marked as WRONG because it attempts to access the ""name"" variable of the grandparent class, ""Transport"", which is not directly accessible."
"* **((Transport)this).name:** This explicitly casts the current object to the ""Transport"" type and accesses its ""name"" variable."
"The image also visually separates the accessible variables from the hidden ones. The ""name"" variables of the ""Car"" and ""Vehicle"" classes are grouped together and labeled as ""visible"" because they can be accessed directly"
". The ""name"" variable of the ""Transport"" class is labeled as ""hidden"" because it's not directly accessible from the ""Car"" class."
"Overriding II
Method overriding. What is it?
• Method overriding is useful for:
– Extending the functionality of a method
– Particularizing the functionality of the method in the derived class
• If the subclass defines a method with the same"
"• If the subclass defines a method with the same
signature (name + number and type of theparameters) the method in the superclass is hidden
• How can we access hidden methods?
– start() (runs the start method of the Car)"
"– start() (runs the start method of the Car)
– this.start() (runs the start method of the Car)
– super.start() (runs the start method of the Vehicle)
– super.super.start() (WRONG)
Methods ofthe childclass: visible
Methods ofthe parentclass: hidden"
"Method overriding. What is it?
Method overriding is useful for extending the functionality of a method and particularizing the functionality of the method in the derived class."
"If the subclass defines a method with the same signature, which is the name plus number and type of the parameters, the method in the superclass is hidden.
How can we access hidden methods?"
"How can we access hidden methods?
We can use start, which runs the start method of the car. This dot start runs the start method of the car. Super dot start runs the start method of the vehicle. Super dot super dot start is wrong."
"The methods of the child class are visible. The methods of the parent class are hidden.
Method overriding. What is it for?"
"We see two class diagrams. The first one shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds three methods: ""getLocation"", ""getDescriptoin"" and ""location"". The ""Computer"" class adds two methods: ""getOS"" and ""operatingSystem""."
"The second class diagram also shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds two methods: ""getLocation"" and ""location"". The ""Computer"" class adds one method: ""getOS"". The ""getDescription"" method in the ""Classroom"" class is highlighted and two more methods are shown below: ""this"
".getDescription()"" and ""super.getDescripcion""."
"Method overriding
The diagram illustrates the concept of method overriding in object-oriented programming."
"We see an object on the left side of the image, from which an arrow labeled ""message"" points to the right. The message contains the text ""method(parameters)"""
". The message contains the text ""method(parameters)"". On the right side, we see a flow chart with four boxes representing different classes: ""Subclass"", ""Superclass"", ""Another ancestor"", and ""Object"". These boxes are connected by upward arrows."
"The ""Subclass"" box is connected to the ""object"" with a dashed arrow labeled ""instance"". Each connection between the boxes has a corresponding cloud above it, containing the text ""∃ method(parameters)?"""
". All connections except the one from ""Object"" are also labeled ""no"". The connection from ""Object"" is labeled ""no"" and points to a box labeled ""error"""
".This diagram explains how the program searches for the correct method to execute when a message is sent to an object. It starts by checking the ""Subclass"" for a matching method"
". It starts by checking the ""Subclass"" for a matching method. If not found, it moves up the inheritance hierarchy to ""Superclass"", then ""Another ancestor"", and finally ""Object"". If a matching method is found at any level, it is executed"
". If a matching method is found at any level, it is executed. If no matching method is found even in the ""Object"" class, an error is thrown."
"Method overriding
When sending a message to an object, the selected method:
- Depends on the class which the object is an instance of
- Does not depend on the reference class to which it is assigned, as in the case of attributes
Method overriding. Example"
"We see three code snippets. The first one defines a class named ""Person"" with a protected string attribute called ""firstName"" initialized to ""Juan"""
". This class has a public method called ""print"" that prints ""Person"" followed by the value of the ""firstName"" attribute."
"The second snippet defines a class named ""Student"" that extends the ""Person"" class. This class also has a protected string attribute called ""firstName"", but it's initialized to ""Juan Pablo"""
". It also has a public method called ""print"" that prints ""Student"" followed by the value of the ""firstName"" attribute."
"The third snippet defines a class named ""Test2"" with a main method. Inside the main method, a new ""Student"" object is created and assigned to a variable called ""s"". Then, a ""Person"" variable called ""p"" is declared and assigned the value of ""s"""
". Finally, the ""print"" method is called on both ""s"" and ""p""."
"Both calls to the ""print"" method will output ""Student: Juan Pablo"" because the ""print"" method in the ""Student"" class overrides the ""print"" method in the ""Person"" class. This is an example of method overriding in Java."
"Overriding II
Method overriding. What is it for?
Resource
• name
• description
• getName()
• getDescription()
Resource
• name
• description
• getName()
• getDescription()
Classroom
• name
• description
• location
• getName()
• getDescriptoin()"
"• name
• description
• location
• getName()
• getDescriptoin()
• getLocation()
Computer
• name
• description
• operatingSystem
• getName()
• getDescription()
• getOS()
public class Classroom extends Resource
public class Computer extends Resource"
"public class Computer extends Resource
Classroom
• description
• location
• getLocation()
• getDescription()
Computer
• operatingSystem
• getOS()
this.getDescription()
super.getDescripcion"
"Method overriding. What is it?
Method overriding is useful for extending the functionality of a method and particularizing the functionality of the method in the derived class."
"If the subclass defines a method with the same signature, which is the name plus number and type of the parameters, the method in the superclass is hidden.
How can we access hidden methods?"
"How can we access hidden methods?
We can use start, which runs the start method of the car. This dot start runs the start method of the car. Super dot start runs the start method of the vehicle. Super dot super dot start is wrong."
"The methods of the child class are visible. The methods of the parent class are hidden.
Method overriding. What is it for?"
"We see two class diagrams. The first one shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds three methods: ""getLocation"", ""getDescriptoin"" and ""location"". The ""Computer"" class adds two methods: ""getOS"" and ""operatingSystem""."
"The second class diagram also shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds two methods: ""getLocation"" and ""location"". The ""Computer"" class adds one method: ""getOS"". The ""getDescription"" method in the ""Classroom"" class is highlighted and two more methods are shown below: ""this"
".getDescription()"" and ""super.getDescripcion""."
"Method overriding
The diagram illustrates the concept of method overriding in object-oriented programming."
"We see an object on the left side of the image, from which an arrow labeled ""message"" points to the right. The message contains the text ""method(parameters)"""
". The message contains the text ""method(parameters)"". On the right side, we see a flow chart with four boxes representing different classes: ""Subclass"", ""Superclass"", ""Another ancestor"", and ""Object"". These boxes are connected by upward arrows."
"The ""Subclass"" box is connected to the ""object"" with a dashed arrow labeled ""instance"". Each connection between the boxes has a corresponding cloud above it, containing the text ""∃ method(parameters)?"""
". All connections except the one from ""Object"" are also labeled ""no"". The connection from ""Object"" is labeled ""no"" and points to a box labeled ""error"""
".This diagram explains how the program searches for the correct method to execute when a message is sent to an object. It starts by checking the ""Subclass"" for a matching method"
". It starts by checking the ""Subclass"" for a matching method. If not found, it moves up the inheritance hierarchy to ""Superclass"", then ""Another ancestor"", and finally ""Object"". If a matching method is found at any level, it is executed"
". If a matching method is found at any level, it is executed. If no matching method is found even in the ""Object"" class, an error is thrown."
"Method overriding
When sending a message to an object, the selected method:
- Depends on the class which the object is an instance of
- Does not depend on the reference class to which it is assigned, as in the case of attributes
Method overriding. Example"
"We see three code snippets. The first one defines a class named ""Person"" with a protected string attribute called ""firstName"" initialized to ""Juan"""
". This class has a public method called ""print"" that prints ""Person"" followed by the value of the ""firstName"" attribute."
"The second snippet defines a class named ""Student"" that extends the ""Person"" class. This class also has a protected string attribute called ""firstName"", but it's initialized to ""Juan Pablo"""
". It also has a public method called ""print"" that prints ""Student"" followed by the value of the ""firstName"" attribute."
"The third snippet defines a class named ""Test2"" with a main method. Inside the main method, a new ""Student"" object is created and assigned to a variable called ""s"". Then, a ""Person"" variable called ""p"" is declared and assigned the value of ""s"""
". Finally, the ""print"" method is called on both ""s"" and ""p""."
"Both calls to the ""print"" method will output ""Student: Juan Pablo"" because the ""print"" method in the ""Student"" class overrides the ""print"" method in the ""Person"" class. This is an example of method overriding in Java."
"Overriding II
Method overriding
error
no
Object
$ method(parameters)?
no
Another ancestor
$ method(parameters)?
no
Superclass
$ method(parameters)?
no
message
method(parameters)
object
instance
Subclass
$ method(parameters)?"
"Method overriding. What is it?
Method overriding is useful for extending the functionality of a method and particularizing the functionality of the method in the derived class."
"If the subclass defines a method with the same signature, which is the name plus number and type of the parameters, the method in the superclass is hidden.
How can we access hidden methods?"
"How can we access hidden methods?
We can use start, which runs the start method of the car. This dot start runs the start method of the car. Super dot start runs the start method of the vehicle. Super dot super dot start is wrong."
"The methods of the child class are visible. The methods of the parent class are hidden.
Method overriding. What is it for?"
"We see two class diagrams. The first one shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds three methods: ""getLocation"", ""getDescriptoin"" and ""location"". The ""Computer"" class adds two methods: ""getOS"" and ""operatingSystem""."
"The second class diagram also shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds two methods: ""getLocation"" and ""location"". The ""Computer"" class adds one method: ""getOS"". The ""getDescription"" method in the ""Classroom"" class is highlighted and two more methods are shown below: ""this"
".getDescription()"" and ""super.getDescripcion""."
"Method overriding
The diagram illustrates the concept of method overriding in object-oriented programming."
"We see an object on the left side of the image, from which an arrow labeled ""message"" points to the right. The message contains the text ""method(parameters)"""
". The message contains the text ""method(parameters)"". On the right side, we see a flow chart with four boxes representing different classes: ""Subclass"", ""Superclass"", ""Another ancestor"", and ""Object"". These boxes are connected by upward arrows."
"The ""Subclass"" box is connected to the ""object"" with a dashed arrow labeled ""instance"". Each connection between the boxes has a corresponding cloud above it, containing the text ""∃ method(parameters)?"""
". All connections except the one from ""Object"" are also labeled ""no"". The connection from ""Object"" is labeled ""no"" and points to a box labeled ""error"""
".This diagram explains how the program searches for the correct method to execute when a message is sent to an object. It starts by checking the ""Subclass"" for a matching method"
". It starts by checking the ""Subclass"" for a matching method. If not found, it moves up the inheritance hierarchy to ""Superclass"", then ""Another ancestor"", and finally ""Object"". If a matching method is found at any level, it is executed"
". If a matching method is found at any level, it is executed. If no matching method is found even in the ""Object"" class, an error is thrown."
"Method overriding
When sending a message to an object, the selected method:
- Depends on the class which the object is an instance of
- Does not depend on the reference class to which it is assigned, as in the case of attributes
Method overriding. Example"
"We see three code snippets. The first one defines a class named ""Person"" with a protected string attribute called ""firstName"" initialized to ""Juan"""
". This class has a public method called ""print"" that prints ""Person"" followed by the value of the ""firstName"" attribute."
"The second snippet defines a class named ""Student"" that extends the ""Person"" class. This class also has a protected string attribute called ""firstName"", but it's initialized to ""Juan Pablo"""
". It also has a public method called ""print"" that prints ""Student"" followed by the value of the ""firstName"" attribute."
"The third snippet defines a class named ""Test2"" with a main method. Inside the main method, a new ""Student"" object is created and assigned to a variable called ""s"". Then, a ""Person"" variable called ""p"" is declared and assigned the value of ""s"""
". Finally, the ""print"" method is called on both ""s"" and ""p""."
"Both calls to the ""print"" method will output ""Student: Juan Pablo"" because the ""print"" method in the ""Student"" class overrides the ""print"" method in the ""Person"" class. This is an example of method overriding in Java."
"Overriding II
Method overriding
• When sending a message to an object,
the selected method:
– Depends on the class which the object is
an instance of
– Does not depend on the reference classto which it is assigned, as in the case ofattributes"
"Method overriding. What is it?
Method overriding is useful for extending the functionality of a method and particularizing the functionality of the method in the derived class."
"If the subclass defines a method with the same signature, which is the name plus number and type of the parameters, the method in the superclass is hidden.
How can we access hidden methods?"
"How can we access hidden methods?
We can use start, which runs the start method of the car. This dot start runs the start method of the car. Super dot start runs the start method of the vehicle. Super dot super dot start is wrong."
"The methods of the child class are visible. The methods of the parent class are hidden.
Method overriding. What is it for?"
"We see two class diagrams. The first one shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds three methods: ""getLocation"", ""getDescriptoin"" and ""location"". The ""Computer"" class adds two methods: ""getOS"" and ""operatingSystem""."
"The second class diagram also shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds two methods: ""getLocation"" and ""location"". The ""Computer"" class adds one method: ""getOS"". The ""getDescription"" method in the ""Classroom"" class is highlighted and two more methods are shown below: ""this"
".getDescription()"" and ""super.getDescripcion""."
"Method overriding
The diagram illustrates the concept of method overriding in object-oriented programming."
"We see an object on the left side of the image, from which an arrow labeled ""message"" points to the right. The message contains the text ""method(parameters)"""
". The message contains the text ""method(parameters)"". On the right side, we see a flow chart with four boxes representing different classes: ""Subclass"", ""Superclass"", ""Another ancestor"", and ""Object"". These boxes are connected by upward arrows."
"The ""Subclass"" box is connected to the ""object"" with a dashed arrow labeled ""instance"". Each connection between the boxes has a corresponding cloud above it, containing the text ""∃ method(parameters)?"""
". All connections except the one from ""Object"" are also labeled ""no"". The connection from ""Object"" is labeled ""no"" and points to a box labeled ""error"""
".This diagram explains how the program searches for the correct method to execute when a message is sent to an object. It starts by checking the ""Subclass"" for a matching method"
". It starts by checking the ""Subclass"" for a matching method. If not found, it moves up the inheritance hierarchy to ""Superclass"", then ""Another ancestor"", and finally ""Object"". If a matching method is found at any level, it is executed"
". If a matching method is found at any level, it is executed. If no matching method is found even in the ""Object"" class, an error is thrown."
"Method overriding
When sending a message to an object, the selected method:
- Depends on the class which the object is an instance of
- Does not depend on the reference class to which it is assigned, as in the case of attributes
Method overriding. Example"
"We see three code snippets. The first one defines a class named ""Person"" with a protected string attribute called ""firstName"" initialized to ""Juan"""
". This class has a public method called ""print"" that prints ""Person"" followed by the value of the ""firstName"" attribute."
"The second snippet defines a class named ""Student"" that extends the ""Person"" class. This class also has a protected string attribute called ""firstName"", but it's initialized to ""Juan Pablo"""
". It also has a public method called ""print"" that prints ""Student"" followed by the value of the ""firstName"" attribute."
"The third snippet defines a class named ""Test2"" with a main method. Inside the main method, a new ""Student"" object is created and assigned to a variable called ""s"". Then, a ""Person"" variable called ""p"" is declared and assigned the value of ""s"""
". Finally, the ""print"" method is called on both ""s"" and ""p""."
"Both calls to the ""print"" method will output ""Student: Juan Pablo"" because the ""print"" method in the ""Student"" class overrides the ""print"" method in the ""Person"" class. This is an example of method overriding in Java."
"Overriding II
Method overriding. Example
class Person {
protected String firstName = ”Juan"";
public void print() {
System.out.println(”Person: "" + firstName);
}
}
class Student extends Person {
protected String firstName = ”Juan Pablo"";"
"protected String firstName = ”Juan Pablo"";
public void print() {
System.out.println(”Student: "" + firstName);
}
}
class Test2 {
public static void main (String[] args) {
Student s = new Student();
Person p = s;
s.print();
p.print();
Both print:"
"Person p = s;
s.print();
p.print();
Both print:
“Student: Juan Pablo”
}
}"
"Method overriding. What is it?
Method overriding is useful for extending the functionality of a method and particularizing the functionality of the method in the derived class."
"If the subclass defines a method with the same signature, which is the name plus number and type of the parameters, the method in the superclass is hidden.
How can we access hidden methods?"
"How can we access hidden methods?
We can use start, which runs the start method of the car. This dot start runs the start method of the car. Super dot start runs the start method of the vehicle. Super dot super dot start is wrong."
"The methods of the child class are visible. The methods of the parent class are hidden.
Method overriding. What is it for?"
"We see two class diagrams. The first one shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds three methods: ""getLocation"", ""getDescriptoin"" and ""location"". The ""Computer"" class adds two methods: ""getOS"" and ""operatingSystem""."
"The second class diagram also shows two classes, ""Classroom"" and ""Computer"", both extending a class called ""Resource"". The ""Resource"" class has the following methods: ""getName"", ""getDescription"", ""name"" and ""description"""
". The ""Classroom"" class adds two methods: ""getLocation"" and ""location"". The ""Computer"" class adds one method: ""getOS"". The ""getDescription"" method in the ""Classroom"" class is highlighted and two more methods are shown below: ""this"
".getDescription()"" and ""super.getDescripcion""."
"Method overriding
The diagram illustrates the concept of method overriding in object-oriented programming."
"We see an object on the left side of the image, from which an arrow labeled ""message"" points to the right. The message contains the text ""method(parameters)"""
". The message contains the text ""method(parameters)"". On the right side, we see a flow chart with four boxes representing different classes: ""Subclass"", ""Superclass"", ""Another ancestor"", and ""Object"". These boxes are connected by upward arrows."
"The ""Subclass"" box is connected to the ""object"" with a dashed arrow labeled ""instance"". Each connection between the boxes has a corresponding cloud above it, containing the text ""∃ method(parameters)?"""
". All connections except the one from ""Object"" are also labeled ""no"". The connection from ""Object"" is labeled ""no"" and points to a box labeled ""error"""
".This diagram explains how the program searches for the correct method to execute when a message is sent to an object. It starts by checking the ""Subclass"" for a matching method"
". It starts by checking the ""Subclass"" for a matching method. If not found, it moves up the inheritance hierarchy to ""Superclass"", then ""Another ancestor"", and finally ""Object"". If a matching method is found at any level, it is executed"
". If a matching method is found at any level, it is executed. If no matching method is found even in the ""Object"" class, an error is thrown."
"Method overriding
When sending a message to an object, the selected method:
- Depends on the class which the object is an instance of
- Does not depend on the reference class to which it is assigned, as in the case of attributes
Method overriding. Example"
"We see three code snippets. The first one defines a class named ""Person"" with a protected string attribute called ""firstName"" initialized to ""Juan"""
". This class has a public method called ""print"" that prints ""Person"" followed by the value of the ""firstName"" attribute."
"The second snippet defines a class named ""Student"" that extends the ""Person"" class. This class also has a protected string attribute called ""firstName"", but it's initialized to ""Juan Pablo"""
". It also has a public method called ""print"" that prints ""Student"" followed by the value of the ""firstName"" attribute."
"The third snippet defines a class named ""Test2"" with a main method. Inside the main method, a new ""Student"" object is created and assigned to a variable called ""s"". Then, a ""Person"" variable called ""p"" is declared and assigned the value of ""s"""
". Finally, the ""print"" method is called on both ""s"" and ""p""."
"Both calls to the ""print"" method will output ""Student: Juan Pablo"" because the ""print"" method in the ""Student"" class overrides the ""print"" method in the ""Person"" class. This is an example of method overriding in Java."
"Exercise 6
• Override the method speedUp() from Bicycle in thesubclasses MountainBike and TandemBike so thatspeeding up means tripling the current speed in the firstcase, and quadrupling the current speed in the second case."
"• Create two objects of classes MountainBike and
TandemBike and call the method speedUp() on them,what is the result?
• How would you access the implementation of the methodspeedUp() of Bicycle from the two objects you havejust created?"
"We are asked to override the method speedUp, that takes no arguments, from the Bicycle class in the MountainBike and TandemBike subclasses. In the MountainBike subclass, tripling the current speed is how we are defining speeding up"
". In the TandemBike subclass, quadrupling the current speed is how we are defining speeding up."
"Next, we are asked to create two objects, one of class MountainBike and one of class TandemBike. We are then asked to call the speedUp method on both of these objects"
". Finally, we are asked what the result of calling this method on each of these objects is and how we would access the implementation of the speedUp method of the Bicycle class from the two objects that we just created."
"Overriding vs. overloading
• Overriding: The subclass substitutes the
implementation of a method of the superclass
– Both methods need to have the same signature
• Overloading: There is more than one methodwith the same name but different signature"
"– The overloaded methods can be declared in the
same class or in different classes in theinheritance hierarchy"
"- Overriding: The subclass substitutes the implementation of a method of the superclass
    - Both methods need to have the same signature
- Overloading: There is more than one method with the same name but different signature"
- The overloaded methods can be declared in the same class or in different classes in the inheritance hierarchy
"Constructors and inheritance
• Steps to create an object:
. The base part is created
. The derived part is added
– If the base class of the object inherits from another class,step 1 is applied in the order of the inheritance chain,until we reach Object"
"• For example, when creating a Student object,
that extends Person, the steps would be:
. The part corresponding to Person is created. To do so:
. The part corresponding to Object is created.
. The Person elements are added"
". The Person elements are added
. The Student elements are added"
"the steps to create an object.
First, the base part is created, then the derived part is added.
If the base class of the object inherits from another class, step 1 is applied in the order of the inheritance chain until we reach the object class."
"For example, when creating a student object that extends person, the steps would be:
First, the part corresponding to person is created. To do so, the part corresponding to object is created, then the person elements are added."
"Finally, the student elements are added."
"- A call to the constructor of the base class is always done in the constructor of the derived class.
- This is the first action of the constructor (always in the first line).
- Two possibilities:    - Not explicitly indicated"
"- Two possibilities:    - Not explicitly indicated
    - Explicitly indicated (mandatory in the first line)"
"- Explicitly indicated (mandatory in the first line)
If a call to the superclass constructor is not made explicit, Java automatically inserts a call to ""super()"" in the first line of the constructor of the derived class."
"The code example shows the constructor of the class ""Student"" which takes as arguments: a string ""firstName"", a string ""lastName"", an integer ""birthYear"", a string ""group"" and a character ""timetable""."
The comment in the code indicates that Java would insert a call to the superclass constructor at that position.
""""" presents a code snippet illustrating how to explicitly indicate inheritance in a constructor. The code defines a ""Student"" constructor in Java. This constructor takes a first name, last name, birth year, group, and timetable as arguments"
". It then calls the superclass constructor using the ""super"" keyword, passing in the first name, last name, and birth year. Finally, it sets the group and timetable fields of the ""Student"" object to the values passed in as arguments"
". The keyword ""super"" is highlighted in blue."
"Constructors and inheritance
• A call to the constructor of the base class
is always done in the constructor of thederived class.
• This is the first action of the constructor
(always in the first line)
• Two possibilities:
– Not explicitly indicated"
"• Two possibilities:
– Not explicitly indicated
– Explicitly indicated
(mandatory in the first line)"
"the steps to create an object.
First, the base part is created, then the derived part is added.
If the base class of the object inherits from another class, step 1 is applied in the order of the inheritance chain until we reach the object class."
"For example, when creating a student object that extends person, the steps would be:
First, the part corresponding to person is created. To do so, the part corresponding to object is created, then the person elements are added."
"Finally, the student elements are added."
"- A call to the constructor of the base class is always done in the constructor of the derived class.
- This is the first action of the constructor (always in the first line).
- Two possibilities:    - Not explicitly indicated"
"- Two possibilities:    - Not explicitly indicated
    - Explicitly indicated (mandatory in the first line)"
"- Explicitly indicated (mandatory in the first line)
If a call to the superclass constructor is not made explicit, Java automatically inserts a call to ""super()"" in the first line of the constructor of the derived class."
"The code example shows the constructor of the class ""Student"" which takes as arguments: a string ""firstName"", a string ""lastName"", an integer ""birthYear"", a string ""group"" and a character ""timetable""."
The comment in the code indicates that Java would insert a call to the superclass constructor at that position.
""""" presents a code snippet illustrating how to explicitly indicate inheritance in a constructor. The code defines a ""Student"" constructor in Java. This constructor takes a first name, last name, birth year, group, and timetable as arguments"
". It then calls the superclass constructor using the ""super"" keyword, passing in the first name, last name, and birth year. Finally, it sets the group and timetable fields of the ""Student"" object to the values passed in as arguments"
". The keyword ""super"" is highlighted in blue."
"Constructors and inheritance
.If it is not explicit, Java automaticallyinserts a call to super() in the firstline of the constructor of the derivedclass
public Student (String firstName, String lastName,
int birthYear, String group, char timetable) {"
"int birthYear, String group, char timetable) {
// Java inserts here a call to super()
this.firstName = firstName;
this.lastName = lastName;
this.birthYear = birthYear;
this.group = group;
this.timetable = timetable;
}"
"the steps to create an object.
First, the base part is created, then the derived part is added.
If the base class of the object inherits from another class, step 1 is applied in the order of the inheritance chain until we reach the object class."
"For example, when creating a student object that extends person, the steps would be:
First, the part corresponding to person is created. To do so, the part corresponding to object is created, then the person elements are added."
"Finally, the student elements are added."
"- A call to the constructor of the base class is always done in the constructor of the derived class.
- This is the first action of the constructor (always in the first line).
- Two possibilities:    - Not explicitly indicated"
"- Two possibilities:    - Not explicitly indicated
    - Explicitly indicated (mandatory in the first line)"
"- Explicitly indicated (mandatory in the first line)
If a call to the superclass constructor is not made explicit, Java automatically inserts a call to ""super()"" in the first line of the constructor of the derived class."
"The code example shows the constructor of the class ""Student"" which takes as arguments: a string ""firstName"", a string ""lastName"", an integer ""birthYear"", a string ""group"" and a character ""timetable""."
The comment in the code indicates that Java would insert a call to the superclass constructor at that position.
""""" presents a code snippet illustrating how to explicitly indicate inheritance in a constructor. The code defines a ""Student"" constructor in Java. This constructor takes a first name, last name, birth year, group, and timetable as arguments"
". It then calls the superclass constructor using the ""super"" keyword, passing in the first name, last name, and birth year. Finally, it sets the group and timetable fields of the ""Student"" object to the values passed in as arguments"
". The keyword ""super"" is highlighted in blue."
"Constructors and inheritance
. Explicitly indicated
public Student (String firstName, String lastName,
int birthYear, String group, char timetable) {
super(firstName, lastName, birthYear);
this.group = group;
this.timetable = timetable;
}"
"the steps to create an object.
First, the base part is created, then the derived part is added.
If the base class of the object inherits from another class, step 1 is applied in the order of the inheritance chain until we reach the object class."
"For example, when creating a student object that extends person, the steps would be:
First, the part corresponding to person is created. To do so, the part corresponding to object is created, then the person elements are added."
"Finally, the student elements are added."
"- A call to the constructor of the base class is always done in the constructor of the derived class.
- This is the first action of the constructor (always in the first line).
- Two possibilities:    - Not explicitly indicated"
"- Two possibilities:    - Not explicitly indicated
    - Explicitly indicated (mandatory in the first line)"
"- Explicitly indicated (mandatory in the first line)
If a call to the superclass constructor is not made explicit, Java automatically inserts a call to ""super()"" in the first line of the constructor of the derived class."
"The code example shows the constructor of the class ""Student"" which takes as arguments: a string ""firstName"", a string ""lastName"", an integer ""birthYear"", a string ""group"" and a character ""timetable""."
The comment in the code indicates that Java would insert a call to the superclass constructor at that position.
""""" presents a code snippet illustrating how to explicitly indicate inheritance in a constructor. The code defines a ""Student"" constructor in Java. This constructor takes a first name, last name, birth year, group, and timetable as arguments"
". It then calls the superclass constructor using the ""super"" keyword, passing in the first name, last name, and birth year. Finally, it sets the group and timetable fields of the ""Student"" object to the values passed in as arguments"
". The keyword ""super"" is highlighted in blue."
"More on super
• super
– references the current object casted as if it was an instance
of its superclass
– With the super reference, the methods of the base class 
can be explicitly accessed
– super is useful when overriding methods"
"– super is useful when overriding methods
public class Student extends Person {
// the rest remains the same
public void print(){
super.print();
System.out.print(""Group:"" + group+ schedule);
}
}"
"- The keyword 'super' references the current object casted as if it was an instance of its superclass
- With the 'super' reference, the methods of the base class can be explicitly accessed
- 'super' is useful when overriding methods"
We see an example of a 'Student' class extending a 'Person' class. The 'print' method in the 'Student' class calls the 'print' method of the 'Person' class using 'super.print()' and then prints additional information.
"PolymorphismWhat is it?
• Capacity of an object for deciding which method to apply,
depending on the class it belongs to
– A call to a method on a reference of a generic type (e.g., base"
"class) executes different implementations of the methoddepending on which class the object was created as
• Allows designing and implementing extensible systems
– Programs can process generic objects"
"(described by references of the superclass)
– The specific behavior depends on the subclasses
– New subclasses can be added later"
"PolymorphismExample
• Student, Professor and Secretary
• We create an array of Person where we include objects of
Student, Professor and Secretary."
"Student, Professor and Secretary.
• When calling the method print(), overridden in classesStudent, Professor and Secretary, on the array ofPerson, each object uses its own implementation of themethod
Person[] group = {new Student(…), new Professor(…),"
"Person[] group = {new Student(…), new Professor(…),
new Secretary(…), new Student(…)};
for (int i=0; i<group.length; i++){
group[i].print();
}"
"PolymorphismDynamic binding
• The power of method overriding is that the correct
method is properly called, even though the object ofthe child class is referenced through the base class
• This mechanism is called “dynamic binding”"
"• This mechanism is called “dynamic binding”
– Allows detecting the proper method to call during
runtime
• The compiler does not generate the calling code
during compile time
– It only generates code for calculating which method to call"
"– It only generates code for calculating which method to call
*   Different from “static binding” (e.g., methodoverloading) where the proper method is detected atcompile time"
"Exercise 7
• Create an array of class Bicycle that contains
objects of classes Bicycle, MountainBike andTandemBike.
• Call the method speedUp() on each of theseobjects, taking advantage of the benefits ofpolymorphism and dynamic binding."
"Create an array of class Bicycle that contains objects of classes Bicycle, MountainBike and TandemBike.
Call the method speedUp() on each of these objects, taking advantage of the benefits of polymorphism and dynamic binding."
"Modifiers and access
Final
• If we do not want that derived classes canmodify (override) a method or attribute ofthe base class, then the final modifiershall be used."
"Static (static members)
- Static modifier
- Static members exist only once per class, independently of the number of instances (objects) of the class that have been created or even if there are no instances created yet"
"- The method or attribute behaves always in the same way
- Static members can be accessed using the class name
- A static method cannot access non-static members directly; an object must be created first
Static (static members)"
We have a code snippet that shows how to declare a static attribute in Java
". The example is a class named Car that has a private string attribute for color, a private int attribute for speed, a private float attribute for size, and a private static int attribute for the number of wheels. The static attribute is initialized to 4."
"There is another code snippet showing a static method. The example is the main method, which is declared as public static void. It takes a string array as an argument"
". It takes a string array as an argument. Inside the method, we see how to access the static attribute numberOfWheels using the class name Car followed by a dot and the attribute name."
"On the right-hand side, we see other examples of static members. We have the mathematical constant PI, the minimum value of an integer, and the maximum value of an integer."
"The last code snippet shows that the static method main can access other static members without creating instances of the class. In this case, we are using the static methods sqrt and cos from the Math class.
Static. Some rules"
"Static. Some rules
- Static members are invoked with ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
- Non static members require an instance (object) in order to be accessed: ""ClassName objectName = new ClassName();""."
"- Non static members are invoked with ""objectName.normalMethod();"" and ""objectName.normalAttribute;""."
"- When a static member is invoked (called) from inside the same class, the class name can be deleted. We can write ""staticMethod();"" and ""staticAttribute;"" instead of ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
Final"
"Final
- If we do not want that derived classes can modify (override) a method or attribute of the base class, then the final modifier shall be used.
Final
The final modifier can be applied to parameters, attributes, methods and classes."
"When applied to **parameters**, it means that their value cannot be changed inside the method. For example, in the code snippet 'public void myMethod(final int[] p1, int p2) { }', the values of p1 cannot be changed."
"When applied to **attributes**, it means that their value cannot be changed in the class. It is used together with 'static' to define constants. For example, in the code snippet 'public static final double PI = 3.14;', the value of PI cannot be changed."
"When applied to **methods**, it means that they cannot be overridden in derived classes. For example, in the code snippet 'public final void myMethod() { }', myMethod cannot be overridden."
"When applied to **classes**, it means that the class cannot be extended or inherited. For example, in the code snippet 'public final class myClass(){}', myClass cannot be extended."
"Modifiers and access
Final
• The final modifier can be applied to:
– Parameters: Meaning that their value cannot be changed inside
the method
public void myMethod(final int[] p1, int p2){} //p1 values cannot be changed"
"– Attributes: Meaning that their value cannot be changed in the
class. It is used together with static to define constants.
public static final double PI = 3.14; //PI value cannot be changed
– Methods: Meaning that they cannot be overridden in derived"
"– Methods: Meaning that they cannot be overridden in derived
classes
public final void myMethod(){} //myMethod cannot be overridden
– Classes: Avoid extending the class. It cannot be inherited.
public final class myClass(){} //myClass cannot be extended"
"Static (static members)
- Static modifier
- Static members exist only once per class, independently of the number of instances (objects) of the class that have been created or even if there are no instances created yet"
"- The method or attribute behaves always in the same way
- Static members can be accessed using the class name
- A static method cannot access non-static members directly; an object must be created first
Static (static members)"
We have a code snippet that shows how to declare a static attribute in Java
". The example is a class named Car that has a private string attribute for color, a private int attribute for speed, a private float attribute for size, and a private static int attribute for the number of wheels. The static attribute is initialized to 4."
"There is another code snippet showing a static method. The example is the main method, which is declared as public static void. It takes a string array as an argument"
". It takes a string array as an argument. Inside the method, we see how to access the static attribute numberOfWheels using the class name Car followed by a dot and the attribute name."
"On the right-hand side, we see other examples of static members. We have the mathematical constant PI, the minimum value of an integer, and the maximum value of an integer."
"The last code snippet shows that the static method main can access other static members without creating instances of the class. In this case, we are using the static methods sqrt and cos from the Math class.
Static. Some rules"
"Static. Some rules
- Static members are invoked with ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
- Non static members require an instance (object) in order to be accessed: ""ClassName objectName = new ClassName();""."
"- Non static members are invoked with ""objectName.normalMethod();"" and ""objectName.normalAttribute;""."
"- When a static member is invoked (called) from inside the same class, the class name can be deleted. We can write ""staticMethod();"" and ""staticAttribute;"" instead of ""ClassName.staticMethod();"" and ""ClassName.staticAttribute;"".
Final"
"Final
- If we do not want that derived classes can modify (override) a method or attribute of the base class, then the final modifier shall be used.
Final
The final modifier can be applied to parameters, attributes, methods and classes."
"When applied to **parameters**, it means that their value cannot be changed inside the method. For example, in the code snippet 'public void myMethod(final int[] p1, int p2) { }', the values of p1 cannot be changed."
"When applied to **attributes**, it means that their value cannot be changed in the class. It is used together with 'static' to define constants. For example, in the code snippet 'public static final double PI = 3.14;', the value of PI cannot be changed."
"When applied to **methods**, it means that they cannot be overridden in derived classes. For example, in the code snippet 'public final void myMethod() { }', myMethod cannot be overridden."
"When applied to **classes**, it means that the class cannot be extended or inherited. For example, in the code snippet 'public final class myClass(){}', myClass cannot be extended."
"MODIFIERS
class
method
attribute
public
a
c
c
e
s
s
(friendly)
protected
private
final
o
t
h
e
r
static
Accesible to any other class
Accessible only to classes in the same package
Accessible to the class, its subclasses andclasses in the same package"
"Applied to inner classes
Accessible only inside the class
Cannot be extended.
It is a leaf in the inheritancetree.
Cannot be overridden.
It is constant and cannotbe modified in the childclasses.
Its value cannot be changed, itis constant ."
"Its value cannot be changed, itis constant .
It is normally used togetherwith static.
Maximum level class.
It is the same for all theclass objects.
Use:
It is the same for all the classobjects.
Use:
ClassName.method ();
ClassName.attribute;"
"The table shows Java modifiers and their effect on classes, methods and attributes.
Regarding access, we have:
- public: accessible to any other class.
- (friendly): accessible only to classes in the same package."
"- (friendly): accessible only to classes in the same package.
- protected: accessible to the class, its subclasses and classes in the same package.
- private: accessible only inside the class.
Other modifiers are:"
"Other modifiers are:
- final: cannot be extended for classes, cannot be overridden for methods and its value cannot be changed for attributes. It is constant. It is normally used together with static."
- static: maximum level class. It is the same for all the class objects. It is used as ClassName.method(); for methods and ClassName.attribute; for attributes.
"Systems Programming
Object-ORIENTED programming(advanced)
Departamento de IngenieríaTelemática
CONTENTS ARE MOSTLY BASED ON THE WORK BY:
M. Carmen Fernández Panadero, Raquel M. Crespo García"
"M. Carmen Fernández Panadero, Raquel M. Crespo García
Carlos Delgado Kloos, Natividad Martínez Madrid,                                       
Carlos Alario Hoyos, Julio Villena Román"
Object-ORIENTED programming (basic)
"The title of  """" and the subtitle is ""Object-ORIENTED programming (basic)"".  The name of the department is ""Departamento de Ingeniería Telemática"". The contents of  based on the work of M. Carmen Fernández Panadero, Raquel M"
". Carmen Fernández Panadero, Raquel M. Crespo García, Carlos Delgado Kloos, Natividad Martínez Madrid, Carlos Alario Hoyos, and Julio Villena Román. The logo of Universidad Carlos III de Madrid is displayed in the bottom left corner of the slide"
. The Creative Commons license logo is displayed in the top left corner of the slide.
Object-ORIENTED programming (advanced)
"The title of  """" with a subtitle ""Object-ORIENTED programming (advanced)"".  It seems to be part of a presentation for the Telematics Engineering Department as indicated in the smaller text"
.  The footnote indicates this presentation is based mostly on the work of six individuals.
"Key terms
• Casting
– Upcasting vs Downcasting
– Widening vs Narrowing
• Abstract (classes and methods)
•
– Inheritance
– Polymorphism
Interfaces
– implements
– Inheritance
– Polymorphism"
"The key terms are object and class, state and behavior, attribute and method, data abstraction versus functional abstraction, private/public attribute/method + class, message passing, overloading method, constructor method, static attribute/method"
", constructor method, static attribute/method, get/set method, and package"
.
"key terms related to inheritance. The terms are grouped into the following categories: naming, Java syntax, Java hierarchy, overriding, constructors, and polymorphism."
"The naming category lists the following terms: generalization versus specialization, superclass versus subclass, parent class versus child class, and base class versus derived class."
"The Java syntax category lists the following keywords: extends, super, protected, and final.
The remaining categories, Java hierarchy, overriding, constructors, and polymorphism, are listed as single terms."
"- Casting which can be upcasting vs downcasting or widening vs narrowing
- Abstract classes and methods, including inheritance and polymorphism
- Interfaces, including implements, inheritance and polymorphism"
"Contents
• Casting. Types compatibility
• Abstract classes and methods
• Interfaces"
"topics related to object-oriented programming: classes and objects, object encapsulation with functional and data abstraction, class members, message passing, overloading, constructors, modifiers and access, and packages.
- Basic inheritance concepts"
"- Basic inheritance concepts
- Inheritance hierarchy
- Overriding I: Attribute Hiding
- Overriding II: Method Overriding
- Constructors of derived classes
- Polymorphism
- The final modifier"
"Casting (Type conversion)
Syntax and terminology
• Syntax:(type) identifier
• Two types of casting:
– Widening or upcasting: a subclass is used as aninstance of the superclass. Implicit conversion"
"– Narrowing or downcasting: The superclass isused as an instance of a subclass. Explicitconversion.
• Casting can only be applied to parent and
child classes, not to sibling classes
– String s = “3”;
– Integer i = (Integer) s;"
"– String s = “3”;
– Integer i = (Integer) s;
– Integer i = Integer.parseInt(s);"
"Syntax and terminology
Let's talk about casting in programming, specifically type conversion, its syntax, and terminology."
"Casting syntax follows this structure: within parentheses, you specify the desired data type, followed by the identifier representing the variable or value you want to cast.
There are two primary types of casting:"
"There are two primary types of casting:
- Widening or upcasting: This involves using a subclass as an instance of its superclass. This type of conversion is implicit, meaning the compiler handles it automatically."
"- Narrowing or downcasting: In this case, the superclass is treated as an instance of its subclass. This conversion is explicit, requiring you to explicitly instruct the compiler to perform the cast."
"It's important to note that casting is applicable only between parent and child classes within the class hierarchy. Sibling classes cannot be cast to each other.
To illustrate, let's look at some examples:"
"To illustrate, let's look at some examples:
- The first example shows a string ""3"" assigned to a variable 's'.
- The second example demonstrates an incorrect attempt to directly assign this string to an Integer variable 'i'."
"- The third example provides the correct way to achieve this conversion using Integer.parseInt(s), which correctly parses the string ""3"" into its integer equivalent.
Widening or upcasting"
"Widening or upcasting
Here we are discussing the concept of casting, specifically widening or upcasting."
"The first type of casting, upcasting, refers to compatibility upwards, towards the base class. An object of the derived class can always be used as an object of the base class because it implements an “is-a” relationship"
". For example, the code snippet ""Person p = new Student();"" shows how a variable of type Person can be assigned a new Student object."
"Narrowing or downcasting
Downcasting: compatibility downwards (towards the derived classes)
- Downcasting cannot be applied by default, because an object of the base class is not always an object of the derived class"
"Here we have an example of wrong syntax: ""Student s = new Person(); // wrong""
- It is only possible when the reference of the base class points to an object of the derived class
- In these cases, an explicit casting must be applied
Example"
"Example
The image shows an example of casting in Java. Casting is a type conversion that allows you to treat an object of one type as an object of another type. The example shows how to cast a Student object to a Person object and vice versa."
"The first example shows implicit upcasting, which is allowed because a Student is always a Person. The second example shows implicit downcasting, which is not allowed because a Person is not always a Student"
". The third example shows explicit downcasting, which is allowed because the programmer is explicitly stating that the Person object is actually a Student object."
"The image also includes a note that explains that if someone is both a person and a student, they can be required to do things that are specific to students, but only if it is explicitly stated that they will be treated as a student.
Example"
"Example
 the concept of casting in programming, specifically focusing on downcasting. It presents code examples in an attempt to illustrate why downcasting from a Person object to a Student object is problematic."
"The first code snippet demonstrates implicit downcasting, which results in a compiler error. The code attempts to assign a Person object (p2) to a Student object (s3) without explicit conversion"
. The comment highlights that this approach doesn't work due to a compiler error.
"The second code snippet explores explicit downcasting using type casting. While this approach might seem plausible, it can lead to a ClassCastException at runtime"
. The comment explains that this exception occurs because the Person object (p2) might not actually represent a Student object.
"The third code snippet showcases another instance of implicit downcasting, attempting to create a new Person object and assign it to a Student object (s4). This approach also results in an error, as indicated by the comment.
 the following points:"
"the following points:
- A Person object isn't always a Student object; assuming this implicitly is incorrect."
"- While a Person object can sometimes be a Student object, if it wasn't created as such, it cannot be treated as one, even with explicit casting."
reinforces these points with arrows connecting code snippets to textual explanations. A red arrow links the first and third code snippets to a box stating that a Person object isn't always a Student object and cannot be implicitly assumed as such
". Another red arrow connects the second code snippet to a box explaining that a Person object might sometimes be a Student object, but only if it was created as one. If not, treating it as a Student object will fail, even with explicit casting."
"instanceof operator
- Syntax: object instanceof class
- Checks if an object is really an instance of a given class
Example:"
"In this example, we have a code snippet that defines a public method called ""check"" that takes a ""Person"" object as input and returns a ""Student"" object. Inside the method, a ""Student"" object ""s"" is initialized to null"
". Then, an ""if"" statement checks if the input ""Person"" object ""p"" is an instance of the ""Student"" class using the ""instanceof"" operator. If it is, the ""Student"" object ""s"" is assigned the value of ""p"" casted to the ""Student"" type"
". Finally, the ""Student"" object ""s"" is returned.```java"
"public Student check(Person p) {
  Student s = null;
  if (p instanceof Student)
    s = (Student) p;
  return s;
}
```"
"Casting (Type conversion)
Widening or upcasting
. Upcasting: compatibility upwards
(towards the base class)
– An object of the derived class can alwaysbe used as an object of the base class(because it implements an “is-a”relationship)"
Person p = new Student();
"Syntax and terminology
Let's talk about casting in programming, specifically type conversion, its syntax, and terminology."
"Casting syntax follows this structure: within parentheses, you specify the desired data type, followed by the identifier representing the variable or value you want to cast.
There are two primary types of casting:"
"There are two primary types of casting:
- Widening or upcasting: This involves using a subclass as an instance of its superclass. This type of conversion is implicit, meaning the compiler handles it automatically."
"- Narrowing or downcasting: In this case, the superclass is treated as an instance of its subclass. This conversion is explicit, requiring you to explicitly instruct the compiler to perform the cast."
"It's important to note that casting is applicable only between parent and child classes within the class hierarchy. Sibling classes cannot be cast to each other.
To illustrate, let's look at some examples:"
"To illustrate, let's look at some examples:
- The first example shows a string ""3"" assigned to a variable 's'.
- The second example demonstrates an incorrect attempt to directly assign this string to an Integer variable 'i'."
"- The third example provides the correct way to achieve this conversion using Integer.parseInt(s), which correctly parses the string ""3"" into its integer equivalent.
Widening or upcasting"
"Widening or upcasting
Here we are discussing the concept of casting, specifically widening or upcasting."
"The first type of casting, upcasting, refers to compatibility upwards, towards the base class. An object of the derived class can always be used as an object of the base class because it implements an “is-a” relationship"
". For example, the code snippet ""Person p = new Student();"" shows how a variable of type Person can be assigned a new Student object."
"Narrowing or downcasting
Downcasting: compatibility downwards (towards the derived classes)
- Downcasting cannot be applied by default, because an object of the base class is not always an object of the derived class"
"Here we have an example of wrong syntax: ""Student s = new Person(); // wrong""
- It is only possible when the reference of the base class points to an object of the derived class
- In these cases, an explicit casting must be applied
Example"
"Example
The image shows an example of casting in Java. Casting is a type conversion that allows you to treat an object of one type as an object of another type. The example shows how to cast a Student object to a Person object and vice versa."
"The first example shows implicit upcasting, which is allowed because a Student is always a Person. The second example shows implicit downcasting, which is not allowed because a Person is not always a Student"
". The third example shows explicit downcasting, which is allowed because the programmer is explicitly stating that the Person object is actually a Student object."
"The image also includes a note that explains that if someone is both a person and a student, they can be required to do things that are specific to students, but only if it is explicitly stated that they will be treated as a student.
Example"
"Example
 the concept of casting in programming, specifically focusing on downcasting. It presents code examples in an attempt to illustrate why downcasting from a Person object to a Student object is problematic."
"The first code snippet demonstrates implicit downcasting, which results in a compiler error. The code attempts to assign a Person object (p2) to a Student object (s3) without explicit conversion"
. The comment highlights that this approach doesn't work due to a compiler error.
"The second code snippet explores explicit downcasting using type casting. While this approach might seem plausible, it can lead to a ClassCastException at runtime"
. The comment explains that this exception occurs because the Person object (p2) might not actually represent a Student object.
"The third code snippet showcases another instance of implicit downcasting, attempting to create a new Person object and assign it to a Student object (s4). This approach also results in an error, as indicated by the comment.
 the following points:"
"the following points:
- A Person object isn't always a Student object; assuming this implicitly is incorrect."
"- While a Person object can sometimes be a Student object, if it wasn't created as such, it cannot be treated as one, even with explicit casting."
reinforces these points with arrows connecting code snippets to textual explanations. A red arrow links the first and third code snippets to a box stating that a Person object isn't always a Student object and cannot be implicitly assumed as such
". Another red arrow connects the second code snippet to a box explaining that a Person object might sometimes be a Student object, but only if it was created as one. If not, treating it as a Student object will fail, even with explicit casting."
"instanceof operator
- Syntax: object instanceof class
- Checks if an object is really an instance of a given class
Example:"
"In this example, we have a code snippet that defines a public method called ""check"" that takes a ""Person"" object as input and returns a ""Student"" object. Inside the method, a ""Student"" object ""s"" is initialized to null"
". Then, an ""if"" statement checks if the input ""Person"" object ""p"" is an instance of the ""Student"" class using the ""instanceof"" operator. If it is, the ""Student"" object ""s"" is assigned the value of ""p"" casted to the ""Student"" type"
". Finally, the ""Student"" object ""s"" is returned.```java"
"public Student check(Person p) {
  Student s = null;
  if (p instanceof Student)
    s = (Student) p;
  return s;
}
```"
"Casting (Type conversion)
Narrowing or downcasting
. Downcasting: compatibility downwards
(towards the derived classes)
– Downcasting cannot be applied by default,because an object of the base class is notalways an object of the derived class"
"Student s = new Person(); // wrong
– It is only possible when the reference of the baseclass points to an object of the derived class
– In these cases, an explicit casting must be
applied"
"Syntax and terminology
Let's talk about casting in programming, specifically type conversion, its syntax, and terminology."
"Casting syntax follows this structure: within parentheses, you specify the desired data type, followed by the identifier representing the variable or value you want to cast.
There are two primary types of casting:"
"There are two primary types of casting:
- Widening or upcasting: This involves using a subclass as an instance of its superclass. This type of conversion is implicit, meaning the compiler handles it automatically."
"- Narrowing or downcasting: In this case, the superclass is treated as an instance of its subclass. This conversion is explicit, requiring you to explicitly instruct the compiler to perform the cast."
"It's important to note that casting is applicable only between parent and child classes within the class hierarchy. Sibling classes cannot be cast to each other.
To illustrate, let's look at some examples:"
"To illustrate, let's look at some examples:
- The first example shows a string ""3"" assigned to a variable 's'.
- The second example demonstrates an incorrect attempt to directly assign this string to an Integer variable 'i'."
"- The third example provides the correct way to achieve this conversion using Integer.parseInt(s), which correctly parses the string ""3"" into its integer equivalent.
Widening or upcasting"
"Widening or upcasting
Here we are discussing the concept of casting, specifically widening or upcasting."
"The first type of casting, upcasting, refers to compatibility upwards, towards the base class. An object of the derived class can always be used as an object of the base class because it implements an “is-a” relationship"
". For example, the code snippet ""Person p = new Student();"" shows how a variable of type Person can be assigned a new Student object."
"Narrowing or downcasting
Downcasting: compatibility downwards (towards the derived classes)
- Downcasting cannot be applied by default, because an object of the base class is not always an object of the derived class"
"Here we have an example of wrong syntax: ""Student s = new Person(); // wrong""
- It is only possible when the reference of the base class points to an object of the derived class
- In these cases, an explicit casting must be applied
Example"
"Example
The image shows an example of casting in Java. Casting is a type conversion that allows you to treat an object of one type as an object of another type. The example shows how to cast a Student object to a Person object and vice versa."
"The first example shows implicit upcasting, which is allowed because a Student is always a Person. The second example shows implicit downcasting, which is not allowed because a Person is not always a Student"
". The third example shows explicit downcasting, which is allowed because the programmer is explicitly stating that the Person object is actually a Student object."
"The image also includes a note that explains that if someone is both a person and a student, they can be required to do things that are specific to students, but only if it is explicitly stated that they will be treated as a student.
Example"
"Example
 the concept of casting in programming, specifically focusing on downcasting. It presents code examples in an attempt to illustrate why downcasting from a Person object to a Student object is problematic."
"The first code snippet demonstrates implicit downcasting, which results in a compiler error. The code attempts to assign a Person object (p2) to a Student object (s3) without explicit conversion"
. The comment highlights that this approach doesn't work due to a compiler error.
"The second code snippet explores explicit downcasting using type casting. While this approach might seem plausible, it can lead to a ClassCastException at runtime"
. The comment explains that this exception occurs because the Person object (p2) might not actually represent a Student object.
"The third code snippet showcases another instance of implicit downcasting, attempting to create a new Person object and assign it to a Student object (s4). This approach also results in an error, as indicated by the comment.
 the following points:"
"the following points:
- A Person object isn't always a Student object; assuming this implicitly is incorrect."
"- While a Person object can sometimes be a Student object, if it wasn't created as such, it cannot be treated as one, even with explicit casting."
reinforces these points with arrows connecting code snippets to textual explanations. A red arrow links the first and third code snippets to a box stating that a Person object isn't always a Student object and cannot be implicitly assumed as such
". Another red arrow connects the second code snippet to a box explaining that a Person object might sometimes be a Student object, but only if it was created as one. If not, treating it as a Student object will fail, even with explicit casting."
"instanceof operator
- Syntax: object instanceof class
- Checks if an object is really an instance of a given class
Example:"
"In this example, we have a code snippet that defines a public method called ""check"" that takes a ""Person"" object as input and returns a ""Student"" object. Inside the method, a ""Student"" object ""s"" is initialized to null"
". Then, an ""if"" statement checks if the input ""Person"" object ""p"" is an instance of the ""Student"" class using the ""instanceof"" operator. If it is, the ""Student"" object ""s"" is assigned the value of ""p"" casted to the ""Student"" type"
". Finally, the ""Student"" object ""s"" is returned.```java"
"public Student check(Person p) {
  Student s = null;
  if (p instanceof Student)
    s = (Student) p;
  return s;
}
```"
"Casting (Type conversion)
Example
public class Test2 {
public static void main (String[] args) {
Person p1;
//implicit upcasting - works
Student s1 = new Student();
p1 = s1;                    
A student isalways a person(implicit)
Student s2;"
"A student isalways a person(implicit)
Student s2;
//implicit downcasting – does not work
s2 = p1; //error because no explicit casting is done
A person is notalways a student
//explicit downcasting - works
s2 = (Student) p1;   // p1 actually references an"
"s2 = (Student) p1;   // p1 actually references an
// instance of class Student"
"// instance of class Student
If someone, besides being a person, is also a student(not always happens), (s)he can be required stuff asa student, but must be explicitly stated that (s)hewill be treated as a student."
"Syntax and terminology
Let's talk about casting in programming, specifically type conversion, its syntax, and terminology."
"Casting syntax follows this structure: within parentheses, you specify the desired data type, followed by the identifier representing the variable or value you want to cast.
There are two primary types of casting:"
"There are two primary types of casting:
- Widening or upcasting: This involves using a subclass as an instance of its superclass. This type of conversion is implicit, meaning the compiler handles it automatically."
"- Narrowing or downcasting: In this case, the superclass is treated as an instance of its subclass. This conversion is explicit, requiring you to explicitly instruct the compiler to perform the cast."
"It's important to note that casting is applicable only between parent and child classes within the class hierarchy. Sibling classes cannot be cast to each other.
To illustrate, let's look at some examples:"
"To illustrate, let's look at some examples:
- The first example shows a string ""3"" assigned to a variable 's'.
- The second example demonstrates an incorrect attempt to directly assign this string to an Integer variable 'i'."
"- The third example provides the correct way to achieve this conversion using Integer.parseInt(s), which correctly parses the string ""3"" into its integer equivalent.
Widening or upcasting"
"Widening or upcasting
Here we are discussing the concept of casting, specifically widening or upcasting."
"The first type of casting, upcasting, refers to compatibility upwards, towards the base class. An object of the derived class can always be used as an object of the base class because it implements an “is-a” relationship"
". For example, the code snippet ""Person p = new Student();"" shows how a variable of type Person can be assigned a new Student object."
"Narrowing or downcasting
Downcasting: compatibility downwards (towards the derived classes)
- Downcasting cannot be applied by default, because an object of the base class is not always an object of the derived class"
"Here we have an example of wrong syntax: ""Student s = new Person(); // wrong""
- It is only possible when the reference of the base class points to an object of the derived class
- In these cases, an explicit casting must be applied
Example"
"Example
The image shows an example of casting in Java. Casting is a type conversion that allows you to treat an object of one type as an object of another type. The example shows how to cast a Student object to a Person object and vice versa."
"The first example shows implicit upcasting, which is allowed because a Student is always a Person. The second example shows implicit downcasting, which is not allowed because a Person is not always a Student"
". The third example shows explicit downcasting, which is allowed because the programmer is explicitly stating that the Person object is actually a Student object."
"The image also includes a note that explains that if someone is both a person and a student, they can be required to do things that are specific to students, but only if it is explicitly stated that they will be treated as a student.
Example"
"Example
 the concept of casting in programming, specifically focusing on downcasting. It presents code examples in an attempt to illustrate why downcasting from a Person object to a Student object is problematic."
"The first code snippet demonstrates implicit downcasting, which results in a compiler error. The code attempts to assign a Person object (p2) to a Student object (s3) without explicit conversion"
. The comment highlights that this approach doesn't work due to a compiler error.
"The second code snippet explores explicit downcasting using type casting. While this approach might seem plausible, it can lead to a ClassCastException at runtime"
. The comment explains that this exception occurs because the Person object (p2) might not actually represent a Student object.
"The third code snippet showcases another instance of implicit downcasting, attempting to create a new Person object and assign it to a Student object (s4). This approach also results in an error, as indicated by the comment.
 the following points:"
"the following points:
- A Person object isn't always a Student object; assuming this implicitly is incorrect."
"- While a Person object can sometimes be a Student object, if it wasn't created as such, it cannot be treated as one, even with explicit casting."
reinforces these points with arrows connecting code snippets to textual explanations. A red arrow links the first and third code snippets to a box stating that a Person object isn't always a Student object and cannot be implicitly assumed as such
". Another red arrow connects the second code snippet to a box explaining that a Person object might sometimes be a Student object, but only if it was created as one. If not, treating it as a Student object will fail, even with explicit casting."
"instanceof operator
- Syntax: object instanceof class
- Checks if an object is really an instance of a given class
Example:"
"In this example, we have a code snippet that defines a public method called ""check"" that takes a ""Person"" object as input and returns a ""Student"" object. Inside the method, a ""Student"" object ""s"" is initialized to null"
". Then, an ""if"" statement checks if the input ""Person"" object ""p"" is an instance of the ""Student"" class using the ""instanceof"" operator. If it is, the ""Student"" object ""s"" is assigned the value of ""p"" casted to the ""Student"" type"
". Finally, the ""Student"" object ""s"" is returned.```java"
"public Student check(Person p) {
  Student s = null;
  if (p instanceof Student)
    s = (Student) p;
  return s;
}
```"
"Casting (Type conversion)
Example
Person p2 = new Person();
Student s3;
//implicit downcasting – does not work
s3 = p2;   //compiler error
//explicit downcasting – does not works sometimes
//ClassCastException will be thrown"
"//ClassCastException will be thrown
//because p2 does not refer to a Student object
s3 = (Student) p2; //error
//implicit downcasting – does not work
Student s4 = new Person(); //error
}
}
A person is not always a student. It cannot beassumed implicitly."
"A person is notalways astudent. Itcannot beimplicitly
assumed.
A person issometimes a student, but ifnot (it has notbeen created assuch), it cannotbe treated assuch, not eventhough explicitly
trying."
"Syntax and terminology
Let's talk about casting in programming, specifically type conversion, its syntax, and terminology."
"Casting syntax follows this structure: within parentheses, you specify the desired data type, followed by the identifier representing the variable or value you want to cast.
There are two primary types of casting:"
"There are two primary types of casting:
- Widening or upcasting: This involves using a subclass as an instance of its superclass. This type of conversion is implicit, meaning the compiler handles it automatically."
"- Narrowing or downcasting: In this case, the superclass is treated as an instance of its subclass. This conversion is explicit, requiring you to explicitly instruct the compiler to perform the cast."
"It's important to note that casting is applicable only between parent and child classes within the class hierarchy. Sibling classes cannot be cast to each other.
To illustrate, let's look at some examples:"
"To illustrate, let's look at some examples:
- The first example shows a string ""3"" assigned to a variable 's'.
- The second example demonstrates an incorrect attempt to directly assign this string to an Integer variable 'i'."
"- The third example provides the correct way to achieve this conversion using Integer.parseInt(s), which correctly parses the string ""3"" into its integer equivalent.
Widening or upcasting"
"Widening or upcasting
Here we are discussing the concept of casting, specifically widening or upcasting."
"The first type of casting, upcasting, refers to compatibility upwards, towards the base class. An object of the derived class can always be used as an object of the base class because it implements an “is-a” relationship"
". For example, the code snippet ""Person p = new Student();"" shows how a variable of type Person can be assigned a new Student object."
"Narrowing or downcasting
Downcasting: compatibility downwards (towards the derived classes)
- Downcasting cannot be applied by default, because an object of the base class is not always an object of the derived class"
"Here we have an example of wrong syntax: ""Student s = new Person(); // wrong""
- It is only possible when the reference of the base class points to an object of the derived class
- In these cases, an explicit casting must be applied
Example"
"Example
The image shows an example of casting in Java. Casting is a type conversion that allows you to treat an object of one type as an object of another type. The example shows how to cast a Student object to a Person object and vice versa."
"The first example shows implicit upcasting, which is allowed because a Student is always a Person. The second example shows implicit downcasting, which is not allowed because a Person is not always a Student"
". The third example shows explicit downcasting, which is allowed because the programmer is explicitly stating that the Person object is actually a Student object."
"The image also includes a note that explains that if someone is both a person and a student, they can be required to do things that are specific to students, but only if it is explicitly stated that they will be treated as a student.
Example"
"Example
 the concept of casting in programming, specifically focusing on downcasting. It presents code examples in an attempt to illustrate why downcasting from a Person object to a Student object is problematic."
"The first code snippet demonstrates implicit downcasting, which results in a compiler error. The code attempts to assign a Person object (p2) to a Student object (s3) without explicit conversion"
. The comment highlights that this approach doesn't work due to a compiler error.
"The second code snippet explores explicit downcasting using type casting. While this approach might seem plausible, it can lead to a ClassCastException at runtime"
. The comment explains that this exception occurs because the Person object (p2) might not actually represent a Student object.
"The third code snippet showcases another instance of implicit downcasting, attempting to create a new Person object and assign it to a Student object (s4). This approach also results in an error, as indicated by the comment.
 the following points:"
"the following points:
- A Person object isn't always a Student object; assuming this implicitly is incorrect."
"- While a Person object can sometimes be a Student object, if it wasn't created as such, it cannot be treated as one, even with explicit casting."
reinforces these points with arrows connecting code snippets to textual explanations. A red arrow links the first and third code snippets to a box stating that a Person object isn't always a Student object and cannot be implicitly assumed as such
". Another red arrow connects the second code snippet to a box explaining that a Person object might sometimes be a Student object, but only if it was created as one. If not, treating it as a Student object will fail, even with explicit casting."
"instanceof operator
- Syntax: object instanceof class
- Checks if an object is really an instance of a given class
Example:"
"In this example, we have a code snippet that defines a public method called ""check"" that takes a ""Person"" object as input and returns a ""Student"" object. Inside the method, a ""Student"" object ""s"" is initialized to null"
". Then, an ""if"" statement checks if the input ""Person"" object ""p"" is an instance of the ""Student"" class using the ""instanceof"" operator. If it is, the ""Student"" object ""s"" is assigned the value of ""p"" casted to the ""Student"" type"
". Finally, the ""Student"" object ""s"" is returned.```java"
"public Student check(Person p) {
  Student s = null;
  if (p instanceof Student)
    s = (Student) p;
  return s;
}
```"
"Casting (Type conversion)
instanceof operator
• Syntax:
object instanceof class
– Checks if an object is really an instance of a
given class
• Example:
public Student check(Person p) {
Student s = null;
if (p instanceof Student)
s = (Student) p;
return s;"
"if (p instanceof Student)
s = (Student) p;
return s;
}"
"Syntax and terminology
Let's talk about casting in programming, specifically type conversion, its syntax, and terminology."
"Casting syntax follows this structure: within parentheses, you specify the desired data type, followed by the identifier representing the variable or value you want to cast.
There are two primary types of casting:"
"There are two primary types of casting:
- Widening or upcasting: This involves using a subclass as an instance of its superclass. This type of conversion is implicit, meaning the compiler handles it automatically."
"- Narrowing or downcasting: In this case, the superclass is treated as an instance of its subclass. This conversion is explicit, requiring you to explicitly instruct the compiler to perform the cast."
"It's important to note that casting is applicable only between parent and child classes within the class hierarchy. Sibling classes cannot be cast to each other.
To illustrate, let's look at some examples:"
"To illustrate, let's look at some examples:
- The first example shows a string ""3"" assigned to a variable 's'.
- The second example demonstrates an incorrect attempt to directly assign this string to an Integer variable 'i'."
"- The third example provides the correct way to achieve this conversion using Integer.parseInt(s), which correctly parses the string ""3"" into its integer equivalent.
Widening or upcasting"
"Widening or upcasting
Here we are discussing the concept of casting, specifically widening or upcasting."
"The first type of casting, upcasting, refers to compatibility upwards, towards the base class. An object of the derived class can always be used as an object of the base class because it implements an “is-a” relationship"
". For example, the code snippet ""Person p = new Student();"" shows how a variable of type Person can be assigned a new Student object."
"Narrowing or downcasting
Downcasting: compatibility downwards (towards the derived classes)
- Downcasting cannot be applied by default, because an object of the base class is not always an object of the derived class"
"Here we have an example of wrong syntax: ""Student s = new Person(); // wrong""
- It is only possible when the reference of the base class points to an object of the derived class
- In these cases, an explicit casting must be applied
Example"
"Example
The image shows an example of casting in Java. Casting is a type conversion that allows you to treat an object of one type as an object of another type. The example shows how to cast a Student object to a Person object and vice versa."
"The first example shows implicit upcasting, which is allowed because a Student is always a Person. The second example shows implicit downcasting, which is not allowed because a Person is not always a Student"
". The third example shows explicit downcasting, which is allowed because the programmer is explicitly stating that the Person object is actually a Student object."
"The image also includes a note that explains that if someone is both a person and a student, they can be required to do things that are specific to students, but only if it is explicitly stated that they will be treated as a student.
Example"
"Example
 the concept of casting in programming, specifically focusing on downcasting. It presents code examples in an attempt to illustrate why downcasting from a Person object to a Student object is problematic."
"The first code snippet demonstrates implicit downcasting, which results in a compiler error. The code attempts to assign a Person object (p2) to a Student object (s3) without explicit conversion"
. The comment highlights that this approach doesn't work due to a compiler error.
"The second code snippet explores explicit downcasting using type casting. While this approach might seem plausible, it can lead to a ClassCastException at runtime"
. The comment explains that this exception occurs because the Person object (p2) might not actually represent a Student object.
"The third code snippet showcases another instance of implicit downcasting, attempting to create a new Person object and assign it to a Student object (s4). This approach also results in an error, as indicated by the comment.
 the following points:"
"the following points:
- A Person object isn't always a Student object; assuming this implicitly is incorrect."
"- While a Person object can sometimes be a Student object, if it wasn't created as such, it cannot be treated as one, even with explicit casting."
reinforces these points with arrows connecting code snippets to textual explanations. A red arrow links the first and third code snippets to a box stating that a Person object isn't always a Student object and cannot be implicitly assumed as such
". Another red arrow connects the second code snippet to a box explaining that a Person object might sometimes be a Student object, but only if it was created as one. If not, treating it as a Student object will fail, even with explicit casting."
"instanceof operator
- Syntax: object instanceof class
- Checks if an object is really an instance of a given class
Example:"
"In this example, we have a code snippet that defines a public method called ""check"" that takes a ""Person"" object as input and returns a ""Student"" object. Inside the method, a ""Student"" object ""s"" is initialized to null"
". Then, an ""if"" statement checks if the input ""Person"" object ""p"" is an instance of the ""Student"" class using the ""instanceof"" operator. If it is, the ""Student"" object ""s"" is assigned the value of ""p"" casted to the ""Student"" type"
". Finally, the ""Student"" object ""s"" is returned.```java"
"public Student check(Person p) {
  Student s = null;
  if (p instanceof Student)
    s = (Student) p;
  return s;
}
```"
"Abstract classes
What is an abstract class?
•
It declares the structure of a given abstraction,without providing all the implementation details (i.e.without implementing completely every method)
• An abstract class is a class that can have abstract"
"• An abstract class is a class that can have abstract
methods (not implemented, without code)
– If the class has at least one abstract method, it will be
abstract
Message
Email
SMS
WhatsApp"
"What is an abstract class?
An abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely."
"An abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract."
"There is a diagram representing the concept of abstraction with classes. The parent class is ""Message"" and it has three children classes: ""Email"", ""SMS"" and ""WhatsApp"".
Characteristics"
"Characteristics
Classes and methods are defined as abstract using the reserved word abstract
There is a code snippet: public abstract class Figure"
"There is a code snippet: public abstract class Figure
There is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.
Characteristics
-  cannot be instantiated"
"Characteristics
-  cannot be instantiated
  - References to abstract classes can exist
  - But they point to objects of classes derived of the abstract class
  - Example: Figure fig = new Rectangle(2,3);
-  can be extended"
"-  can be extended
- In an abstract class, there can be both
  - abstract methods
  - non abstract methods
The diagram shows that the class ""Figure"" is an abstract class and it has 3 child classes: ""Circle"", ""Rectangle"", and ""Triangle""."
"What are they for? partial implementations
 are normally used for representing partially implemented classes.
Some methods are not implemented but declared."
"Some methods are not implemented but declared.
The objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method.
Abstract methods"
"Abstract methods
- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'."
"- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.
Note: No braces. They are not implemented, thus only a semicolon follows the declaration.
Abstract methods"
"Abstract methods
The abstract modifier cannot be applied to:
- constructors
- private methods
- static methods
How are they used? Example"
"- private methods
- static methods
How are they used? Example
We see an example of Java code showing the definition of an abstract class named ""Figure"" and a class named ""Rectangle"" that extends it."
"The ""Figure"" class has two protected attributes of type double, ""dim1"" and ""dim2"", and a constructor that initializes them. It also has an abstract method called ""area"" that returns a double."
"The ""Rectangle"" class extends the ""Figure"" class and provides an implementation for the ""area"" method, which returns the product of ""dim1"" and ""dim2""."
"Abstract classes
Characteristics
• Classes and methods are defined as abstract
using the reserved word abstract
public abstract class Figure{...}"
"What is an abstract class?
An abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely."
"An abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract."
"There is a diagram representing the concept of abstraction with classes. The parent class is ""Message"" and it has three children classes: ""Email"", ""SMS"" and ""WhatsApp"".
Characteristics"
"Characteristics
Classes and methods are defined as abstract using the reserved word abstract
There is a code snippet: public abstract class Figure"
"There is a code snippet: public abstract class Figure
There is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.
Characteristics
-  cannot be instantiated"
"Characteristics
-  cannot be instantiated
  - References to abstract classes can exist
  - But they point to objects of classes derived of the abstract class
  - Example: Figure fig = new Rectangle(2,3);
-  can be extended"
"-  can be extended
- In an abstract class, there can be both
  - abstract methods
  - non abstract methods
The diagram shows that the class ""Figure"" is an abstract class and it has 3 child classes: ""Circle"", ""Rectangle"", and ""Triangle""."
"What are they for? partial implementations
 are normally used for representing partially implemented classes.
Some methods are not implemented but declared."
"Some methods are not implemented but declared.
The objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method.
Abstract methods"
"Abstract methods
- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'."
"- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.
Note: No braces. They are not implemented, thus only a semicolon follows the declaration.
Abstract methods"
"Abstract methods
The abstract modifier cannot be applied to:
- constructors
- private methods
- static methods
How are they used? Example"
"- private methods
- static methods
How are they used? Example
We see an example of Java code showing the definition of an abstract class named ""Figure"" and a class named ""Rectangle"" that extends it."
"The ""Figure"" class has two protected attributes of type double, ""dim1"" and ""dim2"", and a constructor that initializes them. It also has an abstract method called ""area"" that returns a double."
"The ""Rectangle"" class extends the ""Figure"" class and provides an implementation for the ""area"" method, which returns the product of ""dim1"" and ""dim2""."
"Abstract classes
Characteristics
• Abstract classes cannot be instantiated
– References to abstract classes can exist
– But they point to objects of classes derived of the
abstract class
Figure fig = new Rectangle(2,3);
• Abstract classes can be extended"
"• Abstract classes can be extended
• In an abstract class, there can be both
– abstract methods
– non abstract methods"
"What is an abstract class?
An abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely."
"An abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract."
"There is a diagram representing the concept of abstraction with classes. The parent class is ""Message"" and it has three children classes: ""Email"", ""SMS"" and ""WhatsApp"".
Characteristics"
"Characteristics
Classes and methods are defined as abstract using the reserved word abstract
There is a code snippet: public abstract class Figure"
"There is a code snippet: public abstract class Figure
There is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.
Characteristics
-  cannot be instantiated"
"Characteristics
-  cannot be instantiated
  - References to abstract classes can exist
  - But they point to objects of classes derived of the abstract class
  - Example: Figure fig = new Rectangle(2,3);
-  can be extended"
"-  can be extended
- In an abstract class, there can be both
  - abstract methods
  - non abstract methods
The diagram shows that the class ""Figure"" is an abstract class and it has 3 child classes: ""Circle"", ""Rectangle"", and ""Triangle""."
"What are they for? partial implementations
 are normally used for representing partially implemented classes.
Some methods are not implemented but declared."
"Some methods are not implemented but declared.
The objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method.
Abstract methods"
"Abstract methods
- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'."
"- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.
Note: No braces. They are not implemented, thus only a semicolon follows the declaration.
Abstract methods"
"Abstract methods
The abstract modifier cannot be applied to:
- constructors
- private methods
- static methods
How are they used? Example"
"- private methods
- static methods
How are they used? Example
We see an example of Java code showing the definition of an abstract class named ""Figure"" and a class named ""Rectangle"" that extends it."
"The ""Figure"" class has two protected attributes of type double, ""dim1"" and ""dim2"", and a constructor that initializes them. It also has an abstract method called ""area"" that returns a double."
"The ""Rectangle"" class extends the ""Figure"" class and provides an implementation for the ""area"" method, which returns the product of ""dim1"" and ""dim2""."
"Abstract classes
What are they for? partial implementations
• Abstract classes are normally used for representing
partially implemented classes
– Some methods are not implemented but declared
• The objective of partial implementations is to provide"
"• The objective of partial implementations is to provide
a common interface to all derived classes
– Even though in cases when the base class has not enough
information to implement the method"
"What is an abstract class?
An abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely."
"An abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract."
"There is a diagram representing the concept of abstraction with classes. The parent class is ""Message"" and it has three children classes: ""Email"", ""SMS"" and ""WhatsApp"".
Characteristics"
"Characteristics
Classes and methods are defined as abstract using the reserved word abstract
There is a code snippet: public abstract class Figure"
"There is a code snippet: public abstract class Figure
There is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.
Characteristics
-  cannot be instantiated"
"Characteristics
-  cannot be instantiated
  - References to abstract classes can exist
  - But they point to objects of classes derived of the abstract class
  - Example: Figure fig = new Rectangle(2,3);
-  can be extended"
"-  can be extended
- In an abstract class, there can be both
  - abstract methods
  - non abstract methods
The diagram shows that the class ""Figure"" is an abstract class and it has 3 child classes: ""Circle"", ""Rectangle"", and ""Triangle""."
"What are they for? partial implementations
 are normally used for representing partially implemented classes.
Some methods are not implemented but declared."
"Some methods are not implemented but declared.
The objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method.
Abstract methods"
"Abstract methods
- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'."
"- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.
Note: No braces. They are not implemented, thus only a semicolon follows the declaration.
Abstract methods"
"Abstract methods
The abstract modifier cannot be applied to:
- constructors
- private methods
- static methods
How are they used? Example"
"- private methods
- static methods
How are they used? Example
We see an example of Java code showing the definition of an abstract class named ""Figure"" and a class named ""Rectangle"" that extends it."
"The ""Figure"" class has two protected attributes of type double, ""dim1"" and ""dim2"", and a constructor that initializes them. It also has an abstract method called ""area"" that returns a double."
"The ""Rectangle"" class extends the ""Figure"" class and provides an implementation for the ""area"" method, which returns the product of ""dim1"" and ""dim2""."
"Abstract classes
Abstract methods
• Methods declared but not implemented in
abstract classes
abstract returnType name(parameters);
– Abstract methods are declared using the reserved
word abstract
• Classes inheriting from the abstract class"
"word abstract
• Classes inheriting from the abstract class
must implement all the abstract methods ofthe superclass
– Or they will be abstract as well
NOTE: No braces!! They are notimplemented, thus only a semicolon (;)
follows the declaration"
"What is an abstract class?
An abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely."
"An abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract."
"There is a diagram representing the concept of abstraction with classes. The parent class is ""Message"" and it has three children classes: ""Email"", ""SMS"" and ""WhatsApp"".
Characteristics"
"Characteristics
Classes and methods are defined as abstract using the reserved word abstract
There is a code snippet: public abstract class Figure"
"There is a code snippet: public abstract class Figure
There is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.
Characteristics
-  cannot be instantiated"
"Characteristics
-  cannot be instantiated
  - References to abstract classes can exist
  - But they point to objects of classes derived of the abstract class
  - Example: Figure fig = new Rectangle(2,3);
-  can be extended"
"-  can be extended
- In an abstract class, there can be both
  - abstract methods
  - non abstract methods
The diagram shows that the class ""Figure"" is an abstract class and it has 3 child classes: ""Circle"", ""Rectangle"", and ""Triangle""."
"What are they for? partial implementations
 are normally used for representing partially implemented classes.
Some methods are not implemented but declared."
"Some methods are not implemented but declared.
The objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method.
Abstract methods"
"Abstract methods
- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'."
"- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.
Note: No braces. They are not implemented, thus only a semicolon follows the declaration.
Abstract methods"
"Abstract methods
The abstract modifier cannot be applied to:
- constructors
- private methods
- static methods
How are they used? Example"
"- private methods
- static methods
How are they used? Example
We see an example of Java code showing the definition of an abstract class named ""Figure"" and a class named ""Rectangle"" that extends it."
"The ""Figure"" class has two protected attributes of type double, ""dim1"" and ""dim2"", and a constructor that initializes them. It also has an abstract method called ""area"" that returns a double."
"The ""Rectangle"" class extends the ""Figure"" class and provides an implementation for the ""area"" method, which returns the product of ""dim1"" and ""dim2""."
"Abstract classes
Abstract methods
• The abstract modifier cannot be applied to:
– constructors
– private methods
– static methods"
"What is an abstract class?
An abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely."
"An abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract."
"There is a diagram representing the concept of abstraction with classes. The parent class is ""Message"" and it has three children classes: ""Email"", ""SMS"" and ""WhatsApp"".
Characteristics"
"Characteristics
Classes and methods are defined as abstract using the reserved word abstract
There is a code snippet: public abstract class Figure"
"There is a code snippet: public abstract class Figure
There is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.
Characteristics
-  cannot be instantiated"
"Characteristics
-  cannot be instantiated
  - References to abstract classes can exist
  - But they point to objects of classes derived of the abstract class
  - Example: Figure fig = new Rectangle(2,3);
-  can be extended"
"-  can be extended
- In an abstract class, there can be both
  - abstract methods
  - non abstract methods
The diagram shows that the class ""Figure"" is an abstract class and it has 3 child classes: ""Circle"", ""Rectangle"", and ""Triangle""."
"What are they for? partial implementations
 are normally used for representing partially implemented classes.
Some methods are not implemented but declared."
"Some methods are not implemented but declared.
The objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method.
Abstract methods"
"Abstract methods
- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'."
"- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.
Note: No braces. They are not implemented, thus only a semicolon follows the declaration.
Abstract methods"
"Abstract methods
The abstract modifier cannot be applied to:
- constructors
- private methods
- static methods
How are they used? Example"
"- private methods
- static methods
How are they used? Example
We see an example of Java code showing the definition of an abstract class named ""Figure"" and a class named ""Rectangle"" that extends it."
"The ""Figure"" class has two protected attributes of type double, ""dim1"" and ""dim2"", and a constructor that initializes them. It also has an abstract method called ""area"" that returns a double."
"The ""Rectangle"" class extends the ""Figure"" class and provides an implementation for the ""area"" method, which returns the product of ""dim1"" and ""dim2""."
"Abstract classesHow are they used? Example
public abstract class Figure { // any figure
protected double dim1;
protected double dim2;
public Figure(double dim1, double dim2) {
this.dim1 = dim1;
this.dim2 = dim2;
}
public abstract double area();
}"
"this.dim2 = dim2;
}
public abstract double area();
}
public class Rectangle extends Figure {
public Rectangle(double dim1, double dim2) {
super(dim1,dim2);
}
public double area() {
return dim1*dim2;
}
}
// rectangle area"
"Exercise 8
•
•
•
Starting from the class Bicycle which has threeattributes, speed, cadence and gear, of type integerand four methods speedUp(), brake(),setCadence(int newCadence), andsetGear(int newGear), implement the abstract classVehicle."
"Think about the attributes and methods that will be ofBicycle, and those which can be inherited, consideringthat besides Bicycle, we will have classes Car and
Truck.
Think about the methods that shall be abstract and thosewhich shall not in class Vehicle."
"Starting from the class ""Bicycle"" which has three attributes: ""speed"", ""cadence"", and ""gear"" of type integer, and four methods: ""speedUp"", ""brake"", ""setCadence"" which takes an integer ""newCadence"" as input"
", ""setCadence"" which takes an integer ""newCadence"" as input, and ""setGear"" which takes an integer ""newGear"" as input, implement the abstract class ""Vehicle"""
.
"Think about the attributes and methods that will be specific to ""Bicycle"" and those that can be inherited, considering that besides ""Bicycle"" we will have classes ""Car"" and ""Truck""."
"Think about the methods that shall be abstract and those that shall not be abstract in the class ""Vehicle""."
"Abstract classes
Polymorphism
An array of objects of typeFigure (abstract)
public static void main(String args[]){
Figure[] myFigures = new Figure[3];
myFigures[0] = new Rectangle(1,3);
myFigures[1] = new Triangle(2,5);
myFigures[2] = new Square(3);"
"myFigures[1] = new Triangle(2,5);
myFigures[2] = new Square(3);
Array elements are instances ofa concrete (non-abstract) class(Rectangle, Triangle, Square)
for(int i=0; i<myFigures.length; i++){
System.out.println(myFigures[i].area());
}
}"
"System.out.println(myFigures[i].area());
}
}
We call the method area() on the objects of typeFigure. During runtime it will be checked whichtype of object is contained and the proper methodwill be called. – Dynamic binding"
"What is an abstract class?
An abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely."
"An abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract."
"There is a diagram representing the concept of abstraction with classes. The parent class is ""Message"" and it has three children classes: ""Email"", ""SMS"" and ""WhatsApp"".
Characteristics"
"Characteristics
Classes and methods are defined as abstract using the reserved word abstract
There is a code snippet: public abstract class Figure"
"There is a code snippet: public abstract class Figure
There is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.
Characteristics
-  cannot be instantiated"
"Characteristics
-  cannot be instantiated
  - References to abstract classes can exist
  - But they point to objects of classes derived of the abstract class
  - Example: Figure fig = new Rectangle(2,3);
-  can be extended"
"-  can be extended
- In an abstract class, there can be both
  - abstract methods
  - non abstract methods
The diagram shows that the class ""Figure"" is an abstract class and it has 3 child classes: ""Circle"", ""Rectangle"", and ""Triangle""."
"What are they for? partial implementations
 are normally used for representing partially implemented classes.
Some methods are not implemented but declared."
"Some methods are not implemented but declared.
The objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method.
Abstract methods"
"Abstract methods
- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'."
"- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.
Note: No braces. They are not implemented, thus only a semicolon follows the declaration.
Abstract methods"
"Abstract methods
The abstract modifier cannot be applied to:
- constructors
- private methods
- static methods
How are they used? Example"
"- private methods
- static methods
How are they used? Example
We see an example of Java code showing the definition of an abstract class named ""Figure"" and a class named ""Rectangle"" that extends it."
"The ""Figure"" class has two protected attributes of type double, ""dim1"" and ""dim2"", and a constructor that initializes them. It also has an abstract method called ""area"" that returns a double."
"The ""Rectangle"" class extends the ""Figure"" class and provides an implementation for the ""area"" method, which returns the product of ""dim1"" and ""dim2""."
"Interfaces
What is an interface?
•
•
•
Interfaces take the abstract class concept one stepfurther
– All methods in the interface are abstract
Interfaces are always public
– Interface attributes are public by default"
"– Interface attributes are public by default
– Interface methods are public by default
Interfaces are implemented by classes
– A class implements an interface defining the body of  all the
methods"
"methods
– An abstract class implements an interface implementing or
declaring abstracts the methods
– A class (abstract or not) can implement one or more
interfaces"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Interfaces
What is an interface?
• An interface is a pure design element
– What to do?
• A class (including abstract ones) is a mix of design
and implementation
– What to do and how?
• Different classes can implement the same interface
in different ways"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Interfaces
Declaration
• Syntax:
public interface Name {
static final type CONSTANTNAME = value;
returnType methodName(parameters);
}
NOTE 1: No braces!! As the method isnot implemented, only a semicolon (; )
follows the declaration"
"follows the declaration
NOTE 2: Constants and methods ininterfaces are always public(no need to make it explicit)"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Interfaces
Implementation
•
If a class implements an interface, it implements allabstract methods declared in such interface
• Represented with the reserved word implements
public class MyClass implements Interface, Interface2 {...}"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Interfaces
What are they for?. Multiple inheritance
methodA
methodB
methodC
ClassA
extends
Interface B
Interface C
implements
implements
ClassC
• Java does not allow multiple inheritance
• But it several interfaces can be implemented"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Interfaces
How to use them?
Figure
•area()
Drawable
•draw()
extends
implements
Circle
•area()
•draw()
Rectangle
•area()
•draw()
public abstract class Figure {…}
public interface Drawable {…}
public class Circle extends Figure implements Drawable"
"public class Circle extends Figure implements Drawable
public class Rectangle extends Figure implements Drawable"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Interfaces
Example
public interface LowEmission {
// Attributes
// public char tag; // Not allowed as it is not initialized
public char tag = 'B';
char tag2 = 'B';
// public static double emission // Not allowed, not initialized"
"public static double emission = 12.4;
static double emission2 = 12.4;
// public static final double maxEmission // Not allowed, not initialized
public static final double maxEmission = 12;
static final double maxEmission2 = 12;"
"static final double maxEmission2 = 12;
// private int license // Private attributes are not allowed
// Methods
public char getTag();
// public static double getEmission(); // Not allowed
public static double getEmission() { return 0; }"
"public static double getEmission() { return 0; }
static double getEmission2() { return 0; }
// private int getLicense() // Private methods are not allowed
}"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Exercise 9
•
Implement the interface Printable, which containsthe method print(), which does not return anyvalue.
• Class Bicycle implements the interface
Printable, so that it prints on screen the values ofcurrent speed, cadence and gear.
2"
"2
Implement the interface **Printable**, which contains the method **print()**, which does not return any value.
Class **Bicycle** implements the interface **Printable**, so that it prints on screen the values of current speed, cadence and gear."
"Interfaces
Interface inheritance. Polymorphism
• Interfaces can also have an inheritance
hierarchy.
• Classes  implementing the interfaces in
the hierarchy must include all the methodsdefine in the interfaces.
• Interfaces also support dynamic resolution"
"• Interfaces also support dynamic resolution
of methods during runtime (dynamicbinding)
3"
"What is an interface?
-  take the abstract class concept one step further
- All methods in the interface are abstract
-  are always public
    - Interface attributes are public by default
    - Interface methods are public by default"
"- Interface methods are public by default
-  are implemented by classes
    - A class implements an interface defining the body of all the methods
    - An abstract class implements an interface implementing or declaring abstracts the methods"
"- A class (abstract or not) can implement one or more interfaces
What is an interface?
- An *interface* is a pure design element: what to do.
- A *class* (including abstract ones) is a mix of design and implementation: what to do and how."
"- Different classes can implement the same interface in different ways.
Declaration
Let's talk about the syntax for declaring interfaces."
"Let's talk about the syntax for declaring interfaces.
We start with the keywords ""public interface"" followed by the name of the interface. The body of the interface is enclosed in curly braces.
Inside the interface, we can define constants and methods."
"Inside the interface, we can define constants and methods.
Constants are declared using the keywords ""static final"" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon."
"Methods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon."
There are two important notes to keep in mind.
"First, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface."
"Second, constants and methods in interfaces are always public, even if the ""public"" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.
Implementation"
"Implementation
- If a class implements an interface, it implements all abstract methods declared in such interface
- Represented with the reserved word 'implements'
There is a code snippet:
public class MyClass implements Interface, Interface2 {...}"
"public class MyClass implements Interface, Interface2 {...}
The snippet shows how to implement interfaces in a class declaration.
What are they for?. Multiple inheritance"
"What are they for?. Multiple inheritance
We have a class diagram showing the concept of multiple inheritance using interfaces.
There are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right."
ClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.
"An arrow labeled ""extends"" goes from Class C to ClassA. Two arrows labeled ""implements"" go from Class C to Interface B and Interface C, respectively."
"There are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.
How to use them?"
"We have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area"
. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable.
"Example
This code defines a public interface called ""LowEmission"".
**Attributes:**
* It first declares a public character variable named ""tag"" and initializes it with the character 'B'."
"* Then, it declares another character variable ""tag2"" and sets it to 'B'.
* Next, it defines a public static double variable ""emission"" and assigns it the value 12.4.
* It also declares a static double variable ""emission2"" with the same value, 12.4."
"* Further, it declares a public static final double variable ""maxEmission"" and initializes it with the value 12.
* Another static final double variable ""maxEmission2"" is declared and set to 12.
The comments in the code indicate that:"
"The comments in the code indicate that:
* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.
* Private attributes are not allowed in interfaces.
**Methods:**"
"**Methods:**
* The interface includes a public method called ""getTag"" that returns a character.
* It also has a public static method named ""getEmission"" which returns a double value of 0."
"* Additionally, there's a static method ""getEmission2"" that also returns a double value of 0.
Similar to attributes, the comments highlight that:
* Private methods are not allowed in interfaces."
"* Private methods are not allowed in interfaces.
* It's not allowed to have only the declaration of a method without a body in an interface."
"Exercise 10
•
Implement the interface Definible, which containsthe method getAttributes(). This methodreturns the value of the attributes of the object. Theinterface Printable inherits from Definible."
"• Which changes are needed in the interfacePrintable? And in the class Bicycle.
4"
"Implement the interface ""Definable"", which contains the method ""getAttributes()"". This method returns the value of the attributes of the object. The interface ""Printable"" inherits from ""Definable"""
". The interface ""Printable"" inherits from ""Definable"". Which changes are needed in the interface ""Printable""? And in the class ""Bicycle""?"
"Object Orientation Summary
• Class (actual)
– All methods are implemented
• Abstract class
– Can include methods which are not
implemented but just declared
– abstract modifier
• Interface
– No implementation at all
– Reserved word: interface
5"
"– No implementation at all
– Reserved word: interface
5
We are going to talk about classes, abstract classes and interfaces.
A class, in its actual form, has all its methods implemented."
"A class, in its actual form, has all its methods implemented.
An abstract class can include methods which are not implemented but just declared. Abstract classes use the abstract modifier."
"Finally, an interface has no implementation at all. The reserved word for interface is, as you can imagine, ""interface""."
"A class, which can be actual or abstract, can extend only one base class, which is called simple inheritance. It can implement one or more interfaces, which is called multiple inheritance.
An Interface can extend one or more interfaces."
"Object Orientation Summary
• Class (actual or abstract)
– Can extend (extends)  only one base class
(simple inheritance)
– Can implement (implements) one or more
interfaces (multiple inheritance)
• Interface
– Can extend (extends) one or more
interfaces
6"
"• Interface
– Can extend (extends) one or more
interfaces
6
We are going to talk about classes, abstract classes and interfaces.
A class, in its actual form, has all its methods implemented."
"A class, in its actual form, has all its methods implemented.
An abstract class can include methods which are not implemented but just declared. Abstract classes use the abstract modifier."
"Finally, an interface has no implementation at all. The reserved word for interface is, as you can imagine, ""interface""."
"A class, which can be actual or abstract, can extend only one base class, which is called simple inheritance. It can implement one or more interfaces, which is called multiple inheritance.
An Interface can extend one or more interfaces."
"MODIFIERS
class
method
attribute
public
a
c
c
e
s
s
(friendly)
protected
private
abstract
Accesible to any other class
Accessible only to classes in the same package
Accessible to the class, its subclasses and classesin the same package"
"Applied to inner classes
Accessible only inside the class
Cannot be instantiated
For inheriting from them
At least 1 abstract method
Has no codeIt is implemented in thesubclasses or child classes
final
o
t
h
e
r
Cannot be extended."
"final
o
t
h
e
r
Cannot be extended.
It is a leaf in the inheritancetree.
Cannot be overridden.
It is constant and cannot bemodified in the child classes.
Its value cannot be changed, it isconstant .
It is normally used together withstatic.
static"
"It is normally used together withstatic.
static
Maximum level class.
It is the same for all the classobjects.
Use:
It is the same for all the classobjects.
Use:
ClassName.method ();
ClassName.attribute;
7"
"Use:
ClassName.method ();
ClassName.attribute;
7
The table shows Java modifiers and their effect on classes, methods and attributes.
Regarding access, we have:
- public: accessible to any other class."
"- public: accessible to any other class.
- (friendly): accessible only to classes in the same package.
- protected: accessible to the class, its subclasses and classes in the same package.
- private: accessible only inside the class.
Other modifiers are:"
"Other modifiers are:
- final: cannot be extended for classes, cannot be overridden for methods and its value cannot be changed for attributes. It is constant. It is normally used together with static."
- static: maximum level class. It is the same for all the class objects. It is used as ClassName.method(); for methods and ClassName.attribute; for attributes.
Scenario IV: Declare and implement a class
"the fourth scenario of a programming course, which focuses on declaring and implementing a class. The scenario assumes prior knowledge of reading code and implementing methods"
. The objective is to design a new class that defines a new data type with its own characteristics and behavior.
"There are two main learning objectives: first, to be able to declare a class with attributes (characteristics) and methods (behavior), and second, to be able to create objects from this class and manage access to their state and behavior."
"The work plan for achieving these objectives includes: memorizing the basic nomenclature of object-oriented programming, practicing object modeling with simple examples to understand the distinction between a class, an object, its state, and its behavior"
", an object, its state, and its behavior, reviewing the Java syntax for declaring classes, attributes, constructors, and methods, and finally, reviewing the mechanism and syntax for message passing between objects"
.
"Some classes so far...
We have two classes, car and bicycle. Both classes have attributes and methods."
Scenario V: Reusing code. Inheritance
"the concept of inheritance in programming. It starts by stating that once you can create your own classes, you are ready to work in teams and reuse code developed by your colleagues"
. Your team will provide you with a set of classes and you are required to create specializations or generalizations of them.
The objective of this scenario is to be able to create a derived class adding some characteristics (attributes) and behavior (methods) to an existing class
. You should also be able to extract all the common code from a set of similar classes in order to group it into a new parent class so that the code is easier to maintain
". Finally, you should be able to create objects, and reference and access their attributes and methods, depending on their position in the inheritance hierarchy and their modifiers."
"The work plan for this scenario is to memorize the naming related to inheritance, memorize the Java syntax related to inheritance (`extends`), to reference (`super`, `this`) and to advanced access modifiers (`protected`)"
". You should also know basic inheritance mechanisms, such as attribute hiding, overriding of methods, and what they are used for and how they are used."
"Inheritance What is it?
We see two class diagrams, one with no inheritance and one with inheritance."
"On the left diagram titled ""No inheritance"", we have two classes, ""Classroom"" and ""Computer"", which both have the attributes ""name"", ""description"", ""getName()"", ""getDescription()"""
". Additionally, ""Classroom"" has the attribute ""location"" and the method ""getLocation()"", and ""Computer"" has the attribute ""operatingSystem"" and the method ""getOS()""."
"On the right diagram titled ""Inheritance"", we have a parent class ""Resource"" with the attributes ""name"", ""description"", ""getName()"", ""getDescription()"". The child classes ""Classroom"" and ""Computer"" inherit from ""Resource"""
". ""Classroom"" also has the attribute ""location"" and the method ""getLocation()"", and ""Computer"" has the attribute ""operatingSystem"" and the method ""getOS()""."
The text explains that the attributes and methods that appear in blue in the parent class are repeated in the subclasses in the left diagram
". It is not necessary to repeat the code, you only have to say that a class extends the other or inherits from it, as shown in the right diagram."
Inheritance How is it used?
"We see a code snippet defining a class named ""Student"" that inherits from a class named ""Person"". The ""Student"" class has two protected attributes: ""group"" of type String and ""timetable"" of type char"
". It also has three methods: ""setGroup"", ""setTimetable"", and ""printGroup"". The ""setGroup"" method checks if the group is null or empty and prints an error message if it is. Otherwise, it sets the group attribute to the given value"
". Otherwise, it sets the group attribute to the given value. The ""setTimetable"" method checks if the timetable is 'M' or 'A' and prints an error message if it is not. Otherwise, it sets the timetable attribute to the given value"
". Otherwise, it sets the timetable attribute to the given value. The ""printGroup"" method prints the group and timetable attributes"
". The ""Student"" class also has a constructor that takes the student's first name, last name, birth year, group, and timetable as arguments"
". This constructor calls the superclass constructor to initialize the first name, last name, and birth year attributes, and then it calls the ""setGroup"" and ""setTimetable"" methods to initialize the group and timetable attributes."
"On the right-hand side, we have a diagram representing the ""Student"" class. It shows that the ""Student"" class inherits from the ""Person"" class and lists the attributes and methods of both classes"
". The ""Student"" class has two attributes: ""group"" and ""timetable"". It also has three methods: ""setGroup"", ""setTimetable"", and ""printGroup"". The ""Person"" class has three attributes: ""firstName"", ""lastName"", and ""birthYear"". It also has one method: ""print"""
". It also has one method: ""print"". The diagram also shows that the ""Student"" class inherits the ""print"" method from the ""Person"" class."
"Finally, the keyword ""super"" is used to access attributes or methods from the superclass."
Inheritance How is it used?
"We see a code snippet of a program written in Java. The program defines a class named ""Test"" with a main method. Inside the main method, two objects are created: ""neighbor"" of type ""Person"" and ""aStudent"" of type ""Student"""
". The ""Student"" class inherits from the ""Person"" class. Both objects are initialized with data, and then several methods are called on them, including ""setGroup"", ""setTimetable"", ""print"", and ""printGroup""."
"The expected output of the program is shown below the code, indicating that it will print personal data for both the ""Person"" and ""Student"" objects, including the student's group"
". This example demonstrates the concept of inheritance in object-oriented programming, where a subclass (Student) can inherit properties and methods from a superclass (Person)."
"Polymorphism
What is it?
Polymorphism is the capacity of an object for deciding which method to apply, depending on the class it belongs to."
"A call to a method on a reference of a generic type, for example, a base class, executes different implementations of the method depending on which class the object was created as.
Polymorphism allows designing and implementing extensible systems."
"Programs can process generic objects described by references of the superclass.
The specific behavior depends on the subclasses.
New subclasses can be added later."
"Polymorphism
Example"
"We have an example of polymorphism with Student, Professor and Secretary. We create an array of Person where we include objects of Student, Professor and Secretary"
". When calling the method print(), overridden in classes Student, Professor and Secretary, on the array of Person, each object uses its own implementation of the method."
The code snippet shows how to create an array of Person objects and how to call the print() method on each object in the array.- The first line of code declares an array of Person objects called group
".- The second line of code initializes the array with four Person objects: a Student, a Professor, a Secretary, and another Student.- The third line of code is a for loop that iterates over the array of Person objects"
.- The fourth line of code calls the print() method on each Person object in the array.
"Polymorphism
Dynamic binding"
"The power of method overriding is that the correct method is properly called even though the object of the child class is referenced through the base class. This mechanism is called ""dynamic binding"""
". This mechanism is called ""dynamic binding"". It allows detecting the proper method to call during runtime. The compiler does not generate the calling code during compile time, it only generates code for calculating which method to call"
". This is different from ""static binding"" (e.g., method overloading) where the proper method is detected at compile time."
"**Contents**
- Casting and type compatibility
- Abstract classes and methods
- Interfaces"
"Abstract classes Polymorphism
The image shows a code snippet illustrating the concept of polymorphism in object-oriented programming using abstract classes."
"An array named ""myFigures"" of type ""Figure"" is declared and initialized with a size of 3. The ""Figure"" class is abstract, meaning it cannot be instantiated directly."
"Each element of the array is then assigned an instance of a concrete subclass of ""Figure"": ""Rectangle"", ""Triangle"", and ""Square"". This demonstrates polymorphism, as the array can hold objects of different but related types."
"The code then iterates through the ""myFigures"" array and calls the ""area()"" method on each element. Since ""area()"" is declared in the abstract ""Figure"" class, each concrete subclass must provide its own implementation"
". This ensures that the correct area calculation is performed based on the actual type of object at runtime, showcasing dynamic binding."
"An annotation highlights that calling the ""area()"" method on objects of type ""Figure"" during runtime will determine the specific object type and execute the appropriate method. This dynamic behavior is referred to as ""Dynamic binding""."
"Another annotation points out that although the array ""myFigures"" is of type ""Figure"" (abstract), its elements are instances of concrete classes, namely ""Rectangle"", ""Triangle"", and ""Square"", which are non-abstract subclasses of ""Figure""."
"Interfaces. Interface inheritance. Polymorphism
- Interfaces can also have an inheritance hierarchy.
- Classes implementing the interfaces in the hierarchy must include all the methods defined in the interfaces."
- Interfaces also support dynamic resolution of methods during runtime (dynamic binding).
"The table describes Java modifiers.
The table lists 6 access modifiers: public, friendly (package), protected, private, abstract and final, and one modifier that changes the behavior of members of a class: static."
"For each modifier, the table describes how it affects classes, methods and attributes.
**public** elements are accessible from any other class.
**(friendly)** elements are only accessible to classes in the same package."
"**protected** elements are accessible to the class, its subclasses and classes in the same package.
**private** elements are only accessible inside the class."
"**private** elements are only accessible inside the class.
**abstract** classes cannot be instantiated but are designed to be inherited from. They have no code, and it is implemented in the subclasses. They must have at least one abstract method."
**final** classes cannot be extended and are a leaf in the inheritance tree. Final methods cannot be overridden. Final attributes are constants and their value cannot be changed.
"**static** elements are the same for all the class objects. To use a static method, use ClassName.method(); To use a static attribute, use ClassName.attribute;"
"Contents
v Recursion
v Types of recursion
v Recursion vs. iteration"
"Recursive Methods
• A method is called recursive, if it calls itself
(directly or indirectly)
• (For a recursive method to define a
terminating computation)
the recursive call(s) have to be simpler
(according to some metric)"
"- A method is called recursive if it calls itself directly or indirectly.
- For a recursive method to define a terminating computation, the recursive call(s) have to be simpler according to some metric."
"The call stack and the JVM
The stack is used to store theexecution order of methods andlocal variables.
The heapstores theobjects
Java Virtual Machine (JVM)"
"The stack is used to store the execution order of methods and local variables. The heap stores the objects.
There are three boxes: ""Call Stack"", ""Stack Memory"", and ""Heap Space""."
"The ""Call Stack"" box contains three boxes: ""main (String [])"", ""buildStudent (int,string)"", and ""Student(int,string)""."
"The ""Stack Memory"" box is divided by a dashed line. The upper part contains: ""Integer value"" with value ""rollno = 05"", ""String Reference"" with value ""name"", and ""Student Reference"" with value ""this"""
". The lower part contains: ""Integer value"" with value ""rollno = 05"", ""String Reference"" with value ""Tom"", and ""Student Reference"" with value ""student""."
"The ""Heap Space"" box contains a box labeled ""String Pool"" which contains a box labeled ""Tom"". There is also a box labeled ""05|""name""\nreference"" pointing to a box labeled ""Student Object""."
"There are arrows pointing from the ""Student Reference"" in the upper part of the ""Stack Memory"" box to the ""Tom"" box in the ""String Pool"" box, from the ""Student Reference"" in the lower part of the ""Stack Memory"" box to the ""05|""name""\nreference"" box"
", and from the ""05|""name""\nreference"" box to the ""Student Object"" box"
.
"Example 1
• Summation from 1 to n (with n > 0)
public static long s (int n) {
    if (n==1){
     return 1;
    }
  else{
     return s(n-1)+n;
    }
}
Basecase
Recursivecase"
"This code sample shows how to calculate the summation from 1 to n, with n greater than 0, using a recursive function in Java. The function is named ""s"" and takes an integer ""n"" as input. Inside the function, there is a base case and a recursive case"
". Inside the function, there is a base case and a recursive case. The base case is when n equals 1, in which case the function returns 1. The recursive case is when n is not 1, in which case the function returns the sum of s(n-1) and n"
". This means that the function will recursively call itself with n-1 until it reaches the base case, at which point it will start returning the sum of all the previous calls."
"how to calculate the sum of numbers from 1 to n, where n is greater than 0, using a recursive function in programming."
"The code is written in a C-like language and defines a function called ""s"" that takes an integer ""n"" as input and returns a long integer.
- The base case of the recursion is when n is equal to 1. In this case, the function returns 1."
"- The recursive case is when n is greater than 1. In this case, the function returns the sum of s(n-1) and n.
 an example of how the function works when n is equal to 3.
- The function first calculates s(2) which in turn calculates s(1)."
"- s(1) returns 1 (base case).
- s(2) then returns 3 (1 + 2).
- Finally, s(3) returns 6 (3 + 3).
 by stating that the recursive case happens twice (for s(3) and s(2)) and the base case happens once (for s(1))."
"Example 1
• Summation from 1 to n (with n > 0)
❚ s(3) =
❚ s(2)+3 =
❚  s(1)+2)+3 =
❚  (1+2)+3 =
❚  (3+3)=
❚  6
public static long s (int n){       if (n==1){
      return 1;
   }
   else{
      return s(n-1)+n;
   }
}
•
•"
"return 1;
   }
   else{
      return s(n-1)+n;
   }
}
•
•
The recursive case happens twice => s(3) and s(2)
The base case happens once => s(1)"
"This code sample shows how to calculate the summation from 1 to n, with n greater than 0, using a recursive function in Java. The function is named ""s"" and takes an integer ""n"" as input. Inside the function, there is a base case and a recursive case"
". Inside the function, there is a base case and a recursive case. The base case is when n equals 1, in which case the function returns 1. The recursive case is when n is not 1, in which case the function returns the sum of s(n-1) and n"
". This means that the function will recursively call itself with n-1 until it reaches the base case, at which point it will start returning the sum of all the previous calls."
"how to calculate the sum of numbers from 1 to n, where n is greater than 0, using a recursive function in programming."
"The code is written in a C-like language and defines a function called ""s"" that takes an integer ""n"" as input and returns a long integer.
- The base case of the recursion is when n is equal to 1. In this case, the function returns 1."
"- The recursive case is when n is greater than 1. In this case, the function returns the sum of s(n-1) and n.
 an example of how the function works when n is equal to 3.
- The function first calculates s(2) which in turn calculates s(1)."
"- s(1) returns 1 (base case).
- s(2) then returns 3 (1 + 2).
- Finally, s(3) returns 6 (3 + 3).
 by stating that the recursive case happens twice (for s(3) and s(2)) and the base case happens once (for s(1))."
"Example 2
• Badly designed recursion*
public static long s (int n){       if (n==1){
      return 1;
   }
   else{
Basecase
      return s(n+1)+n;
   }
}
*(if n > 1)
Recursivecase"
"an example of a badly designed recursive function in Java. The function is called ""s"" and takes an integer ""n"" as input. The function has a base case where if ""n"" is equal to 1, it returns 1"
". Otherwise, it recursively calls itself with ""n+1"" and adds ""n"" to the result. This is a bad design because it will result in an infinite loop if ""n"" is greater than 1"
". The comment at the bottom of  that the recursive case is only executed if ""n"" is greater than 1."
a badly designed recursive function in programming.
"The code snippet shows a function named ""s"" that takes an integer ""n"" as input. If ""n"" is equal to 1, it returns 1. Otherwise, it returns the result of calling the function ""s"" with ""n+1"" as input, plus the value of ""n""."
"provides examples of calling the function with different input values. For instance, s(3) would lead to s(4)+3, which in turn would lead to s(5)+4)+3, and so on."
"that this recursion is badly designed because it does not terminate. The recursive case, where ""n"" is not equal to 1, will always lead to another recursive call with a larger value of ""n"". This results in an infinite loop."
"explains that the base case, where ""n"" is equal to 1, is never reached because the recursive calls continue indefinitely."
"As a consequence, the code would result in a StackOverflowError. This error occurs when too much memory is used in the call stack, which happens when a recursive function keeps calling itself without reaching a base case."
"Example 2
• Badly designed recursion*
❚  s(3) =
❚  s(4)+3 =
❚  (s(5)+4)+3 =
public static long s (int n){       if (n==1){
      return 1;
   }
   else{
❚  ((s(6)+5)+4)+3 =
      return s(n+1)+n;
❚  (((s(7)+6)+5)+4)+3 =
❚  ...
❚    It does not terminate"
"❚  (((s(7)+6)+5)+4)+3 =
❚  ...
❚    It does not terminate
   }
}
•
•
•
The recursive case happens “infinite” number of times
The base case never happens
StackOverflowError (too much memory used in the call stack)
*(if n > 1)"
"an example of a badly designed recursive function in Java. The function is called ""s"" and takes an integer ""n"" as input. The function has a base case where if ""n"" is equal to 1, it returns 1"
". Otherwise, it recursively calls itself with ""n+1"" and adds ""n"" to the result. This is a bad design because it will result in an infinite loop if ""n"" is greater than 1"
". The comment at the bottom of  that the recursive case is only executed if ""n"" is greater than 1."
a badly designed recursive function in programming.
"The code snippet shows a function named ""s"" that takes an integer ""n"" as input. If ""n"" is equal to 1, it returns 1. Otherwise, it returns the result of calling the function ""s"" with ""n+1"" as input, plus the value of ""n""."
"provides examples of calling the function with different input values. For instance, s(3) would lead to s(4)+3, which in turn would lead to s(5)+4)+3, and so on."
"that this recursion is badly designed because it does not terminate. The recursive case, where ""n"" is not equal to 1, will always lead to another recursive call with a larger value of ""n"". This results in an infinite loop."
"explains that the base case, where ""n"" is equal to 1, is never reached because the recursive calls continue indefinitely."
"As a consequence, the code would result in a StackOverflowError. This error occurs when too much memory is used in the call stack, which happens when a recursive function keeps calling itself without reaching a base case."
"Example 3
• Summation from n to 1000
public static long s (int n){       if (n==1000){
      return 1000;
   }
   else if (n>1000){
Base cases
      return 0;
   }
   else{
      return s(n+1)+n;
Recursive case
   }
}"
"This code sample shows a recursive function in Java that calculates the summation from n to 1000. The function takes an integer n as input. If n is equal to 1000, it returns 1000. This is the base case. If n is greater than 1000, it returns 0"
". This is the base case. If n is greater than 1000, it returns 0. This is another base case. Otherwise, it recursively calls itself with n+1 and adds n to the result. This is the recursive case. The base cases are highlighted on the right side of the code"
". The base cases are highlighted on the right side of the code. The first base case is labeled ""Base cases"" and the second base case is labeled ""Recursive case""."
"Example 4
• Countdown (with counter > 0)
public static void countdown(int counter){
   if(counter == 0){
      return;
   }
   else{
      System.out.println(counter+"" "");
      countdown(--counter);
      return;
   }
}
Base case
Recursive case"
Countdown (with counter greater than 0)
"We see a code snippet showing a recursive function called countdown. The function takes an integer called counter as input. If the counter equals 0, the function returns"
". If the counter equals 0, the function returns. Otherwise, it prints the counter value followed by a space and recursively calls itself with a decremented counter value. The base case is highlighted with a red bracket and labeled ""Base case"""
". The recursive case is highlighted with a red bracket and labeled ""Recursive case""."
"Exercise 1
•
Implement the recursive methodsquare(int n), which calculates thesquare of n (when n > 1). We shallconsider the following formula in yourimplementation:
(N-1)2 = N2 - 2N + 1"
"Implement the recursive method square, which takes an integer n as input and calculates the square of n when n is greater than 1. The formula (N-1)^2 = N^2 - 2N + 1 should be considered in the implementation."
"Exercise 2
•
Implement the recursive method  riddle(intp, int q)with p and q > 0. Each time thismethod is called, the value of q increases in oneunit, while the value of p decreases in one unit.When p is zero, the method returns the value of q."
"• How many time are the recursive and base casesexecuted when calling riddle(3,5) and whatvalue is returned?"
"We are asked to implement a recursive method called ""riddle"" that takes two integer arguments, p and q, both greater than 0. Each time the method is called, the value of q is incremented by one, and the value of p is decremented by one"
". When p reaches zero, the method returns the value of q."
"The second question asks how many times the recursive and base cases are executed when calling the riddle method with the arguments (3, 5), and what value is returned."
"Types of recursion
• Linear recursion
– One recursive call per recursive case at most
– Non-tail recursion
• We need to reach the base case to get the first result.
Then we go back calculating the final result
• It is computationally expensive"
"• It is computationally expensive
– Tail recursion
• The final result is computed when reaching the base
case (using an accumulator)
• Lower computational cost"
"We are going to see the different types of recursion.
Linear recursion: one recursive call per recursive case at most."
Non-tail recursion: we need to reach the base case to get the first result. Then we go back calculating the final result. It is computationally expensive.
Tail recursion: the final result is computed when reaching the base case using an accumulator. Lower computational cost.
"Non-linear recursion. Several recursive calls per recursive case. Cascade recursion. For example, return method of n plus method of n minus 1. Nested recursion. For example, return method of n, method of n minus 1.
- Mutual"
"- Mutual
We see two blocks of code and a diagram."
"The first block of code defines a function called ""even"" that takes an integer ""n"" as input and returns a boolean value.If ""n"" is equal to 0, the function returns ""true"""
".If ""n"" is equal to 0, the function returns ""true"". Otherwise, it returns the result of calling another function called ""odd"" with ""n-1"" as input."
"The second block of code defines a function called ""odd"" that takes an integer ""n"" as input and returns a boolean value.If ""n"" is equal to 0, the function returns ""false"". Otherwise, it returns the result of calling the ""even"" function with ""n-1"" as input"
.
"The diagram on the right shows two ovals, one labeled ""odd"" and the other labeled ""even"", with arrows pointing from each oval to the other. This illustrates the concept of mutual recursion, where two or more functions call each other in a circular fashion"
". In this case, the ""even"" function calls the ""odd"" function, which in turn calls the ""even"" function again, and so on. This process continues until one of the functions returns a value without making another recursive call."
"Non-tail recursion
• Computing the factorial
fac(n) = n! = n*(n-1)*(n-2)…2*1 (with n >= 0)
public static long fac(int n){
   if (n<=1){
      return 1;
   }
   else{
      return n*fac(n-1);
   }
}
fac (4) =4*fac(3) =
*3*fac(2) =
*3*2*fac(1) =
*3*(2*1) ="
"}
}
fac (4) =4*fac(3) =
*3*fac(2) =
*3*2*fac(1) =
*3*(2*1) =
*(3*2) =
*6 ="
"public static void main (String[] args){
   System.out.println(fac(4));
}"
"The image shows an example of non-tail recursion.
The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 4! = 4 * 3 * 2 * 1 = 24."
"The code defines a function called ""fac"" that takes an integer n as input and returns the factorial of n"
". The function is defined recursively, meaning that it calls itself with a smaller value of n until it reaches the base case, which is when n is less than or equal to 1. In this case, the function returns 1."
"The code also includes a main function that calls the fac function with the value 4 and prints the result to the console.
The code on the right side of the image shows the step-by-step calculation of fac(4)."
"First, fac(4) is called. Since 4 is not less than or equal to 1, the function enters the else block and returns 4 * fac(3).
Next, fac(3) is called. Since 3 is not less than or equal to 1, the function enters the else block and returns 3 * fac(2)."
"Next, fac(2) is called. Since 2 is not less than or equal to 1, the function enters the else block and returns 2 * fac(1).
Next, fac(1) is called. Since 1 is less than or equal to 1, the function enters the if block and returns 1."
"Now that fac(1) has returned 1, the calculation of fac(2) can be completed: 2 * 1 = 2.
Next, the calculation of fac(3) can be completed: 3 * 2 = 6.
Finally, the calculation of fac(4) can be completed: 4 * 6 = 24."
"Therefore, the output of the program is 24."
"Tail recursion
• Computing the factorial
fac(n) = n! = n*(n-1)*(n-2)…2*1 (with n >= 0)
public static long fact(int n, int m){
   if (n<=1){
      return m;
   }   else{
      return fact(n-1, n*m);
   }
}
public static void main (String[] args){"
"}
}
public static void main (String[] args){
   System.out.println(fact(4,1));
}
fac (4) =fact(4,1) =
fact(3,4) =
fact(2,12) =
fact(1,24) ="
"- Computing the factorial.
- Mathematical formula for calculating the factorial of n: fac(n) = n! = n*(n-1)*(n-2)...2*1 (with n >= 0)
- Java code snippet showing a tail-recursive function to calculate the factorial of a number."
"- The code defines a function called ""fact"" that takes two integer arguments, n and m.
- The function checks if n is less than or equal to 1. If it is, it returns the value of m.
- Otherwise, it recursively calls itself with n-1 and n*m as arguments."
"- The code also includes a main method that calls the fact function with arguments 4 and 1 and prints the result to the console.
- On the right-hand side, there is a breakdown of how the factorial of 4 is calculated using the defined function."
- It shows the values of the arguments passed to the function in each recursive call and the final result of 24.
"Types of recursion
• Non-Linear recursion
– Several recursive calls per recursive case
– Cascade recursion
• E.g., return method(n) + method(n-1);
– Nested recursion
• E.g., return method(n, method(n-1));"
"We are going to see the different types of recursion.
Linear recursion: one recursive call per recursive case at most."
Non-tail recursion: we need to reach the base case to get the first result. Then we go back calculating the final result. It is computationally expensive.
Tail recursion: the final result is computed when reaching the base case using an accumulator. Lower computational cost.
"Non-linear recursion. Several recursive calls per recursive case. Cascade recursion. For example, return method of n plus method of n minus 1. Nested recursion. For example, return method of n, method of n minus 1.
- Mutual"
"- Mutual
We see two blocks of code and a diagram."
"The first block of code defines a function called ""even"" that takes an integer ""n"" as input and returns a boolean value.If ""n"" is equal to 0, the function returns ""true"""
".If ""n"" is equal to 0, the function returns ""true"". Otherwise, it returns the result of calling another function called ""odd"" with ""n-1"" as input."
"The second block of code defines a function called ""odd"" that takes an integer ""n"" as input and returns a boolean value.If ""n"" is equal to 0, the function returns ""false"". Otherwise, it returns the result of calling the ""even"" function with ""n-1"" as input"
.
"The diagram on the right shows two ovals, one labeled ""odd"" and the other labeled ""even"", with arrows pointing from each oval to the other. This illustrates the concept of mutual recursion, where two or more functions call each other in a circular fashion"
". In this case, the ""even"" function calls the ""odd"" function, which in turn calls the ""even"" function again, and so on. This process continues until one of the functions returns a value without making another recursive call."
Cascade recursion: Fibonacci
"The image shows a table with two columns: n and fib(n). The first column contains the numbers 0, 1, 2, 3, 4, 5 and the second column contains the numbers 1, 1, 2, 3, 5, 8"
". The table shows the Fibonacci sequence, which is a sequence of numbers where each number is the sum of the two preceding ones. The image also shows a diagram of a tree with rabbits. The tree shows how the Fibonacci sequence can be calculated recursively"
". The root of the tree is a pair of rabbits. Each node in the tree represents a pair of rabbits, and the children of a node represent the offspring of that pair of rabbits"
". The number of pairs of rabbits in each generation of the tree corresponds to a number in the Fibonacci sequence. The image also shows the equation fib(5) = fib(4) + fib(3) = 5 + 3, which shows how the fifth Fibonacci number can be calculated recursively."
"The image shows a code snippet of a function called ""fib"" that takes an integer ""n"" as input and returns a long integer. The function calculates the Fibonacci series for a given input ""n"" where n is greater than zero"
". The function uses a recursive approach where it calls itself twice with n-1 and n-2 as input parameters. The base case for the recursion is when n is less than or equal to 1, in which case the function returns 1."
"We are looking at a diagram representing the Fibonacci series from cascade recursion to linear recursion. On the left, we have a box labeled fib(4) with the value 5. An arrow points to the right to a box labeled fibo(4,0,1) also with the value 5"
". This box points downwards to another box labeled fibo(3,1,1) with the value 5, which points downwards to a box labeled fibo(2,1,2) with the value 5. Finally, this box points downwards to a box labeled fibo(1,2,3) with the value 5."
The image shows an example of cascade recursion with the Fibonacci series. Cascade recursion is a type of recursion where the recursive call is made with a modified version of the original arguments
". In this case, the fibo function takes three arguments: n, x, and y. If n is less than or equal to 1, the function returns x+y. Otherwise, it returns the result of calling fibo with n-1, y, and x+y. This process is repeated until n is equal to 1"
. This process is repeated until n is equal to 1. The image also shows a diagram of the recursive calls made when calculating the fourth Fibonacci number
". The diagram shows that the fibo function is called four times, with the arguments (4,0,1), (3,1,1), (2,1,2), and (1,2,3). The final result of the calculation is 5, which is the fourth Fibonacci number."
"Cascade recursion: Fibonacci
• Fibonacci series (with n > 0)
public static long fib(int n){
   if (n<=1){
      return 1;
   }
   else{
      return fib(n-1)+fib(n-2);
   }
}"
"The image shows a table with two columns: n and fib(n). The first column contains the numbers 0, 1, 2, 3, 4, 5 and the second column contains the numbers 1, 1, 2, 3, 5, 8"
". The table shows the Fibonacci sequence, which is a sequence of numbers where each number is the sum of the two preceding ones. The image also shows a diagram of a tree with rabbits. The tree shows how the Fibonacci sequence can be calculated recursively"
". The root of the tree is a pair of rabbits. Each node in the tree represents a pair of rabbits, and the children of a node represent the offspring of that pair of rabbits"
". The number of pairs of rabbits in each generation of the tree corresponds to a number in the Fibonacci sequence. The image also shows the equation fib(5) = fib(4) + fib(3) = 5 + 3, which shows how the fifth Fibonacci number can be calculated recursively."
"The image shows a code snippet of a function called ""fib"" that takes an integer ""n"" as input and returns a long integer. The function calculates the Fibonacci series for a given input ""n"" where n is greater than zero"
". The function uses a recursive approach where it calls itself twice with n-1 and n-2 as input parameters. The base case for the recursion is when n is less than or equal to 1, in which case the function returns 1."
"We are looking at a diagram representing the Fibonacci series from cascade recursion to linear recursion. On the left, we have a box labeled fib(4) with the value 5. An arrow points to the right to a box labeled fibo(4,0,1) also with the value 5"
". This box points downwards to another box labeled fibo(3,1,1) with the value 5, which points downwards to a box labeled fibo(2,1,2) with the value 5. Finally, this box points downwards to a box labeled fibo(1,2,3) with the value 5."
The image shows an example of cascade recursion with the Fibonacci series. Cascade recursion is a type of recursion where the recursive call is made with a modified version of the original arguments
". In this case, the fibo function takes three arguments: n, x, and y. If n is less than or equal to 1, the function returns x+y. Otherwise, it returns the result of calling fibo with n-1, y, and x+y. This process is repeated until n is equal to 1"
. This process is repeated until n is equal to 1. The image also shows a diagram of the recursive calls made when calculating the fourth Fibonacci number
". The diagram shows that the fibo function is called four times, with the arguments (4,0,1), (3,1,1), (2,1,2), and (1,2,3). The final result of the calculation is 5, which is the fourth Fibonacci number."
"Cascade recursion: Fibonacci
• Fibonacci series: from cascade recursion
to linear recursion"
"The image shows a table with two columns: n and fib(n). The first column contains the numbers 0, 1, 2, 3, 4, 5 and the second column contains the numbers 1, 1, 2, 3, 5, 8"
". The table shows the Fibonacci sequence, which is a sequence of numbers where each number is the sum of the two preceding ones. The image also shows a diagram of a tree with rabbits. The tree shows how the Fibonacci sequence can be calculated recursively"
". The root of the tree is a pair of rabbits. Each node in the tree represents a pair of rabbits, and the children of a node represent the offspring of that pair of rabbits"
". The number of pairs of rabbits in each generation of the tree corresponds to a number in the Fibonacci sequence. The image also shows the equation fib(5) = fib(4) + fib(3) = 5 + 3, which shows how the fifth Fibonacci number can be calculated recursively."
"The image shows a code snippet of a function called ""fib"" that takes an integer ""n"" as input and returns a long integer. The function calculates the Fibonacci series for a given input ""n"" where n is greater than zero"
". The function uses a recursive approach where it calls itself twice with n-1 and n-2 as input parameters. The base case for the recursion is when n is less than or equal to 1, in which case the function returns 1."
"We are looking at a diagram representing the Fibonacci series from cascade recursion to linear recursion. On the left, we have a box labeled fib(4) with the value 5. An arrow points to the right to a box labeled fibo(4,0,1) also with the value 5"
". This box points downwards to another box labeled fibo(3,1,1) with the value 5, which points downwards to a box labeled fibo(2,1,2) with the value 5. Finally, this box points downwards to a box labeled fibo(1,2,3) with the value 5."
The image shows an example of cascade recursion with the Fibonacci series. Cascade recursion is a type of recursion where the recursive call is made with a modified version of the original arguments
". In this case, the fibo function takes three arguments: n, x, and y. If n is less than or equal to 1, the function returns x+y. Otherwise, it returns the result of calling fibo with n-1, y, and x+y. This process is repeated until n is equal to 1"
. This process is repeated until n is equal to 1. The image also shows a diagram of the recursive calls made when calculating the fourth Fibonacci number
". The diagram shows that the fibo function is called four times, with the arguments (4,0,1), (3,1,1), (2,1,2), and (1,2,3). The final result of the calculation is 5, which is the fourth Fibonacci number."
"Cascade recursion: Fibonacci
• Fibonacci series: from cascade recursion
to linear recursion
public static long fibo(int n, int x, int y){
   if (n<=1){
      return x+y;
   }
   else {
      return fibo(n-1, y, x+y);
   }
}
public static long fib (int n){"
"}
}
public static long fib (int n){
   return fibo(n,0,1);
}"
"The image shows a table with two columns: n and fib(n). The first column contains the numbers 0, 1, 2, 3, 4, 5 and the second column contains the numbers 1, 1, 2, 3, 5, 8"
". The table shows the Fibonacci sequence, which is a sequence of numbers where each number is the sum of the two preceding ones. The image also shows a diagram of a tree with rabbits. The tree shows how the Fibonacci sequence can be calculated recursively"
". The root of the tree is a pair of rabbits. Each node in the tree represents a pair of rabbits, and the children of a node represent the offspring of that pair of rabbits"
". The number of pairs of rabbits in each generation of the tree corresponds to a number in the Fibonacci sequence. The image also shows the equation fib(5) = fib(4) + fib(3) = 5 + 3, which shows how the fifth Fibonacci number can be calculated recursively."
"The image shows a code snippet of a function called ""fib"" that takes an integer ""n"" as input and returns a long integer. The function calculates the Fibonacci series for a given input ""n"" where n is greater than zero"
". The function uses a recursive approach where it calls itself twice with n-1 and n-2 as input parameters. The base case for the recursion is when n is less than or equal to 1, in which case the function returns 1."
"We are looking at a diagram representing the Fibonacci series from cascade recursion to linear recursion. On the left, we have a box labeled fib(4) with the value 5. An arrow points to the right to a box labeled fibo(4,0,1) also with the value 5"
". This box points downwards to another box labeled fibo(3,1,1) with the value 5, which points downwards to a box labeled fibo(2,1,2) with the value 5. Finally, this box points downwards to a box labeled fibo(1,2,3) with the value 5."
The image shows an example of cascade recursion with the Fibonacci series. Cascade recursion is a type of recursion where the recursive call is made with a modified version of the original arguments
". In this case, the fibo function takes three arguments: n, x, and y. If n is less than or equal to 1, the function returns x+y. Otherwise, it returns the result of calling fibo with n-1, y, and x+y. This process is repeated until n is equal to 1"
. This process is repeated until n is equal to 1. The image also shows a diagram of the recursive calls made when calculating the fourth Fibonacci number
". The diagram shows that the fibo function is called four times, with the arguments (4,0,1), (3,1,1), (2,1,2), and (1,2,3). The final result of the calculation is 5, which is the fourth Fibonacci number."
Non-recursive
"Nested recursion: Morris
public static int mor(int n, int m){
   if (n==m){
      return (m+1);
   }
   else{
      return(mor(n, mor(n-1, m+1)));
   }
}
❚ mor(4,0) =
❚ mor(4, mor(3,1)) =
❚ mor(4, mor(3, mor(2,2)) =
❚ mor(4, mor(3,3)) =
❚ mor(4,4) =
❚ 5"
"We see a piece of code that defines a function called ""mor"" that takes two integer arguments, n and m. The function returns an integer value.
- If n is equal to m, the function returns m+1.- Otherwise, the function recursively calls itself twice."
"Below the code, we see several lines of text that illustrate how the ""mor"" function is evaluated for the input values n=4 and m=0. The final result of the evaluation is 5."
"Exercise 3
•
Implement the recursive method a(int m,int n), which allows computing theAckermann-Péter function, defined as follows:
• What is the result of a(3,3)?• What happens with a(4,3)?"
"We are asked to implement a recursive method called ""a"", which takes two integer parameters, m and n, and computes the Ackermann-Péter function.
The Ackermann-Péter function is defined by a mathematical formula. This formula has three cases:"
"* If m equals zero, the function returns n plus 1.
* If m is greater than zero and n equals zero, the function returns A(m - 1, 1), which is a recursive call to the function with m decremented by 1 and n set to 1."
"* If m is greater than zero and n is greater than zero, the function returns A(m - 1, A(m, n - 1)), which is a nested recursive call to the function.
Finally, we are asked two questions:
* What is the result of a(3,3)?
* What happens with a(4,3)?"
"Types of recursion
• Mutual
public static boolean even(int n){
   if (n==0){
      return true;
   }
   else{
      return odd(n-1);
   }
}
public static boolean odd(int n){
   if (n==0){
      return false;
   }
   else{
      return even(n-1);
   }
}
odd"
"}
   else{
      return even(n-1);
   }
}
odd
even"
"We are going to see the different types of recursion.
Linear recursion: one recursive call per recursive case at most."
Non-tail recursion: we need to reach the base case to get the first result. Then we go back calculating the final result. It is computationally expensive.
Tail recursion: the final result is computed when reaching the base case using an accumulator. Lower computational cost.
"Non-linear recursion. Several recursive calls per recursive case. Cascade recursion. For example, return method of n plus method of n minus 1. Nested recursion. For example, return method of n, method of n minus 1.
- Mutual"
"- Mutual
We see two blocks of code and a diagram."
"The first block of code defines a function called ""even"" that takes an integer ""n"" as input and returns a boolean value.If ""n"" is equal to 0, the function returns ""true"""
".If ""n"" is equal to 0, the function returns ""true"". Otherwise, it returns the result of calling another function called ""odd"" with ""n-1"" as input."
"The second block of code defines a function called ""odd"" that takes an integer ""n"" as input and returns a boolean value.If ""n"" is equal to 0, the function returns ""false"". Otherwise, it returns the result of calling the ""even"" function with ""n-1"" as input"
.
"The diagram on the right shows two ovals, one labeled ""odd"" and the other labeled ""even"", with arrows pointing from each oval to the other. This illustrates the concept of mutual recursion, where two or more functions call each other in a circular fashion"
". In this case, the ""even"" function calls the ""odd"" function, which in turn calls the ""even"" function again, and so on. This process continues until one of the functions returns a value without making another recursive call."
"Recursion vs. Iteration
• Tail recursion can be immediately
converted into iteration (loop)
• Other forms of recursion require
program transformation techniques andpossibly more complex data structures"
"“The transformation from recursion to iteration is one of the mostfundamental concepts of computer science.”  D. Knuth, 1974"
"- Tail recursion can be immediately converted into iteration (loop).
- Other forms of recursion require program transformation techniques and possibly more complex data structures."
"""The transformation from recursion to iteration is one of the most fundamental concepts of computer science."" D. Knuth, 1974"
"Recursion vs. Iteration
• Computing the factorial
fac(n) = n! = n*(n-1)*(n-2)…2*1 (with n > 0 and m = 1)
public static long fac(int n, int m){
   if (n<=1){
      return m;
   }   else{
      return fac(n-1, n*m);
   }
}"
"return m;
   }   else{
      return fac(n-1, n*m);
   }
}
public static long fac(int n, int m){
while (! (n <= 1)){
m = n * m;
n = n - 1;
}
return m;
}
Recursion
Iteration"
"- Tail recursion can be immediately converted into iteration (loop).
- Other forms of recursion require program transformation techniques and possibly more complex data structures."
"""The transformation from recursion to iteration is one of the most fundamental concepts of computer science."" D. Knuth, 1974"
"Exercise 4
•
Implement the recursive method gcd(int a,int b), which allows computing the greatestcommon divisor of two integer numbers."
"Implement the recursive method gcd (int a, int b), which allows computing the greatest common divisor of two integer numbers.
The method is defined as follows: gcd(x, y) = x if y = 0, gcd(x, y) = gcd(y, remainder(x, y)) if y > 0."
"Exercise 5
•
Implement the recursive method decToBin(intdecimal, String binary), which receives adecimal number and returns a String with theequivalent binary number."
"Implement the recursive method ""decToBin"" which takes an integer ""decimal"" and a String ""binary"" as input, and returns a String with the equivalent binary number."
"To remember
• Range of values for termination
• Base case(s) and decreasing recursive
case(s)
• Linear recursion (≤1 recursive call/branch)
– Tail-recursion (call: last operation, easilyconvertible to loop) or non-tail recursion
• Non-linear recursion"
"• Non-linear recursion
(>1 recursive calls on some branch)
– Cascading or nested recursion"
"- Range of values for termination
- Base case(s) and decreasing recursive case(s)"
"- Base case(s) and decreasing recursive case(s)
- Linear recursion: less than or equal to 1 recursive call per branch. It can be tail-recursion, where the recursive call is the last operation and easily convertible to a loop, or non-tail recursion."
- Non-linear recursion: more than 1 recursive call on some branch. It can be cascading or nested recursion.
Non-recursive
The image presents a mathematical formula for calculating the Fibonacci sequence non-recursively
. The formula is fib(n) equals open parenthesis one plus the square root of five close parenthesis to the power of n plus 1 minus open parenthesis 1 minus the square root of 5 close parenthesis to the power of n plus 1 all divided by open parenthesis 2 to
to the power of n plus 1 all divided by open parenthesis 2 to the power of n plus 1 times the square root of 5 close parenthesis
.
"**Recursion vs. Iteration**
*Computing the factorial*
The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120."
two ways to compute the factorial of a number: recursively and iteratively.
"The recursive approach defines a function `fac(n, m)` that takes two integer arguments, n and m. If n is less than or equal to 1, the function returns m. Otherwise, it returns the result of calling `fac()` with n-1 and n*m as arguments."
"The iterative approach defines a function `fac(n, m)` that takes two integer arguments, n and m. The function uses a while loop to iterate over the numbers from n down to 2, multiplying m by each number in turn"
". When the loop finishes, the function returns m."
"Both approaches achieve the same result, but they do so in different ways. The recursive approach is more concise and elegant, but it can be less efficient than the iterative approach for large values of n"
". This is because each recursive call adds a new frame to the call stack, which can lead to a stack overflow error if the recursion is too deep"
". The iterative approach, on the other hand, does not use recursion, so it is not susceptible to stack overflow errors."
"Contents
v Stacks
v Queues
v Deques – double-ended queues"
"Stacks
• Linear data structure
•
Insertion and extraction into/from the (same) end (side)
ü LIFO (Last-In-First-Out)"
"- Linear data structure
- Insertion and extraction into/from the same end (side)
- LIFO (Last-In-First-Out)"
"The image shows a stack of books. The books are stacked on top of each other, with the last book placed on top being the first one that can be removed"
". This illustrates the concept of a LIFO (Last-In-First-Out) data structure, where the last element added to the stack is the first one to be removed."
"- Insert into an end: push (x)
- Extract from the same end: pop ()"
"A diagram shows a stack with 5 elements. The top element of the stack is the darkest shade of blue, and each element below it is a lighter shade of blue"
". An arrow labeled ""Push"" points to the top of the stack, and an arrow labeled ""Pop"" points away from the top of the stack. There is a blue rectangle above the ""Push"" arrow and to the right of the ""Pop"" arrow."
"Stacks
•
Insert into an end: push(x)
• Extract from the same end: pop()"
"- Linear data structure
- Insertion and extraction into/from the same end (side)
- LIFO (Last-In-First-Out)"
"The image shows a stack of books. The books are stacked on top of each other, with the last book placed on top being the first one that can be removed"
". This illustrates the concept of a LIFO (Last-In-First-Out) data structure, where the last element added to the stack is the first one to be removed."
"- Insert into an end: push (x)
- Extract from the same end: pop ()"
"A diagram shows a stack with 5 elements. The top element of the stack is the darkest shade of blue, and each element below it is a lighter shade of blue"
". An arrow labeled ""Push"" points to the top of the stack, and an arrow labeled ""Pop"" points away from the top of the stack. There is a blue rectangle above the ""Push"" arrow and to the right of the ""Pop"" arrow."
"Interface for stacks
public interface Stack<E> {
boolean isEmpty();
int size();
E top();
void push(E info);
E pop();
}"
This code defines a public interface in Java called Stack that takes a generic type parameter E
". The interface includes methods to check if the stack is empty, get the size of the stack, get the top element of the stack, push an element onto the stack, and pop an element from the stack."
"Interface for stacks (with exceptions)
public interface Stack<E> {
boolean isEmpty();
int size();
E top() throws
EmptyStackException;
void push(E info) throws
StackOverflowException;
E pop() throws
EmptyStackException;
}"
This code defines a public interface named Stack for a generic type E
". The interface includes methods to check if the stack is empty, get the size of the stack, get the top element of the stack, push an element onto the stack, and pop an element from the stack"
". The top and pop methods throw an EmptyStackException if the stack is empty, and the push method throws a StackOverflowException if the stack is full."
"Interface for stacks (without generics)
public interface Stack {
boolean isEmpty();
int size();
Object top();
void push(Object info);
Object pop();
}"
"This code defines a public interface in Java called ""Stack"". The interface includes the following methods:  is Empty, size, top, push, and pop. The is Empty method returns a boolean value. The size method returns an integer"
. The size method returns an integer. The top method returns an Object. The push method takes an Object as an argument and returns void. The pop method takes no arguments and returns an Object.
"One interface, two implementations
• Array-based implementation:
ü ArrayStack
• Linked-list-based implementation:
ü LinkedStack

We have one interface called ""Stack"" and two implementations: ""ArrayStack"" and ""LinkedStack""."
"the concept of having one interface and two implementations. There is a single interface called ""Queue"" which is implemented by two classes: ""ArrayQueue"" and ""LinkedListQueue"""
". The diagram shows two arrows pointing from the ""Queue"" interface to the two implementation classes."
"ArrayStack
top






 … … N-1
Empty stack
top







 … … N-1
Stack with 1 element
top


 3






 … … N-1
End forinsertion andextraction
Stack with 4elements"
The image illustrates the concept of an array-based stack data structure.
"We see four horizontal arrays of equal size, representing the stack at different states of occupancy. Each array element is depicted as a rectangle. The arrays are labeled with indices from 0 to N-1."
"The term ""top,"" accompanied by a downward arrow, indicates the top element of the stack at each state.
- The first array, labeled ""Empty stack,"" has an upward arrow pointing to the last element (N-1)."
"- The second array, ""Stack with 1 element,"" has the first element (index 0) filled with the value ""1,"" and the ""top"" arrow points to this element. The upward arrow again points to the last element."
"- The third array is not labeled but represents the stack with four elements. The first four elements are filled with values ""1,"" ""2,"" ""3,"" and ""4,"" and the ""top"" arrow points to the fourth element."
"- The final state, labeled ""Stack with 4 elements,"" is identical to the previous one, with the upward arrow pointing to the last element (N-1)."
"A red arrow connects the last element of the empty stack to the last element of the stack with one element, and another red arrow connects that point to the last element of the stack with four elements"
". This line is labeled ""End for insertion and extraction,"" indicating that elements are added and removed from the stack at this end."
"Exercise 1
• Create the ArrayStack<E> class, which implements Stack<E>,and has three attributes: int capacity, the array of generics data
array and int top with -1 as initial value."
"• Create the class constructor, which takes just one argument, and usesit to initialize the capacity attribute, creating also an array of datawith such capacity"
". IMPORTANT: We cannot create an array ofgenerics, so we need to create an array Object and do a casting."
"Implement the following methods:
o boolean isEmpty()
o int size()
o void push(E info)
•
• Homework: implement these methods:
o E pop()
o E top()"
"The first exercise requires creating an ""ArrayStack"" class of type E"
". This class implements the ""Stack"" of type E and has three attributes: an integer called ""capacity"", an array of generics called ""data"", and an integer called ""top"" with an initial value of -1"
". The class constructor takes one argument and uses it to initialize the ""capacity"" attribute. It also creates an array of data with the given capacity"
". It also creates an array of data with the given capacity. It is important to note that an array of generics cannot be created directly, so an array of Objects needs to be created and then cast to the desired type"
". The exercise also requires implementing the following methods: ""isEmpty"" which returns a boolean, ""size"" which returns an integer, and ""push"" which takes an argument of type E called ""info"" and returns void"
". As homework, the exercise requires implementing the ""pop"" and ""top"" methods, both of which return type E."
"LinkedStack
End forinsertionandextraction
Empty stack
Stack with 1 element
Stack with 4elements"
"The image shows three different states of a linked stack. The first state is an empty stack, represented by a single dot labeled ""top"". The second state is a stack with one element, represented by two boxes stacked on top of each other"
". The top box contains a black dot and is labeled ""top"", while the bottom box contains the word ""Múnich"". The third state is a stack with four elements, represented by four boxes stacked on top of each other"
". Each box contains a black dot and is connected to the box below it by an arrow. The top box is labeled ""top"", and the boxes below it are labeled ""Moscú"", ""Madrid"", ""Miami"", and ""Múnich"" from top to bottom"
". An arrow labeled ""End for insertion and extraction"" points to the top of each stack."
"Remembering the Node class
public class Node<E> {
private E info;private Node<E> next;
public Node()
{…}
public Node(E info)
public Node(E info, Node<E> next)
{…}
{…}
public Node<E> getNext() {…}
public void setNext(Node<E> next) {…}
public E getInfo() {…}"
"public void setNext(Node<E> next) {…}
public E getInfo() {…}
public void setInfo(E info) {…}
}"
We have a generic class Node that takes a type parameter E. It has two private members: info of type E and next of type Node with the same type parameter E.
"The class has three constructors: one without parameters, one taking an argument of type E to initialize info, and another one taking an argument of type E for info and another one of type Node with type parameter E for next."
The class also has public methods to get and set the next node and to get and set the info.
"LinkedStack (I)
public class LinkedStack<E> implements Stack<E> {
private Node<E> top;
private int size;
public LinkedStack() { }   
public boolean isEmpty() {
return (size == 0);
// return (top == null);
}
public int size() {return size;"
"// return (top == null);
}
public int size() {return size;
}  public E top() {
E info = null;
if (!isEmpty()) {
info = top.getInfo();
}
return info;
Attributes
Constructor
Stack interface methods toimplement (I)
}
…"
"We have a class definition for LinkedStack, which implements the Stack interface. The class has two private attributes: top of type Node and size of type int. There is also a constructor defined for the class"
". There is also a constructor defined for the class. The class implements the isEmpty method, which checks if the size is zero. It also implements the size method, which returns the size"
". It also implements the size method, which returns the size. Finally, the class implements the top method, which returns the info of the top node if the stack is not empty"
. The comment on the right side of the code states that these are the Stack interface methods to implement.
Insertion (push)
"The diagram shows the insertion operation, also known as push, in a stack data structure. The stack is represented as a linked list, with each element containing a value and a pointer to the next element"
". The ""top"" of the stack is indicated by a black dot, which initially points to the last element of the list. A new element containing the value ""Moscú"" is being inserted into the stack. This element is highlighted in red"
". This element is highlighted in red. An orange arrow indicates that the ""top"" pointer will be updated to point to the new element after insertion. The existing elements, ""Madrid"", ""Miami"", and ""Múnich"", remain in the stack, with their order preserved."
Extraction (pop)
We see a diagram representing a data structure. The structure is composed of four elements containing a black dot each. The elements are linked to each other. The second element from the left is highlighted in red
". The second element from the left is highlighted in red. An arrow points to the highlighted element and is labeled ""top"". The arrow originates from a black dot"
". The arrow originates from a black dot. There are four more arrows, each one pointing down, from each one of the elements to rounded rectangles containing the following labels: ""Moscú"", ""Madrid"", ""Miami"", and ""Múnich""."
"LinkedStack (II)
…
public void push(E info){
Node<E> n = new Node<E>(info, top);
top = n;
size++;
}
public E pop() {
E info = null;
if (!isEmpty()) {
info = top.getInfo();
top = top.getNext();
size--;
}
return info;
}
}"
"top = top.getNext();
size--;
}
return info;
}
}
Stack interface methodsto implement (II)"
"The image shows code snippets for the push and pop methods of a LinkedStack data structure, along with diagrams illustrating their effects."
"The push method takes an element ""info"" as input and creates a new node containing that element. This new node is then linked to the top of the stack, effectively pushing the new element onto the stack"
". The ""top"" reference is updated to point to the new node, and the size of the stack is incremented."
"The pop method, on the other hand, first checks if the stack is empty"
". If not, it retrieves the element stored in the top node, updates the ""top"" reference to point to the next node in the stack, decrements the stack size, and finally returns the retrieved element."
"The diagrams visually represent the state of the stack before and after the push and pop operations. Each node in the stack is represented by a rectangle, with the top node indicated by an arrow labeled ""top"""
. The elements stored in the stack are shown inside the rectangles. The arrows connecting the nodes represent the links between them.
"Queues
• Linear data structure
•
Insertion into one end and extraction from theopposite end
ü FIFO (First-In-First-Out)"
"-  are a linear data structure.
- Insertion happens at one end of the queue and extraction happens at the opposite end.
-  follow the FIFO principle: First-In-First-Out."
"-  follow the FIFO principle: First-In-First-Out.
- The image shows a queue of people waiting to board a bus, illustrating the concept of a queue."
"the concept of a queue data structure. It defines two main operations: enqueue, which inserts an element at the back of the queue, and dequeue, which extracts an element from the front."
"a diagram to illustrate how these operations work. The diagram shows a queue with five elements, labeled ""Back"" and ""Front"" to indicate the ends of the queue"
". An arrow labeled ""Enqueue"" points to the back of the queue, indicating where new elements are added. Another arrow labeled ""Dequeue"" points away from the front of the queue, indicating where elements are removed."
"Queues
•
Insert into one end: enqueue(x)
• Extract from the opposite end: dequeue()"
"-  are a linear data structure.
- Insertion happens at one end of the queue and extraction happens at the opposite end.
-  follow the FIFO principle: First-In-First-Out."
"-  follow the FIFO principle: First-In-First-Out.
- The image shows a queue of people waiting to board a bus, illustrating the concept of a queue."
"the concept of a queue data structure. It defines two main operations: enqueue, which inserts an element at the back of the queue, and dequeue, which extracts an element from the front."
"a diagram to illustrate how these operations work. The diagram shows a queue with five elements, labeled ""Back"" and ""Front"" to indicate the ends of the queue"
". An arrow labeled ""Enqueue"" points to the back of the queue, indicating where new elements are added. Another arrow labeled ""Dequeue"" points away from the front of the queue, indicating where elements are removed."
"Interface for queues
public interface Queue<E> {
boolean isEmpty();
int size();
E front();
void enqueue (E info);
E dequeue();
}"
"This code defines a public interface called Queue for a generic type E. The interface includes the following methods: isEmpty, size, front, enqueue, and dequeue.- isEmpty: returns true if the queue is empty, false otherwise"
".- isEmpty: returns true if the queue is empty, false otherwise.- size: returns the number of elements in the queue.- front: returns the element at the front of the queue without removing it.- enqueue: adds an element to the back of the queue"
.- enqueue: adds an element to the back of the queue.- dequeue: removes and returns the element at the front of the queue.
"Interface for queues (with exceptions)
public interface Queue<E> {
boolean isEmpty();
int size();
E front() throws
EmptyQueueException;
void enqueue (E info) throws
QueueOverflowException;
E dequeue() throws
EmptyQueueException;
}"
"This code defines a public interface in Java called ""Queue"" that takes a generic type parameter ""E"""
". The interface includes methods to check if the queue is empty, get its size, get the element at the front of the queue, add an element to the back of the queue, and remove and return the element at the front of the queue"
". The ""front"" and ""dequeue"" methods can throw an ""EmptyQueueException"" if the queue is empty, while the ""enqueue"" method can throw a ""QueueOverflowException"" if the queue is full."
"Interface for queues (without generics)
public interface Queue {
boolean isEmpty();
int size();
Object front();
void enqueue (Object info);
Object dequeue();
}"
"This code defines a public interface in Java called ""Queue"". The interface outlines the methods that any class implementing it must provide"
". These methods include: ""isEmpty"" which returns a boolean indicating whether the queue is empty, ""size"" which returns an integer representing the number of elements in the queue, ""front"" which returns the Object at the front of the queue"
", ""front"" which returns the Object at the front of the queue, ""enqueue"" which takes an Object as input and adds it to the end of the queue, and ""dequeue"" which removes and returns the Object at the front of the queue"
.
"One interface, two implementations
• Array-based implementation:
ü ArrayQueue
• Linked-list-based implementation:
ü LinkedQueue

We have one interface called ""Stack"" and two implementations: ""ArrayStack"" and ""LinkedStack""."
"the concept of having one interface and two implementations. There is a single interface called ""Queue"" which is implemented by two classes: ""ArrayQueue"" and ""LinkedListQueue"""
". The diagram shows two arrows pointing from the ""Queue"" interface to the two implementation classes."
"ArrayQueue
Extractionend
head
tail


tail
head




 … … N-1
Empty queue


head




 … … N-1

tail


 5


 3




head
tail
 … … N-1
Insertion of 1 element
Insertionend
Insertion of 5extra elements










 … … N-1
Extraction of2 elements"
"The image describes the  data structure.
It shows an array with N-1 positions. The first diagram shows an empty queue, where both the head and tail pointers point to the first position of the array."
"The second diagram shows the insertion of one element. The tail pointer now points to the second position of the array, while the head remains in the first position."
"The third diagram shows the insertion of five more elements. The tail pointer now points to the sixth position of the array, as we have inserted six elements in total. The head remains in the first position."
"The fourth diagram shows the extraction of two elements. The head pointer now points to the third position of the array, while the tail pointer remains in the sixth position."
"LinkedQueue
head tail
head
tail
Extractionend
head
Empty queue
Queue with1element
tail
Insertion end
Queue with 4elements"
"The image shows four different states of a linked queue data structure.
The first state, labeled ""Empty queue,"" shows a single dot representing both the head and tail of the queue."
"The second state, labeled ""Queue with 1 element,"" shows a single node containing the value ""Múnich."" This node is both the head and tail of the queue."
"The third state, labeled ""Queue with 4 elements,"" shows four nodes linked together"
". The first node contains the value ""Múnich,"" the second node contains the value ""Miami,"" the third node contains the value ""Madrid,"" and the fourth node contains the value ""Moscú"
"."" The head of the queue is the first node, and the tail of the queue is the fourth node."
"Red arrows are used to indicate the ""Extraction end"" and the ""Insertion end"" of the queue. The extraction end is at the head of the queue, and the insertion end is at the tail of the queue."
"LinkedQueue (I)
public class LinkedQueue<E> implements Queue<E> {
private Node<E> head;
private Node<E> tail;
private int size;
public LinkedQueue(){}
public boolean isEmpty() {
return (size == 0);
// return (head == null);
}
public int size() {"
"// return (head == null);
}
public int size() {
return size;
}
public E front() {
E info = null;
if (!isEmpty()) {
info = head.getInfo();
}
return info;
Attributes
Constructor
Queue interface methodsto implement(I)
}
…"
"We're looking at the code for a LinkedQueue class, which implements the Queue interface. The class has three private attributes: head and tail, which are both Node objects of type E, and size, which is an integer"
". The class also has a constructor, which takes no arguments. There are three public methods: isEmpty, size, and front. The isEmpty method returns true if the size is equal to 0, and false otherwise. The size method returns the size of the queue"
". The size method returns the size of the queue. The front method returns the info of the head node if the queue is not empty, and null otherwise"
". On the right side of the slide, we see that the code snippet shows the attributes and constructor of the class, and the methods from the Queue interface that need to be implemented."
"Insertion (enqueue)
head"
"The diagram shows a queue data structure. The queue contains three elements: Madrid, Miami, and Munich. The head of the queue is pointing to Madrid, and the tail of the queue is pointing to Munich. A new element, Moscú, is being added to the queue"
". A new element, Moscú, is being added to the queue. The tail of the queue will now point to Moscú. The letter 'n' is indicating the new element being added."
"LinkedQueue (II)
…
public void enqueue (E info){
Node<E> n = new Node<E>(info, null);
if (isEmpty()){
head = n;
} else {
tail.setNext(n);
Queue interface methodsto implement (II)
}tail = n;
size++;
head
}
…"
"We see a code snippet of a method called enqueue, which takes an argument info of type E. Inside the method, a new node is created with the given info and a null next pointer. If the queue is empty, the head is set to the new node"
". If the queue is empty, the head is set to the new node. Otherwise, the next pointer of the current tail is set to the new node. Finally, the tail is updated to the new node and the size is incremented."
There is also a note indicating that this is part of the implementation of the Queue interface methods.
"The diagram illustrates the process of enqueuing a new element into a linked queue. The queue contains four nodes with values Madrid, Miami, Munich, and Moscú"
". The head of the queue points to the node with the value Madrid, while the tail points to the node with the value Moscú. A new node with the value 'n' is being added to the end of the queue. The tail will now point to this new node."
"Extraction (dequeue)
head"
"We see a diagram representing a queue data structure. The queue contains four elements: Madrid, Miami, Munich, and Moscú. The head of the queue is pointing to the element ""Madrid"", while the tail is pointing to the element ""Moscú"""
". An arrow is coming out from the element ""Madrid"" and is going to the left, outside of the queue. This represents the extraction or dequeue operation, where the element at the head of the queue is removed."
"LinkedQueue (III)
…
public E dequeue(){
E info = null;
if (!isEmpty()) {
info = head.getInfo();
head = head.getNext();
size--;
if (isEmpty()) {
tail = null;
}
}
}
}
return info;
head
Queue interface methodsto implement(III)"
We see a code snippet of a dequeue method and a diagram illustrating a linked queue. The dequeue method first checks if the queue is empty
". The dequeue method first checks if the queue is empty. If it is not empty, it retrieves the information from the head node, updates the head to the next node, and decrements the size"
". If the queue becomes empty after removing the element, it sets the tail to null. Finally, it returns the retrieved information."
"The diagram depicts a linked queue with four nodes representing cities: Madrid, Miami, Munich, and Moscow. Each node contains data and a pointer to the next node in the queue"
". The head points to the first node (Madrid), and the tail points to the last node (Moscow). The arrows indicate the direction of the queue, with elements being added at the tail and removed from the head."
"Double-ended queues (deques)
• Linear data structures
o Deque (double-ended queue)
•
Insertion and extraction from any end"
"Double-ended queues are linear data structures. A deque is a double-ended queue. Insertion and extraction are possible from any end. The diagram shows a deque with 5 elements. The first element is labeled ""first"" and the last element is labeled ""last"""
". The operations that can be performed on a deque are: insertFirst, removeFirst, insertLast, and removeLast."
"Interface for deques
public interface Deque<E> {
public boolean isEmpty();
public int size();
public E first();
public E last();
public void insertFirst(E info);
public void insertLast(E info);
public E removeFirst();
public E removeLast();
}"
"This code defines an interface for a double-ended queue, or ""deque"", in Java. A deque is a data structure that allows elements to be added or removed from both the front and back of the queue."
"The interface includes methods for checking if the deque is empty, getting the size of the deque, getting the first and last elements of the deque, inserting elements at the front and back of the deque"
", inserting elements at the front and back of the deque, and removing elements from the front and back of the deque"
.
"The image shows four tables that represent the interface for stacks, queues, and deques.
The first table, labeled ""Stack,"" lists the following methods: size, isEmpty, top, push, and pop."
"The second table, labeled ""Deque,"" lists the following methods: size, isEmpty, last, insertFirst, and removeFirst.
The third table, labeled ""Queue,"" lists the following methods: size, isEmpty, front, enqueue, and dequeue."
"The fourth table, labeled ""Deque,"" lists the following methods: size, isEmpty, first, insertLast, and removeFirst."
"Interface for deques
Stack
Deque
Queue
Deque
size()
size()
size()
size()
isEmpty() isEmpty()
isEmpty()
isEmpty()
top()
last()
front()
first()
push(x)
insertFirst(x)
enqueue(x) insertLast(x)
pop()
removeFirst()
dequeue()
removeFirst()"
"This code defines an interface for a double-ended queue, or ""deque"", in Java. A deque is a data structure that allows elements to be added or removed from both the front and back of the queue."
"The interface includes methods for checking if the deque is empty, getting the size of the deque, getting the first and last elements of the deque, inserting elements at the front and back of the deque"
", inserting elements at the front and back of the deque, and removing elements from the front and back of the deque"
.
"The image shows four tables that represent the interface for stacks, queues, and deques.
The first table, labeled ""Stack,"" lists the following methods: size, isEmpty, top, push, and pop."
"The second table, labeled ""Deque,"" lists the following methods: size, isEmpty, last, insertFirst, and removeFirst.
The third table, labeled ""Queue,"" lists the following methods: size, isEmpty, front, enqueue, and dequeue."
"The fourth table, labeled ""Deque,"" lists the following methods: size, isEmpty, first, insertLast, and removeFirst."
"Implementation of deques
•
(regular) linked lists are not the best ideabecause removeLast needs to traversethe whole list to get the reference to thenext-to-last element
• Solution: doubly-linked lists"
"Regular linked lists are not the best idea because removeLast needs to traverse the whole list to get the reference to the next-to-last element.
The solution is to use doubly-linked lists."
"Doubly-linked lists
• Linked lists where each node, in addition to the
information and the reference to the next node inthe list, also stores a reference to the previous node
o The list can be traversed in both ways"
"o The list can be traversed in both ways
o The cost to extract the last node is reduced
head
null
info
prev
next
info
prev
next
info
prev
next
tail
null"
"are linked lists where each node, in addition to the information and the reference to the next node in the list, also stores a reference to the previous node"
. This means the list can be traversed in both ways and the cost to extract the last node is reduced.
"The diagram shows three nodes, each with three fields: info, prev, and next. The info field contains the data stored in the node. The prev field contains a pointer to the previous node in the list"
. The next field contains a pointer to the next node in the list. The first node in the list is called the head. The last node in the list is called the tail. The prev field of the head points to null. The next field of the tail points to null.
"The implementation of deques based on linked lists needs to check in each operation that both the previous and the next node exist. A simplification to this is to create two special nodes, called dummy nodes, with no data"
". One of these nodes is at the beginning and the other at the end of the list. An empty list only contains these two nodes. In each insertion or extraction operation, both the previous and the next node always exist, without needing to check"
. The head and tail references never change.
"There is a diagram showing three nodes. The leftmost and rightmost nodes are dummy nodes. The leftmost node is pointed to by the text ""head"" and the rightmost node is pointed to by the text ""tail"""
. The leftmost node points to null on the left and the middle node on the right. The middle node points to the leftmost node on the left and the rightmost node on the right. The rightmost node points to the middle node on the left and null on the right.
"Class DLNode
public class DLNode<E> {
private E info;
private DLNode<E> prev;
private DLNode<E> next;
public DLNode() {…}
public DLNode(E info) {…}
public DLNode(E info, DLNode<E> prev, DLNode<E> next){…}
public DLNode<E> getNext(){…}"
"public DLNode<E> getNext(){…}
public void setNext(DLNode<E> next){…}
public DLNode<E> getPrev(){…}
public void setPrev(DLNode<E> prev){…}
public E getInfo(){…}
public void setInfo(E info){…}
}"
"The image shows a code snippet for a generic doubly linked list node class named ""DLNode"". The class uses the generic type parameter ""E"" to represent the type of data stored in each node"
". The class has three private member variables: ""info"" of type E to store the data, ""prev"" of type DLNode<E> to store the reference to the previous node in the list, and ""next"" of type DLNode<E> to store the reference to the next node in the list"
". The class has three constructors: a default constructor that does nothing, a constructor that takes an argument of type E to initialize the ""info"" member variable, and a constructor that takes three arguments of type E, DLNode<E>"
", DLNode<E>, and DLNode<E> to initialize the ""info"", ""prev"", and ""next"" member variables, respectively"
". The class also has public getter and setter methods for each of the member variables, as well as a ""getNext()"" method that returns the ""next"" member variable and a ""getPrev()"" method that returns the ""prev"" member variable."
"Exercise 2
• Complete the code for the class DLNode<E>.
Add three constructors: one with no parameters, asecond one that allows initializing the info
attribute, and third one that allows initializing allattributes."
"Complete the code for the class DLNode of type E. Add three constructors: one with no parameters, a second one that allows initializing the info attribute, and a third one that allows initializing all attributes."
"Doubly-linked lists
•
•
The implementation of deques based on linked lists needs to checkin each operation that both the previous and the next node exist"
"Simplification: Create two special nodes (dummy nodes), with nodata, one at the beginning and another at the end of the list:o An empty list only contains these two nodes.
o In each insertion or extraction operation, both the previous and the next"
"node always exist, without needing to check.
o head and tail references never change.
head"
"are linked lists where each node, in addition to the information and the reference to the next node in the list, also stores a reference to the previous node"
. This means the list can be traversed in both ways and the cost to extract the last node is reduced.
"The diagram shows three nodes, each with three fields: info, prev, and next. The info field contains the data stored in the node. The prev field contains a pointer to the previous node in the list"
. The next field contains a pointer to the next node in the list. The first node in the list is called the head. The last node in the list is called the tail. The prev field of the head points to null. The next field of the tail points to null.
"The implementation of deques based on linked lists needs to check in each operation that both the previous and the next node exist. A simplification to this is to create two special nodes, called dummy nodes, with no data"
". One of these nodes is at the beginning and the other at the end of the list. An empty list only contains these two nodes. In each insertion or extraction operation, both the previous and the next node always exist, without needing to check"
. The head and tail references never change.
"There is a diagram showing three nodes. The leftmost and rightmost nodes are dummy nodes. The leftmost node is pointed to by the text ""head"" and the rightmost node is pointed to by the text ""tail"""
. The leftmost node points to null on the left and the middle node on the right. The middle node points to the leftmost node on the left and the rightmost node on the right. The rightmost node points to the middle node on the left and null on the right.
"Double queue class (DLDeque) withdoubly-linked lists
public class DLDeque<E> implements Deque<E>{
private DLNode<E> head;
private DLNode<E> tail;
private int size;
public DLDeque(){
head = new DLNode<E>();
tail = new DLNode<E>();
tail.setPrev(head);"
"tail = new DLNode<E>();
tail.setPrev(head);
head.setNext(tail);
size = 0;
}
…
Attributes
Constructor"
"Exercise 3
•
Implement the following methods in theDLDeque<E> class: o boolean isEmpty()
o int size()
o E first()
o E last()

Implement the following methods in the DLDeque<E> class:
- boolean isEmpty()
- int size()
- E first()
- E last()"
"Double queue class (DLDeque) with doubly-
linked lists: Insertion at the beginning
public void insertFirst(E info) {
DLNode<E> second = head.getNext();
DLNode<E> first = new DLNode<E>(info, head, second);
second.setPrev(first);
head.setNext(first);
size++;"
"second.setPrev(first);
head.setNext(first);
size++;
}
head"
"Double queue class (DLDeque) with doubly-
linked lists: Extraction from the beginning
public E removeFirst() {
E info = null;
if (!(head.getNext() == tail)) {
DLNode<E> first = head.getNext();
info = first.getInfo();
DLNode<E> second = first.getNext();"
"info = first.getInfo();
DLNode<E> second = first.getNext();
head.setNext(second);
second.setPrev(head);
size--;
}
return info;
}
head
first
second
tail
Moscú
Madrid
Miami
Múnich"
"Exercise 4
•
Implement the following methods in the
DLDeque<E> class:o void insertLast (E info)
• Homework:
o E removeLast()"
"We will implement the following methods in the DLDeque of E class: insertLast which takes an argument of type E called info, and for homework, we will implement removeLast which takes no arguments and returns an object of type E."
"Insertion (without dummy nodes)
head
DLNode<E> node = new DLNode<E>(data);"
"The diagram shows the insertion of a node into a doubly linked list. The new node is red. It is inserted between the node labeled ""prev"" and the next node. The code shows how to insert the new node. First, the new node's previous pointer is set to ""prev"""
". First, the new node's previous pointer is set to ""prev"". Then, if ""prev"" is not null, the new node's next pointer is set to the next node after ""prev"" and the next pointer of ""prev"" is set to the new node."
"The diagram shows the insertion of a new node into a doubly linked list, without using dummy nodes. The new node is shown in red."
"The code checks if the previous node is null. If it is, it means that the new node should be inserted at the beginning of the list"
". In this case, the new node's next pointer is set to the current head of the list, and the head is updated to point to the new node."
"If the previous node is not null, the code checks if the new node's next pointer is not null. If it is not, it means that the new node is not being inserted at the end of the list. In this case, the next node's previous pointer is set to the new node"
". Otherwise, the new node is being inserted at the end of the list, so the tail is updated to point to the new node."
"Insertion (without dummy nodes)
head
node.setPrev(prev);
if (prev != null) {
node.setNext(prev.getNext());
prev.setNext(node);
}"
"The diagram shows the insertion of a node into a doubly linked list. The new node is red. It is inserted between the node labeled ""prev"" and the next node. The code shows how to insert the new node. First, the new node's previous pointer is set to ""prev"""
". First, the new node's previous pointer is set to ""prev"". Then, if ""prev"" is not null, the new node's next pointer is set to the next node after ""prev"" and the next pointer of ""prev"" is set to the new node."
"The diagram shows the insertion of a new node into a doubly linked list, without using dummy nodes. The new node is shown in red."
"The code checks if the previous node is null. If it is, it means that the new node should be inserted at the beginning of the list"
". In this case, the new node's next pointer is set to the current head of the list, and the head is updated to point to the new node."
"If the previous node is not null, the code checks if the new node's next pointer is not null. If it is not, it means that the new node is not being inserted at the end of the list. In this case, the next node's previous pointer is set to the new node"
". Otherwise, the new node is being inserted at the end of the list, so the tail is updated to point to the new node."
"Insertion (without dummy nodes)
head
if (prev == null) { // Insert at the beginning
node.setNext(head);
head = node;
}
if (node.getNext() != null) {
node.getNext().setPrev(node);
} else {
tail = node;
}"
"The diagram shows the insertion of a node into a doubly linked list. The new node is red. It is inserted between the node labeled ""prev"" and the next node. The code shows how to insert the new node. First, the new node's previous pointer is set to ""prev"""
". First, the new node's previous pointer is set to ""prev"". Then, if ""prev"" is not null, the new node's next pointer is set to the next node after ""prev"" and the next pointer of ""prev"" is set to the new node."
"The diagram shows the insertion of a new node into a doubly linked list, without using dummy nodes. The new node is shown in red."
"The code checks if the previous node is null. If it is, it means that the new node should be inserted at the beginning of the list"
". In this case, the new node's next pointer is set to the current head of the list, and the head is updated to point to the new node."
"If the previous node is not null, the code checks if the new node's next pointer is not null. If it is not, it means that the new node is not being inserted at the end of the list. In this case, the next node's previous pointer is set to the new node"
". Otherwise, the new node is being inserted at the end of the list, so the tail is updated to point to the new node."
"Double queue class (DLDeque) with doubly-linked lists
We are looking at the code for a double-ended queue class called DLDeque. The class implements the Deque interface and uses a doubly-linked list to store the elements."
"The class has three attributes: head, tail, and size. Head is a reference to the first node in the list, tail is a reference to the last node in the list, and size is the number of elements in the list."
The class has a constructor that initializes the head and tail nodes and sets the size to 0. The head and tail nodes are initially connected to each other to form an empty list.
"Double queue class (DLDeque) with doubly-linked lists: Insertion at the beginning
The image shows the Java code and a diagram illustrating the insertion of a new element at the beginning of a double ended queue implemented with a doubly-linked list."
The code defines a method called insertFirst that takes a generic type E info as input.
"The diagram shows a doubly-linked list with 3 nodes: head, second and tail. Each node has two pointers: one to the previous node and one to the next node"
". The head node points to the first element of the list, while the tail node points to the last element of the list."
"The insertFirst method inserts a new node, labeled as ""first"", before the head node. The new node contains the value ""Moscú"". The next pointer of the new node points to the previous head node, and the previous pointer of the new node points to null"
". The next pointer of the head node is updated to point to the new node, and the previous pointer of the second node is updated to point to the new node. The size of the list is incremented by 1."
"**Double queue class (DLDeque) with doubly-linked lists: Extraction from the beginning**
The image shows the code and a diagram illustrating the process of removing the first element from a double-ended queue implemented using a doubly-linked list."
The code is a Java method called `removeFirst()` that returns an element of generic type `E`.
. **Initialization:** The method starts by initializing a variable `info` of type `E` to `null`. This variable will store the information of the element being removed.
". **Checking for an empty queue:** It then checks if the queue is empty by comparing the `next` pointer of the `head` node to the `tail` node. If they are the same, the queue is empty, and the method returns the initial `null` value of `info`."
". **Extracting the first element:** If the queue is not empty, the method retrieves the first node after the `head` and stores it in the `first` variable. The information of this node is then extracted and stored in the `info` variable."
". **Updating pointers:** Next, the method gets the second node in the queue and stores it in the `second` variable. The `next` pointer of the `head` node is updated to point to the `second` node, effectively removing the `first` node from the queue"
". The `prev` pointer of the `second` node is then updated to point to the `head` node, maintaining the doubly-linked list structure."
. **Decreasing the size:** The size of the queue is decremented by one to reflect the removal of an element.
". **Returning the removed element:** Finally, the method returns the `info` variable, which contains the information of the element that was removed from the beginning of the queue."
"The diagram visually represents the doubly-linked list before and after the removal of the first element. The orange boxes represent the nodes of the list, with arrows indicating the `next` and `prev` pointers"
". The first node, labeled ""first"", is removed from the list, and the `head` pointer is updated to point to the second node. The `Moscú` element is removed from the queue."
**Insertion (without dummy nodes)**
"The image shows three existing nodes in a doubly linked list, labeled ""head"", ""prev"", and ""tail"". Each node has two pointers: one to the previous node (""prev"") and one to the next node"
". The ""head"" node's ""prev"" pointer points to ""null"", indicating that it is the first node in the list. Similarly, the ""tail"" node's next pointer points to ""null"", indicating it is the last node."
"A new node, colored red, is being inserted into the list. The code snippet below the diagram shows the creation of this new node:
```
DLNode<E> node = new DLNode<E>(data);
```"
"```
DLNode<E> node = new DLNode<E>(data);
```
This line of code creates a new `DLNode` object with the given data and assigns it to the variable `node`. The `<E>` syntax indicates that this is a generic type, meaning it can hold any type of data."
"Contents
v Concept of tree
v Terminology
v Implementation
v Particular cases
Ø Binary search trees
Ø (Binary) heaps"
"The contents of this presentation are: Concept of tree, Terminology, Implementation, and Particular cases. The particular cases are: Binary search trees and (Binary) heaps."
"Concept of tree
A tree is a non-lineardata structure thatstores the elementshierarchically
(Generalization of lists)

A tree is a non-linear data structure that stores the elements hierarchically. This is a generalization of lists."
"Examples
. Classification of information in an
encyclopedia"
"We see a tree diagram with the root node labeled ""Encyclopaedia"". The root node has two children: ""Science"" on the left and ""Culture"" on the right. The ""Culture"" node has two children: ""Art"" on the left and ""Craft"" on the right."
"A diagram shows a file system. The root directory is at the top, and it branches down to several other directories, including home, tmp, usr, and var. The home directory branches down to its and scs. The its directory branches down to ug1 and pg1"
". The its directory branches down to ug1 and pg1. The ug1 directory branches down to ee51vn and ma51ik. The ee51vn directory branches down to docs, pics, and report.doc. The scs directory branches down to staff."
"three examples: Management structure of a company, Rank system in the army, Structure of a book or document. There are three dots below the list, indicating that there are more examples"
". On the right side of the slide, there is a cartoon drawing of a book with an ""at"" symbol on the cover. The book has three bookmarks in green, yellow, and red."
"We see a tree data structure with nodes a, b, c, d, e, f, g. Node a is the root and has children b, c, d and e. Node b has children f and g. The size of the tree is 7 and the height of the tree is 2."
"On the right side, we see a table with five columns: Node, Height, Depth, Size, Int./Ext. The table lists the properties of each node in the tree. For example, node a has height 2, depth 0, size 7 and is an internal node"
". Node b has height 1, depth 1, size 3 and is an internal node. Node c has height 0, depth 1, size 1 and is an external node. Node d has height 0, depth 1, size 1 and is an external node. Node e has height 0, depth 1, size 1 and is an external node"
". Node e has height 0, depth 1, size 1 and is an external node. Node f has height 0, depth 2, size 1 and is an external node. Node g has height 0, depth 2, size 1 and is an external node."
"Examples
. File system"
"We see a tree diagram with the root node labeled ""Encyclopaedia"". The root node has two children: ""Science"" on the left and ""Culture"" on the right. The ""Culture"" node has two children: ""Art"" on the left and ""Craft"" on the right."
"A diagram shows a file system. The root directory is at the top, and it branches down to several other directories, including home, tmp, usr, and var. The home directory branches down to its and scs. The its directory branches down to ug1 and pg1"
". The its directory branches down to ug1 and pg1. The ug1 directory branches down to ee51vn and ma51ik. The ee51vn directory branches down to docs, pics, and report.doc. The scs directory branches down to staff."
"three examples: Management structure of a company, Rank system in the army, Structure of a book or document. There are three dots below the list, indicating that there are more examples"
". On the right side of the slide, there is a cartoon drawing of a book with an ""at"" symbol on the cover. The book has three bookmarks in green, yellow, and red."
"We see a tree data structure with nodes a, b, c, d, e, f, g. Node a is the root and has children b, c, d and e. Node b has children f and g. The size of the tree is 7 and the height of the tree is 2."
"On the right side, we see a table with five columns: Node, Height, Depth, Size, Int./Ext. The table lists the properties of each node in the tree. For example, node a has height 2, depth 0, size 7 and is an internal node"
". Node b has height 1, depth 1, size 3 and is an internal node. Node c has height 0, depth 1, size 1 and is an external node. Node d has height 0, depth 1, size 1 and is an external node. Node e has height 0, depth 1, size 1 and is an external node"
". Node e has height 0, depth 1, size 1 and is an external node. Node f has height 0, depth 2, size 1 and is an external node. Node g has height 0, depth 2, size 1 and is an external node."
"Examples
. Management structure of a company
. Rank system in the army
. Structure of a book or document
…"
"We see a tree diagram with the root node labeled ""Encyclopaedia"". The root node has two children: ""Science"" on the left and ""Culture"" on the right. The ""Culture"" node has two children: ""Art"" on the left and ""Craft"" on the right."
"A diagram shows a file system. The root directory is at the top, and it branches down to several other directories, including home, tmp, usr, and var. The home directory branches down to its and scs. The its directory branches down to ug1 and pg1"
". The its directory branches down to ug1 and pg1. The ug1 directory branches down to ee51vn and ma51ik. The ee51vn directory branches down to docs, pics, and report.doc. The scs directory branches down to staff."
"three examples: Management structure of a company, Rank system in the army, Structure of a book or document. There are three dots below the list, indicating that there are more examples"
". On the right side of the slide, there is a cartoon drawing of a book with an ""at"" symbol on the cover. The book has three bookmarks in green, yellow, and red."
"We see a tree data structure with nodes a, b, c, d, e, f, g. Node a is the root and has children b, c, d and e. Node b has children f and g. The size of the tree is 7 and the height of the tree is 2."
"On the right side, we see a table with five columns: Node, Height, Depth, Size, Int./Ext. The table lists the properties of each node in the tree. For example, node a has height 2, depth 0, size 7 and is an internal node"
". Node b has height 1, depth 1, size 3 and is an internal node. Node c has height 0, depth 1, size 1 and is an external node. Node d has height 0, depth 1, size 1 and is an external node. Node e has height 0, depth 1, size 1 and is an external node"
". Node e has height 0, depth 1, size 1 and is an external node. Node f has height 0, depth 2, size 1 and is an external node. Node g has height 0, depth 2, size 1 and is an external node."
"Non-recursive definition
• A tree consists of a set of nodes and a
set of edges, such that:
– There is a special node called root"
"set of edges, such that:
– There is a special node called root
– For each node c (child), except for the root,there is one edge from another node p (p isparent of c, and can have several children)
– For each node there is a single path"
"– For each node there is a single path
(sequence of edges) from the root
– Nodes without children are called leaves"
"A tree consists of a set of nodes and a set of edges, such that:
- There is a special node called root
- For each node c (child), except for the root, there is one edge from another node p (p is parent of c, and can have several children)"
"- For each node there is a single path (sequence of edges) from the root
- Nodes without children are called leaves"
"The image shows a tree data structure with nodes represented as orange circles. The top node is labeled as ""Root (no parent)"". An arrow points from the root node to a node labeled ""p"". Another arrow points from ""p"" to a node labeled ""c"""
". Another arrow points from ""p"" to a node labeled ""c"". A text box next to ""p"" reads ""The parent of c"". A text box next to ""c"" reads ""A child of p"". A text box pointing to a group of nodes that are children of the root node reads ""sibling of c"""
". A text box pointing to a group of nodes that have no children reads ""Leaves (no children)""."
"Non-recursive definition
Root (no parent)
p
siblingof c
The parent of c
A child of p
c
Hojas
Leaves (no
(sin hijos)
children)
Leaves (no
Hojas
children)
(sin h"
"A tree consists of a set of nodes and a set of edges, such that:
- There is a special node called root
- For each node c (child), except for the root, there is one edge from another node p (p is parent of c, and can have several children)"
"- For each node there is a single path (sequence of edges) from the root
- Nodes without children are called leaves"
"The image shows a tree data structure with nodes represented as orange circles. The top node is labeled as ""Root (no parent)"". An arrow points from the root node to a node labeled ""p"". Another arrow points from ""p"" to a node labeled ""c"""
". Another arrow points from ""p"" to a node labeled ""c"". A text box next to ""p"" reads ""The parent of c"". A text box next to ""c"" reads ""A child of p"". A text box pointing to a group of nodes that are children of the root node reads ""sibling of c"""
". A text box pointing to a group of nodes that have no children reads ""Leaves (no children)""."
"Recursive definition
• A tree is
– empty– or a node (root) and zero or more trees(subtrees) connected to the node bymeans of an edge to its root
* Trees connected to the root are called subtrees"
A tree is either empty or it is a node called root and zero or more trees called subtrees connected to the root by means of an edge.
a diagram of a tree: the root is represented as an orange circle and it is connected to three subtrees represented as orange triangles.
"We see a diagram with a series of triangles and rectangles. The top rectangle, labeled ""a,"" has arrows pointing to five other triangles, each containing a rectangle. These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h"
". These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h."" Rectangles ""b"" and ""e"" each have arrows pointing to two more rectangles within their respective triangles, labeled ""f"" and ""g"" for ""b,"" and ""i"" and ""j"" for ""e"
"."" Finally, rectangle ""j"" has an arrow pointing to a final rectangle labeled ""k."""
"We see a diagram with several triangles connected by lines. One triangle is highlighted in orange. The diagram illustrates a recursive definition. The top element ""a"" is connected to four other elements ""b"", ""c"", ""d"", and ""e"""
". Element ""e"" is part of the orange triangle and is further connected to ""i"", ""j"", and ""k"". Element ""j"" is connected to element ""k"". Elements ""b"", ""f"", ""g"", and ""h"" are placed within separate triangles."
We see a diagram with several triangles connected by arrows. The triangles represent data structures and the arrows represent relationships between them. The topmost triangle contains the letter 'a'
". The topmost triangle contains the letter 'a'. It has arrows pointing to four other triangles containing the letters 'b', 'c', 'd', and 'e' respectively. Triangle 'b' has arrows pointing to two triangles containing 'f' and 'g'"
". Triangle 'e' is highlighted in orange and has arrows pointing to two other triangles, also highlighted in orange, containing nothing and 'j'. Triangle 'j' has an arrow pointing to a final orange triangle containing 'k'."
"We see a diagram with a tree data structure. The nodes of the tree are labeled with letters from 'a' to 'k'. The node 'a' is the root of the tree and has five children: 'b', 'c', 'd', 'e', and an unlabeled node. The node 'b' has two children: 'f' and 'g'"
. The node 'b' has two children: 'f' and 'g'. The node 'e' has two children: an unlabeled node and 'j'. The node 'j' has one child: 'k'. The node 'k' is highlighted in orange.
"We see a diagram with several triangles connected by arrows. The triangles represent data structures, and the arrows represent relationships between them. The top triangle, labeled ""a"", points to four other triangles, labeled ""b"", ""c"", ""d"", and ""e"""
". Triangle ""b"" points to triangles ""f"" and ""g"". Triangle ""d"" points to triangle ""h"". Triangle ""e"" points to triangles ""i"" and ""j"". Triangle ""j"" is highlighted in orange and points to triangle ""l"""
". This diagram illustrates a recursive definition, where a data structure is defined in terms of itself."
"Recursive definition
a
b
c
f
g
d
h
e
i
j
k"
A tree is either empty or it is a node called root and zero or more trees called subtrees connected to the root by means of an edge.
a diagram of a tree: the root is represented as an orange circle and it is connected to three subtrees represented as orange triangles.
"We see a diagram with a series of triangles and rectangles. The top rectangle, labeled ""a,"" has arrows pointing to five other triangles, each containing a rectangle. These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h"
". These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h."" Rectangles ""b"" and ""e"" each have arrows pointing to two more rectangles within their respective triangles, labeled ""f"" and ""g"" for ""b,"" and ""i"" and ""j"" for ""e"
"."" Finally, rectangle ""j"" has an arrow pointing to a final rectangle labeled ""k."""
"We see a diagram with several triangles connected by lines. One triangle is highlighted in orange. The diagram illustrates a recursive definition. The top element ""a"" is connected to four other elements ""b"", ""c"", ""d"", and ""e"""
". Element ""e"" is part of the orange triangle and is further connected to ""i"", ""j"", and ""k"". Element ""j"" is connected to element ""k"". Elements ""b"", ""f"", ""g"", and ""h"" are placed within separate triangles."
We see a diagram with several triangles connected by arrows. The triangles represent data structures and the arrows represent relationships between them. The topmost triangle contains the letter 'a'
". The topmost triangle contains the letter 'a'. It has arrows pointing to four other triangles containing the letters 'b', 'c', 'd', and 'e' respectively. Triangle 'b' has arrows pointing to two triangles containing 'f' and 'g'"
". Triangle 'e' is highlighted in orange and has arrows pointing to two other triangles, also highlighted in orange, containing nothing and 'j'. Triangle 'j' has an arrow pointing to a final orange triangle containing 'k'."
"We see a diagram with a tree data structure. The nodes of the tree are labeled with letters from 'a' to 'k'. The node 'a' is the root of the tree and has five children: 'b', 'c', 'd', 'e', and an unlabeled node. The node 'b' has two children: 'f' and 'g'"
. The node 'b' has two children: 'f' and 'g'. The node 'e' has two children: an unlabeled node and 'j'. The node 'j' has one child: 'k'. The node 'k' is highlighted in orange.
"We see a diagram with several triangles connected by arrows. The triangles represent data structures, and the arrows represent relationships between them. The top triangle, labeled ""a"", points to four other triangles, labeled ""b"", ""c"", ""d"", and ""e"""
". Triangle ""b"" points to triangles ""f"" and ""g"". Triangle ""d"" points to triangle ""h"". Triangle ""e"" points to triangles ""i"" and ""j"". Triangle ""j"" is highlighted in orange and points to triangle ""l"""
". This diagram illustrates a recursive definition, where a data structure is defined in terms of itself."
"Recursive definition
a
b
c
f
g
d
h
e
i
j
k"
A tree is either empty or it is a node called root and zero or more trees called subtrees connected to the root by means of an edge.
a diagram of a tree: the root is represented as an orange circle and it is connected to three subtrees represented as orange triangles.
"We see a diagram with a series of triangles and rectangles. The top rectangle, labeled ""a,"" has arrows pointing to five other triangles, each containing a rectangle. These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h"
". These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h."" Rectangles ""b"" and ""e"" each have arrows pointing to two more rectangles within their respective triangles, labeled ""f"" and ""g"" for ""b,"" and ""i"" and ""j"" for ""e"
"."" Finally, rectangle ""j"" has an arrow pointing to a final rectangle labeled ""k."""
"We see a diagram with several triangles connected by lines. One triangle is highlighted in orange. The diagram illustrates a recursive definition. The top element ""a"" is connected to four other elements ""b"", ""c"", ""d"", and ""e"""
". Element ""e"" is part of the orange triangle and is further connected to ""i"", ""j"", and ""k"". Element ""j"" is connected to element ""k"". Elements ""b"", ""f"", ""g"", and ""h"" are placed within separate triangles."
We see a diagram with several triangles connected by arrows. The triangles represent data structures and the arrows represent relationships between them. The topmost triangle contains the letter 'a'
". The topmost triangle contains the letter 'a'. It has arrows pointing to four other triangles containing the letters 'b', 'c', 'd', and 'e' respectively. Triangle 'b' has arrows pointing to two triangles containing 'f' and 'g'"
". Triangle 'e' is highlighted in orange and has arrows pointing to two other triangles, also highlighted in orange, containing nothing and 'j'. Triangle 'j' has an arrow pointing to a final orange triangle containing 'k'."
"We see a diagram with a tree data structure. The nodes of the tree are labeled with letters from 'a' to 'k'. The node 'a' is the root of the tree and has five children: 'b', 'c', 'd', 'e', and an unlabeled node. The node 'b' has two children: 'f' and 'g'"
. The node 'b' has two children: 'f' and 'g'. The node 'e' has two children: an unlabeled node and 'j'. The node 'j' has one child: 'k'. The node 'k' is highlighted in orange.
"We see a diagram with several triangles connected by arrows. The triangles represent data structures, and the arrows represent relationships between them. The top triangle, labeled ""a"", points to four other triangles, labeled ""b"", ""c"", ""d"", and ""e"""
". Triangle ""b"" points to triangles ""f"" and ""g"". Triangle ""d"" points to triangle ""h"". Triangle ""e"" points to triangles ""i"" and ""j"". Triangle ""j"" is highlighted in orange and points to triangle ""l"""
". This diagram illustrates a recursive definition, where a data structure is defined in terms of itself."
"Recursive definition
a
b
c
f
g
d
h
e
i
j
k"
A tree is either empty or it is a node called root and zero or more trees called subtrees connected to the root by means of an edge.
a diagram of a tree: the root is represented as an orange circle and it is connected to three subtrees represented as orange triangles.
"We see a diagram with a series of triangles and rectangles. The top rectangle, labeled ""a,"" has arrows pointing to five other triangles, each containing a rectangle. These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h"
". These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h."" Rectangles ""b"" and ""e"" each have arrows pointing to two more rectangles within their respective triangles, labeled ""f"" and ""g"" for ""b,"" and ""i"" and ""j"" for ""e"
"."" Finally, rectangle ""j"" has an arrow pointing to a final rectangle labeled ""k."""
"We see a diagram with several triangles connected by lines. One triangle is highlighted in orange. The diagram illustrates a recursive definition. The top element ""a"" is connected to four other elements ""b"", ""c"", ""d"", and ""e"""
". Element ""e"" is part of the orange triangle and is further connected to ""i"", ""j"", and ""k"". Element ""j"" is connected to element ""k"". Elements ""b"", ""f"", ""g"", and ""h"" are placed within separate triangles."
We see a diagram with several triangles connected by arrows. The triangles represent data structures and the arrows represent relationships between them. The topmost triangle contains the letter 'a'
". The topmost triangle contains the letter 'a'. It has arrows pointing to four other triangles containing the letters 'b', 'c', 'd', and 'e' respectively. Triangle 'b' has arrows pointing to two triangles containing 'f' and 'g'"
". Triangle 'e' is highlighted in orange and has arrows pointing to two other triangles, also highlighted in orange, containing nothing and 'j'. Triangle 'j' has an arrow pointing to a final orange triangle containing 'k'."
"We see a diagram with a tree data structure. The nodes of the tree are labeled with letters from 'a' to 'k'. The node 'a' is the root of the tree and has five children: 'b', 'c', 'd', 'e', and an unlabeled node. The node 'b' has two children: 'f' and 'g'"
. The node 'b' has two children: 'f' and 'g'. The node 'e' has two children: an unlabeled node and 'j'. The node 'j' has one child: 'k'. The node 'k' is highlighted in orange.
"We see a diagram with several triangles connected by arrows. The triangles represent data structures, and the arrows represent relationships between them. The top triangle, labeled ""a"", points to four other triangles, labeled ""b"", ""c"", ""d"", and ""e"""
". Triangle ""b"" points to triangles ""f"" and ""g"". Triangle ""d"" points to triangle ""h"". Triangle ""e"" points to triangles ""i"" and ""j"". Triangle ""j"" is highlighted in orange and points to triangle ""l"""
". This diagram illustrates a recursive definition, where a data structure is defined in terms of itself."
"Recursive definition
a
b
c
f
g
d
h
e
i
j
k"
A tree is either empty or it is a node called root and zero or more trees called subtrees connected to the root by means of an edge.
a diagram of a tree: the root is represented as an orange circle and it is connected to three subtrees represented as orange triangles.
"We see a diagram with a series of triangles and rectangles. The top rectangle, labeled ""a,"" has arrows pointing to five other triangles, each containing a rectangle. These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h"
". These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h."" Rectangles ""b"" and ""e"" each have arrows pointing to two more rectangles within their respective triangles, labeled ""f"" and ""g"" for ""b,"" and ""i"" and ""j"" for ""e"
"."" Finally, rectangle ""j"" has an arrow pointing to a final rectangle labeled ""k."""
"We see a diagram with several triangles connected by lines. One triangle is highlighted in orange. The diagram illustrates a recursive definition. The top element ""a"" is connected to four other elements ""b"", ""c"", ""d"", and ""e"""
". Element ""e"" is part of the orange triangle and is further connected to ""i"", ""j"", and ""k"". Element ""j"" is connected to element ""k"". Elements ""b"", ""f"", ""g"", and ""h"" are placed within separate triangles."
We see a diagram with several triangles connected by arrows. The triangles represent data structures and the arrows represent relationships between them. The topmost triangle contains the letter 'a'
". The topmost triangle contains the letter 'a'. It has arrows pointing to four other triangles containing the letters 'b', 'c', 'd', and 'e' respectively. Triangle 'b' has arrows pointing to two triangles containing 'f' and 'g'"
". Triangle 'e' is highlighted in orange and has arrows pointing to two other triangles, also highlighted in orange, containing nothing and 'j'. Triangle 'j' has an arrow pointing to a final orange triangle containing 'k'."
"We see a diagram with a tree data structure. The nodes of the tree are labeled with letters from 'a' to 'k'. The node 'a' is the root of the tree and has five children: 'b', 'c', 'd', 'e', and an unlabeled node. The node 'b' has two children: 'f' and 'g'"
. The node 'b' has two children: 'f' and 'g'. The node 'e' has two children: an unlabeled node and 'j'. The node 'j' has one child: 'k'. The node 'k' is highlighted in orange.
"We see a diagram with several triangles connected by arrows. The triangles represent data structures, and the arrows represent relationships between them. The top triangle, labeled ""a"", points to four other triangles, labeled ""b"", ""c"", ""d"", and ""e"""
". Triangle ""b"" points to triangles ""f"" and ""g"". Triangle ""d"" points to triangle ""h"". Triangle ""e"" points to triangles ""i"" and ""j"". Triangle ""j"" is highlighted in orange and points to triangle ""l"""
". This diagram illustrates a recursive definition, where a data structure is defined in terms of itself."
"Recursive definition
a
b
c
f
g
d
h
e
i
j
k"
A tree is either empty or it is a node called root and zero or more trees called subtrees connected to the root by means of an edge.
a diagram of a tree: the root is represented as an orange circle and it is connected to three subtrees represented as orange triangles.
"We see a diagram with a series of triangles and rectangles. The top rectangle, labeled ""a,"" has arrows pointing to five other triangles, each containing a rectangle. These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h"
". These rectangles are labeled ""b,"" ""c,"" ""d,"" ""e,"" and ""h."" Rectangles ""b"" and ""e"" each have arrows pointing to two more rectangles within their respective triangles, labeled ""f"" and ""g"" for ""b,"" and ""i"" and ""j"" for ""e"
"."" Finally, rectangle ""j"" has an arrow pointing to a final rectangle labeled ""k."""
"We see a diagram with several triangles connected by lines. One triangle is highlighted in orange. The diagram illustrates a recursive definition. The top element ""a"" is connected to four other elements ""b"", ""c"", ""d"", and ""e"""
". Element ""e"" is part of the orange triangle and is further connected to ""i"", ""j"", and ""k"". Element ""j"" is connected to element ""k"". Elements ""b"", ""f"", ""g"", and ""h"" are placed within separate triangles."
We see a diagram with several triangles connected by arrows. The triangles represent data structures and the arrows represent relationships between them. The topmost triangle contains the letter 'a'
". The topmost triangle contains the letter 'a'. It has arrows pointing to four other triangles containing the letters 'b', 'c', 'd', and 'e' respectively. Triangle 'b' has arrows pointing to two triangles containing 'f' and 'g'"
". Triangle 'e' is highlighted in orange and has arrows pointing to two other triangles, also highlighted in orange, containing nothing and 'j'. Triangle 'j' has an arrow pointing to a final orange triangle containing 'k'."
"We see a diagram with a tree data structure. The nodes of the tree are labeled with letters from 'a' to 'k'. The node 'a' is the root of the tree and has five children: 'b', 'c', 'd', 'e', and an unlabeled node. The node 'b' has two children: 'f' and 'g'"
. The node 'b' has two children: 'f' and 'g'. The node 'e' has two children: an unlabeled node and 'j'. The node 'j' has one child: 'k'. The node 'k' is highlighted in orange.
"We see a diagram with several triangles connected by arrows. The triangles represent data structures, and the arrows represent relationships between them. The top triangle, labeled ""a"", points to four other triangles, labeled ""b"", ""c"", ""d"", and ""e"""
". Triangle ""b"" points to triangles ""f"" and ""g"". Triangle ""d"" points to triangle ""h"". Triangle ""e"" points to triangles ""i"" and ""j"". Triangle ""j"" is highlighted in orange and points to triangle ""l"""
". This diagram illustrates a recursive definition, where a data structure is defined in terms of itself."
"Terminology
• A node is external, if it has no children (it is a leaf)
– According to the recursive definition: if all the subtrees
connected to that node are empty
• A node is internal, if it has one or more children"
"• A node is internal, if it has one or more children
– According to the recursive definition: if any of the subtrees
connected to that node is not empty"
"connected to that node is not empty
• A node is ancestor of another one, if the former isa parent of the latter or an ancestor of its parent
• A node is descendent of another one, if the latter
is ancestor of the former"
"is ancestor of the former
– The descendants of a node determine a subtree where this
node acts as the root"
"- A node is external, if it has no children (it is a leaf)
  - According to the recursive definition: if all the subtrees connected to that node are empty
- A node is internal, if it has one or more children"
"- A node is internal, if it has one or more children
  - According to the recursive definition: if any of the subtrees connected to that node is not empty"
"- A node is ancestor of another one, if the former is a parent of the latter or an ancestor of its parent
- A node is descendent of another one, if the latter is ancestor of the former"
"- The descendants of a node determine a subtree where this node acts as the root
- A path from one node to another one is a sequence of consecutive edges between the nodes. The length is the number of edges in the path."
"- The depth of a node is the length of the path from the root to this node.
- The height of a tree is the depth of the deepest node.
- The size of a tree is the number of nodes."
"Terminology
• A path from one node to another one is a
sequence of consecutive edges between thenodes.
– The length is the number of edges in the path.
• The depth of a node is the length of the path from
the root to this node."
"the root to this node.
• The height of a tree is the depth of the deepest
node.
• The size of a tree is the number of nodes."
"- A node is external, if it has no children (it is a leaf)
  - According to the recursive definition: if all the subtrees connected to that node are empty
- A node is internal, if it has one or more children"
"- A node is internal, if it has one or more children
  - According to the recursive definition: if any of the subtrees connected to that node is not empty"
"- A node is ancestor of another one, if the former is a parent of the latter or an ancestor of its parent
- A node is descendent of another one, if the latter is ancestor of the former"
"- The descendants of a node determine a subtree where this node acts as the root
- A path from one node to another one is a sequence of consecutive edges between the nodes. The length is the number of edges in the path."
"- The depth of a node is the length of the path from the root to this node.
- The height of a tree is the depth of the deepest node.
- The size of a tree is the number of nodes."
"Examples
Size of the tree: 7
Height of the tree: 2
Node Height
a
b
c
d
e
f
g







Depth

Size"
"Int./Ext.
Internal
Internal
External
External
External
External
External"
"External
External
External
We see a tree diagram with the root node labeled ""Encyclopaedia"". The root node has two children: ""Science"" on the left and ""Culture"" on the right. The ""Culture"" node has two children: ""Art"" on the left and ""Craft"" on the right."
"A diagram shows a file system. The root directory is at the top, and it branches down to several other directories, including home, tmp, usr, and var. The home directory branches down to its and scs. The its directory branches down to ug1 and pg1"
". The its directory branches down to ug1 and pg1. The ug1 directory branches down to ee51vn and ma51ik. The ee51vn directory branches down to docs, pics, and report.doc. The scs directory branches down to staff."
"three examples: Management structure of a company, Rank system in the army, Structure of a book or document. There are three dots below the list, indicating that there are more examples"
". On the right side of the slide, there is a cartoon drawing of a book with an ""at"" symbol on the cover. The book has three bookmarks in green, yellow, and red."
"We see a tree data structure with nodes a, b, c, d, e, f, g. Node a is the root and has children b, c, d and e. Node b has children f and g. The size of the tree is 7 and the height of the tree is 2."
"On the right side, we see a table with five columns: Node, Height, Depth, Size, Int./Ext. The table lists the properties of each node in the tree. For example, node a has height 2, depth 0, size 7 and is an internal node"
". Node b has height 1, depth 1, size 3 and is an internal node. Node c has height 0, depth 1, size 1 and is an external node. Node d has height 0, depth 1, size 1 and is an external node. Node e has height 0, depth 1, size 1 and is an external node"
". Node e has height 0, depth 1, size 1 and is an external node. Node f has height 0, depth 2, size 1 and is an external node. Node g has height 0, depth 2, size 1 and is an external node."
"Exercise 1
• Complete the table for the following tree
Node Height
a
b
c
d
e
f
g
h
i
j
k











Depth

Size"
"Depth

Size





















Int./Ext.
Internal
Internal
External
Interno
Interno
External
External
Externo
Externo
Interno
Externo
Size of the tree:Height of the tree:"
"We have a diagram representing a tree data structure and a table to be filled with information about the nodes of the tree.
The tree has the following structure:
- The root node is ""a"".
- Node ""a"" has 5 children: ""b"", ""c"", ""d"", and ""e""."
"- Node ""a"" has 5 children: ""b"", ""c"", ""d"", and ""e"".
- Node ""b"" has 2 children: ""f"" and ""g"".
- Node ""e"" has 2 children: ""h"" and ""i"".
- Node ""j"" is a child of ""i"".
- Node ""k"" is a child of ""j""."
"- Node ""j"" is a child of ""i"".
- Node ""k"" is a child of ""j"".
The table has the following columns: ""Node"", ""Height"", ""Depth"", ""Size"", ""Int./Ext."".
The table is partially filled. The following information is already present:
- Node ""a"" is an internal node."
"- Node ""a"" is an internal node.
- Node ""b"" has height 1, depth 1, size 3 and is internal.
- Node ""c"" has height 0, depth 1, size 1 and is external.
- Node ""f"" has height 0, depth 2, size 1 and is external."
"- Node ""f"" has height 0, depth 2, size 1 and is external.
- Node ""g"" has height 0, depth 2, size 1 and is external.
The following questions are asked about the tree:
- What is the size of the tree?
- What is the height of the tree?"
"Terminology: ordered tree
a
a
b
c
c
b
• A tree is ordered, if for each node there exists a
linear ordering for its children."
"We see two tree data structures. The nodes in both trees contain the letters a, b, and c. In the tree on the left, b is to the left of c, while in the tree on the right, c is to the left of b. The question is whether these two trees are the same."
"The text below states that a tree is ordered if, for each node, there exists a linear ordering for its children."
"Terminology: binary tree
• A binary tree is an ordered tree, where
each node has 2 subtrees (left and right).
– According to the recursive definition of tree
– Left and/or right subtrees can be empty"
"A binary tree is an ordered tree, where each node has two subtrees: a left subtree and a right subtree. According to the recursive definition of a tree, the left and/or right subtrees can be empty."
"Interface Btree<E>
public interface BTree<E> {
static final int LEFT = 0;
static final int RIGHT = 1;
boolean isEmpty();
E getInfo();
BTree<E> getLeft();
BTree<E> getRight();
void insert(BTree<E> tree, int side);
BTree<E> extract(int side);"
"BTree<E> extract(int side);
String toStringPreOrder();
String toStringInOrder();
String toStringPostOrder();
String toString(); // preorder
int size();
int height();
boolean equals(BTree<E> tree);
boolean find(BTree<E> tree);
}"
"The image shows an interface definition, for a Binary Tree, written in a language similar to Java. The name of the interface is ""BTree"" and it has a generic type ""E"".
The interface defines the following methods:"
"The interface defines the following methods:
* isEmpty: returns true if the tree is empty, false otherwise.
* getInfo: returns the element stored in the root of the tree.
* getLeft: returns the left subtree.
* getRight: returns the right subtree."
"* getRight: returns the right subtree.
* insert: inserts a new element in the tree.
* extract: extracts an element from the tree.
* toStringPreOrder: returns a string representation of the tree in preorder."
"* toStringInOrder: returns a string representation of the tree in inorder.
* toStringPostOrder: returns a string representation of the tree in postorder.
* toString: returns a string representation of the tree, by default in preorder."
"* size: returns the number of elements in the tree.
* height: returns the height of the tree.
* equals: checks if two trees are equal.
* find: checks if an element is in the tree.
The interface also defines two constants:"
"The interface also defines two constants:
* LEFT: represents the left side of a node.
* RIGHT: represents the right side of a node."
"Interface Btree<E>(with exceptions)
public interface BTree<E> {
static final int LEFT = 0;
static final int RIGHT = 1;
boolean isEmpty();
E getInfo() throws BTreeException;
BTree<E> getLeft() throws BTreeException;"
"BTree<E> getLeft() throws BTreeException;
BTree<E> getRight() throws BTreeException;
void insert(BTree<E> tree, int side) throws BTreeException;
BTree<E> extract(int side) throws BTreeException;
String toStringPreOrder();
String toStringInOrder();"
"String toStringPreOrder();
String toStringInOrder();
String toStringPostOrder();
String toString(); // preorder
int size();
int height();
boolean equals(BTree<E> tree);
boolean find(BTree<E> tree);
}"
"One interface several implementations
• Array-based implementation
v Left subtree
ü Position of root * 2 +1
v Right subtree
ü Position of root * 2 +2
p(root)=0
p(x.left)=2*p(x)+1
p(x.right)=2*p(x)+2
or
p(root)=1
p(x.left)=2*p(x)
p(x.right)=2*p(x)+1"
"or
p(root)=1
p(x.left)=2*p(x)
p(x.right)=2*p(x)+1
 an array-based implementation of a binary tree."
"an array-based implementation of a binary tree.
The diagram shows a binary tree with 7 nodes. The nodes are numbered from 1 to 7. The root node is 1, and it has two children: 2 and 3. Node 2 has two children: 4 and 5. Node 3 has two children: 6 and 7."
"The nodes of the tree are stored in an array. The root node is stored at index 0 of the array. The left child of a node at index i is stored at index 2*i+1, and the right child is stored at index 2*i+2."
There are two possible ways to store the root node: at index 0 or at index 1.  the formulas for calculating the indexes of the left and right children for both cases.
"Implementation based on a linked structure
• Linked-based implementation
§ Linked Binary Node (LBNode<E>)
§ Linked Binary Tree (LBTree<E>)
ü Each tree (LBTree<E>) has a root (attribute LBNode<E>)"
"ü Each tree (LBTree<E>) has a root (attribute LBNode<E>)
ü Each root (LBNode<E>) has two subtrees (attributesLBTree<E>), which can be empty (root is null)
We have a linked-based implementation.
- Linked Binary Node (LBNode<E>)"
"- Linked Binary Node (LBNode<E>)
- Linked Binary Tree (LBTree<E>)
Each tree (LBTree<E>) has a root (attribute LBNode<E>).
Each root (LBNode<E>) has two subtrees (attributes LBTree<E>), which can be empty (root is null)."
There is a diagram of a binary tree with 7 nodes. The nodes are numbered 1 through 7. Node 1 is the root node. Node 2 is the left child of node 1 and node 3 is the right child of node 1
. Node 4 is the left child of node 2 and node 5 is the right child of node 2. Node 6 is the left child of node 3 and node 7 is the right child of node 3.
"The nodes are colored in red and green. The nodes 1, 2, 4 and 6 are colored in red and the nodes 3, 5 and 7 are colored in green. The nodes are connected by lines"
. The nodes are connected by lines. The lines connecting the red nodes are also red and the lines connecting the green nodes are also green. The line connecting node 1 and node 2 is red and the line connecting node 1 and node 3 is green.
"*Binary node... (non-recursive)
public class LBNode<E> {
private E info;
private LBNode<E> left;
private LBNode<E> right;
public LBNode() {
this(null);
}
public LBNode(E info) {
this(info, null, null);
}
public LBNode(E info, LBNode<E> l, LBNode<E> r) {"
"}
public LBNode(E info, LBNode<E> l, LBNode<E> r) {
this.info = info;left = l;right = r;
}
}"
"LBNode<E> (recursive tree)
public class LBNode<E> {
private E info;
private BTree<E> left;
private BTree<E> right;
public LBNode(E info, BTree<E> left, BTree<E> right) {…}
public E getInfo() {…}
public void setInfo(E info) {…}
public BTree<E> getLeft() {…}"
"public void setInfo(E info) {…}
public BTree<E> getLeft() {…}
public void setLeft(BTree<E> left) {…}
public BTree<E> getRight() {…}
public void setRight(BTree<E> right){…}
}"
"We see a code snippet showing the definition of a class named LBNode, parameterized with a generic type E"
". This class represents a node in a binary tree, where each node stores an element of type E and references to its left and right children, which are also of type BTree<E>"
". The class provides a constructor to initialize the node with its info, left child, and right child. It also includes methods to get and set the info, left child, and right child of the node."
"Exercise 2
• Complete the implementation of
the class LBNode<E>.

Complete the implementation of the class LBNode of type E."
"LBTree<E> (I) (recursive tree)
public class LBTree<E> implements BTree<E> {
private LBNode<E> root;
public LBTree() {
root = null;
}
public LBTree(E info) {
root = new LBNode<E>(info, new LBTree<E>(), new LBTree<E>());
}
public boolean isEmpty() {"
"}
public boolean isEmpty() {
return (root==null);
}
…"
"We see code for a class named ""LBTree"" which implements the ""BTree"" interface. This class represents a binary tree data structure. It has a private member variable ""root"" of type ""LBNode"", representing the root node of the tree."
"The class has two constructors: a no-argument constructor that initializes the root to null, and a constructor that takes an argument of type ""E"" representing the information to be stored in the root node"
". This constructor creates a new ""LBNode"" with the given information and two empty subtrees, represented by new instances of ""LBTree""."
"Finally, the class has an ""isEmpty"" method that returns true if the tree is empty (i.e., the root is null) and false otherwise."
"LBTree<E> (II) (recursive tree)
…
public E getInfo() throws BTreeException {
if (isEmpty()) {
throw new BTreeException(""empty trees do not have info"");
}
return root.getInfo();
}
public BTree<E> getLeft() throws BTreeException {
if (isEmpty()) {"
"if (isEmpty()) {
throw new BTreeException(""empty trees do not have a left child"");
}
return root.getLeft();
}
public BTree<E> getRight() throws BTreeException {
if (isEmpty()) {
throw new BTreeException(""empty trees do not have a right child"");
}"
"}
return root.getRight();
}
…"
"The image shows three code snippets of a data structure called LBTree. The first snippet shows the method ""getInfo"" which returns the information stored in the root of the tree"
". The second snippet shows the method ""getLeft"" which returns the left subtree of the root. The third snippet shows the method ""getRight"" which returns the right subtree of the root. All three methods throw a BTreeException if the tree is empty."
"Basic algorithms
• Size (number of nodes)
• Height
• Traversals
– Euler
– Pre-, in- and post-order
(To simplify, we assume binary trees)"
"- Size: number of nodes
- Height
- Traversals: Euler, Pre-order, In-order, and Post-order
To simplify, we assume binary trees."
"LBTree<E>: size()
public int size() {
if (isEmpty()) {
return 0;
} else {
return 1 + root.getLeft().size()
+ root.getRight().size();
}
}"
"We see a code snippet showing the implementation of a method called size. The method first checks if the tree is empty. If it is, it returns zero"
". If it is, it returns zero. Otherwise, it recursively calls the size method on the left and right subtrees, adds one to the result, and returns the sum."
"LBTree<E>: size() non-recursive
. Create empty queue
. enqueue(root)
. Loop until empty queue
. Dequeue() an element
.
. Enqueue() its children
size++"
". Dequeue() an element
.
. Enqueue() its children
size++
The image describes an algorithm to calculate the size of an LBTre of generic type E. The algorithm is non-recursive and uses a queue."
"On the left side of the image, we see a tree. The root of the tree is node 1. Node 1 has two children: node 2 and node 3. Node 2 has two children: node 4 and node 5. Node 3 has two children: node 6 and node 7."
"On the right side of the image, we see a schematic representation of a queue. The queue is initially empty. The algorithm works as follows:
. Create an empty queue.
. Enqueue the root of the tree (node 1 in this case).
. Loop until the queue is empty."
". Loop until the queue is empty.
   1. Dequeue an element from the queue.
   2. Increment the size of the tree by one.
   3. Enqueue all the children of the dequeued element."
"The algorithm iterates through the tree level by level. It starts by adding the root node to the queue. Then, for each node dequeued from the queue, the algorithm increments the size count and adds all the node's children to the queue"
". This process continues until the queue is empty, ensuring that all nodes in the tree are visited and counted."
"LBTree<E>: height()
public int height() {
if (isEmpty()) {
return -1;
} else {
int leftHeight = root.getLeft().height();
int rightHeight = root.getRight().height();
if (leftHeight > rightHeight) {
return 1 + leftHeight;
+Math.max(leftHeight,rightHeight);"
"return 1 + leftHeight;
+Math.max(leftHeight,rightHeight);
} else {
return 1 + rightHeight;
}
}
}"
"We have a code snippet showing the implementation of the method ""height"" for a generic type ""LBTree"". The method begins by checking if the tree is empty. If it is, it returns -1"
". If it is, it returns -1. Otherwise, it recursively calculates the height of the left and right subtrees. The height of the tree is then determined by taking the maximum height of the left and right subtrees and adding 1"
". This is represented by the expression ""1 + Math.max(leftHeight, rightHeight)""."
"LBTree<E>: height() non-recursive
. Create empty queue
. enqueue(root)
. Loop until empty queue
. Dequeue() all element
. Enqueue() their children
.
if (queue is not empty) => height++"
".
if (queue is not empty) => height++
The image describes an algorithm to calculate the height of a binary tree in a non-recursive way."
"On the left side, we see a binary tree with 7 nodes. The nodes are numbered from 1 to 7. The root node is 1, and it has two children: 2 and 3. Node 2 has two children: 4 and 5. Node 3 has two children: 6 and 7."
"On the right side, there is a visual representation of a queue data structure. The queue is represented as a horizontal array with ""Front"" and ""Back"" labels. The ""Enqueue"" arrow points to the back of the queue, indicating where elements are added"
". The ""Dequeue"" arrow points from the front of the queue, indicating where elements are removed."
"Below the tree and the queue, there is a numbered list describing the steps of the algorithm:
. Create empty queue
. enqueue(root) - Add the root node to the queue.
. Loop until empty queue
   1. Dequeue() all element - Remove all elements from the queue."
"2. Enqueue() their children - Add all children of the removed elements to the queue.
   3. if (queue is not empty) => height++ - If the queue is not empty after adding the children, increment the height."
"Euler traversal

We see a tree with seven nodes. An arrow indicates that the traversal starts at the topmost node. The text ""Also applicable to non-binary trees!"" highlights that  is not limited to binary trees."
"Preorder traversal

• First the node (root)
• Then its children
(recursively)"
We see a diagram representing a tree data structure with nodes numbered from 1 to 7. Node 1 is the root node. An arrow originates from the root node and follows the path of a preorder traversal
". The preorder traversal visits the root node first, then recursively visits its children. In this case, the traversal order is 1, 2, 3, 4, 5, 6, 7."
"LBTree<E>: toStringPreOrder()
public String toStringPreOrder() {
if (isEmpty()) {
return """";
} else {
return root.getInfo().toString() + "" "" +
root.getLeft().toStringPreOrder() +
root.getRight().toStringPreOrder();
}
}"
"We see a code snippet for a function called `toStringPreOrder`. It's a recursive function that takes no arguments and returns a `String`. If the tree is empty, it returns an empty string"
". Otherwise, it returns a string containing the root node's information, followed by the string representation of the left subtree in pre-order, and then the string representation of the right subtree in pre-order."
"There is also a tree diagram with nodes containing the numbers 1 through 7. The node containing 1 is the root node. The node containing 2 is the left child of the root node, and the node containing 3 is the right child of the root node"
". The node containing 4 is the left child of the node containing 3, and the node containing 6 is the right child of the node containing 3"
". The node containing 5 is the left child of the node containing 4, and the node containing 7 is the right child of the node containing 4."
"LBTree<E>: toStringPreorder() non-recursive
. Create empty stack
. push(root)
. Loop until empty stack
.
.
.
.
pop()
print value
push(rightChild)
push(leftChild)"
".
.
.
.
pop()
print value
push(rightChild)
push(leftChild)
We have an example of a non-recursive implementation of the toStringPreorder method for a binary tree.
The algorithm is as follows:
First, create an empty stack."
"The algorithm is as follows:
First, create an empty stack.
Then, push the root of the tree onto the stack.
Iterate while the stack is not empty:
- pop the top node from the stack.
- print the value of the node."
"- print the value of the node.
- push the right child of the node onto the stack.
- push the left child of the node onto the stack.
This will print the values of the nodes in the tree in preorder."
There is a diagram representing a binary tree with 7 nodes. The nodes are numbered from 1 to 7. The root node is node 1. The left child of node 1 is node 2. The right child of node 1 is node 3. The left child of node 2 is node 4
. The left child of node 2 is node 4. The right child of node 2 is node 5. The left child of node 3 is node 6. The right child of node 3 is node 7.
There is a diagram representing a stack. The stack is initially empty. The algorithm pushes and pops nodes from the stack in the order that they are visited during the preorder traversal.
"Postorder traversal
• First the children trees

(recursively)
• Then the node (root)"
"We see a diagram representing a tree data structure. The nodes in the tree are numbered 1 through 7. The postorder traversal algorithm is described as follows: first, the children trees are traversed recursively, then the node itself is visited."
"LBTree<E>: toStringPostOrder()
public String toStringPostOrder() {
if (isEmpty()) {
return """";
} else {
return root.getLeft().toStringPostOrder() +
root.getRight().toStringPostOrder() +
root.getInfo().toString() + "" "";
}
}"
"We see a code snippet of a recursive function called toStringPostOrder. The function returns a string. If the tree is empty, it returns an empty string"
". If the tree is empty, it returns an empty string. Otherwise, it recursively calls itself on the left and right subtrees, concatenates the results with the string representation of the root node's information, and returns the resulting string."
"There is a diagram of a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, and 7. The root node is 7, and the left and right subtrees are rooted at 1 and 6, respectively."
"Inorder (symmetric) traversal



• First the left tree
(recursively)
• Then the node
• Finally, the right tree
(recursively)"
"The image shows a binary tree with 7 nodes, numbered from 1 to 7. The nodes are connected by lines. The lines are colored in black, except for the lines that connect the nodes in the order of an inorder traversal, which are colored in green"
". The inorder traversal is a way to visit all the nodes in a tree. It starts by recursively visiting the left subtree, then it visits the current node, and finally it recursively visits the right subtree"
". The inorder traversal of the tree in the image is: 1, 3, 4, 5, 6, 7."
"LBTree<E>: toStringInOrder()
public String toStringInOrder() {
if (isEmpty()) {
return """";
} else {
return root.getLeft().toStringInOrder() +
root.getInfo().toString() + "" "" +
root.getRight().toStringInOrder();
}
}"
"We have some source code for a function called toStringInOrder. The function returns a string. If the tree is empty, it returns an empty string"
". If the tree is empty, it returns an empty string. Otherwise, it recursively calls the function on the left and right subtrees, concatenating the results with the value of the root node in the middle, separated by spaces"
". There is also a diagram showing a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, and 7. The tree is structured such that the in-order traversal would visit the nodes in the following order: 1, 3, 4, 5, 6, 7, 2."
"Exercise 3
• Considering the following binary tree,
indicate which traversal type produces theresult (A+B)*(C-D)"
We are presented with a binary tree and asked to determine which traversal type produces the result: open parenthesis A plus B close parenthesis asterisk open parenthesis C minus D close parenthesis. The tree has a root node with an asterisk symbol
. The tree has a root node with an asterisk symbol. The root node branches to the left to a node with a plus symbol and to the right to a node with a minus symbol
. The plus node branches to the left to a leaf node with the letter A and to the right to a leaf node with the letter B. The minus node branches to the left to a leaf node with the letter C and to the right to a leaf node with the letter D.
"Different mathematical notation
Infix
A+B
Prefix
+AB
Postfix
AB+
A+B–C
–+ABC
AB+C–
(A+B)*(C–D)
*+AB–CD
AB+CD–*"
"The table shows different mathematical notations: infix, prefix and postfix. The first column shows the infix notation, the second column shows the prefix notation and the third column shows the postfix notation"
". The first row shows the addition of A and B, the second row shows the addition of A and B minus C, and the third row shows the multiplication of the sum of A and B and the subtraction of C from D."
"Systems Programming
Trees (II)
Departamento de Ingeniería
Telemática
CONTENTS ARE MOSTLY BASED ON THE WORK BY:
Carlos Alario Hoyos, Raquel M. Crespo García, Carlos Delgado Kloos,Mª Carmen Fernández Panadero, Julio Villena Román
Trees (II)"
"The presentation is about Trees, part 2, for a  course. It was created by the Telematics Engineering Department. The content is based on the work of Carlos Alario Hoyos, Raquel M"
". Crespo García, Carlos Delgado Kloos, Mª Carmen Fernández Panadero, and Julio Villena Román. The presentation is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike license."
"Contents
v Concept of tree
v Terminology
v Implementation
v Particular cases
Ø Binary search trees
Ø (Binary) heaps"
"The contents of this presentation are: Concept of tree, Terminology, Implementation, and Particular cases. The particular cases are: Binary search trees and (Binary) heaps."
"Notation
• So far:
o One node, three attributes: information, left subtree and
right subtree
o One tree, one attribute: node (root)
• When drawing a tree we represent the information as
the content in each node"
"We have a tree data structure. Each node has three attributes: information, left subtree and right subtree. When drawing a tree we represent the information as the content in each node. The tree has a root node containing an asterisk"
. The tree has a root node containing an asterisk. The root node branches into a plus sign on the left and a minus sign on the right. The plus sign branches into A on the left and B on the right
. The plus sign branches into A on the left and B on the right. The minus sign branches into C on the left and D on the right.
"From now on, we will add an additional attribute: the key. It facilitates using the tree for searching, inserting, and extracting. Depending on the implementation, the key can be an attribute of the node or an attribute of the key"
". When drawing the tree, the dark color will represent the key and the light color will represent information. We see an example of a tree. The root node has a key of 4 and the rest of the nodes have keys 2, 8, 1, 3, 6, and 9."
"Notation
• From now on:
o We add an additional attribute: the key
•
•
It facilitates using the tree for searching, inserting and extracting
Depending on the implementation, the key can be an attribute of thenode or an attribute of the key.
*"
"When drawing the tree
v Dark color: Key
v Light color: Information
+

-

A

B

C

D"
"We have a tree data structure. Each node has three attributes: information, left subtree and right subtree. When drawing a tree we represent the information as the content in each node. The tree has a root node containing an asterisk"
. The tree has a root node containing an asterisk. The root node branches into a plus sign on the left and a minus sign on the right. The plus sign branches into A on the left and B on the right
. The plus sign branches into A on the left and B on the right. The minus sign branches into C on the left and D on the right.
"From now on, we will add an additional attribute: the key. It facilitates using the tree for searching, inserting, and extracting. Depending on the implementation, the key can be an attribute of the node or an attribute of the key"
". When drawing the tree, the dark color will represent the key and the light color will represent information. We see an example of a tree. The root node has a key of 4 and the rest of the nodes have keys 2, 8, 1, 3, 6, and 9."
"Example of using keys
• Priority queues
o Linear data structure that returns the elements according tothe value of a key, instead of the order in which they wereinserted into the queue. The key indicates the priority.
Priority queue
COLA CON PRIORIDAD"
"Priority queue
COLA CON PRIORIDAD
*1 => Max. priority"
"We have an example of a priority queue. A priority queue is a linear data structure that returns the elements according to the value of a key, instead of the order in which they were inserted into the queue. The key indicates the priority"
". The key indicates the priority. In this example, 1 is the maximum priority. We have the elements ""E"", ""U"", ""U"", ""Q"" and ""E"" with the keys 3, 2, 4, 1 and 5 respectively"
". After processing the elements through the priority queue, the order of the elements is ""Q"", ""U"", ""E"", ""U"" and ""E""."
The image describes two implementations of priority queues.
"The first implementation compares elements at insertion time. This approach facilitates extraction, as the element with the highest priority is always at the front of the queue. The diagram shows a queue with five elements, labeled Q, U, E, U, and E"
". The elements are ordered by priority, with E having the highest priority and Q having the lowest. When a new element is inserted into the queue, it is compared to the existing elements and placed in the appropriate position based on its priority."
"The second implementation compares elements at extraction time. This approach facilitates insertion, as new elements can be added to the end of the queue without comparison"
". However, extracting the element with the highest priority requires comparing all elements in the queue. The diagram shows the same queue as in the first implementation, but this time the elements are not ordered by priority"
". When an element needs to be extracted from the queue, all elements are compared to find the one with the highest priority."
"Example of using keys
• Priority queues
o Implementation 1: Comparing at insertion
ü Facilitates extraction
o Implementation 2: Comparing at extraction
ü Facilitates insertion"
"We have an example of a priority queue. A priority queue is a linear data structure that returns the elements according to the value of a key, instead of the order in which they were inserted into the queue. The key indicates the priority"
". The key indicates the priority. In this example, 1 is the maximum priority. We have the elements ""E"", ""U"", ""U"", ""Q"" and ""E"" with the keys 3, 2, 4, 1 and 5 respectively"
". After processing the elements through the priority queue, the order of the elements is ""Q"", ""U"", ""E"", ""U"" and ""E""."
The image describes two implementations of priority queues.
"The first implementation compares elements at insertion time. This approach facilitates extraction, as the element with the highest priority is always at the front of the queue. The diagram shows a queue with five elements, labeled Q, U, E, U, and E"
". The elements are ordered by priority, with E having the highest priority and Q having the lowest. When a new element is inserted into the queue, it is compared to the existing elements and placed in the appropriate position based on its priority."
"The second implementation compares elements at extraction time. This approach facilitates insertion, as new elements can be added to the end of the queue without comparison"
". However, extracting the element with the highest priority requires comparing all elements in the queue. The diagram shows the same queue as in the first implementation, but this time the elements are not ordered by priority"
". When an element needs to be extracted from the queue, all elements are compared to find the one with the highest priority."
"Binary search trees
• Concept of binary search tree
• Operations
– Searching
– Insertion
– Extraction
- Concept of binary search tree
- Operations
  - Searching
  - Insertion
  - Extraction"
"Binary search trees: concept
• A binary search tree is a binary tree
where for each node n,– all the keys in the left subtree are
lower than the key of n
– and all those of the right subtree are 
greater than the key of n"
"greater than the key of n
– Some implementations allow keys that are equal to that of n on the left or right
– Others just override the info in case of two identical keys"
"A binary search tree is a binary tree where for each node n, all the keys in the left subtree are lower than the key of n and all those of the right subtree are greater than the key of n."
Some implementations allow keys that are equal to that of n on the left or right. Others just override the info in case of two identical keys.
"Example (I)

≤

≤

≥

≥
≤


≥

≥

≤




- We only represent keys (the stored information is not included)- Wrong implementation (left subtree of “2” includes a key that is greater than “2”)"
"We have a binary search tree with nodes containing the numbers 1, 2, 4, 5, 6, 7, 8 and 9. The root node is 4. The left subtree of the root node contains the nodes 1 and 2. The right subtree of the root node contains the nodes 6 and 8"
". The right subtree of the root node contains the nodes 6 and 8. The left subtree of the node 2 contains the node 3, which is marked as an error. The left subtree of the node 6 contains the node 5. The right subtree of the node 6 contains the node 7"
. The right subtree of the node 6 contains the node 7. The right subtree of the node 8 contains the node 9.
"On the right side of the image, there are three arrows pointing down. The first arrow points to the number 1, the second arrow points to the number 2 and the third arrow points to the number 3."
"The text below the diagram states that only keys are represented in the tree, and that the stored information is not included"
". It also states that the implementation of the tree is wrong because the left subtree of the node ""2"" includes a key that is greater than ""2""."
"We have a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, 7, 8 and 9. The root node is 4. The left child of 4 is 2 and the right child is 8. The children of 2 are 1 and 3. The children of 8 are 6 and 9"
". The children of 2 are 1 and 3. The children of 8 are 6 and 9. Finally, the children of 6 are 5 and 7."
"On the right side of the image, there are three green arrows pointing down at the numbers 1, 2 and 3."
"Below the tree, there are two sentences. The first sentence says: ""We only represent keys (the stored information is not included)"". The second sentence says: ""Correct implementation""."
"Example (I)

≥
≤

≤


≤

≥
≤


≥

≥




- We only represent keys (the stored information is not included)- Correct implementation"
"We have a binary search tree with nodes containing the numbers 1, 2, 4, 5, 6, 7, 8 and 9. The root node is 4. The left subtree of the root node contains the nodes 1 and 2. The right subtree of the root node contains the nodes 6 and 8"
". The right subtree of the root node contains the nodes 6 and 8. The left subtree of the node 2 contains the node 3, which is marked as an error. The left subtree of the node 6 contains the node 5. The right subtree of the node 6 contains the node 7"
. The right subtree of the node 6 contains the node 7. The right subtree of the node 8 contains the node 9.
"On the right side of the image, there are three arrows pointing down. The first arrow points to the number 1, the second arrow points to the number 2 and the third arrow points to the number 3."
"The text below the diagram states that only keys are represented in the tree, and that the stored information is not included"
". It also states that the implementation of the tree is wrong because the left subtree of the node ""2"" includes a key that is greater than ""2""."
"We have a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, 7, 8 and 9. The root node is 4. The left child of 4 is 2 and the right child is 8. The children of 2 are 1 and 3. The children of 8 are 6 and 9"
". The children of 2 are 1 and 3. The children of 8 are 6 and 9. Finally, the children of 6 are 5 and 7."
"On the right side of the image, there are three green arrows pointing down at the numbers 1, 2 and 3."
"Below the tree, there are two sentences. The first sentence says: ""We only represent keys (the stored information is not included)"". The second sentence says: ""Correct implementation""."
"Example (II)

≥

≥

≤

≥

≤

≤

≥

≤





v Correct implementation of a binary search tree"
"We see a binary search tree with the number 8 at the root. The left subtree of the root contains the values 1, 2, 3, 4, 6. The right subtree of the root contains the values 9 and 7"
". The right subtree of the root contains the values 9 and 7. The values in the tree are in green, and the comparison operators are in blue. To the right of the tree, we see a green down arrow with the numbers 1, 2, 3, and 4"
". Below the tree, we see the text ""Correct implementation of a binary search tree""."
"Operation: Searching
Searching “3”:
• 3<4: go to left subtree
• 3>2: go to right subtree
• 3=3: element found


≥
≤


≤



≤

≥
≤


≥

≥"
"The image shows how to search for the element ""3"" in a binary search tree."
"The search starts at the root node, which has a value of 4. Since 3 is less than 4, the search continues to the left subtree. The left subtree has a root node with a value of 2. Since 3 is greater than 2, the search continues to the right subtree"
". The right subtree has a root node with a value of 3. Since 3 is equal to 3, the element has been found."
The search path is indicated by arrows. The arrows are labeled with the comparison that was made at each step
". For example, the arrow from the node with value 4 to the node with value 2 is labeled ""3<4"" because the search went to the left subtree because 3 is less than 4."
"Operation: Insertion
Inserting “6”:
• 6<7: go to left subtree
• 6>2: go to right subtree
• when gap: insert


≥

≤


≥
≤



≥

≤"
The image shows how to insert the number six into a binary search tree
". The tree has the following existing nodes: seven at the root, two as the left child of seven, nine as the right child of seven, one as the left child of two, five as the right child of two, and three as the left child of five"
". The insertion process starts by comparing the new value, six, with the value of the root node, seven. Since six is less than seven, we move to the left subtree. Next, we compare six with the value of the current node, two"
". Next, we compare six with the value of the current node, two. Since six is greater than two, we move to the right subtree. There is no right child of two, so we insert six as the right child of five"
". The final tree has the following nodes: seven at the root, two as the left child of seven, nine as the right child of seven, one as the left child of two, five as the right child of two, three as the left child of five, and six as the right child of five"
.
"Exercise 4
• Given the following binary search tree, insert three
nodes with keys 4, 8, 10


≥

≤


≥


≥

≤

≤"
"Given the following binary search tree, insert three nodes with keys 4, 8, 10."
The image shows a binary search tree. The root node is 7. The left child of 7 is 2 and the right child of 7 is 9. The left child of 2 is 1 and the right child of 2 is 5. The left child of 5 is 3 and the right child of 5 is 6.
"Operation: Extraction (II)
If left and right subtrees
are empty (“leaf”)
• Remove node
• e.g. remove “3”
≤



≥

≤


≥


≥

≤"
"The image shows an example of node extraction from a binary tree. The text explains that if the left and right subtrees of a node are empty, the node should be removed. The example shows a binary tree with a root node of 7"
". The example shows a binary tree with a root node of 7. The node to be removed is 3, which has both left and right subtrees empty."
"If one of the subtrees in empty
- Replace by the root of the non-empty subtree
- e.g. extract ""5"""
We see a tree data structure. The root node is 7. The left subtree has root node 2. Node 2 has two children: 1 and 3. Node 3 has one child: 3. The right subtree of node 7 has a single node: 9
". The right subtree of node 7 has a single node: 9. The node with value 3, child of the node with value 2, is colored blue."
"Operation: Extraction (II)
If one of the subtrees inempty
• Replace by the root ofthe non-empty subtree
• e.g. extract “5”
≤


≥
≤


≥

≤"
"The image shows an example of node extraction from a binary tree. The text explains that if the left and right subtrees of a node are empty, the node should be removed. The example shows a binary tree with a root node of 7"
". The example shows a binary tree with a root node of 7. The node to be removed is 3, which has both left and right subtrees empty."
"If one of the subtrees in empty
- Replace by the root of the non-empty subtree
- e.g. extract ""5"""
We see a tree data structure. The root node is 7. The left subtree has root node 2. Node 2 has two children: 1 and 3. Node 3 has one child: 3. The right subtree of node 7 has a single node: 9
". The right subtree of node 7 has a single node: 9. The node with value 3, child of the node with value 2, is colored blue."
"Operation: Extraction (III)
If none of the subtrees
in empty
• Replace by the greatestkey in the left subtree orby the lowest key in theright subtree
• e.g. extract “2”(replacing by “1” or “3”)
≤

≤


≥
≤


≥"
"The diagram illustrates the extraction operation on a binary tree.
If none of the subtrees are empty, the node to be extracted is replaced by the greatest key in the left subtree or by the lowest key in the right subtree."
"For example, to extract ""2"", it can be replaced by ""1"" or ""3"". The diagram shows a binary tree with nodes containing the numbers 1, 3, 5, 7, and 9. The node with the value 7 is at the root of the tree"
. The node with the value 7 is at the root of the tree. The node with the value 3 is the left child of the root node. The node with the value 9 is the right child of the root node
. The node with the value 9 is the right child of the root node. The node with the value 1 is the left child of the left child of the root node. The node with the value 5 is the right child of the left child of the root node
. The node with the value 3 is the left child of the right child of the left child of the root node.
"Exercise 5
• Given the following binary search tree, extract thenode with key 7. Propose two ways of doing thisoperation


≥

≤

≤




≥
≤"
"Given the following binary search tree, extract the node with key 7. Propose two ways of doing this operation."
The binary search tree has the root node with value 7. The left child of the root has value 2 and the right child has value 9. The left child of node 2 has value 1 and the right child has value 5. The left child of node 5 has value 3.
"(Binary) Heaps
• A binary heap is a complete binary treewhere every node has a key greater(*)than the key of its parent (min-heap).
– Usually, heaps refer to binary heaps
* It could also be defined as less than (max-heap)"
"* It could also be defined as less than (max-heap)
* Some implementations allow equal keys, others override the information
• Utility
– Priority queues
– Sorting algorithms (Heap Sort)"
"A binary heap is a complete binary tree where every node has a key greater than the key of its parent. This is called a min-heap. Usually, heaps refer to binary heaps. It could also be defined as less than, which is called a max-heap"
". Some implementations allow equal keys, others override the information."
"Some of the utilities of binary heaps are priority queues and sorting algorithms, such as Heap Sort."
"(Binary) Heaps: properties
• A (binary) heap fulfils two properties:
. For each node n (except for the root),its key is greater than or equal to theone of its parent.
. Completeness
Complete
Not complete"
"A binary heap fulfills two properties. The first property is that for each node n, except for the root, its key is greater than or equal to the one of its parent. The second property is completeness."
There are two diagrams. The first diagram is an example of a complete binary tree. The second diagram shows two examples of binary trees that are not complete.
"Example 1









Not a heap: it is not complete

We see a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, 7, 8 and 9. The tree is not a heap because it is not complete: node 6 is missing a left child."
"Example 2









Not a heap: keys in some childrenare lower than those of the parent"
We see a tree with nodes containing numbers. The root node is a one. Its children are a three and a four. The three has children two and five. The four has children six and nine. The two has children eight and seven
". The two has children eight and seven. This is not a heap because some children have keys lower than those of the parent. For example, node two has a lower value than its parent, node three."
"Example 3









Heap

A diagram shows a binary tree labeled heap. The nodes of the tree contain the following values: 1 at the root, 2 and 4 on the second level, 3, 5, 6, and 9 on the third level, and 8 and 7 on the fourth level."
"Sequence-based implementation







 2 3 4 5 6 7
p(root)=0
p(x.left)=2*p(x)+1
p(x.right)=2*p(x)+2
or
p(root)=1
p(x.left)=2*p(x)
p(x.right)=2*p(x)+1
    1    2    3    4    5    6"
"We see a binary tree with 7 nodes. The nodes are numbered from 1 to 7. Node 1 is the root node, nodes 2 and 3 are its children, nodes 4 and 5 are children of node 2, and nodes 6 and 7 are children of node 3."
"Below the tree, we see a sequence-based representation of the tree. The sequence contains the numbers from 1 to 7.
The mapping between the tree and the sequence is defined by the following formulas:
- p(root) = 0
- p(x.left) = 2 * p(x) + 1"
"- p(root) = 0
- p(x.left) = 2 * p(x) + 1
- p(x.right) = 2 * p(x) + 2
where:
- p(x) is the position of node x in the sequence
- x.left is the left child of node x
- x.right is the right child of node x"
"- x.right is the right child of node x
Alternatively, the mapping can be defined by the following formulas:
- p(root) = 1
- p(x.left) = 2 * p(x)
- p(x.right) = 2 * p(x) + 1"
"Insert
Insert elementwith key=“2”"
We are given instructions to insert an element with a key of two into a data structure. The data structure is a binary search tree. The tree has a root node with a value of four. The left child of the root node has a value of five
. The left child of the root node has a value of five. The right child of the root node has a value of six. The left child of the node with value five has a value of fifteen. The right child of the node with value five has a value of nine
. The left child of the node with value six has a value of seven. The right child of the node with value six has a value of twenty. The left child of the node with value fifteen has a value of sixteen
. The right child of the node with value fifteen has a value of twenty five. The left child of the node with value nine has a value of fourteen. The right child of the node with value nine has a value of twelve
. The left child of the node with value seven has a value of eleven. The right child of the node with value seven has a value of eight.
The image shows a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5 and the right child has the value 6. The left child of 5 has the value 15 and the right child has the value 9
. The left child of 15 has the value 16 and the right child has the value 25. The left child of 9 has the value 14 and the right child has the value 12. The left child of 6 has the value 7 and the right child has the value 20
". The left child of 7 has the value 11 and the right child has the value 8. The left child of 20 has the value 2. The node with the value 2 is highlighted in blue. The text "" element with key=""2"""" is displayed above the tree."
"The image contains a red-black tree. The tree is composed of nodes connected by lines. Each node contains a number, called a key. The root node, at the top of the tree, has key=4. Its left and right children have keys 5 and 6, respectively."
"The instruction "" element with key='2'"" is shown above the tree. The key '2' has been inserted into the tree. The node containing the key '2' is colored blue, to indicate that it is the node that has just been inserted."
"We see a tree. The text "" element with key=2"" suggests we are about to insert an element with key ""2"" into this tree. The tree has a light blue node with the value ""2"" as its root"
". The tree has a light blue node with the value ""2"" as its root. The root has two children: a left child, which is a red node with the value ""5"", and a right child, which is a light blue node with the value ""4"""
". The node with value ""5"" has a left child with value ""15"" and a right child with value ""9"". The node with value ""15"" has a left child with value ""16"" and a right child with value ""25"""
". The node with value ""9"" has a left child with value ""14"" and a right child with value ""12"". The node with value ""4"" has a left child with value ""7"" and a right child with value ""6"""
". The node with value ""7"" has a left child with value ""11"" and a right child with value ""8"". The node with value ""6"" has a left child with value ""20""."
"Insert
Insert elementwith key=“2”"
We are given instructions to insert an element with a key of two into a data structure. The data structure is a binary search tree. The tree has a root node with a value of four. The left child of the root node has a value of five
. The left child of the root node has a value of five. The right child of the root node has a value of six. The left child of the node with value five has a value of fifteen. The right child of the node with value five has a value of nine
. The left child of the node with value six has a value of seven. The right child of the node with value six has a value of twenty. The left child of the node with value fifteen has a value of sixteen
. The right child of the node with value fifteen has a value of twenty five. The left child of the node with value nine has a value of fourteen. The right child of the node with value nine has a value of twelve
. The left child of the node with value seven has a value of eleven. The right child of the node with value seven has a value of eight.
The image shows a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5 and the right child has the value 6. The left child of 5 has the value 15 and the right child has the value 9
. The left child of 15 has the value 16 and the right child has the value 25. The left child of 9 has the value 14 and the right child has the value 12. The left child of 6 has the value 7 and the right child has the value 20
". The left child of 7 has the value 11 and the right child has the value 8. The left child of 20 has the value 2. The node with the value 2 is highlighted in blue. The text "" element with key=""2"""" is displayed above the tree."
"The image contains a red-black tree. The tree is composed of nodes connected by lines. Each node contains a number, called a key. The root node, at the top of the tree, has key=4. Its left and right children have keys 5 and 6, respectively."
"The instruction "" element with key='2'"" is shown above the tree. The key '2' has been inserted into the tree. The node containing the key '2' is colored blue, to indicate that it is the node that has just been inserted."
"We see a tree. The text "" element with key=2"" suggests we are about to insert an element with key ""2"" into this tree. The tree has a light blue node with the value ""2"" as its root"
". The tree has a light blue node with the value ""2"" as its root. The root has two children: a left child, which is a red node with the value ""5"", and a right child, which is a light blue node with the value ""4"""
". The node with value ""5"" has a left child with value ""15"" and a right child with value ""9"". The node with value ""15"" has a left child with value ""16"" and a right child with value ""25"""
". The node with value ""9"" has a left child with value ""14"" and a right child with value ""12"". The node with value ""4"" has a left child with value ""7"" and a right child with value ""6"""
". The node with value ""7"" has a left child with value ""11"" and a right child with value ""8"". The node with value ""6"" has a left child with value ""20""."
"Insert
Insert elementwith key=“2”"
We are given instructions to insert an element with a key of two into a data structure. The data structure is a binary search tree. The tree has a root node with a value of four. The left child of the root node has a value of five
. The left child of the root node has a value of five. The right child of the root node has a value of six. The left child of the node with value five has a value of fifteen. The right child of the node with value five has a value of nine
. The left child of the node with value six has a value of seven. The right child of the node with value six has a value of twenty. The left child of the node with value fifteen has a value of sixteen
. The right child of the node with value fifteen has a value of twenty five. The left child of the node with value nine has a value of fourteen. The right child of the node with value nine has a value of twelve
. The left child of the node with value seven has a value of eleven. The right child of the node with value seven has a value of eight.
The image shows a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5 and the right child has the value 6. The left child of 5 has the value 15 and the right child has the value 9
. The left child of 15 has the value 16 and the right child has the value 25. The left child of 9 has the value 14 and the right child has the value 12. The left child of 6 has the value 7 and the right child has the value 20
". The left child of 7 has the value 11 and the right child has the value 8. The left child of 20 has the value 2. The node with the value 2 is highlighted in blue. The text "" element with key=""2"""" is displayed above the tree."
"The image contains a red-black tree. The tree is composed of nodes connected by lines. Each node contains a number, called a key. The root node, at the top of the tree, has key=4. Its left and right children have keys 5 and 6, respectively."
"The instruction "" element with key='2'"" is shown above the tree. The key '2' has been inserted into the tree. The node containing the key '2' is colored blue, to indicate that it is the node that has just been inserted."
"We see a tree. The text "" element with key=2"" suggests we are about to insert an element with key ""2"" into this tree. The tree has a light blue node with the value ""2"" as its root"
". The tree has a light blue node with the value ""2"" as its root. The root has two children: a left child, which is a red node with the value ""5"", and a right child, which is a light blue node with the value ""4"""
". The node with value ""5"" has a left child with value ""15"" and a right child with value ""9"". The node with value ""15"" has a left child with value ""16"" and a right child with value ""25"""
". The node with value ""9"" has a left child with value ""14"" and a right child with value ""12"". The node with value ""4"" has a left child with value ""7"" and a right child with value ""6"""
". The node with value ""7"" has a left child with value ""11"" and a right child with value ""8"". The node with value ""6"" has a left child with value ""20""."
"Insert
Insert elementwith key=“2”"
We are given instructions to insert an element with a key of two into a data structure. The data structure is a binary search tree. The tree has a root node with a value of four. The left child of the root node has a value of five
. The left child of the root node has a value of five. The right child of the root node has a value of six. The left child of the node with value five has a value of fifteen. The right child of the node with value five has a value of nine
. The left child of the node with value six has a value of seven. The right child of the node with value six has a value of twenty. The left child of the node with value fifteen has a value of sixteen
. The right child of the node with value fifteen has a value of twenty five. The left child of the node with value nine has a value of fourteen. The right child of the node with value nine has a value of twelve
. The left child of the node with value seven has a value of eleven. The right child of the node with value seven has a value of eight.
The image shows a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5 and the right child has the value 6. The left child of 5 has the value 15 and the right child has the value 9
. The left child of 15 has the value 16 and the right child has the value 25. The left child of 9 has the value 14 and the right child has the value 12. The left child of 6 has the value 7 and the right child has the value 20
". The left child of 7 has the value 11 and the right child has the value 8. The left child of 20 has the value 2. The node with the value 2 is highlighted in blue. The text "" element with key=""2"""" is displayed above the tree."
"The image contains a red-black tree. The tree is composed of nodes connected by lines. Each node contains a number, called a key. The root node, at the top of the tree, has key=4. Its left and right children have keys 5 and 6, respectively."
"The instruction "" element with key='2'"" is shown above the tree. The key '2' has been inserted into the tree. The node containing the key '2' is colored blue, to indicate that it is the node that has just been inserted."
"We see a tree. The text "" element with key=2"" suggests we are about to insert an element with key ""2"" into this tree. The tree has a light blue node with the value ""2"" as its root"
". The tree has a light blue node with the value ""2"" as its root. The root has two children: a left child, which is a red node with the value ""5"", and a right child, which is a light blue node with the value ""4"""
". The node with value ""5"" has a left child with value ""15"" and a right child with value ""9"". The node with value ""15"" has a left child with value ""16"" and a right child with value ""25"""
". The node with value ""9"" has a left child with value ""14"" and a right child with value ""12"". The node with value ""4"" has a left child with value ""7"" and a right child with value ""6"""
". The node with value ""7"" has a left child with value ""11"" and a right child with value ""8"". The node with value ""6"" has a left child with value ""20""."
"Insert
Insert elementwith key=“2”"
We are given instructions to insert an element with a key of two into a data structure. The data structure is a binary search tree. The tree has a root node with a value of four. The left child of the root node has a value of five
. The left child of the root node has a value of five. The right child of the root node has a value of six. The left child of the node with value five has a value of fifteen. The right child of the node with value five has a value of nine
. The left child of the node with value six has a value of seven. The right child of the node with value six has a value of twenty. The left child of the node with value fifteen has a value of sixteen
. The right child of the node with value fifteen has a value of twenty five. The left child of the node with value nine has a value of fourteen. The right child of the node with value nine has a value of twelve
. The left child of the node with value seven has a value of eleven. The right child of the node with value seven has a value of eight.
The image shows a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5 and the right child has the value 6. The left child of 5 has the value 15 and the right child has the value 9
. The left child of 15 has the value 16 and the right child has the value 25. The left child of 9 has the value 14 and the right child has the value 12. The left child of 6 has the value 7 and the right child has the value 20
". The left child of 7 has the value 11 and the right child has the value 8. The left child of 20 has the value 2. The node with the value 2 is highlighted in blue. The text "" element with key=""2"""" is displayed above the tree."
"The image contains a red-black tree. The tree is composed of nodes connected by lines. Each node contains a number, called a key. The root node, at the top of the tree, has key=4. Its left and right children have keys 5 and 6, respectively."
"The instruction "" element with key='2'"" is shown above the tree. The key '2' has been inserted into the tree. The node containing the key '2' is colored blue, to indicate that it is the node that has just been inserted."
"We see a tree. The text "" element with key=2"" suggests we are about to insert an element with key ""2"" into this tree. The tree has a light blue node with the value ""2"" as its root"
". The tree has a light blue node with the value ""2"" as its root. The root has two children: a left child, which is a red node with the value ""5"", and a right child, which is a light blue node with the value ""4"""
". The node with value ""5"" has a left child with value ""15"" and a right child with value ""9"". The node with value ""15"" has a left child with value ""16"" and a right child with value ""25"""
". The node with value ""9"" has a left child with value ""14"" and a right child with value ""12"". The node with value ""4"" has a left child with value ""7"" and a right child with value ""6"""
". The node with value ""7"" has a left child with value ""11"" and a right child with value ""8"". The node with value ""6"" has a left child with value ""20""."
"Exercise 6
• Given the following binary heap, insert 3, 10, 1"
"Given the following binary heap, insert 3, 10, 1: The heap is represented as a tree with nodes containing the numbers 2, 5, 4, 15, 9, 7, 6, 16, 25, 14, 12, 11, 8 and 20. Node 2 is at the root, its children are nodes 5 and 4"
". Node 2 is at the root, its children are nodes 5 and 4. Node 5's children are 15 and 9, node 4's children are 7 and 6. Node 15's children are 16 and 25, node 9's children are 14 and 12, node 7's children are 11 and 8 and node 6's child is 20."
"Extract
Extract elementwith key=“4”"
The image shows a tree data structure. We are trying to extract the element with key equal to 4. The tree has root 8 and the following children: 5 on the left and 6 on the right
". The right subtree, starting at node 6, has a left child 7 and a right child 20. The node with key 4 is not present in the tree, so it's highlighted with a red arrow pointing to an empty space on the right of node 8."
We see a binary search tree. The root node has the value five. Its left child has the value eight and its right child has the value six. The objective is to extract the element with key four.
"Extract
Extract elementwith key=“4”"
The image shows a tree data structure. We are trying to extract the element with key equal to 4. The tree has root 8 and the following children: 5 on the left and 6 on the right
". The right subtree, starting at node 6, has a left child 7 and a right child 20. The node with key 4 is not present in the tree, so it's highlighted with a red arrow pointing to an empty space on the right of node 8."
We see a binary search tree. The root node has the value five. Its left child has the value eight and its right child has the value six. The objective is to extract the element with key four.
"Extract
Extract elementwith key=“4”"
The image shows a tree data structure. We are trying to extract the element with key equal to 4. The tree has root 8 and the following children: 5 on the left and 6 on the right
". The right subtree, starting at node 6, has a left child 7 and a right child 20. The node with key 4 is not present in the tree, so it's highlighted with a red arrow pointing to an empty space on the right of node 8."
We see a binary search tree. The root node has the value five. Its left child has the value eight and its right child has the value six. The objective is to extract the element with key four.
"Exercise 7
• Given the following binary heap, extract 15, 5, 7"
"Given the following binary heap, extract 15, 5, 7. The heap is structured as follows: at the root, we have a node with value 5, its left child has value 8 and its right child has value 6"
. The node with value 8 has a left child with value 15 and a right child with value 9. The node with value 15 has a left child with value 16 and a right child with value 25
. The node with value 9 has a left child with value 14 and a right child with value 12. The node with value 6 has a left child with value 7 and a right child with value 20. The node with value 7 has a right child with value 11.
Interface Btree<E> (with exceptions)
The image shows code for a Java interface called BTree which takes a generic type E. It has two static final integer variables called LEFT and RIGHT that are initialized to 0 and 1 respectively. It also has the following methods:
"- isEmpty: returns a boolean
- getInfo: returns a generic type E and throws a BTreeException
- getLeft: returns a BTree of generic type E and throws a BTreeException
- getRight: returns a BTree of generic type E and throws a BTreeException"
"- insert: takes a BTree of generic type E and an integer and throws a BTreeException
- extract: takes an integer and throws a BTreeException
- toStringPreOrder: returns a String
- toStringInOrder: returns a String
- toStringPostOrder: returns a String"
"- toStringPostOrder: returns a String
- toString: returns a String, this is the preorder traversal of the tree
- size: returns an integer
- height: returns an integer
- equals: takes a BTree of generic type E and returns a boolean"
"- equals: takes a BTree of generic type E and returns a boolean
- find: takes a BTree of generic type E and returns a boolean"
"*Binary node... (non-recursive)*
We see a code snippet showing the implementation of a binary node in Java. The class LBNode has three private attributes: info of generic type E, left of type LBNode, and right of type LBNode."
"The class has three constructors:- LBNode() -  a no-argument constructor that calls the constructor with one parameter E, passing null as argument."
"- LBNode(E info) - a constructor that takes an argument of type E and calls the constructor with three arguments, passing the received argument, null and null."
"- LBNode(E info, LBNode<E> l, LBNode<E> r) - a constructor that takes three arguments: info of type E, l of type LBNode, and r of type LBNode"
". It sets the info attribute to the value of the info argument, the left attribute to the value of the l argument, and the right attribute to the value of the r argument."
"Insert element with key=""2"""
"a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5, and the right child has the value 2. The left child of the node with value 5 has the value 15, and the right child has the value 9"
". The left child of the node with value 15 has the value 16, and the right child has the value 25. The left child of the node with value 9 has the value 14, and the right child has the value 12"
". The left child of the node with value 2 has the value 7, and the right child has the value 6. The left child of the node with value 7 has the value 11, and the right child has the value 8. The left child of the node with value 6 has the value 20"
". The left child of the node with value 6 has the value 20. The nodes with values 2, 6, and 20 are highlighted in blue."
"Extract element with key=""4”"
"We have a tree data structure. The root node has key equals 4. The left child of the root node has key equals 5, and the right child of the root node has key equals 6"
". The left child of node 5 has key equals 15, and the right child of node 5 has key equals 9. The left child of node 6 has key equals 7, and the right child of node 6 has key equals 20"
". The left child of node 15 has key equals 16, and the right child of node 15 has key equals 25. The left child of node 9 has key equals 14, and the right child of node 9 has key equals 12"
". The left child of node 7 has key equals 11, and the right child of node 7 has key equals 8."
"Contents
• Introduction• Types of testing⎻ Unit testing
o White-box testing
o Black-box testing
⎻ Integration testing
⎻ Other types of testing
• Test plan"
"Introduction
What is testing?
• Finding the largest number of errors in a
program
• Watch out! It is not convincing oneself that
the program is correct...
• Testing is searching for errors on purpose
• The aim is to detect errors"
"What is testing?
- Finding the largest number of errors in a program
- Watch out! It is not convincing oneself that the program is correct...
- Testing is searching for errors **on purpose**
- The aim is to detect errors
Debugging"
"- The aim is to detect errors
Debugging
- Identifying and removing ""bugs"" on software
""Bug"" found in a Mark II in Harvard in 1947 and taped to the ""log file"""
"There is a piece of paper with text and handwritten notes on it. The notes describe chronologically the steps taken to identify a bug in a Mark II computer in Harvard in 1947. The bug was found in relay number 70, panel F"
". The bug was found in relay number 70, panel F. A moth was found trapped in the relay."
"The perfect test in impossible
Ideally, we should test the program in all possible situations.
It is impossible from any point of view: human, economic, and mathematical, due to infinite loops.
There is a huge number of combinations."
"There is a huge number of combinations.
We should test all the possible variations in input data.
We cannot reach perfection, but we can do it well enough.
Criteria for good tests
Here are some criteria for good tests:"
"Criteria for good tests
Here are some criteria for good tests:
- Complete: Covering most of the code.
- Automated (as far as possible): minimum manual intervention. Useful for continuous integration."
"- Repeatable or Reusable: Test should be able to run more than once. Useful for continuous integration.
- Independent: Running a test should not affect the execution of another test."
"- Professionals: Testing has the same consideration as coding, documentation, etc."
"Introduction
Debugging
• Identifying and removing “bugs” on software
“Bug” found in a Mark II in Harvard in 1947 and taped to the “log file”"
"What is testing?
- Finding the largest number of errors in a program
- Watch out! It is not convincing oneself that the program is correct...
- Testing is searching for errors **on purpose**
- The aim is to detect errors
Debugging"
"- The aim is to detect errors
Debugging
- Identifying and removing ""bugs"" on software
""Bug"" found in a Mark II in Harvard in 1947 and taped to the ""log file"""
"There is a piece of paper with text and handwritten notes on it. The notes describe chronologically the steps taken to identify a bug in a Mark II computer in Harvard in 1947. The bug was found in relay number 70, panel F"
". The bug was found in relay number 70, panel F. A moth was found trapped in the relay."
"The perfect test in impossible
Ideally, we should test the program in all possible situations.
It is impossible from any point of view: human, economic, and mathematical, due to infinite loops.
There is a huge number of combinations."
"There is a huge number of combinations.
We should test all the possible variations in input data.
We cannot reach perfection, but we can do it well enough.
Criteria for good tests
Here are some criteria for good tests:"
"Criteria for good tests
Here are some criteria for good tests:
- Complete: Covering most of the code.
- Automated (as far as possible): minimum manual intervention. Useful for continuous integration."
"- Repeatable or Reusable: Test should be able to run more than once. Useful for continuous integration.
- Independent: Running a test should not affect the execution of another test."
"- Professionals: Testing has the same consideration as coding, documentation, etc."
"Introduction
The perfect test in impossible
• Ideally, we should test the program in all
possible situations
• Impossible from any point of view:
⎻ Human
⎻ Economic
⎻ Mathematic: infinite loops
• Huge number of combinations"
"⎻ Mathematic: infinite loops
• Huge number of combinations
• We should test all the possible variations in
input data
• We cannot reach perfection but… we can do
it well enough"
"What is testing?
- Finding the largest number of errors in a program
- Watch out! It is not convincing oneself that the program is correct...
- Testing is searching for errors **on purpose**
- The aim is to detect errors
Debugging"
"- The aim is to detect errors
Debugging
- Identifying and removing ""bugs"" on software
""Bug"" found in a Mark II in Harvard in 1947 and taped to the ""log file"""
"There is a piece of paper with text and handwritten notes on it. The notes describe chronologically the steps taken to identify a bug in a Mark II computer in Harvard in 1947. The bug was found in relay number 70, panel F"
". The bug was found in relay number 70, panel F. A moth was found trapped in the relay."
"The perfect test in impossible
Ideally, we should test the program in all possible situations.
It is impossible from any point of view: human, economic, and mathematical, due to infinite loops.
There is a huge number of combinations."
"There is a huge number of combinations.
We should test all the possible variations in input data.
We cannot reach perfection, but we can do it well enough.
Criteria for good tests
Here are some criteria for good tests:"
"Criteria for good tests
Here are some criteria for good tests:
- Complete: Covering most of the code.
- Automated (as far as possible): minimum manual intervention. Useful for continuous integration."
"- Repeatable or Reusable: Test should be able to run more than once. Useful for continuous integration.
- Independent: Running a test should not affect the execution of another test."
"- Professionals: Testing has the same consideration as coding, documentation, etc."
"Introduction
Criteria for good tests
• Complete: Covering most of the code.
• Automated (as far as possible): minimum manual
intervention. Useful for continuous integration.
• Repeatable or Reusable: Test should be able to"
"• Repeatable or Reusable: Test should be able to
run more than once. Useful for continuousintegration.
• Independent: Running a test should not affect the
execution of another test.
• Professionals: Testing has the same"
"• Professionals: Testing has the same
consideration as coding, documentation, etc."
"What is testing?
- Finding the largest number of errors in a program
- Watch out! It is not convincing oneself that the program is correct...
- Testing is searching for errors **on purpose**
- The aim is to detect errors
Debugging"
"- The aim is to detect errors
Debugging
- Identifying and removing ""bugs"" on software
""Bug"" found in a Mark II in Harvard in 1947 and taped to the ""log file"""
"There is a piece of paper with text and handwritten notes on it. The notes describe chronologically the steps taken to identify a bug in a Mark II computer in Harvard in 1947. The bug was found in relay number 70, panel F"
". The bug was found in relay number 70, panel F. A moth was found trapped in the relay."
"The perfect test in impossible
Ideally, we should test the program in all possible situations.
It is impossible from any point of view: human, economic, and mathematical, due to infinite loops.
There is a huge number of combinations."
"There is a huge number of combinations.
We should test all the possible variations in input data.
We cannot reach perfection, but we can do it well enough.
Criteria for good tests
Here are some criteria for good tests:"
"Criteria for good tests
Here are some criteria for good tests:
- Complete: Covering most of the code.
- Automated (as far as possible): minimum manual intervention. Useful for continuous integration."
"- Repeatable or Reusable: Test should be able to run more than once. Useful for continuous integration.
- Independent: Running a test should not affect the execution of another test."
"- Professionals: Testing has the same consideration as coding, documentation, etc."
"Types of testing
• Unit testing
• White-box testing (structural)
⎻ Method coverage
⎻ Line/Instruction coverage
⎻ Branch/Condition/Loop coverage
• Black-box testing (functional)
⎻ Requirement coverage
• Integration testing
• Other types of testing"
"a list of software testing types.
It is divided into four main categories: unit testing, integration testing, other types of testing, and a subcategory of unit testing."
"The first category, unit testing, is further divided into two subcategories: white-box testing, also called structural testing, and black-box testing, also called functional testing."
"White-box testing includes method coverage, line or instruction coverage, and branch, condition, and loop coverage.
Black-box testing includes requirement coverage."
"Unit Testing
• Testing isolated modules (methods, classes…)
• Informal phase first
⎻ Running simple examples⎻ Tools that automatically analyze program syntax (and
even “suggest” potential sources of error).
• Systematic testing phase"
"• Systematic testing phase
⎻ White-box testing: The structure of the code is tested
thoroughly
⎻ Black-box testing: The functionality of the module is
tested without looking at the code
• JUnit 5 (Jupiter) (integrated in Eclipse)"
"• JUnit 5 (Jupiter) (integrated in Eclipse)
⎻ Requires Java 8 (1.8) or above
o “Eclipse” => “Preferences” => “Java” => “Compiler”
o Or “Project” => “Properties” => “Java Compiler”"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing. Example with JUnit5
Example Java code to be tested
Differences in types(parameters, returnvalues, and exceptionhandling"
"The image shows an example of Java code to be tested. The code contains four methods for division: division, division2, division3, and division4. The methods differ in the types of parameters, return values, and exception handling."
"- The `division` method takes two integers as input and returns an integer, which is the result of the division."
"- The `division2` method takes two integers as input and returns an integer, which is the result of the division. If the divisor is zero, it throws an exception with the message ""Cannot divide by 0""."
"- The `division3` method takes two integers as input and returns a double, which is the result of the division. If the divisor is zero, it throws an exception with the message ""Cannot divide by 0""."
"- The `division4` method takes two doubles as input and returns a double, which is the result of the division.
Creation of a JUnit Test Case"
"The image shows a screenshot of a computer screen displaying the process of creating a new JUnit test case in a Java IDE. The user has navigated to the ""New"" menu and is selecting the ""JUnit Test Case"" option"
". The text on the right provides additional information about JUnit test cases, stating that they are files that can run as Java applications without a main method and that they are used to test other Java classes and methods."
"Unit Testing. Example with JUnit5
Creation of a JUnit Test Case
File that can run as JavaApplication without amain method
It is used to test otherJava classes / methods"
"The image shows an example of Java code to be tested. The code contains four methods for division: division, division2, division3, and division4. The methods differ in the types of parameters, return values, and exception handling."
"- The `division` method takes two integers as input and returns an integer, which is the result of the division."
"- The `division2` method takes two integers as input and returns an integer, which is the result of the division. If the divisor is zero, it throws an exception with the message ""Cannot divide by 0""."
"- The `division3` method takes two integers as input and returns a double, which is the result of the division. If the divisor is zero, it throws an exception with the message ""Cannot divide by 0""."
"- The `division4` method takes two doubles as input and returns a double, which is the result of the division.
Creation of a JUnit Test Case"
"The image shows a screenshot of a computer screen displaying the process of creating a new JUnit test case in a Java IDE. The user has navigated to the ""New"" menu and is selecting the ""JUnit Test Case"" option"
". The text on the right provides additional information about JUnit test cases, stating that they are files that can run as Java applications without a main method and that they are used to test other Java classes and methods."
"Unit Testing. Example with JUnit5 (I)
JUnit Test Case
Method to be tested
Result of the test"
The image shows an example of unit testing using JUnit5.
"On the left-hand side, we see the code of a JUnit test case. The test case includes three test methods: `testDivision1_1`, `testDivision1_2`, and `testDivision1_3`"
. Each test method is annotated with `@Test` and calls a `division` method with different input values. The `assertEquals` method is used to assert that the expected result matches the actual result of the `division` method.
"The `division` method is defined in a separate class and is shown on the right-hand side of the image. The method takes two integer arguments, `x` and `y`, and returns the result of dividing `x` by `y`."
"The test results are shown in a separate window on the right-hand side of the image. The results show that the first test method passed, the second test method failed, and the third test method threw an `ArithmeticException`."
"The second test method failed because the expected result (2.5) did not match the actual result (2). The third test method threw an exception because the `division` method was called with `y` equal to 0, which resulted in a division by zero error."
"Unit Testing. Example with JUnit5 (II)
Method to be tested
JUnit Test Case
Result of the test"
The image shows an example of unit testing with JUnit5
". The code snippet on the right side, enclosed in a box with the title ""Method to be tested,"" presents a Java method named `division2` that takes two integers, `x` and `y`, as input and returns the result of their division"
". The method includes a condition to handle division by zero by throwing an exception with the message ""Cannot divide by 0""."
"On the left side, there are two JUnit test cases designed to test the `division2` method. The first test case, `testDivision2_1`, aims to verify the normal division functionality"
". It calls the `division2` method with arguments 4 and 2, expecting the result to be 2. The `assertEquals` assertion is used to compare the expected result with the actual result returned by the method."
"The second test case, `testDivision2_2`, focuses on testing the exception handling mechanism of the `division2` method"
". It utilizes the `assertThrows` assertion to verify that the method throws an exception of type `Exception` when attempting to divide by zero. The test case then asserts that the exception message is ""Cannot divide by 0"" using the `assertEquals` assertion"
.
"Finally, at the bottom of the image, a box labeled ""Result of the test"" displays the outcomes of running the two test cases. Both tests are marked with green checkmarks, indicating that they passed successfully"
". The execution time for each test is also provided, with `testDivision2_1` taking 0.002 seconds and `testDivision2_2` taking 0.003 seconds."
"Unit Testing. Example with JUnit5 (III)
Method to be tested
JUnit Test Case
Result of the test"
"The image shows an example of unit testing with JUnit5. The example shows a method called ""division3"" that takes two integers as input and returns a double. The method throws an exception if the second integer is zero"
. The method throws an exception if the second integer is zero. The example also shows two JUnit test cases. The first test case tests the method with valid input and the second test case tests the method with invalid input
. The first test case passes and the second test case fails. The result of the test is shown in the bottom right corner of the image. The first test case took 0.001 seconds to run and the second test case took 0.003 seconds to run
.003 seconds to run. The second test case failed because the expected result was 2.0 but the actual result was 2.5.
"Unit Testing. Example with JUnit5 (IV)
Method to be tested
JUnit Test Case
Result of the test"
"The image shows an example of unit testing with JUnit5. The method to be tested is ""division4"", which takes two doubles as input and returns their quotient as a double. Two test cases are shown: ""testDivision4_1"" and ""testDivision4_2"""
". The first test case asserts that the result of calling ""division4"" with arguments 4.0 and 2.0 is equal to 2.0. The second test case asserts that the result of calling ""division4"" with arguments 5.0 and 2.0 is equal to 2.5"
.0 and 2.0 is equal to 2.5. The result of the test shows that both test cases passed with a running time of 0.000 seconds.
"Unit Testing
White-box testing
• White-box, glass-box, transparent-box, structural
testing…
• Aim: Testing thoroughly the code structure
• Coverage: measure of the percentage of code that
has been tested or ”covered” with the tests.
⎻ Method coverage"
"has been tested or ”covered” with the tests.
⎻ Method coverage
⎻ Line/Instruction coverage
⎻ Branch/Condition/Loop coverage
• EclEmma (integrated in Eclipse)
⎻ Code coverage"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
White-box testing example
Program
Test class using JUnit 5 (Jupiter)
Result of the test
- Green: Covered
- Yellow: Partially covered
- Red: Not covered"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
White-box testing example
• Method coverage
⎻ Testing that all the methods meet their role
and return the expected result
⎻ Example: Three methods tested plus implicit
constructor"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
White-box testing example
• Line/Instruction coverage
⎻ A line of code can include several instructionso E.g., f = f*i; (multiplication and assignment)
⎻ We do not normally pass through all the lines/instructions,"
"⎻ We do not normally pass through all the lines/instructions,
only through most of them, but choosing wisely.
⎻ Example: Lines covered (green and yellow) vs. lines not
covered (red)"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
White-box testing example
• Branch/condition/loop coverage
⎻ Testing all possible paths in branches
o Testing every condition (when it is true and false)
o Testing every loop (entering and not entering the loop)
•"
"o Testing every loop (entering and not entering the loop)
•
for loop is safer than while and do-while
o Testing all possible program exist and decision points
(including exceptions)
⎻ Example:"
"(including exceptions)
⎻ Example:
o max: the else of the first if, and the second if/else are not tested
o fac: the if, and entering / not entering the loop are tested"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
White-box testing example
Test class using JUnit 5 (Jupiter)**Calculator.fac(-1); fails as it is expected
Result of the test
All covered (100% coverage)"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
White-box testing
• What to do in real life?
⎻ Testing 100% of the methods
⎻ Approaching 100% of line/instruction coverage⎻ Reaching a good branch/condition/loop coverage
⎻ The coverage depends on the type of program:"
"⎻ The coverage depends on the type of program:
o Games: enough with 60-80% code coverage
o Critical software (health, nuclear power plants, military, etc.)
>90%
o The code coverage required grows with the distribution degree
of the program"
"of the program
⎻ White-box testing is usually supported by specific tools
(e.g., EclEmma + JUnit)"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
White-box testing
• Limitations
⎻ White-box testing checks the structure, but
not the functionality of the program"
"not the functionality of the program
⎻ A program can be correctly structured, but notworking according to the functionality that wasexpected (it does correctly what it does, but itdoes not what we wanted)
⎻ We need to test the functionality with black-box"
"⎻ We need to test the functionality with black-box
testing"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Exercise 1A
• Design a class that conducts a white-box testing over thefollowing code, maximizing the code coverage. UseassertTrue and assertFalse of class Assert of JUnit(instead of assertEquals) to test if a condition is true orfalse, respectively"
"public class M {
public static boolean checkPrime(int a){      
if (a<=0){return false;}
else {
int tmp = 0;
for(int i=2; i<=a/2; i++){
tmp = a%i;
if(tmp==0){return false;}
}
return true;
}
}   
}"
"an exercise about white-box testing. The task is to design a class that conducts a white-box testing over the given code, maximizing the code coverage"
". The code snippet represents a function called ""checkPrime"" that takes an integer ""a"" as input and returns a boolean value. The function checks if the input integer is a prime number"
". The function checks if the input integer is a prime number. The instructions specify to use ""assertTrue"" and ""assertFalse"" methods of the ""Assert"" class from JUnit to test if a condition is true or false, respectively, instead of using ""assertEquals""."
"Exercise 1B
• Starting from the class Bicycle which has three attributes,"
"speed, cadence and gear, of type integer and fourmethods speedUp(), brake(), setCadence(intnewCadence), and setGear(int newGear), plusthree “get” methods, implement a test class with JUnitBicycleTest, which reaches a code coverage of 100%"
.• Use @BeforeEach to create the object of the bicycle which
"will be used for testing purposes.
    @BeforeEach
   public void setUp() {
    …
    }"
"Starting from the class ""Bicycle"" which has 3 attributes: speed, cadence and gear of type integer, and 4 methods: ""speedUp"", ""brake"", ""setCadence"" which takes an integer ""newCadence"" as input, and ""setGear"" which takes an integer ""newGear"" as input"
", and ""setGear"" which takes an integer ""newGear"" as input, plus 3 ""get"" methods, implement a test class with JUnit ""BicycleTest"", which reaches a code coverage of 100%"
". Use ""@BeforeEach"" to create the object of the bicycle which will be used for testing purposes."
"The code snippet shows the ""@BeforeEach"" annotation preceding the definition of the ""setup"" method which is public, void and takes no arguments."
"Unit Testing
Black-box testing
• Also called:
⎻ Functional testing
⎻ Behavioral testing
⎻ Input/output
⎻ Data-driven testing
• Aim: testing the functionality of the code
• They try to find cases in which the module
does not fulfil its specification"
"does not fulfil its specification
• Particularly important in modules that will
be the interface with the end-user"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
Black-box testing
• Requirement coverage: number of requirements
that were tested
• The problem: the set of data tends to be very large
• Solution: “Equivalence classes”
⎻ Disjoint sets of possible data"
"⎻ Disjoint sets of possible data
⎻ Not to be confused with Java “Classes”!!
• Tricks to identify them:
⎻ Below, in, and above the range
⎻ Below, in, and above a specific value
⎻ In and out the set
⎻ True or false
⎻ The same criteria for output data"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
Black-box testing
• Example: Integer to identify the day of the month
⎻ Possible values: [1..31]
⎻ Three equivalence classes:
o Numbers below 1
o Numbers between 1 and 31
o Numbers above 31
• Pay attention to singular values"
"o Numbers above 31
• Pay attention to singular values
• We choose one value of each class (but not in the
boundaries)
• And then we test boundary values (1 and 31)"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
"Unit Testing
Black-box testing
• Limitations:
⎻ Black-box testing tests the functionality (the
program does what we want) but...
⎻ They do not check if the program does otherthings as well… (e.g., a virus, malware…)
⎻ Black-box testing is not enough"
"- Testing isolated modules, such as methods and classes.
- It can be done in two phases: informal and systematic.
- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors."
"- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code."
"- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.
- To configure JUnit 5 in Eclipse, go to ""Preferences"" -> ""Java"" -> ""Compiler"" or ""Project"" -> ""Properties"" -> ""Java Compiler"".
White-box testing"
"White-box testing
 about  and more specifically about White-box testing.
White-box testing is also called glass-box testing, transparent-box testing, or structural testing.
The aim of White-box testing is to thoroughly test the code structure."
"Coverage is a measure of the percentage of code that has been tested or ""covered"" with the tests.
There are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage."
"Finally,  EclEmma, a tool integrated in Eclipse, that provides Code coverage.
White-box testing example
We see an example of unit testing using a white-box testing approach."
"On the left side, we have a code snippet showing a class named ""Calculator"" written in Java. This class contains three static methods:
- ""add"" which takes two integers as input and returns their sum."
"- ""max"" which takes two integers and returns the larger of the two.
- ""fac"" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid."
"On the right side, we have another code snippet, this time showing a ""CalculatorTest"" class, also written in Java. This class is designed to test the functionality of the ""Calculator"" class using the JUnit 5 framework."
"The ""CalculatorTest"" class includes three test methods:
- ""testAdd"" which tests the ""add"" method of the Calculator class.
- ""testMax"" which tests the ""max"" method of the Calculator class.
- ""testFac"" which tests the ""fac"" method of the Calculator class."
Each test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.
"Below the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully."
"Finally, at the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter)"" confirming the testing framework used."
"The image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:
- Green: indicates lines of code that were fully covered and executed during the tests."
"- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.
- Red: indicates lines of code that were not covered at all by the tests."
"In the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the ""Calculator"" class.
White-box testing example
Method coverage"
"White-box testing example
Method coverage
- Testing that all the methods meet their role and return the expected result
- Example: Three methods tested plus implicit constructor"
"The table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor.
White-box testing example"
"White-box testing example
Line/Instruction coverage"
"A line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely"
". Example: Lines covered, green and yellow, versus lines not covered, red."
"There are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83"
". The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%."
"The second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%."
"White-box testing example
 about branch, condition, and loop coverage in white-box testing. It lists the following points:
- Testing all possible paths in branches
- Testing every condition (when it is true and false)"
"- Testing every condition (when it is true and false)
- Testing every loop (entering and not entering the loop)
  - for loop is safer than while and do-while
- Testing all possible program exit and decision points (including exceptions)"
"An example is given with two functions: max and fac.
- For max: the else of the first if, and the second if/else are not tested
- For fac: the if, and entering / not entering the loop are tested"
"A table shows the coverage, covered branches, missed branches, and total branches for each function.
- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches."
"- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.
- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches."
"- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.
- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.
White-box testing example"
"White-box testing example
The image shows an example of unit testing using JUnit 5 in Java."
"On the left side, there is a code snippet of a test class named ""CalculatorTest2"". This class contains three test methods: ""testAdd"", ""testMax"", and ""testFac"". Each test method is annotated with ""@Test"" and uses assertions from the ""org.junit"
".junit.Assert"" class to verify the expected behavior of the corresponding methods in the ""Calculator"" class."
"The ""testAdd"" method tests the ""add"" method of the ""Calculator"" class by asserting that the sum of 3 and 2 is equal to 5."
"The ""testMax"" method tests the ""max"" method of the ""Calculator"" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values."
"The ""testFac"" method tests the ""fac"" method of the ""Calculator"" class. It first asserts that calling ""fac"" with an input value of 3 returns the expected factorial value of 6"
". Then, it uses the ""assertThrows"" method to assert that calling ""fac"" with an invalid input value of -1 throws a ""NumberFormatException"". It further verifies that the exception message is ""invalid number""."
"On the right side, there is a code snippet of the ""Calculator"" class being tested. The class contains three static methods: ""add"", ""max"", and ""fac"".
The ""add"" method takes two integer arguments and returns their sum."
"The ""max"" method takes two integer arguments and returns the maximum value among them."
"The ""fac"" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a ""NumberFormatException"" with the message ""invalid number""."
"At the bottom of the image, there is a caption that reads: ""Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected"""
".fac(-1); fails as it is expected"". This indicates that the test case for the ""fac"" method with an input of -1 is designed to fail, as it is expected to throw an exception."
"Finally, there is a statement: ""Result of the test All covered (100% coverage)"". This indicates that all the code in the ""Calculator"" class has been tested, resulting in 100% code coverage.
White-box testing
What to do in real life?"
"White-box testing
What to do in real life?
- Testing 100% of the methods
- Approaching 100% of line/instruction coverage
- Reaching a good branch/condition/loop coverage
- The coverage depends on the type of program:"
"- The coverage depends on the type of program:
  - Games: enough with 60-80% code coverage
  - Critical software (health, nuclear power plants, military, etc.) >90%
  - The code coverage required grows with the distribution degree of the program"
"- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)
White-box testing
Limitations
- White-box testing checks the **structure**, but not the functionality of the program"
"- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)
- We need to test the functionality with black-box testing
Black-box testing"
"Black-box testing
 about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing."
The aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user.
Black-box testing
"Requirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: ""Equivalence classes"". Equivalence classes are disjoint sets of possible data"
". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java ""Classes"""
". Note: they are not to be confused with Java ""Classes"". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data."
"Black-box testing
 the concept of equivalence classes and boundary values in the context of black-box testing.
We have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31."
"From this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31."
"the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values.
Finally, it emphasizes the need to test boundary values, which are 1 and 31 in this case.
Black-box testing"
"Black-box testing
 about the limitations of black-box testing."
"Black-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware"
". Therefore, black-box testing is not enough to ensure the quality of a program."
Exercise 2
"• We program a method that calculates the quadrant to whichan object of class Point, received as argument, belongs.The object of class Point has two attributes of typedouble, which indicate the x and y coordinates"
". Think ofthe pairs of coordinates (x,y) that the objects of class Pointshould have in the black-box testing. How many pairs ofcoordinates must be used at least to test that the functionalityis correct?"
"We are programming a method that, given a point as an argument, calculates the quadrant to which the point belongs. The point is defined by its x and y coordinates, which are double-precision floating-point numbers"
. The question is: how many pairs of coordinates must be used at least to test that the functionality is correct?
"The image shows a coordinate system with four quadrants. The first quadrant is the upper right quadrant, the second quadrant is the upper left quadrant, the third quadrant is the lower left quadrant, and the fourth quadrant is the lower right quadrant."
"To test the functionality of the method, we need to provide at least one point in each quadrant. This means that we need at least four pairs of coordinates."
"Integration testing
• Several modules (methods, classes) are
involved
• They can be structural or functional
⎻ Structural: like white-box tests, but analyzing calls
between modules
⎻ Functional: like black-box tests, but checking joint
functionalities"
"functionalities
⎻ Equivalence classes and boundary values are
used in the analysis
• Final tests consider the whole system, fully
covering the whole specification with the userrequirements"
"Several modules, like methods or classes, are involved in integration testing.  can be structural or functional. Structural testing is like white-box testing, but it analyzes calls between modules"
". Functional testing is like black-box testing, but it checks joint functionalities. Equivalence classes and boundary values are used in the analysis. Final tests consider the whole system, fully covering the whole specification with the user requirements."
"Some design approaches
There are three approaches to integration testing: top-down, bottom-up, and incremental coding."
Top-down testing starts by testing the most general modules first. The advantage of this approach is that it allows you to think of the whole functionality of the system from the beginning
". The disadvantage is that specific modules may not be ready yet, which can delay testing."
Bottom-up testing starts by testing the base modules first. The advantage of this approach is that there is no need for building artificial modules. The disadvantage is that it can be more focused on the development than in the client's expectations.
"Incremental coding is a technique where only the parts of the program needed for each functionality are coded. Once those parts are tested, more functionalities are added"
". Once those parts are tested, more functionalities are added. The advantage of this approach is that it allows for a lot of interaction with the user. The disadvantage is that complete modules are not ready until the end of the process."
"Integration Testing
Some design approaches
• Top-down: the most general modules are tested first
⎻ Advantage: Think of the whole functionality⎻ Disadvantage: Specific modules are not ready yet• Bottom-up: base modules are tested first"
"⎻ Advantage: No need for building artificial modules
⎻ Disadvantage: More focused on the development than in the client’s
expectations
• Incremental coding: only the parts of the program"
"• Incremental coding: only the parts of the program
needed for each functionality are coded; once tested,more functionalities are added
⎻ Advantage: If there is much interaction with the user"
"⎻ Advantage: If there is much interaction with the user
⎻ Disadvantage: Complete modules are not ready until the end of the process"
"Several modules, like methods or classes, are involved in integration testing.  can be structural or functional. Structural testing is like white-box testing, but it analyzes calls between modules"
". Functional testing is like black-box testing, but it checks joint functionalities. Equivalence classes and boundary values are used in the analysis. Final tests consider the whole system, fully covering the whole specification with the user requirements."
"Some design approaches
There are three approaches to integration testing: top-down, bottom-up, and incremental coding."
Top-down testing starts by testing the most general modules first. The advantage of this approach is that it allows you to think of the whole functionality of the system from the beginning
". The disadvantage is that specific modules may not be ready yet, which can delay testing."
Bottom-up testing starts by testing the base modules first. The advantage of this approach is that there is no need for building artificial modules. The disadvantage is that it can be more focused on the development than in the client's expectations.
"Incremental coding is a technique where only the parts of the program needed for each functionality are coded. Once those parts are tested, more functionalities are added"
". Once those parts are tested, more functionalities are added. The advantage of this approach is that it allows for a lot of interaction with the user. The disadvantage is that complete modules are not ready until the end of the process."
"Other types of testing
System testing
• Functional tests of the whole system,
including the software developed and therest of the components interacting with it.
• Equivalent to black-box testing as noknowledge on the code is required."
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"Other types of testing
Acceptance testing
• Functional tests done by the client before the
application goes into the production phase
• There are errors that only the client can detect…
And “the client is always right”
• Some techniques:"
"And “the client is always right”
• Some techniques:
⎻ Alpha tests: The client comes to the developmentenvironment, and does the test on a controlledenvironment
⎻ Beta tests: They are done in the client’s environment."
"⎻ Beta tests: They are done in the client’s environment.
The client is left alone with the product in anuncontrolled environment
⎻ Both tests are very common when the program is
delivered to many clients"
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"Other types of testing
• Walkthroughs
⎻ Developers and critics are met in the same room:
critics read the code line by line and ask forexplanations to the developers"
"⎻ Effective for errors of local nature⎻ Terrible to identify errors in interactions between
remote parts
• Random testing
⎻ Because the probability of discovering errors withrandom tests is like that of using coverage criteria"
"⎻ Reasonable to start testing the program
⎻ But insufficient in critical programs"
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"Other types of testing
• Robustness testing
⎻ How does the program react with incorrect input data?⎻ If the data are commands, we should check that:
o All the commands are correct
o Commands with syntax errors
o Commands correct but out of place"
"o Commands correct but out of place
o The command null
o Commands with more data than expectedo Forcing an interruption after a command
o Commands with inappropriate opening and closing
symbols
o Commands with incoherent opening and closing
symbols ( ]"
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"Other types of testing
• Stress testing
⎻ Testing  beyond normal capacity for internal reasons
⎻ Examples:
o Can the program work with the disk at the 90%?"
"⎻ Examples:
o Can the program work with the disk at the 90%?
o Does the program work with thousands of concurrent users?o Can the program work with files larger than 1GB?"
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"Other types of testing
• Performance testing
⎻ Performance of the system (responsiveness and stability)
under a particular workload, disk or memory load
• Conformance testing"
"• Conformance testing
⎻ Rules and standards that the program must fulfil⎻ Black-box tests to check that the program follow the
standards
• Interoperability testing
⎻ Look for communication problems between out product
and others it must work with"
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"Other types of testing
• Regression testing
⎻ A new version requires a test round (all the tests!)
⎻ In order to reuse tests, they must be very well
documents
• Mutation testing
⎻ Adding errors to the software on purposes"
"• Mutation testing
⎻ Adding errors to the software on purposes
(creating a “mutant”) to verify the quality of thetests"
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"Other types of testing
• Smoke testing (or build verification
testing)
⎻ Testing the system constantly until it “breaks”, trying
to catch fire (or “smoke”)."
"to catch fire (or “smoke”).
⎻ “Simple” tests (non-exhaustive), but at all levels, tosee the stability of the program and move forwardwith the development"
"System testing
- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.
- Equivalent to black-box testing as no knowledge on the code is required.
Acceptance testing"
Functional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right
". Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment"
. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients.
- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature
". This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts."
"- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs.
- Robustness testing"
How does the program react with incorrect input data
"? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command"
", forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols"
.
"other types of testing.
Stress testing: testing beyond normal capacity for internal reasons. Examples:- Can the program work with the disk at the 90%?
- Does the program work with thousands of concurrent users?"
"- Does the program work with thousands of concurrent users?
- Can the program work with files larger than 1GB?"
"- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load."
"- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.
- Interoperability testing: looks for communication problems between the product and other systems it must work with.
- Regression testing"
"- Regression testing
  - A new version requires a test round (all the tests!)
  - In order to reuse tests, they must be very well documents
- Mutation testing"
"- Mutation testing
  - Adding errors to the software on purposes (creating a ""mutant"") to verify the quality of the tests
- Smoke testing (or build verification testing)
Testing the system constantly until it ""breaks"", trying to catch fire (or ""smoke”)."
"- ""Simple"" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development"
"And more…
• Grey-box testing
• Database testing
• Security testing
• Documentation testing
• Usability testing
• Installation testing
• Fault tolerance testing
• Recovery testing"
"Test Plan
• Set of tests to be done
• Each test must specify:
⎻ The properties that are being tested
⎻ How to measure the result
⎻ What is the test about
⎻ What is the expected result
• “Soft” tests are useless"
"- A test plan is a set of tests to be done.
- Each test must specify the properties that are being tested, how to measure the result, what the test is about, and what the expected result is.
- ""Soft"" tests are useless."
"- ""Soft"" tests are useless.
- A case test includes the purpose of the test, the steps to run the test and the expected result
- They need to be perfectly documented
- This is laborious, tedious, boring and unpleasant"
"The order of tests is as follows: First, we perform black-box tests with boundary values. Then, we identify equivalence classes for input data and add more black-box tests. Next, we add more tests based on presumption of error"
". Next, we add more tests based on presumption of error. Finally, we measure the code coverage of white-box testing that was achieved with the previous phases and add more white-box tests."
"Test Plan
• A case test includes:
⎻  The purpose of the test
⎻  The steps to run the test
⎻  The expected result
• They need to be perfectly documented
• This is laborious, tedious, boring and
unpleasant"
"- A test plan is a set of tests to be done.
- Each test must specify the properties that are being tested, how to measure the result, what the test is about, and what the expected result is.
- ""Soft"" tests are useless."
"- ""Soft"" tests are useless.
- A case test includes the purpose of the test, the steps to run the test and the expected result
- They need to be perfectly documented
- This is laborious, tedious, boring and unpleasant"
"The order of tests is as follows: First, we perform black-box tests with boundary values. Then, we identify equivalence classes for input data and add more black-box tests. Next, we add more tests based on presumption of error"
". Next, we add more tests based on presumption of error. Finally, we measure the code coverage of white-box testing that was achieved with the previous phases and add more white-box tests."
"Test Plan
• Order of tests:
⎻ Black-box tests with boundary values
⎻ Identifying equivalence classes for input data
and adding more black-box tests
⎻ Adding more tests based on presumption of error
“I suspected it!”"
"“I suspected it!”
⎻ Measuring the code coverage of white-boxtesting that was achieved with the previousphases and adding more white-box tests"
"- A test plan is a set of tests to be done.
- Each test must specify the properties that are being tested, how to measure the result, what the test is about, and what the expected result is.
- ""Soft"" tests are useless."
"- ""Soft"" tests are useless.
- A case test includes the purpose of the test, the steps to run the test and the expected result
- They need to be perfectly documented
- This is laborious, tedious, boring and unpleasant"
"The order of tests is as follows: First, we perform black-box tests with boundary values. Then, we identify equivalence classes for input data and add more black-box tests. Next, we add more tests based on presumption of error"
". Next, we add more tests based on presumption of error. Finally, we measure the code coverage of white-box testing that was achieved with the previous phases and add more white-box tests."
"Psychological and organizationalaspects of testing…
• Testing is exercising the program to find errors, not to
demonstrate that it works
• A test is successful when it finds a bug
• Tests should be designed and run by a different team that of"
"• Tests should be designed and run by a different team that of
which wrote the code
• We shall not wait until the whole code is written to start the tests
• If tests reveal several errors in a module, we must insist on it"
"• If tests reveal many error in a module, we should discard it, and
redesign and program it from scratch
• Test can find errors, but can never prove that there are not
• Test can also contain errors"
"Conclusions
• Testing is finding errors/bugs in a program
• Testing entails an important part of software
development costs
• There are tools for testing, but in the end, we
need people"
"• There are tools for testing, but in the end, we
need people
“Testing shows the presence, not the absence of bugs”, Edsger W. Dijkstra"
"- Testing is finding errors or bugs in a program
- Testing entails an important part of software development costs
- There are tools for testing, but in the end, we need people"
"- There are tools for testing, but in the end, we need people
There is a quote from Edsger W. Dijkstra that says: ""Testing shows the presence, not the absence of bugs""."
"Practical case
• Develop a test plan for the following
method:
public boolean search (char what, char where[])
• The method returns true if what is in where,
and false otherwise"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
• Identify equivalence classes:
⎻ what: poorly specified
⎻ where: no information on the dimensions of
the array or in the ordering criteria
⎻ What the method returns is clear
• First of all, we need to clarify these"
"• First of all, we need to clarify these
points in the specification of the problem"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
• New version of the specification:
public boolean search (char what, char where[])"
"“This Java method receives a character(char) what and an array of char, where. Any8-bit character that can be represented in aJava program is valid. The array can havebetween 0 and 10,000 characters and mustbe sorted alphabetically in ascending order"
".Any string of characters is admissible. Themethod returns true if what is in where, andfalse otherwise.”"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
• Now we can identify the equivalence classes:
⎻ what
o Any character
⎻ where
o An empty array
o An array between 1 and 10.000 elements, sorted
o An array between 1 and 10.000 elements, unsorted
⎻ Result
o true
o false"
"⎻ Result
o true
o false
• We might consider singular combinations ofinput data (e.g., that the character to look for isthe first or the last in the array)"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
Black-box testing
• Black-box testing: boundary values
. Look for the character ‘k’ in the array {} à must return false
. Look for the character ‘k’ in the array {‘k’} à must return true"
". Look for the character ‘k’ in the array {‘c’} à must return false
. Look for the character ‘k’ in the array {‘k’,’l’} à must return true
. Look for the character ‘k’ in the array {‘j’,’k’} à must return true"
". Look for the character ‘k’ in the array of 10,000  ‘a’ à must
return false
(we do not consider tests related to the order of the array so far)"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
Black-box testing
• Black-box testing: Regular values
. Look for the character ‘k’ in the array {‘a’,’b’,’c’} à must return false
. Look for the character ‘k’ in the array {‘j’,’k’,’l’} à must return true"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
White-box testing
public class Search{  public static boolean search ( char what, char where[] ) {        int a, z, m;
    a = 0;
    z = where.length – 1;
    while ( a <= z ) {
      m = ( a + z ) / 2;
      if (where[m] == what )"
"m = ( a + z ) / 2;
      if (where[m] == what )
        return true;
      else {
        if (where[m] < what )
          a = m + 1;
        else
          z = m – 1;
      }
    }
    return false;
  }
}"
"z = m – 1;
      }
    }
    return false;
  }
}
For white-boxtesting we needto look at the code"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
White-box testing
• If we run the aforementioned tests, and we mark thelines and branches that we traverse, we will see thatonly branch “else z = m – 1;” has not beentested
• We need an additional case for white-box testing:"
"• We need an additional case for white-box testing:
. Look for the character ‘k’ in the array {‘l’} à must return false
• Code coverage 100% of lines/instructions and
branches"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
• Formalization of test set (9 tests)
q if (search(‘k’, {})) System.out.println(“fails 1.1”);
q if (!search(‘k’, {‘k’})) System.out.println(“fails 1.2”);
q if (search(‘k’, {‘c’})) System.out.println(“fails 1.3”);"
"q if (search(‘k’, {‘c’})) System.out.println(“fails 1.3”);
q if (!search(‘k’, {‘k’,‘l’})) System.out.println(“fails 1.4”);
q if (!search(‘k’, {‘j’,‘k’})) System.out.println(“fails 1.5”);"
"q if (!search(‘k’, {‘j’,‘k’})) System.out.println(“fails 1.5”);
q if (search(‘k’, {‘a’,‘a’,‘a’,‘a’})) System.out.println(“fails 1.6”);
q if (search(‘k’, {‘a’,‘b’,‘c’})) System.out.println(“fails 2.1”);"
"q if (!search(‘k’, {‘j’,‘k’,‘l’})) System.out.println(“fails 2.2”);
q if (search(‘k’, {‘l’})) System.out.println(“fails 3.1”);"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
JUnit Test Cases"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
JUnit Test Cases
All test pass
0% coverage"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"Practical case
Robustness testing
• We could also have robustness tests:
⎻ What if we go over the 10,000 limit in the array?
⎻ What if the array was disordered?"
"We have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise."
"We need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear"
". What the method returns is clear. First of all, we need to clarify these points in the specification of the problem."
"We are looking at a new version of a specification for a Java method called ""search"". The method takes two arguments: a character called ""what"" and an array of characters called ""where"""
". The specification states that any 8-bit character that can be represented in a Java program is valid for the ""what"" argument. The ""where"" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order"
". Any string of characters is admissible for the ""where"" argument. The method returns true if the ""what"" character is present in the ""where"" array, and false otherwise."
"We can identify the following equivalence classes:- What: any character
- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted
- Result: true or false"
"- Result: true or false
We might consider singular combinations of input data, for example that the character to look for is the first or the last in the array.
Black-box testing
Black-box testing: Regular values"
"We have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false.The second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true.
White-box testing"
"White-box testing
We need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches."
"If we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch ""else z = m - 1;"" has not been tested."
"To address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false."
"And more...
- Grey-box testing
- Database testing
- Security testing
- Documentation testing
- Usability testing
- Installation testing
- Fault tolerance testing
- Recovery testing"
"Psychological and organizational aspects of testing...
- Testing is meant to find errors in a program, not to demonstrate that it works.
- A test is considered successful when it finds a bug."
"- A test is considered successful when it finds a bug.
- Tests should be designed and run by a team different from the one that wrote the code.
- Testing should not wait until all the code is written."
"- Testing should not wait until all the code is written.
- If several errors are found in a module, it's crucial to insist on fixing them.
- If many errors are found in a module, it's best to discard it and start over with the design and programming."
"- While tests can find errors, they can never definitively prove that there are no errors.
- It's important to remember that tests themselves can also contain errors."
"Practical case Black-box testing
The image shows a slide titled ""Practical case Black-box testing"".  on black-box testing with boundary values. It lists six test cases for finding the character 'k' in different arrays."
"- The first test case suggests looking for 'k' in an empty array, which should return false.
- The second test case suggests looking for 'k' in an array containing only 'k', which should return true."
"- The third test case suggests looking for 'k' in an array containing only 'c', which should return false.
- The fourth test case suggests looking for 'k' in an array containing 'k' and 'l', which should return true."
"- The fifth test case suggests looking for 'k' in an array containing 'j' and 'k', which should return true.
- The sixth test case suggests looking for 'k' in an array of 10,000 'a's, which should return false."
by stating that the order of the array is not considered in these test cases.
**Practical case White-box testing**
"The image shows a code snippet of a search function in Java. The code is used to illustrate the concept of white-box testing, which requires looking at the code to design test cases. The code implements a binary search algorithm"
". The code implements a binary search algorithm.The function takes two arguments: a character to search for (what) and a character array to search in (where). The function returns true if the character is found in the array, and false otherwise."
"The code starts by initializing three integer variables: a, z, and m. The variable a is initialized to 0, z is initialized to the length of the array minus 1, and m is initialized to the middle index of the array."
"The code then enters a while loop that continues as long as the value of a is less than or equal to the value of z. Inside the loop, the code calculates the middle index of the array and stores it in the variable m"
". The code then checks if the character at the middle index of the array is equal to the character being searched for. If it is, the function returns true."
"If the character at the middle index of the array is not equal to the character being searched for, the code checks if the character at the middle index is less than the character being searched for"
". If it is, the value of a is set to the middle index plus 1. Otherwise, the value of z is set to the middle index minus 1."
"The loop continues until the value of a is greater than the value of z. At this point, the function returns false."
The comment on the right side of the image emphasizes that white-box testing requires understanding the internal workings of the code to design effective test cases.
**Formalization of test set (9 tests)**
"We have a list of nine tests for the function ""search"". Each test consists of a call to the function with different inputs and a message that will be printed to the standard output depending on the result of the function."
The first test checks if the function returns false when the second argument is an empty set. The second test checks if the function returns true when the second argument contains the element we are looking for
. The third test checks if the function returns false when the second argument does not contain the element we are looking for
. The fourth test checks if the function returns true when the second argument contains the element we are looking for and another element
. The fifth test checks if the function returns true when the second argument contains the element we are looking for and two other elements
. The sixth test checks if the function returns true when the second argument contains the element we are looking for repeated four times
. The seventh test checks if the function returns false when the second argument contains three different elements but not the one we are looking for
. The eighth test checks if the function returns true when the second argument contains the element we are looking for and two other elements
. The ninth test checks if the function returns true when the second argument contains only the element we are looking for.
"**Practical case JUnit Test Cases**
We see a code snippet showing a JUnit test class named ""SearchTest"".
The class starts by declaring a variable ""s"" of type ""Search"" and initializing it with a new ""Search"" object."
"The code then defines nine test methods: ""test1"" through ""test9"". Each test method is annotated with ""@Test"" and calls the ""search"" method of the ""Search"" class with different input parameters"
". The ""search"" method seems to take a character and an array of characters as input."
"The test methods use assertions to verify the expected outcome of the ""search"" method. For example, ""test1"" asserts that the ""search"" method should return false when searching for the character 'k' in an empty array"
". Similarly, ""test2"" asserts that the ""search"" method should return true when searching for the character 'k' in an array containing only the character 'k'."
"The ""test6"" method creates a large array of characters filled with the character 'a' and asserts that the ""search"" method should return false when searching for the character 'k' in this array."
"The remaining test methods (""test7"" to ""test9"") continue to test the ""search"" method with different input parameters and assertions to ensure its correctness."
Practical case JUnit Test Cases
The image shows the code and the result of running some JUnit test cases for that code. The code is a simple search algorithm that takes two arguments: a character to search for and an array of characters to search in
". The algorithm returns true if the character is found in the array, and false otherwise."
The test results show that all nine test cases passed and that the code coverage is 100%. This means that all lines of code in the search algorithm were executed by at least one test case.
"**Practical case Robustness testing**
We could also have robustness tests:
- What if we go over the 10,000 limit in the array?
- What if the array was disordered?"

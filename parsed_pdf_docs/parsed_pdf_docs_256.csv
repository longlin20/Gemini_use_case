content_pages
"2
Overview
. Objects and Classes
. Object encapsulation
. Message passing
. Overloading
. Constructors
. Modifiers and access"
"3
. Objects and Classes"
"4
Objects
´ Computational representations of(simple/complex)
(real/imagined) things:
´ Car
´ Clock
´ Airplane
´ Bird
´ …
´ Some things are simply characteristics of the objects
´ Car => color, speed, number of wheels"
"´ Objects have concrete values for their characteristics
´ Car => color (red), speed (90), number of wheels (4)"
"5
Objects and classes
´ Objects are sets of related data (state) and functionality (behavior)
´ Classes are blocks of code which include
´ Attributes (variables used to stored the state of objects of the same type)"
´ Methods (functions used to carry out the behavior of objects of the same type)
"6
Objects and classes
´ Creating a new class means creating a new data type:
´ Primitive data type (not classes): int, boolean, char, double…
´ Non-primitive data types (classes): String, Integer, Double, Boolean, Car…"
"´ Creating a new object from a class is called instantiation
´ Objects are instances of classes
´ Classes are the pattern to create objects
´ Where can I find objects and classes?"
"´ Classes are stored in files ”.java” (with the same name of the class)
´ Objects are stored in the memory of our program and only exist in runtime"
"7
Objects: functional and data abstractions
A. Functional abstraction:
B. Data abstraction:
´ Things the object does (behavior)
´ Properties of the object (state)
Ø Move forward
Ø Move backwards
Ø Turn left
Ø Turn right
Ø Speed up
Ø Brake"
"Ø Refuel
Ø …
Ø Color
Ø Brand
Ø Maximum speed
Ø Number of wheels
Ø Number of doors
Ø Fuel
Ø …"
"8
Example
Class
Objects
 attributes
State
 methods
Constructor
Behavior
• new operator to create instances from a class
• this reference the the current object
• public/private access modifiers"
"9
Exercise 1
•"
"Implement the class Bicycle, which has three attributes,
speed, cadence and gear, of type integer and four methods
speedUp(), brake(), setCadence(int newCadence), and
setGear(int newGear), where the first method doubles the"
"current speed, the second method halves the current speed,
and the third and fourth methods set the cadence and gear
according to the arguments received. The class must have a
constructor which initializes all the attributes."
"• Create two objects of
this class: myBicycle and
yourBicycle."
"10
. Object encapsulation
. Objects bundle data and methods together
A. Methods are used to operate on that data
. Direct access to some parts of the object are restricted
A.
B."
"Private attributes and methods cannot be accessed directly (information hiding)
Public methods (public interface) allow accessing private data and methods
´ We don't need to know the internal implementation of the private part"
´ The private part can change as long as the public interface remains
"11
. Object encapsulation
´ Methods are typically public
´ Methods for internal use only can be private
´ Attributes are typically private
´ It is dangerous to have public attributes"
"12
. Message passing
´ An objects sends a message to another object
´ By calling a method (method call/invocation) of the public interface of the
receiving object
´ The receiving object will:
´ Change its state (modifying its directly attributes)"
"´ Call public/private methods of the same object
´ Send a message to another object"
"13
Example
Class Car
Class Engine
Class Wheel"
"14
. Overloading
´ Two methods with the same name can be defined in the same class
if they have different parameters
´ It is widely used for constructors
´ The method actually executed depends on the parameters passed
when it is called"
"15
Example
Class
Objects
Overload
Although they have equal
they are different
names,
methods,
they
receive different parameters
because"
"16
Exercise 2
•
In the class Bicycle,
the overloaded
methods setCadence(), and setGear(), which do not
receive arguments and change the values of cadence
and gear to one value by default: 1.
implement"
"17
. Constructors
´ When an object is created, its members are initialized using a
constructor method
´ Constructors:
´Have the same name as the class
´They have no return type (not even void)
´ At least one constructor should be defined per class"
"18
Example
Class
Constructor"
"19
. Constructors
´ Several constructors can exist (overloading)
´ They are distinguished by their parameters
´ If no explicit constructor is defined, then there is a default
constructor without parameters"
"´ It initializes the attributes to their default values
´ If a constructor is defined, the default constructor no longer exits"
"20
Example
Overloaded
Constructors"
"21
Exercise 3
•
In the class Bicycle,
implement an additional
constructor, which does not receive arguments, and
that initializes the speed to 0, and the cadence and gear
to 1."
"22
. Modifiers and Access: static
´ Static members exist only once per class
´ Independently of the number of instances of the class that have been created
´ Even if no instances have been created yet."
"´ The value of static attributes is shared by all objects
´ Changing it for one object affects all the others
´ Static methods do not depend on attributes
´ Although might depend on input parameters"
"´ Static elements can be accessed using the class name
´ A static method cannot access non-static members directly (an object must be
created first)"
"23
. Modifiers and Access: static
Static attributes
…
static attribute
Other examples"
"24
. Modifiers and Access: static
Static method: has access to static attributes.
We do not need to create instances
Other examples
http://docs.oracle.com/javase/9/docs/api/java/lang/Math.html"
"25
. Modifiers and Access: static
´ Static members are invoked with:
ClassName.staticMethod();
ClassName.staticAttribute;
´ Non static members require an instance (object) in order to be accessed.
ClassName objectName = new ClassName();"
"´ Non static members are invoked with:
objectName.normalMethod();
objectName.normalAttribute;
´ When a static member is invoked within the same class, the class name
can be deleted.
staticMethod();
staticAttribute;
instead of:"
"ClassName.staticMethod();
ClassName.staticAttribute;"
"26
. Modifiers and Access: public/private
´ public
´ Attributes/Methods/Classes => Visible from any other class
´ Each public classes needs to be a separate file with the same name of the class
´ private"
"´ Attributes/Methods/Classes => Visible only within the class
´ Private classes are rarely as inner classes inside a file with another public class"
"27
. Modifiers and Access: methods get/set
´ Public methods to controlaccess to private attributes
´ Can include control mechanisms to
avoid undesired modifications
get/set methods"
"28
Exercise 4
•
In the class Bicycle, implement the necessary get()
and set() methods which allow accessing and
modifying all the attributes."
"Overview
 an overview of key concepts, listing six topics: Objects and Classes, Object encapsulation, Message passing, Overloading, Constructors, and Modifiers and access."
1. Objects and Classes
"We have two boxes, the first one is titled ""class"" and contains the drawing of a car with a dotted line and the label ""Car""."
"The second box is titled ""objects"" and contains three drawings of cars: the first one is green and labeled ""Mercedes"", the second one is blue and labeled ""Bmw"", the third one is orange and labeled ""Audi""."
Objects
"Computational representations of simple or complex, real or imagined things. Some examples are: car, clock, airplane, bird, and so on. Some things are simply characteristics of the objects, for example a car has a color, a speed, and a number of wheels"
". Objects have concrete values for their characteristics. For example, a car might have the color red, a speed of 90, and 4 wheels."
Objects and classes
"Objects are sets of related data, called state, and functionality, called behavior. Classes are blocks of code which include attributes and methods. Attributes are variables used to store the state of objects of the same type"
. Methods are functions used to carry out the behavior of objects of the same type.
"There are two boxes, one labeled ""class"" and the other labeled ""objects."" The ""class"" box contains the outline of a car with the label ""Car"" inside. The ""objects"" box contains three filled-in cars, one green, one blue, and one orange"
". The green car is labeled ""Mercedes,"" the blue car is labeled ""Bmw,"" and the orange car is labeled ""Audi."""
Objects and classes
"Creating a new class means creating a new data type. There are two types of data types: primitive data types and non-primitive data types. Primitive data types are not classes and include: int, boolean, char, and double"
". Non-primitive data types are classes and include: String, Integer, Double, Boolean, and Car."
Creating a new object from a class is called instantiation. Objects are instances of classes. Classes are the pattern to create objects.
"Classes are stored in "".java"" files with the same name as the class. Objects are stored in the memory of our program and only exist in runtime."
Objects: functional and data abstractions
We have two types of abstractions: functional and data abstraction.
"Functional abstraction refers to the things the object does, its behavior. Examples of behavior are: move forward, move backwards, turn left, turn right, speed up, brake, refuel, and so on."
"Data abstraction refers to the properties of the object, its state. Examples of properties are: color, brand, maximum speed, number of wheels, number of doors, fuel, and so on.
There is an image of a red sports car at the bottom of the slide."
"Example
The image shows an example of a class and objects in programming."
"On the left side, we have the definition of a class named ""Car"". The class has three private attributes: ""color"" of type String, ""speed"" of type int, and ""size"" of type float"
". It also has a constructor that takes the color, speed, and size as arguments and initializes the corresponding attributes"
". Additionally, the class has five public methods: ""advance"", ""stop"", ""turnLeft"", ""turnRight"", which are all empty, indicating they don't have any implementation yet."
"On the right side, we have the ""Objects"" section, which shows how to create instances of the ""Car"" class. Three car objects are created: ""myCar"" with green color, 80 speed, and 3.2 size, ""yourCar"" with red color, 120 speed, and 4"
".1 size, and ""hisCar"" with yellow color, 100 speed, and 3.4 size."
"The example also highlights three key concepts: the ""new"" operator used to create instances of a class, the ""this"" reference which refers to the current object"
", and the ""public/private"" access modifiers that control the visibility and accessibility of class members"
.
Exercise 1
"We need to implement a class named Bicycle. This class will have 3 attributes: speed, cadence, and gear, all of them of type integer.
The class will also have 4 methods: speedUp, brake, setCadence, and setGear."
"The speedUp method doubles the current speed.
The brake method halves the current speed.
The setCadence method takes an integer called newCadence as an argument and sets the cadence accordingly."
"The setGear method takes an integer called newGear as an argument and sets the gear accordingly.
Finally, the class must have a constructor to initialize all the attributes."
The second part of the exercise asks to create two objects of this class: myBicycle and yourBicycle.
2. Object encapsulation
"Objects bundle data and methods together. Methods are used to operate on that data. Direct access to some parts of the object are restricted. Private attributes and methods cannot be accessed directly, this is called information hiding"
". Public methods, also called public interface, allow accessing private data and methods. We don't need to know the internal implementation of the private part. The private part can change as long as the public interface remains."
"A diagram shows an object with public methods, private data and private methods. The public methods interact with an interaction interface."
"2. Object encapsulation
Methods are typically public. Methods for internal use only can be private. Attributes are typically private. It is dangerous to have public attributes."
"There is a diagram showing an object and an interaction interface. The object has public methods, private data, and private methods. The public methods interact with the interaction interface."
3. Message passing
An object sends a message to another object by calling a method of the public interface of the receiving object
". The receiving object will: change its state by modifying its attributes directly, call public or private methods of the same object, or send a message to another object."
"A diagram shows message passing between two objects. Object A is labeled ""Sending Object"" and Object B is labeled ""Receiving Object"". A curved arrow labeled ""Message"" points from Object A to Object B."
Example Class Car
"We have three classes: Car, Engine and Wheel. The Car class has private String color, int speed, float size, an array of Wheels and Engine as attributes"
. The Car constructor takes as input all the attributes and sets the object's attributes to the values received as parameters
. The Car class has an advance method that calls the injectFuel method on the engine object and then iterates through the wheels array and calls the turn method on each wheel. The main method instantiates an array of wheels and a Car object
. The Engine class has private String type and int hp as attributes. The constructor takes the type and hp as parameters and sets the object's attributes. The Engine class also has an injectFuel method
. The Wheel class has private double diameter and public String manufacturer as attributes. The Wheel constructor takes the diameter and manufacturer as parameters and sets the object's attributes. The Wheel class also has a turn method.
"4. Overloading
Two methods with the same name can be defined in the same class if they have different parameters. It is widely used for constructors. The method actually executed depends on the parameters passed when it is called."
"We see an example with three methods named ""add"". The first method takes two integers as parameters and returns their sum. The second method takes three integers as parameters and returns their sum"
. The third method takes four integers as parameters and returns their sum as a float.
Example
"We have a class named Car. The class has private attributes: String color, int speed, float size. The class has a constructor that takes a String, an int and a float as parameters and sets the color, speed and size attributes, respectively"
". The class also has several public methods: advance, brake, turnLeft, turnRight. The advance method is overloaded"
". One version takes no parameters, another takes an int representing meters and the last one takes an int representing meters and an int representing speed."
"We also have an example of how to instantiate objects of the class Car. We instantiate three objects: myCar, yourCar and hisCar. Each object is instantiated with a different color, speed and size. We then call the advance method on each object"
". For myCar, we call the version of advance that takes no parameters. For yourCar, we call the version of advance that takes an int representing meters"
". For hisCar, we call the version of advance that takes an int representing meters and an int representing speed."
"Although the methods have the same name, they are different methods, because they receive different parameters."
"Exercise 2
In the class Bicycle, implement the overloaded methods setCadence() and setGear(), which do not receive arguments and change the values of cadence and gear to one value by default: 1."
"5. Constructors
When an object is created, its members are initialized using a constructor method.
- Constructors have the same name as the class
- They have no return type (not even void)
- At least one constructor should be defined per class"
"Example
This code defines a class named ""Car"". The class has three private attributes: ""color"" of type String, ""speed"" of type int, and ""size"" of type float."
"The class has a constructor that takes three arguments: a String for the color, an int for the speed, and a float for the size. The constructor initializes the attributes of the class with the values of the arguments."
"The class also has a main method. The main method creates three instances of the ""Car"" class: ""myCar"" with values ""green"", 80, and 3.2f, ""yourCar"" with values ""red"", 120, and 4.1f, and ""hisCar"" with values ""yellow"", 100, and 3.4f"
". The part of the code defining the constructor is labeled ""Constructor""."
5. Constructors
"Several constructors can exist, this is called overloading. They are distinguished by their parameters. If no explicit constructor is defined, then there is a default constructor without parameters. It initializes the attributes to their default values"
". If a constructor is defined, the default constructor no longer exists."
"Example: Overloaded Constructors
We see an example of a Java class named ""Car"" with overloaded constructors. The class has three private member variables: ""color"" of type String, ""speed"" of type int, and ""size"" of type float."
"The class defines four constructors:- a no-argument constructor,- a constructor that takes a String argument and initializes the ""color"" member variable,"
"- a constructor that takes a String and an int argument and initializes the ""color"" and ""speed"" member variables, and- a constructor that takes a String, an int, and a float argument and initializes the ""color"", ""speed"", and ""size"" member variables."
"The class also defines four public methods: ""advance"", ""brake"", ""turnLeft"", and ""turnRight"", all of which take no arguments and have a void return type."
"Exercise 3
In the class ""Bicycle"", implement an additional constructor, which does not receive arguments, and that initializes the speed to 0, and the cadence and gear to 1."
6. Modifiers and Access: static
"Static members exist only once per class, independently of the number of instances of the class that have been created, even if no instances have been created yet"
". The value of static attributes is shared by all objects, changing it for one object affects all the others. Static methods do not depend on attributes, although they might depend on input parameters. Static elements can be accessed using the class name"
". A static method cannot access non-static members directly, an object must be created first."
"6. Modifiers and Access: static
Static attributes
 the concept of static attributes in object-oriented programming."
"A code snippet shows the declaration of a static attribute within a class named ""Car"". The static attribute is named ""numberOfWheels"" and is assigned a value of 4. The code also includes a main method that prints the value of the static attribute."
" provides other examples of static attributes, including:"
"- ""radium"" with a value of 3
- ""areaCircle"" calculated using the value of ""radium"" and the mathematical constant PI
- ""minValue"" assigned with the minimum value of the Integer type
- ""maxValue"" assigned with the maximum value of the Integer type"
"Modifiers and Access: static
 about static methods in programming. A static method has access to static attributes and does not require the creation of an instance.
We see an example of a static method declaration:"
"```java
public static void main(String args[]) {
  int x1 = Integer.parseInt(args[0]);
  double y1 = Double.parseDouble(args[1]);
}
```"
"This code defines the main method, which takes an array of strings as input. Inside the method, two variables, x1 and y1, are declared and initialized by parsing the input arguments as an integer and a double, respectively."
" provides additional examples of static methods:
- `Math.sqrt(100);`
- `Math.cos(76);`
These examples demonstrate how to call static methods from the `Math` class to calculate the square root of 100 and the cosine of 76, respectively."
"Finally, a URL is provided, which points to the documentation of the `Math` class in Java 9."
"Modifiers and Access: static
Static members are invoked with: ClassName.staticMethod(); and ClassName.staticAttribute;
Non-static members require an instance (object) in order to be accessed. ClassName objectName = new ClassName();"
Non-static members are invoked with: objectName.normalMethod(); and objectName.normalAttribute;
"When a static member is invoked within the same class, the class name can be deleted. So instead of ClassName.staticMethod(); and ClassName.staticAttribute; we can use: staticMethod(); and staticAttribute;"
"6. Modifiers and Access: public/private
 the concepts of public and private modifiers in programming."
"- Public attributes, methods, and classes are visible from any other class. Each public class needs to be in a separate file with the same name as the class."
"- Private attributes, methods, and classes are visible only within the class. Private classes are rarely used as inner classes inside a file with another public class."
"The image shows two street signs. The sign pointing to the right says ""Private"" and the sign pointing slightly to the left says ""Public."""
"Modifiers and Access: methods get/set
 the concept of getter and setter methods in object-oriented programming."
It mentions that public methods can be used to control access to private attributes of a class. These methods can include control mechanisms to avoid undesired modifications.
" introduces the concept of ""get/set methods"" and provides an example of a ""Car"" class with private attributes for ""color"" and ""speed"""
". The class includes public methods ""getColor"", ""setColor"", ""getSpeed"", and ""setSpeed"" which allow controlled access to the private attributes."
"Exercise 4
In the class bicycle, implement the necessary get() and set() methods which allow accessing and modifying all the attributes."
"2
Overview
. Syntax errors
. Error correction
A. Hand tracing
B. Extra code
C. Assertions
D. Eclipse Debugger"
"3
. Syntax errors"
"4
Examples of basic syntax errors (I)
. Assignment vs boolean expression
if(x=0){ // if(x==0)
statement;
}
. Missing curly brackets {}
if(x==0) //statement 2 is always executed
statement1;
statement2;
. Missing operators"
System.out.println(“Value:” x); //+ missing
"5
The compiler (sometimes) warns us (I)
. Line nn: “Type mismatch cannot convert from int to boolean”
if(x=0){ // if(x==0)
statement;
}
. The compiler does not detect any errors
if(x==0) //statement 2 is always executed
statement1;
statement2;"
"3. Line nn: “Syntax error on token “x”, delete this token”
System.out.println(“Value:” x); //+ missing"
"6
Examples of basic syntax errors (II)
. Java is a case-sensitive language
int Var=0;
if(var==0){
statement;
}
string s = “Hello”;
By agreement, variables and methods start withlowercase, and classes with capital letters."
Primitive data types must be written with lowercase
"7
The compiler (sometimes) warns us (II)
. Line nn: “var cannot be resolved to a variable”
int Var=0;
if(var==0){
statement;
}
. Line nn: “string cannot be resolved to a type”
string s = “Hello”;"
"8
Examples of syntax errors in methods
.
Line nn: “This method must return a result of type boolean”
public boolean method(){
}
.
Line nn: “This method must return a result of type boolean”
public boolean method(int a){
if (a == 0){"
"return true;
}
}
*A return value must be provided if the condition is not met"
"9
The compiler in Eclipse
´ Eclipse compiles automatically as we write (and when we save)
´ Eclipse provides quick fixes
Use quick fixes
carefully!!"
"10
Errors affecting multiple lines
´ Sometimes we do not get quick fixes
´ If we are sure a line is correct, an error in another line
might be affecting the overall structure of the program"
"11
Errors closing curly brackets
´ A proper code indentation helps
´ PC:
´ Mac
Closing curlybracket for theclass missing"
"12
Exercise 1
´ The following code should calculate the average value of the numbers
entered by the end-user, but it has several syntax errors, fix them!
public class Exercise1 {
public static void main(String args) {"
"Scanner sc = new Scanner(System.in);
System.out.print(""Enter number of element: "");
int n = sc.nextInt();
double sum = 0;
for (i = 0; i < n; i++)
System.out.print(""Enter element "" + (i + 1) + "": "");
int a = sc.nextInt();
sum += a;"
"double Average = sum / n;
System.out.println(""Average value of elements is : "" average);
}
}"
"13
Execution errors (I)
. The code compiles, but the result is not as expected
public static void main (String args[]) {
String a = new String(""Hello"");String b = new String(""Hello"");if (a == b){
System.out.println(a + "" "" + b + "" are equal"");"
"}else{
System.out.println(a + "" "" + b + "" are different"");
}
}
Strings are compared with equals => a.equals(b)"
"14
Execution errors (II)
. The code compiles, but the program crashes
public class Example {
public static int divide (int a, int b){
return a/b;
}
public static void main(String[] args){
int result = divide(3,0);
System.out.println(result);
}
}"
"15
Execution errors (III)
. Use of try-catch block to handle Exceptions
public class Example {
public static int divide (int a, int b){
return a/b;
}
public static void main(String[] args){
try{"
"int result = divide(3,0);
System.out.println(result);
} catch (ArithmeticException e){
System.err.println(""You cannot divide a number by zero"");
}
}
}"
"16
. Error correction"
"17
.A. Hand tracing (I)
´ Calculate the values variables take in the program by hand
m

n

x




y




y*n + x == m"
"18
.A. Hand tracing (II)
m

n

x





y





y*n + x == m"
"19
Exercise 2
´ The followingcode shouldcalculate thefactorial of anumber. Try todetect theerrors by hand."
"20
.B. Extra code
´ Add extra lines of code to see the values of variables"
"21
Exercise 3
´ The followingcode shouldcalculate if anumber a is aprime number.Try to detectthe errorsadding extracode."
"22
.C. Assertions
´ Statements to test assumptions (assert)
. assert booleanExpression;
. assert booleanExpression:value;
´ If the boolean expression is false, an AssertionError is
thrown with the value"
"´ Errors, unlike Exceptions, should not be caught"
"23
.C. Assertions
y*n + x == m"
"24
.C. Assertions
´ Assertions are normallyignored while runningthe program
´ We need to configurethe JVM with “-ea”before running theprogram
´ Run configurations =>Arguments => VMarguments"
"25
.D. Eclipse Debugger
´ Running the program step by step tracking
the values of variables
. Set a breakpoint in the line you want the
program to stop (double click on the numberof the line)
. Run the program with the option “Debug as”"
"=> “Java application”
. The new “Debug” view opens"
"26
.D. Eclipse Debugger
Methods called
Variables
Code
Methods
Breakpoint
Console"
"27
.D. Eclipse Debugger
´ Resume: continues running the program until the
next breakpoint or the end of the program
´ Terminate: forces the termination of the program
´ Step into: executes the next line. If it is a method"
"call, goes into the first line of the method
´ Step over: executes the following line. If it is a
method call, executes it completely
´ Step return: executes the rest of the currentmethod returning the control to the callingmethod"
"28
Exercise 4
´ The following code calculates the greatest divisor of a
random number (between 1 and 100). Run it several timesand try to detect the error using the Eclipse debugger.
public class Example4 {
public static void main(String[] args) {"
"int t = (int) (Math.random() * 100) + 1;
System.out.println(""The number is: ""+t);
int result = 1;
for(int i =t/2; i>1; i--){
if(t%i==0)
result = i;
i = 1;
}
System.out.println(""The greatest divisor is: ""+result);
}
}"
"29
Summary
´ Errors will always happen, but we need to try to detect
and correct them
´ The compiler helps us to detect some syntax errors
´ Execution errors are critical as they end the program
´ Hand tracing and adding extra code are not"
"elegant/efficient solutions
´ If you have errors use the Eclipse debugger"
"Overview
- Syntax errors
- Error correction
    - Hand tracing
    - Extra code
    - Assertions
    - Eclipse Debugger"
"1. Syntax errors
The image shows a computer error message that reads ""Syntax error....I think"". There is an ""OK"" button below the message."
Examples of basic syntax errors (1)
The image shows three examples of basic syntax errors. The first one is an assignment vs. boolean expression error. The code shows an if statement where the condition is (x=0)
". This is an assignment, not a boolean expression, so it will always evaluate to true. The correct boolean expression should be (x==0). The second example is a missing curly brackets error. The code shows an if statement without curly brackets"
. This means that only the first statement after the if condition will be executed if the condition is true. The second statement will always be executed. The third example is a missing operators error. The code shows a System.out
".println statement that is missing the plus operator (+) between the string ""Value: "" and the variable x."
"The compiler (sometimes) warns us (1)
We have three code snippets, each with a different type of error."
"The first snippet shows an if statement with an assignment instead of a comparison in the condition. The error message indicates a type mismatch, as an integer cannot be converted to a boolean."
"The second snippet shows an if statement with a comment indicating that the second statement is always executed. This implies that the condition in the if statement is always true, making the conditional logic redundant."
"The third snippet shows a print statement with a syntax error. The error message points to the token ""x"" and suggests deleting it. This indicates a missing operator, likely a plus sign, between the string literal and the variable x."
Examples of basic syntax errors (II)
"The first example of a basic syntax error is that Java is a case-sensitive language. For example, we have a code snippet where the variable var is defined with a lowercase v. Then, in the if statement, the same variable is used with an uppercase V"
". This will cause a syntax error. Another example is that the string data type is written with a lowercase s, while it should be String with an uppercase S. By convention, variables and methods start with lowercase, and classes with capital letters"
". Also, primitive data types must be written with lowercase."
The compiler (sometimes) warns us (II)
"There are two common compiler warnings listed on this slide. The first is ""Line nn: 'var' cannot be resolved to a variable"". This warning occurs when the variable 'var' is used in the code, but the compiler cannot find a declaration for it"
". This could be because the variable name was misspelled, or because the variable was not declared in the correct scope"
". An example of this warning is shown in the code snippet, where the variable 'var' is used in the if statement, but it is declared as 'Var'."
"The second common compiler warning is ""Line nn: 'string' cannot be resolved to a type"". This warning occurs when the 'string' type is used in the code, but the compiler cannot find a definition for it"
". This could be because the required library was not included in the file, or because the code is being compiled in an environment where the 'string' type is not defined"
". An example of this warning is shown in the code snippet, where the 'string' type is used to declare the variable 's', but the 'string' type is not defined."
"Examples of syntax errors in methods
There are two code snippets, both showing syntax errors in methods."
"The first snippet shows a method called ""method"" that is declared to return a boolean value. However, the method body is empty, so it does not return any value."
"The second snippet shows a method called ""method"" that takes an integer argument and is declared to return a boolean value. The method body contains an if statement that checks if the argument is equal to 0. If it is, the method returns true"
". However, if the argument is not equal to 0, the method does not return any value."
The note at the bottom of  that a return value must be provided for all possible execution paths of a method that is declared to return a value.
The compiler in Eclipse
"Eclipse compiles automatically as we write and when we save. Eclipse provides quick fixes. We can see an example of this in the given code. The code contains an error because the variable ""result"" is not declared"
". When we hover the mouse over the error, Eclipse shows a light bulb icon with several quick fix options. We can choose to create a local variable, a field, or a parameter named ""result"""
". We can also choose to remove the assignment, change the variable name to ""val1"" or ""val2"", or rename the variable in the file. We should use quick fixes carefully because they may not always produce the desired result"
". For example, if we choose to create a local variable named ""result"", the code will compile, but it may not work as expected if we intended to use a field or a parameter with the same name."
Errors affecting multiple lines
" an example of code with errors on lines 3, 4 and 7. The errors are marked with a red X. The first point states that sometimes we do not get quick fixes for errors"
". The second point states that if we are sure a line is correct, an error in another line might be affecting the overall structure of the program."
Errors closing curly brackets
" two code snippets, both containing syntax errors.  that proper code indentation helps identify these errors. The first code snippet is missing a closing curly bracket for the class definition"
". The second code snippet has been corrected by adding the missing curly bracket.  provides keyboard shortcuts for indenting code on both PC and Mac. On a PC, the shortcut is Ctrl+Shift+F, while on a Mac, it is Cmd+Shift+F."
Exercise 1
"The image shows an exercise about fixing syntax errors in a Java code snippet. The code is intended to calculate the average of numbers entered by the user. The code first declares a class named ""Exercise1"" and a main method"
". Inside the main method, it initializes a Scanner object to read user input. It then prompts the user to enter the number of elements and stores it in the variable ""n"""
". A for loop is used to iterate ""n"" times, prompting the user to enter each element and calculating the sum of all entered elements. Finally, the average is calculated by dividing the sum by ""n"" and the result is printed to the console"
". However, the provided code snippet contains syntax errors that need to be fixed."
Execution errors (1)
"The code compiles, but the result is not as expected. We have a snippet of Java code that declares two strings, a and b, both initialized with the value ""Hello"". Inside an if-else block, it checks if a is equal to b using the ""=="" operator"
". If true, it prints ""a and b are equal"", otherwise it prints ""a and b are different"". The code highlights that strings are compared with the ""equals"" method, implying that using ""=="" might lead to unexpected results."
Execution errors (II)
"The code compiles, but the program crashes.
The code defines a class named ""Example"" with two methods: ""divide"" and ""main"".
The ""divide"" method takes two integers as input, divides the first by the second and returns the result."
"The ""main"" method calls the ""divide"" method with 3 and 0 as arguments, stores the result in a variable named ""result"" and prints it to the console.
The program throws an ArithmeticException because it is trying to divide by zero."
"The exception message indicates that the error occurred in the ""divide"" method at line 3 and in the ""main"" method at line 6."
Execution errors (III)
" a code snippet with a try-catch block to handle exceptions. The code defines a class named ""Example"" with two methods: ""divide"" and ""main"". The ""divide"" method takes two integers as input and returns their quotient"
". The ""main"" method calls the ""divide"" method with arguments 3 and 0. Since dividing by zero is not allowed, an ArithmeticException is thrown. The try block encloses the code that might throw an exception"
". The catch block catches the ArithmeticException and prints an error message to the console. The output of the code is ""You cannot divide a number by zero""."
"2. Error correction
The image shows the word ""Error"" written on lined paper. A red eraser at the end of a red pencil is erasing part of the word."
"2.A. Hand tracing (1)
 how to hand-trace a Java program that calculates integer division.
The program defines a class named ""Example"" with two methods: ""intDiv"" and ""main""."
"The ""intDiv"" method takes two integers, ""m"" and ""n"", as input and returns the integer quotient of ""m"" divided by ""n"". It first checks if ""n"" is not equal to 0. If it is, it throws an exception"
". Otherwise, it initializes two integer variables, ""x"" to ""m"" and ""y"" to 0. It then enters a while loop that continues as long as ""x"" is greater than ""n"". Inside the loop, it subtracts ""n"" from ""x"" and increments ""y"" by 1"
". Once the loop terminates, it returns the value of ""y""."
"The ""main"" method is the entry point of the program. It first declares an integer variable ""i"" and initializes it by calling the ""intDiv"" method with arguments 12 and 3. It then prints the value of ""i"" to the console"
". If an exception is thrown by the ""intDiv"" method, it catches the exception and prints an error message to the console."
" includes a table that shows the values of the variables ""m"", ""n"", ""x"", and ""y"" at each iteration of the while loop in the ""intDiv"" method when called with arguments 12 and 3"
". The table shows that the loop iterates 4 times, and at the end of the loop, the value of ""y"" is 3, which is the correct quotient of 12 divided by 3. The value of ""x"" is 3, which is the remainder of the division."
"The equation ""y*n + x == m"" at the bottom of  the relationship between the dividend (""m""), the divisor (""n""), the quotient (""y""), and the remainder (""x"") in integer division."
2.A. Hand tracing (II)
"We have a java program that calculates the integer division of two numbers. The program first checks if the divisor is not zero. If it is, it throws an exception. Otherwise, it initializes two variables, x and y, to the dividend and zero, respectively"
". Then, it enters a while loop that continues as long as x is greater than or equal to the divisor. Inside the loop, it subtracts the divisor from x and increments y by one. Finally, it returns the value of y."
"On the right side of the image, we have a table that shows the values of the variables m, n, x, and y at each iteration of the loop. The first row of the table shows the initial values of the variables"
". The second row shows the values of the variables after the first iteration of the loop. The third row shows the values of the variables after the second iteration of the loop, and so on"
. The last row of the table shows the values of the variables after the loop has finished executing.
"The equation at the bottom of the image shows the relationship between the variables m, n, x, and y. The equation states that the product of y and n plus x is equal to m"
". This equation is true because y represents the quotient of the division of m by n, and x represents the remainder of the division."
Exercise 2
"We have a Java program that calculates the factorial of a number. The 'fac' function takes an integer 'a' as input. If 'a' is greater than 0, it calculates the factorial using a for loop and returns the result"
". If 'a' is not greater than 0, it throws an exception. In the 'main' function, the program calls the 'fac' function with the argument 12, prints the result to the console, and catches any exceptions that may occur"
". If an exception is caught, it prints an error message to the standard error stream."
"Extra code
The code snippet shows a Java program with a class named ""Example"". The program defines a method called ""intDiv"" that takes two integers, ""m"" and ""n"", as input and returns an integer. The method calculates the integer division of ""m"" by ""n""."
"Inside the ""intDiv"" method:
- It first checks if ""n"" is not equal to zero.- If ""n"" is not zero, it initializes two integer variables, ""x"" with the value of ""m"" and ""v"" with the value of 0."
"- It then enters a while loop that continues as long as ""x"" is greater than ""n"".
- Inside the loop, it calculates the difference between ""x"" and ""n"" and assigns the result back to ""x"". It also increments the value of ""v"" by 1."
"- After the loop completes, it returns the value of ""v""."
"The code also includes a ""main"" method that demonstrates the usage of the ""intDiv"" method.- It calls the ""intDiv"" method with the arguments 12 and 3.- It then prints the returned value."
"Additionally, the code includes a try-catch block to handle the exception that would occur if ""n"" is zero. If an exception is caught, it prints an error message ""You cannot divide by zero""."
Exercise 3
"The code defines a function called ""checkPrime"" that takes an integer as input and returns a boolean value. The function is designed to determine if the input integer is a prime number"
". The main function then calls the ""checkPrime"" function with the numbers 0, 1, 4, 6, and 11 as input and prints the results to the console. The output of the code shows that the ""checkPrime"" function incorrectly identifies the number 4 as a prime number."
2.C. Assertions
"- Statements to test assumptions, using the keyword ""assert"".
- There are two ways to use it:
 1. ""assert"" followed by a boolean expression
 2. ""assert"" followed by a boolean expression, then "":"" and a value"
"- If the boolean expression is false, an AssertionError is thrown with the value.
- Errors, unlike Exceptions, should not be caught."
"2.C. Assertions
We have a java code with a class named ""Example underscore"". This class has two methods: ""intDiv"" and ""main""."
"The ""intDiv"" method takes two integers, m and n, as input and returns an integer.- It first checks if n is not equal to zero.- If n is not zero, it initializes two integer variables, x and y, with m and zero respectively."
"- Then, it enters a while loop that continues as long as x is greater than n.- Inside the loop, it subtracts n from x and increments y by one.- After the loop, it asserts that y multiplied by n plus x is equal to m."
"- Then, it asserts that x is less than n.- Finally, it returns the value of y.- If n is zero, the method throws an exception."
"The ""main"" method is the entry point of the program.- It first tries to call the ""intDiv"" method with the arguments 12 and 3 and prints the returned value.- If an exception is caught, it prints an error message to the console."
"When we run this code, an error occurs: an AssertionError exception is thrown. The error message indicates that the assertion ""y * n + x == m"" failed at line 11 of the Example_.java file and that the assertion at line 19 of the same file also failed."
"2.C. Assertions
Assertions are normally ignored while running the program. We need to configure the JVM with ""-ea"" before running the program. Run configurations, arguments, then VM arguments. In the VM arguments field, we have ""-ea""."
2.D. Eclipse Debugger
" how to use the Eclipse debugger. The debugger allows you to run a program step by step and track the values of variables. To use the debugger, you first need to set a breakpoint in the line of code where you want the program to stop"
". You can do this by double-clicking on the number of the line in the editor. Once you have set a breakpoint, you can run the program in debug mode by selecting ""Debug As"" > ""Java Application"" from the Run menu"
". When the program reaches the breakpoint, it will stop and you will be able to step through the code line by line. The new ""Debug"" view will open, showing the current state of the program."
2.D. Eclipse Debugger
"We are looking at a screen capture of the Eclipse IDE. The code is paused at a breakpoint at line 6, inside the ""intDiv"" method of the ""Example"" class"
". The method takes two integers, m and n, as input and is supposed to return the result of the integer division of m by n."
"The ""Variables"" pane shows the current values of the local variables: m is 12, n is 3, x is 12, and y is 0.
The ""Methods"" pane shows the call stack: the ""intDiv"" method was called from the ""main"" method."
"The ""Code"" pane shows the source code of the ""Example"" class. The breakpoint is set on the line ""while (x > n)"".
The ""Console"" pane is at the bottom of the screen."
2.D. Eclipse Debugger
" the debugger functions in Eclipse. The functions are Resume, Terminate, Step into, Step over, and Step return. Resume continues running the program until the next breakpoint or the end of the program"
". Terminate forces the termination of the program. Step into executes the next line. If it is a method call, it goes into the first line of the method. Step over executes the following line. If it is a method call, it executes it completely"
. Step return executes the rest of the current method returning the control to the calling method. Each function is shown with an icon representing its action.
"Exercise 4
The following code calculates the greatest divisor of a random number between 1 and 100. Run it several times and try to detect the error using the Eclipse debugger.
The code is as follows:"
"```java
public class Example4 {
  public static void main(String[] args) {
    int t = (int) (Math.random() * 100) + 1;
    System.out.println(""The number is: "" + t);
    int result = 1;
    for (int i = t / 2; i > 1; i--) {
      if (t % i == 0) {"
"result = i;
        i = 1;
      }
    }
    System.out.println(""The greatest divisor is: "" + result);
  }
}
```"
Summary
"Errors will always happen, but we need to try to detect and correct them. The compiler helps us to detect some syntax errors. Execution errors are critical as they end the program. Hand tracing and adding extra code are not elegant/efficient solutions"
. If you have errors use the Eclipse debugger.
"Methods, Scope
Carlos Delgado Kloos
Universidad Carlos III de Madrid"
"We see two sets X and Y. Set X contains the elements 1, 2, and 3. Set Y contains the elements a, b, c, and d"
". There are arrows pointing from element 1 in set X to element d in set Y, from element 2 in set X to element d in set Y, and from element 3 in set X to element c in set Y"
". The name Carlos Delgado Kloos is displayed below the diagram, followed by the name Universidad Carlos III de Madrid on the next line."
"3
From the Calculator to the Computer
Values
Expressions
Statements
x=x×12;

x
set
get"
"4
d =    0;
C ;






 2 3
⁄
*
−
. +

f"
"5
Method Definition
square: int gint
square(x) = x*x
int
x
square
square
x*x
int
int square (int x)
{
}
return x*x;"
"6
Method Definition
Result type
Parameter type
Method name
Parameter
int square (int x)
return x*x;
Method
header
{
}
Method body
int
x
square
x*x
int"
"7
Method Name
´Recommendations
´Initial small letter
´Verb: move
´Phrase: isEmpty
´For understanding purposes,
it should have a meaning"
"8
Parameter Names
This method gets an integer, which we will call x,
and will return an integer by multiplying x*x
Let's call this method square.
int
int square (int x)
{
}
return x*x;
x
square
x*x
int"
"9
Consistent Substitution
This method gets an integer, which we will call y,
and will return an integer by multiplying y*y
Let's call this method square.
int
int square (int y)
{
}
return y*y;
y
square
y*y
int"
"10
Parameter: Placeholder
This method gets an integer and
will return an integer by multiplying it by itself.
Let's call this method square.
int
int square (int c)
{
}
return c*c;
c
square
c*c
int"
"11
One Parameter
square: int gint
square(x) = x*x
int
x
square
square
x*x
int
int square (int x)
{
}
return x*x;"
"12
Exercise 1
´ Create a new Java class that
´ Contains the method int square (int x), which
returns the square of the parameter received. 
´ Contains a main method that calls the method square"
(in order to call the method square add publicstatic in its signature) and prints the result on screen
"´ The value for which the square is calculated will be aninput argument to the program. Collect this argumentin the main method in args and transform it to an int
with Integer.parseInt()"
"13
More Parameters
int
int
average
int
int mult(int x, int y)
{
return x*y;
}"
"14
Exercise 2
´ Create a new Java class that
´ Contains the method double average(double x,
double y), which returns the average of the twoparameters received. 
´ Contains a main method that calls the method average"
"and prints the result on screen
´ The values for which the average is calculated will be
input arguments to the program. Collect thesearguments in the main method in args and transformthem to double with Double.parseDouble()"
"15
No Parameters
sayHello
String
String sayHello()
{
return ""Hello!"";
}"
"16
No Result
double
printInverse
void printOpposite(double x)
{
System.out.println(-x);
}"
"17
No Parameters, No Result
printHello
void printHello()
{
System.out.println(""Hello!"");
}"
"18
Method Definition
square: int gint
square(x) = x*x
int
x
square
square
x*x
int
int square (int x)
{
}
return x*x;"
"19
Outside / Inside
Outside
Inside
int square (int )
int square (int x)
{
}
return x*x;
int
x
square
square
x*x
int"
"20
Outside / Inside
Outside
Inside
int square (int )
int square (int x)
{
}
return 1+(x+1)*(x-1);
int
x
square
square
x*x
int"
"21
Method Call


y=square(3)+square(4);
Use
Definition


int square (int x)
{
}
return x*x;


int


x
square
square
x*x
int

"
"22
Scope
´ What happens if I use an identifier used in a method body,
also outside of the method?
x
Method
x"
"23
Example 1
int x=1;
int f(int x)
{
}
return x+x;
int z=f(x+1);
x

x

z
"
"24
Example 1
int x=1;
int f(int c)
{
}
return c+c;
int z=f(x+1);"
"25
Example 2
int x=1;
int f(int x)
{
}
return x+x;
int z=f(f(x+1));
x

x
x


z
"
"26
Example 3
int x=1;
int f(int y)
{
}
return x+y;
int z=f(x+1);
x

y

z
"
"27
Example 4
int x=1;
int f()
{
}
int y=2;
return x+y;
int z=f();
x

y

z
"
"28
Example 5
int x=1;
int f()
{
}
int x=2;
return x+x;
int z=f();
x

x

z
"
"29
Example 6
x only exists in for loop
int y=0;
for (int x=1; x<3; x++)
{
}
y=y+x;
int z=y;
y



x


z
"
"30
Example 7
int x=1;
int y=0;
name conflict with x
for (int x=1; x<3; x++)
{
}
y=y+x;
int z=y;"
"31
Example 8
int x=1;
int y=0;
x also exists
out of for loop
for (x=1; x<3; x++)
{
}
y=y+x;
int z=y+x;
x




y



z
"
"32
Example 9
int x=1;
int f()
{
}
return x;
int z=f();
x

z
"
"33
Example 10
int x=1;
int f()
{
}
return x;
int g()
{
}
int x=0;
return f();
int z=g();
x

x

z
"
"34
Example 11
int f()
{
}
return x;
int g()
{
}
int x=0;
return f();
int z=g();"
"35
Environment
x

x

f
(x)->x+x
int x=1;
int f(int x)
{
}
return x+x;
int z=f(x+1);"
"36
To Remember
´ A variable is valid in a scope
(from its declaration to the end of the block)
but can be temporarily hidden
by another variable with the same name
´ However, arrays are passed by reference"
"´ If there are free variables in a method definition,
they are bound at its definition, not at its call"
"37
Exercise 3
´ Program a method that receives three int andreturns the squares of each of these three int
´ Think of different implementations, with and without theuse of arrays and take into account the scope for eachof these cases"
"38
Exercise 4
´ Program the method power, which calculates thepower of a number given the base and a non-
negative exponent as parameters."
"´ Program a method that calculates the area of asphere given its radius and another method thatcalculates the volume of a sphere given its radius.These methods use the method power.
´ Program a main method to test your program
V = (4/3)πr3"
A = 4πr2
39
From the Calculator to the Computer
"The image shows the evolution from a calculator to a computer. It presents three devices: a calculator displaying the value ""36"", a calculator displaying the expression ""3 x 12"", and a calculator displaying the statement ""x = x x 12;"""
". Each device has buttons labeled ""C"" and "";"". The third device also has buttons labeled ""3"", ""x"", ""set"", and ""get""."
"The image shows a calculator with a display at the top and a keypad at the bottom. The display shows ""d = 0"" on the first line and ""C :"" on the second line"
". The keypad has keys for digits 0 to 9, arithmetic operators such as plus, minus, multiplication, division, and a special key labeled ""f""."
Method Definition
"We see the definition of a method named ""square"". The method takes an integer as input and returns an integer as output. The method calculates the square of the input integer and returns the result"
". There is a diagram showing the input and output of the method. The input is an integer and it goes into a box labeled ""square"". The output of the box is also an integer"
". To the right of the box, we see the code implementation of the method in c-like language."
"Method Definition
The image describes the definition of a method."
"The method header is composed of the result type, the method name, and the parameter type. In this example, the result type is ""int"", the method name is ""square"", and the parameter type is ""int x""."
"The method body is composed of the code that will be executed when the method is called. In this example, the method body contains a single line of code that returns the square of the parameter ""x""."
"The diagram shows how the different parts of the method definition are related. The result type is shown at the top, followed by the method name and the parameter type. The method body is shown at the bottom."
The arrows in the diagram show how the different parts of the method definition are related. The arrow from the result type to the method name indicates that the result type specifies the type of value that will be returned by the method
. The arrow from the parameter type to the method name indicates that the parameter type specifies the type of value that will be passed to the method when it is called
. The arrow from the method name to the method body indicates that the method body contains the code that will be executed when the method is called.
"Method Name
- Recommendations for method names:
    - Initial small letter
    - Verb: move
    - Phrase: isEmpty
    - For understanding purposes, it should have a meaning"
Parameter Names
" how to name parameters in a method. It uses the example of a method called ""square"" that takes an integer as input and returns its square. The input integer is named ""x"" within the method"
".  a diagram with two boxes, one representing the method call and the other representing the method definition"
". The diagram illustrates how the value of ""x"" is passed from the method call to the method definition, and how the result of ""x*x"" is returned back."
Consistent Substitution
"This method gets an integer, which we will call Y, and will return an integer by multiplying Y*Y. Let's call this method square. There is a blue arrow pointing from the word ""square"" to the word ""int"" above a blue box"
". Inside the box are a red arrow pointing to the letter ""Y,"" the word ""square,"" and another red arrow pointing to ""Y*Y."" There is also a red arrow pointing from ""Y*Y"" to the word ""int"" below the box"
".  There is a blue arrow pointing from ""(int Y)"" to the word ""int"" above the box."
Parameter: Placeholder
" the concept of a parameter as a placeholder in programming. It describes a method called ""square"" that takes an integer as input and returns its square. The input integer is represented by a placeholder within the method definition"
.  illustrates how the placeholder is replaced with the actual integer value when the method is called. It emphasizes that the parameter acts as a container for the value passed to the method.
"One Parameter
The image describes a function named ""square"" that takes an integer as input and returns an integer as output. The function is defined as `square(x) = x*x`."
"There is a diagram illustrating the function. The diagram shows an input arrow labeled ""int"" pointing to a blue rectangle labeled ""square"".  Another arrow labeled ""int"" is pointing out from the rectangle"
". On the right side of the rectangle, there is a code snippet showing the implementation of the function:"
"```c++
int square (int x)
{
  return x*x;
}
```The code snippet shows that the function takes an integer ""x"" as input and returns the square of ""x"" as output."
"Exercise 1
Create a new Java class that contains the method ""int square (int x)"", which returns the square of the parameter received."
"It also contains a main method that calls the method square. In order to call the method square, add ""public static"" in its signature. This method prints the result on the screen."
"The value for which the square is calculated will be an input argument to the program. Collect this argument in the main method in ""args"" and transform it to an integer with ""Integer.parseInt()""."
"More Parameters
We see a diagram depicting a function called ""average"" that takes two integer parameters as input and returns an integer value. The function calculates the product of the two input integers, x and y, and returns the result."
"Exercise 2
Create a new Java class that contains the method ""double average (double x, double y)"", which returns the average of the two parameters received."
"The class should also contain a main method that calls the method ""average"" and prints the result on the screen."
"The values for which the average is calculated will be input arguments to the program. Collect these arguments in the main method in ""args"" and transform them to ""double"" with ""Double.parseDouble()""."
"No Parameters
We have a function named ""sayHello"". It's return type is String. It doesn't take any parameters and it returns the string ""Hello!""."
"No Result
We have a function definition for printOpposite which takes a double as an argument. The function prints the negative of the double. There is an arrow pointing from the word double to a blue rectangle with the text printInverse."
"No Parameters, No Result
We have a function definition for a function called print hello. This function takes no parameters and returns void. The body of the function simply prints the string hello with a new line to the console."
Method Definition
"The image describes how to define a method called ""square"". The method takes an integer as input and returns an integer as output. The method calculates the square of the input integer by multiplying it by itself"
". The image shows a diagram of the method, with an arrow pointing to a box labeled ""square"". The box has two arrows pointing to it, one labeled ""int"" and the other labeled ""int"""
". The arrow labeled ""int"" represents the input integer, and the arrow labeled ""int"" represents the output integer. The box also contains the code for the method, which is ""return x*x;""."
Outside / Inside
"We have a function definition for a function named square that takes an integer x as input and returns an integer. The body of the function computes x times x and returns the result. There is a blue box labeled ""square"""
". There is an arrow labeled ""int"" pointing down to the box. There is another arrow labeled ""int"" pointing down from the box."
"Outside / Inside
We have a function called ""square"" that takes an integer ""x"" as input and returns an integer. Inside the function, it calculates 1 plus (x+1) times (x-1) and returns the result."
Method Call
"The image describes how a method call works, in this case the method is named ""square"".  There are two calls to the method ""square"", one with the argument 3 and the other with the argument 4"
". The first call returns a value of 9 and the second returns a value of 16. The sum of these two values is assigned to the variable y. The definition of the method ""square"" is shown below the calls"
. It takes an integer argument x and returns an integer value that is the square of x. The value of x is first multiplied by itself and then returned.
"Scope
What happens if I use an identifier used in a method body also outside of the method?
There are two Xs, one outside of a circle and one inside of a circle. The circle is labeled ""Method""."
Example 1
We have a piece of code. The first line declares an integer variable x and assigns it the value 1. The second line defines a function f that takes an integer x as input and returns the sum of x and x
. The third line declares an integer variable z and assigns it the value returned by the function f when called with the argument x+1.
There is a diagram on the right side. The diagram shows the values of the variables x and z at different points in the code. The variable x is initialized to 1 and then passed to the function f
". The function f returns the value 2, which is then assigned to the variable z."
Example 1
"We have a piece of code. First, an integer x is initialized with value 1. Then, we define a function f that takes an integer as input and returns the sum of an empty square and an empty square"
". Finally, we define an integer z equal to the output of the function f when applied to x+1."
Example 2
"We have a function f that takes an integer x and returns x+x. In the main function, we have an integer x initialized to 1. Then, we call the function f twice: first with x+1 as input, and then with the result of the first call as input"
. The final result is stored in an integer z.
Example 3
We have a piece of code. The first line declares an integer variable x and assigns it the value 1. The second line defines a function f that takes an integer y as input and returns the sum of x and y
". The third line declares an integer variable z and assigns it the value returned by calling the function f with the argument x+1. On the right side of the image we have three boxes, one below the other. The top box is labeled X and contains the number 1"
. The middle box is labeled Y and contains the number 2. The bottom box is labeled Z.
Example 4
"We have a piece of code that defines an integer variable x and assigns it the value 1. Then, an integer function f is defined. Inside the function f, an integer variable y is defined and assigned the value 2. The function returns the sum of x and y"
". Finally, an integer variable z is defined and assigned the value returned by the function f."
"There are three boxes, one below the other. The top box is labeled X and contains the value 1. The middle box is labeled Y and contains the value 2. The bottom box is labeled Z. The middle box is colored red."
Example 5
"We have a piece of code that defines an integer variable x and assigns it the value of 1. Then, we define a function called f that takes no arguments and returns an integer"
". Inside the function f, we define another integer variable x and assign it the value of 2. The function then returns the sum of x and x, which is 4. Finally, we define an integer variable z and assign it the value returned by the function f."
There is a diagram on the right side. The diagram shows the values of the variables x and z at different points in the code
". The top box represents the global scope, the middle box represents the scope of the function f, and the bottom box represents the value of z. In the global scope, the value of x is 1. In the scope of the function f, the value of x is 2"
". The value of z is 4, which is the value returned by the function f."
"Example 6
We have a code snippet with a comment ""x only exists in for loop"". The code is:
int y = 0;
for (int x = 1; x less than 3; x plus plus)
{
y = y + x;
}
int z = y;"
"There is a table with three columns: X, Y and Z.
The column X has two rows with the values 1 and 2.
The column Y has one row with the value 0.
The column Z has one row with the value z."
Example 7
We have a code snippet showing a name conflict. The first two lines of code declare an integer variable x and assign it the value 1 and an integer variable y and assign it the value 0
". The next line is a for loop that declares an integer variable x and assigns it the value 1, the condition is x less than 3, and the increment is x plus plus"
". There is a red x over the variable declaration in the for loop and a call out that says ""name conflict with x"". Inside the for loop, y is assigned the value of y plus x. After the for loop, an integer variable z is declared and assigned the value of y."
Example 8
"We have a code snippet that initializes two integer variables, x and y, with values 1 and 0, respectively. A for loop iterates twice, incrementing x by 1 in each iteration. Inside the loop, y is updated by adding the current value of x to it"
". After the loop completes, another integer variable z is declared and initialized with the sum of y and x."
"A table with three columns, x, y, and z, illustrates the values of the variables during the code execution. The x column shows the values 1, 2, and 3. The y column shows the value 0 initially and remains unchanged"
. The z column is represented by a black rectangle. A text box highlights that the variable x also exists outside the for loop.
Example 9
"We have a code snippet that defines an integer variable 'x' initialized to 1. Then, we have a function 'f' that returns an integer. Inside the function 'f', we have a return statement that returns the value of 'x'"
". Finally, we have another integer variable 'z' that is assigned the value returned by the function 'f'. On the right-hand side, we have a memory representation with 'x' at the top and 'z' at the bottom. Both 'x' and 'z' have a value of 1."
Example 10
"We have a code snippet with three functions: f, g, and the main function. The main function first declares an integer variable x and initializes it to 1. Then, it defines a function named f that takes no arguments and returns an integer"
". Inside the function f, it returns the value of x. After that, it defines another function named g that also takes no arguments and returns an integer. Inside the function g, it declares an integer variable x and initializes it to 0"
". Then, it returns the value returned by calling the function f. Finally, in the main function, it declares an integer variable z and assigns it the value returned by calling the function g."
"There is a diagram on the right side. It shows a stack frame with three variables: x, x, and z. The first x is at the top of the stack frame and has a value of 1. The second x is below the first x and has a value of 0"
. The variable z is at the bottom of the stack frame.
"Example 11
We have two functions f and g. Function f returns the value of x. Function g declares x equal to zero and returns the output of function f. Finally, we have a variable z that is assigned the output of function g."
Environment
"We have a piece of code that defines an integer variable x and assigns it the value of 1. Then, it defines a function called f that takes an integer as input and returns an integer. The function f returns the sum of the input integer with itself"
". Finally, the code defines an integer variable z and assigns it the value of the function f called with the argument x+1. The diagram illustrates the environment of the code with two boxes"
. The left box represents the global environment with variable x assigned to value 1. The right box represents the function f with the input variable x assigned to value 2 and the function definition (x)->x+x.
To Remember
"- A variable is valid in a scope from its declaration to the end of the block, but can be temporarily hidden by another variable with the same name
- However, arrays are passed by reference"
"- If there are free variables in a method definition, they are bound at its definition, not at its call"
Exercise 3
The exercise is to program a method that receives three integers and returns the squares of each of these three integers.
"We should think of different implementations, with and without the use of arrays, and take into account the scope for each of these cases."
"Exercise 4
We need to program a method called ""power"" that calculates the power of a number. The method takes two parameters: the base and a non-negative exponent."
"Then, we need to program two more methods: one that calculates the area of a sphere given its radius and another one that calculates the volume of a sphere given its radius. These methods should use the ""power"" method"
. The formula for the volume of a sphere is V = (4/3)πr³ and the formula for the area of a sphere is A = 4πr².
"Finally, we need to program a main method to test the program."
"The word ""wooclap"" in blue letters."
"2
Overview
. Repetition
A. While
B. ForC. Do-While
. Arrays
A. Declaration
Initialization
B.
C. Access"
"3
. Repetition"
"4
. Repetition
. While
while(condition){
statements;
}
. For
for(initialization;condition;update){
statements;
. Do-While
}
do{
statements;
}while(condition);"
"5
.A. While
int i = 5;
while (i>0){
System.out.println(i);
i--;
}
i






Condition Print New i
true
true
true
true
true
false









"
"6
.B. For
i Condition Print New i

true


for (int i=0; i<5; i++) {
System.out.println(i);
}





true
true
true
true
false







"
"7
.B. For
´ When the loop has several statements (in initialization, condition or
update), they will be separated by commas
for(int i=0, int sum=0;
i<=5;
i++, sum+=5){
statements;
}"
"8
.B. For
´ More examples
int i=0;
for (i=0;i<10;){     
int i=0;
for (i=13;i<10; i++){
i=i+2;
i=i+2;
}
}
int i=4;
for (;i<10;){i=i+2;
}
int i=0;
for ( ; ; ){i=i+2;
´
}
int i, sum;
for (i=0, sum=5;i<10;sum+=i){
i=i+8;
}"
"´ How many times are these loops executed?
´ What is the value of “i” in each example at the end of the loop?"
"9
While vs. For
´ When to use while or for
The number of iterations is known (e.g., array)
The number of iterations is unknown
Increase of variables in each cycle
´ E.g.: reading a file with while
´ E.g.: cover an array with for
for
while
X
X
X"
"10
.C. Do-While
int i = 5;
do{
System.out.println(i);
i--;
}while (i>0){
i





Print New i Condition










true
true
true
true
false"
"11
Summary
´ for vs. while vs. do-while
Initializevariables
Updatevariables
Minimumnumber ofExecutions
Frequency of use
for
while
do-while
Yes
No
No
Yes
No
No



High
High
Low"
"12
Additional remarks
´ Nested loops: Program slows down
´ The statements in a while or for
might never run; in a do-while
statements are executed at leastonce
´ Avoid infinite loops (always check
termination condition)"
"´ A for loop always can be convertedinto a  while loop, and vice versa"
"13
Exercise 1
´ Write a method that prints numbers from 1 to 100 in steps of seven.
The output should be:
 8 15 22 29 36 43 50 57 64 71 78 85 92 99
Think of an efficient solution!"
"14
Exercise 2
´ Write a methods that calculates whether an input number n is prime.
The output should be
 is a prime number
 is not a primer number"
*** Remember that a prime number is a positive integer number that has no positive divisors other than 1 and itself.
"15
Exercise 2:Step 1: Think about the algorithm
´ Split the problem into simpler steps:
´ Starting by 2, check for each number if it is an integer divisor of n
´ We only needs to repeat it until n/2
´ Or until we find an integer divisor"
´ We will use a boolean variable as “sentinel”
"16
Exercise 2:Step 2: Represent the algorithm
´ Flowchart
divisor = 2isPrime = true
false
divisor < n / 2
&&
isPrime
true
n % divisor == 0
true
isPrime = false
false
divisor++"
"17
Exercise 2:Step 3: Write the code
public static void main(String[] args){
if (args.length != 0){"
"boolean b = isPrime(Integer.parseInt(args[0]));
if (b) {System.out.println (args[0] + "" is a prime number"");}
else {System.out.println (args[0] + "" is not a prime number"");}
}
}
private static boolean isPrime (int n){"
"int divisor = 2;
boolean isPrime = true;
while ((divisor < n/2) && isPrime){
if (n%divisor == 0){
isPrime = false;
}
divisor++;
}
return isPrime;
}
divisor = 2isPrime = true
false
divisor < n / 2
&&
isPrime
true
n % divisor == 0
true"
"isPrime = false
false
divisor++"
"18
. Arrays"
"19
. Arrays
´ Set of elements belonging to the same data type
´ The index [ ] operator is used to set or retrieve
individual elements from the array
´ The length (attribute) returns the number of
elements in the array.
´ Range of index"
"´ From 0 to length – 1
´ Don’t exceed the maximum length!
´ Exception: IndexOutOfBoundsException"
"20
. Arrays
Index 1st element = 0
Index last element= length - 1
c[0]
c[1]
c[2]
c[3]
c[4]
c[5]
c[6]
c[7]
c[8]
c[9]
-7




-4




Array length= 10
Index nth element = n - 1"
Index : integer expression: 0 <= index <= length - 1
"21
.A. Declaration
´ Assigning an identifier to the array and specify the data type of the
elements that will be stored
type arrayName[];
type[] arrayName;
int arrayName[];
boolean[] arrayName;"
"´ No memory to store the array is allocated in the declaration.
´ The contents cannot be accessed yet."
"22
.B. Creation
´ Allocating memory for the array
´ Use the reserved word new and specify the array size
´ Once created, the elements have default values until the array is initialized
arrayName[] = new type[arraySize];
arrayName[] = new int[10];"
"arrayName[] = new boolean[5];
Default values:
int, short, long  = 0
float, double = 0.0
boolean = false
String = null
Object = null"
"23
.C. Initialization
´ To assign values to each of the elements of the array.
´ Element by element
arrayName[0] = element0;
arrayName[1] = element1;
...
´ Using a loop
for(int i = 0; i < arrayName.length; i++){
arrayName[i] = element-i;
}"
"´ Direct assignment
arrayName = {elem1, elem2, elem3, ...};"
"24
Examples
// declaration
int a[];a = new int[3]  // creation
a[0]=1;
a[1]=2;
a[2]=3;
// initialization
int a[] = new int[3] // declaration, creation
a[0]=1;              // initialization
a[1]=2;
a[2]=3;"
"int a[] = new int[3]          // declaration, creation
for(int i=0; i<a.length;i++){ // initialization
a[i]=i+1;
}
int a[] = {1, 2, 3};   // declaration, creation, initialization"
"25
Common errors
public class ArrayExamples{
public static void main(String args[]){
double myArray[];
System.out.println(myArray[0]);
}
}
WRONG
compile
Compilationfailure
variable myArray may nothave been initialized"
"When an array has been declared but not created or initialized,elements cannot be accessed.The program does not compile and prints an error message"
"26
Common errors
public class ArrayExamples2{
public static void main(String args[]){"
"int myArrayOfIntegers[] = new int[10];
float myArrayOfFloats[]= new float[10];
boolean myArrayOfBooleans[] = new boolean[10];
char myArrayOfCharacters[] = new char[10];
String myArrayOfStrings[] = new String[10];"
"System.out.println(“Integer by default: "" + myArrayOfIntegers[0]);
System.out.println(”Float by default : "" + myArrayOfFloats[0]);
System.out.println(""Boolean by default : "" + myArrayOfBooleans[0]);"
"System.out.println(“Character by default : "" + myArrayOfCharacters[0]);
System.out.println(""String by default : "" + myArrayOfStrings[0]);"
"compile
Run
}   
}
When the array has been declared andcreated but not initialized we can retrieve itselements but they have their default value"
"integer by default: 0
float by default: 0.0
boolean by default: false
char by default:
String by default: null"
"27
Exercise 3
´ Write a method that receives a set of integer values as input, andprints the sum on screen. For example, if the method receives asinput  {1, 2, 3, 4}, then it will print:
"
"´ Assume that the values received as input will be always integer
values. In case that no input is received, the program will print 0."
"28
Exercise 4
´ Write a method that receives a set of integer values as input, andprints the maximum value on screen. For example, if the methodreceives as input {1, -2, 3, -4}, then it will print:
"
"´ Assume that the values received as input will be always integer
values. In case that no input is received, the program will print thesmallest integer value in Java, which is contained inInteger.MIN_VALUE."
"29
N-dimensional Arrays
´ When we need more than one index to set and retrieve the elements of an array


















// Array 3x3 initialized to 0
int [][] a = new int[3][3];
int [][] b = {{1, 2, 3},"
"{4, 5, 6}
{7, 8, 9}};"
"30
N-dimensional Arrays






A B C
D E F
G H I
a[0][2]=‘C’




a
d
g
b
e
h
c
f
i





t
l
c
w
z
ñ
q
f
i
a[0][2][1]=‘l’
char a[][];
a = new char[3][3]; // creation
a[0][0]=‘A’;
...
// initialization"
"// declaration
char a[][][];
a = new char[3][3][3]; // creation
a[0][0][0]=‘a’;
...
// initialization
// declaration"
"31
Exercise 5
´ Write a method public static int max(int[][] a) which"
"receives a bidimensional array of integer values as input, and printsthe maximum value on screen. For example, if the method receivesa where int a[][] = {{1, -2, 8, -4},{3, -1, 7, -2}};
then it will print:
"
"´ Assume that the bidimensional array contains always integer values.In case that no input is received, the program will print the smallestinteger value in Java, which is contained in Integer.MIN_VALUE."
"32
Exercise 6
´ Write a method public static int rowSum(int[][] a, int r)"
"which receives a bidimensional array of integer values as input, andprints the sum of the elements in row r (starting in 0). For example, ifthe program receives a, 1 where"
"int a[][] = {{1, -2, 3, -4},{3, -1, 7, -2}};
then it will print:"
"7
´ Assume that the bidimensional array and r contain always integer
values. In case that no input is received, the program will print an errormessage."
"Overview
 an overview of two programming concepts: repetition and arrays."
"- Repetition is further divided into three sub-concepts: while loops, for loops, and do-while loops.
- Arrays are divided into three sub-concepts: declaration, initialization, and access."
"1. Repetition
The image shows a 3D figure running in a hamster wheel."
1. Repetition
" and describes three types of repetition statements. The first is ""while,"" which has a condition in parentheses followed by statements in curly brackets"
". The second is ""for,"" which has an initialization, condition, and update in parentheses followed by statements in curly brackets"
". The third is ""do-while,"" which has the keyword ""do"" followed by statements in curly brackets, and then ""while"" with a condition in parentheses."
1.A. While
We have a code snippet and a table. The code snippet shows a while loop in Java. It initializes an integer variable 'i' to 5. The while loop continues as long as 'i' is greater than 0
". Inside the loop, the value of 'i' is printed to the console, and then 'i' is decremented by 1."
"The table illustrates the execution of the while loop. Each row in the table represents an iteration of the loop. The columns show the value of 'i', the condition (i > 0), the value printed to the console, and the new value of 'i' after each iteration."
"The loop iterates 5 times, printing the values 5, 4, 3, 2, and 1 to the console. In each iteration, the condition (i > 0) is evaluated. If it's true, the loop continues. Once 'i' becomes 0, the condition becomes false, and the loop terminates."
"1.B. For
We have a for loop with the following structure: for (int i=0; i<5; i++). Inside the loop, we print the value of i using System.out.println(i)."
"A table shows the values of i, the condition (i<5), the printed value, and the new value of i after each iteration."
"- Initially, i is 0, the condition is true, 0 is printed, and i is incremented to 1.
- In the next iteration, i is 1, the condition is true, 1 is printed, and i becomes 2."
"- This process continues until i reaches 4. 4 is printed, and i is incremented to 5.
- Now, the condition (i<5) becomes false, and the loop terminates."
1.B. For
"When the loop has several statements in initialization, condition or update, they will be separated by commas"
". For example, we have a for loop with int i equals 0 comma int sum equals 0, and then i less than or equal to 5 semicolon i plus plus comma sum plus equals 5. Inside the curly braces, we have statements and then the closing curly brace."
"1.B. For
 four examples of for loops in a C-like programming language."
"The first loop initializes an integer variable i to 0. The loop continues as long as i is less than 10. In each iteration of the loop, the value of i is incremented by 2."
"The second loop also initializes an integer variable i to 0. However, the loop condition checks if i is less than 10 after setting i to 13. Since 13 is not less than 10, the loop will not execute"
". In each iteration of the loop, the value of i is incremented by 2."
"The third loop initializes an integer variable i to 4. The loop continues as long as i is less than 10. In each iteration of the loop, the value of i is incremented by 2."
"The fourth loop initializes two integer variables, i and sum, to 0 and 5, respectively. The loop continues as long as i is less than 10. In each iteration of the loop, the value of sum is incremented by i, and the value of i is incremented by 8."
" two questions:
* How many times are these loops executed?
* What is the value of ""i"" in each example at the end of the loop?"
**While vs. For**
"This table describes when to use a ""for"" loop and when to use a ""while"" loop. Use a ""for"" loop when the number of iterations is known, for example when iterating over an array"
". Use a ""while"" loop when the number of iterations is unknown, or when the variables are incremented in each cycle."
"Examples of when to use a ""while"" loop include reading a file. Examples of when to use a ""for"" loop include covering an array."
1.C. Do-While
"The code snippet shows a do-while loop in Java. The loop starts by initializing an integer variable 'i' to 5. Inside the loop, the value of 'i' is printed to the console using System.out.println(i)"
". Then, 'i' is decremented by 1 using the decrement operator. The loop continues to execute as long as the condition 'i > 0' is true."
"The table shows the values of 'i', the printed output, the new value of 'i' after each iteration, and the condition evaluation result. The loop iterates 5 times, printing the values 5, 4, 3, 2, and 1"
". After the fifth iteration, 'i' becomes 0, and the condition 'i > 0' evaluates to false, terminating the loop."
"Summary
for VS. while VS. do-while
The table compares the for, while, and do-while loops in terms of initialization of variables, updating variables, minimum number of executions, and frequency of use."
"- The for loop initializes and updates variables, has a minimum of 0 executions, and is frequently used.
- The while loop does not initialize or update variables, has a minimum of 0 executions, and is frequently used."
"- The do-while loop does not initialize or update variables, has a minimum of 1 execution, and is not used as frequently as the for and while loops."
Additional remarks
"- Nested loops: Program slows down
- The statements in a *while* or *for* might never run; in a *do-while* statements are executed at least once
- Avoid infinite loops (always check termination condition)"
"- A *for* loop always can be converted into a *while* loop, and vice versa"
"Exercise 1
We are asked to write a method that prints numbers from 1 to 100 in steps of seven. The expected output is 1 8 15 22 29 36 43 50 57 64 71 78 85 92 99. We should think of an efficient solution."
Exercise 2
" an exercise to write a method that calculates whether an input number n is prime. The expected output should state if the number is prime or not. For example, for the number 13, the output should be ""13 is a prime number"""
". For the number 16, the output should be ""16 is not a prime number""."
"There is also a reminder at the bottom of  says ""Remember that a prime number is a positive integer number that has no positive divisors other than 1 and itself."""
"Exercise 2:
Step 1: Think about the algorithm"
"Split the problem into simpler steps:
- Starting by 2, check for each number if it is an integer divisor of n
- We only needs to repeat it until n/2
- Or until we find an integer divisor
- We will use a boolean variable as ""sentinel"""
"Exercise 2:
Step 2: Represent the algorithm"
"The image shows a flowchart with a title ""Flowchart"" and a series of steps to check if a number is prime.
- It starts by setting a variable named ""divisor"" to 2 and a variable named ""isPrime"" to true."
"- Then it checks if the divisor is less than half of n and if isPrime is true.
- If both conditions are true, it checks if the remainder of the division of n by the divisor is equal to 0.
- If the remainder is 0, it sets isPrime to false."
"- If any of the conditions are false, it increments the divisor by 1.
- The flowchart ends with a return to the previous step."
"Exercise 2: Step 3: Write the code
We have a piece of code written in Java. This code determines if a given number is a prime number."
"The main function takes an array of strings as an argument. If the array is not empty, it parses the first element as an integer and calls the isPrime function"
". Depending on the boolean value returned by the isPrime function, it prints a message indicating whether the number is prime or not."
The isPrime function takes an integer as an argument and returns a boolean value. It initializes two variables: divisor to 2 and isPrime to true
". It then enters a while loop that continues as long as the divisor is less than half of the input number and isPrime is true. Inside the loop, it checks if the input number is divisible by the current divisor. If it is, it sets isPrime to false"
". The divisor is incremented by one in each iteration of the loop. Finally, the function returns the value of isPrime."
"On the right-hand side, we have a flowchart illustrating the logic of the isPrime function. The flowchart starts by initializing the divisor to 2 and isPrime to true"
". It then enters a loop that continues as long as the divisor is less than half of the input number and isPrime is true. Inside the loop, it checks if the input number is divisible by the current divisor. If it is, it sets isPrime to false"
". The divisor is incremented by one in each iteration of the loop. Finally, the flowchart ends with the isPrime value."
"2. Arrays
The image shows rows of empty chairs."
2. Arrays
"Arrays are sets of elements belonging to the same data type. The index operator, represented by square brackets, is used to set or retrieve individual elements from the array. The length attribute returns the number of elements in the array"
". The range of the index is from 0 to length minus 1. It's important not to exceed the maximum length of the array, otherwise an IndexOutOfBoundsException will be thrown."
"The image shows a set of colorful lockers, representing an array. Each locker is labeled with an index from 0 to 3."
Arrays
The index of the first element in an array is zero. The index of the last element in an array is equal to the length of the array minus one. The index of the nth element in an array is equal to n minus 1
. The index of an array is an integer expression that must be greater than or equal to zero and less than or equal to the length of the array minus one.
The image shows an array named c with 10 elements. The first element is -7 and the last element is 2.
2.A. Declaration
Assigning an identifier to the array and specify the data type of the elements that will be stored
". There are two code snippets: ""type arrayName[];"" and ""type[] arrayName;"" in the first box and ""int arrayName[];"" and ""boolean[] arrayName;"" in the second box. No memory to store the array is allocated in the declaration"
. The contents cannot be accessed yet.
"2.B. Creation
To create an array, you need to allocate memory for it. This is done using the reserved word ""new"" and specifying the array size. Once created, the elements have default values until the array is initialized."
"The syntax for creating an array is:
- arrayName[] = new type[arraySize];
For example, to create an array of integers named ""arrayName"" with a size of 10, you would use the following code:
- arrayName[] = new int[10];"
"The default values for the different data types are:
- int, short, long = 0
- float, double = 0.0
- boolean = false
- String = null
- Object = null"
"2.C. Initialization
We are going to see how to assign values to each of the elements of the array.
The first method is to assign values element by element. For example, we can assign element0 to arrayName at index 0 and element1 to arrayName at index 1."
"The second method is to use a loop. We can iterate from i equals 0 until i is less than the length of the array, incrementing i at each step. For each index i, we assign element-i to arrayName at index i."
"The third method is direct assignment. We can assign the list of elements to arrayName. For example, we can assign the list containing eleml, elem2, elem3, etc. to arrayName."
"Examples
We have three different ways to declare and initialize an integer array in Java."
"The first example shows how to declare an array variable, create an array object, and then initialize the array elements. First, we declare an integer array variable named ""a"" using square brackets"
". Then, we create a new integer array object of size 3 and assign it to the variable ""a"". Finally, we initialize the array elements individually."
"The second example shows how to declare an array variable, create an array object, and initialize the array elements in a single statement"
". We declare an integer array variable named ""a"" using square brackets and assign it to a new integer array object of size 3. We then initialize the array elements individually."
"The third example shows how to declare an array variable, create an array object, and initialize the array elements using a for loop"
". We declare an integer array variable named ""a"" using square brackets and assign it to a new integer array object of size 3. We then use a for loop to iterate over the array elements and initialize each element to its index plus 1."
"The fourth example shows how to declare, create, and initialize an array in a single statement. We declare an integer array variable named ""a"" using square brackets and assign it to an array literal containing the values 1, 2, and 3."
"Common errors
 a common error when working with arrays in programming.
The code declares a double array variable named ""myArray"" but doesn't initialize it. Then, the code attempts to print the value of the first element of the array."
"This will result in a compilation error because the array has been declared but not created or initialized, so its elements cannot be accessed"
". The program will not compile and will display an error message indicating that the variable ""myArray"" may not have been initialized."
"**Common errors**
We see here a code snippet, written in Java, that shows how to declare and initialize arrays of different data types."
"The code first declares and creates five arrays:- `myArrayOfIntegers` of type integer
- `myArrayOfFloats` of type float
- `myArrayOfBooleans` of type boolean
- `myArrayOfCharacters` of type char
- `myArrayOfStrings` of type String"
"Each array has a size of 10.
Then the code prints the value of the first element of each array."
"The output of the code will be the default values for each data type:
- 0 for integer
- 0.0 for float
- false for boolean
- a space character for char
- null for String"
"The code highlights a common error in Java: when an array is declared and created but not initialized, we can still retrieve its elements, but they will have their default values."
"A diagram shows the compilation and execution flow of the code. The code is first compiled, and then it is run. The output of the code is shown in the ""Run"" box."
Exercise 3
"We're tasked with writing a method that takes a set of integers as input and prints their sum. For instance, if the input is the set containing 1, 2, 3, and 4, the method should output 10.  We can assume the input will always consist of integers"
". If no input is provided, the method should output 0."
"Exercise 4
We're tasked with writing a method that takes a set of integers as input and prints the maximum value. For example, if the input is the set containing 1, 2, 3, and -4, the method should print 3."
"We should assume that the input will always be integer values. If no input is received, the program should print the smallest integer value in Java, which is `Integer.MIN_VALUE`."
"N-dimensional Arrays
When we need more than one index to set and retrieve the elements of an array, we can use N-dimensional arrays.
 two examples of how to declare and initialize a 3x3 array in Java."
"The first example shows how to create a 3x3 array initialized to 0.
The second example shows how to create a 3x3 array and initialize it with the values 1, 2, 3, 4, 5, 6, 7, 8, and 9."
"N-dimensional Arrays
The image shows two diagrams representing two-dimensional and three-dimensional arrays, and code snippets for declaring, creating, and initializing them."
The first diagram represents a two-dimensional array with three rows and three columns. Each cell in the array contains a letter. The element in the first row and third column is 'C'.
"The second diagram represents a three-dimensional array with three rows, three columns, and three layers. Each cell in the array contains a letter. The element in the first row, third column, and second layer is 'l'."
"The code snippets show how to declare, create, and initialize two-dimensional and three-dimensional arrays in a programming language"
". The first snippet declares a two-dimensional array 'a' of characters, creates a 3x3 array, and initializes the element at index [0][0] to 'A'"
". The second snippet declares a three-dimensional array 'a' of characters, creates a 3x3x3 array, and initializes the element at index [0][0][0] to 'a'."
Exercise 5
We're tasked with writing a Java method with the signature `public static int max(int[][] a)`. This method takes a two-dimensional array of integers as input and prints the maximum value found within the array
". For instance, if the input array is `{{1, -2, 8, -4},{3, -1, 7, -2}}`, the method should output `8`."
"Additionally, we need to handle the case where the input array is empty. In this scenario, the method should print the smallest possible integer value in Java, which is represented by the constant `Integer.MIN_VALUE`."
Exercise 6
"We are asked to write a Java method with the signature `public static int rowSum(int[][] a, int r)`. This method takes a two-dimensional integer array `a` and an integer `r` as input"
". It calculates and prints the sum of the elements in row `r` of the array, assuming zero-based indexing."
"For instance, if the input array `a` is `{{1, -2, 3, -4},{3, -1, 7, -2}}` and `r` is `1`, the method will print `7`, which is the sum of the elements in the second row (3 + (-1) + 7 + (-2))."
"The input is assumed to always consist of a two-dimensional integer array and an integer. If no input is provided, the program should display an error message."
"2
Overview
. Sorting (advanced algorithms)
A. Heap Sort
B. Merge Sort
C. Quick Sort"
"3
. Sorting (Advanced)"
"4
.1 Heap
v Hierarchical data structure in the form of a tree
• With the root on top
• And the leaves at the bottom
v Every parent node (ascendant) can have 0, 1 or 2 children
(descendant)"
"v All the levels are complete except maybe for the last one
where nodes are arranged from left to right
v Types:
• Max-heap: parents contain larger values than children
• Min-heap: parents contain smaller values than children"
"5
.1 Heap: Example
Root (no parent)
The parent of 4 and 5
A child of 2
LeavesHojas
(no children)
(sin hijos)
Min-heap
LeavesHojas
(no children)
(sin h"
"6
.1 Heap: Example (completeness)









Complete
Not a heap: it is not complete
Not complete"
"7
.1 Heap: Example (values in the nodes)









Not a heap: values in some childrenare lower than those of the parent"
"8
.1 Heap: Example









Min-Heap"
"9
.1 Heap: From the array to the heap



p(root)=0
p(x.left)=2*p(x)+1
p(x.right)=2*p(x)+2




 2 3 4 5 6 7
    1    2    3    4    5    6"
"10
.1 Heap Sort
.
Improved version of Selection Sort
. Two steps:
´ (In ascending order from low to high)
´ Build a heap
´ Binary tree, complete, values in parents are higher than in children
´ Parent with index i"
"´ Left child with index 2*i +1
´ Right child with index 2*i+2
´ The highest element of the heap is swapped with the last unsortedelement. The heap must be updated after the removal of the root."
"https://www.cs.usfca.edu/~galles/visualization/HeapSort.html
http://www.algostructure.com/sorting/heapsort.php
http://www.cs.armstrong.edu/liang/animation/web/Heap.html"
"11
.1 Heap Sort. Example (I)
• Ascending order (from the lowest to the highest)
q Build the heap from the array
q Root in position i (starting from 0)
q Left (child) node: 2*i + 1
q Right (child) node: 2*i + 2
Let’s build a Max-heap"
"12
.1 Heap Sort. Example (II)
•
Step 1: Ordering the heap (root is higher than children)
•"
"Starting from the penultimate row to the right, check if the children is higherthan the parent
Nodes go down to their corresponding position
Swapping 66 and 14
Swapping 98 and 95
Swapping 98 and 80
Swapping 95 and 80
•
.
.
.
."
98 95 66 80 29 49 14
"13
.1 Heap Sort. Example (III)
•
Step 2: Extracting the root and reordering the heap
.
.
Taking 98 and placing it at the end (sorted). The root becomes 14.
Replacing 14 by the highest element of the array (95) and reordering the heap

"
"14
.1 Heap Sort. Example (IV)
•
Step 2: Extracting the root and reordering the heap
.
.
Taking 95 and placing it at the end (sorted). The root becomes 49.
Replacing 49 by the highest element of the array (80) and reordering the heap

"
"15
.1 Heap Sort. Example (V)
•
Step 2: Extracting the root and reordering the heap
.
.
Taking 80 and placing it at the end (sorted). The root becomes 29.
Replacing 29 by the highest element of the array (66) and reordering the heap

"
"16
.1 Heap Sort. Example (VI)
•
Step 2: Extracting the root and reordering the heap
.
.
Taking 66 and placing it at the end (sorted). The root becomes 14.
Replacing 14 by the highest element of the array (49) and reordering the heap

"
"17
.1 Heap Sort. Example (VI)
•
Step 2: Extracting the root and reordering the heap
.
.
."
"Taking 49 and placing it at the end (sorted). The root becomes 29.
Taking 29 and placing it at the end (sorted). The root becomes 14.
Taking 14. The heap is empty
 29 49 66 80 95 98"
"18
.1 Heap Sort. Two external loops
. External loop 1 (Step 1): Building the heap
o
o
For each node, checking that the children are smaller
Number of iterations: half the length of the array
•
•"
"Traversing all the nodes except for the leaves (they do not have children)
Range of the index of external loop 1 [0, length of array - 2)/2]
.
Internal loop 2 (Step 2): Extracting the root and reordering
o
o"
"The root is extracted, placed at the end of the data structure, and theheap is reordered
Number of iterations: length of array
•
Range of the index of external loop 2 [0, length of array - 1]
. After m-th iteration (i=m-1) of the external loop 2:"
"o
o
Elements from 0 to length of array - 2 - i are unsorted
Elements from length of array - 1 - i to length of array - 1 are sorted"
"19
.1 Heap Sort. Code (I)
public static void heapSort(int[] a) {
for (int i=(a.length-2)/2; i>=0; i--)
heapify(a,i,a.length-1);
for (int i=a.length-1; i>=0; i--) {
swap(a,0,i);
heapify(a,0,i-1);
}
}"
"public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
"20
.1 Heap Sort. Code (II)
private static void heapify(int[] a, int i, int m) {
int j;
while(2*i+1<=m) {
j=2*i+1;
if(j<m) {
if(a[j]<a[j+1])
j++;
}
if(a[i]<a[j]) {
swap(a,i,j);
i=j;
} else
i=m;
}
}"
"21
Exercise 1
´ Using the sorting algorithm Heap Sort, how many
swaps are needed to sort the following array from thelowest element to the highest element (ascendingorder)?
{7,3,13,1,11,5}"
"22
.1 Heap Sort: Conclusions
v Advantages:
´ Efficient for arrays with many elements, even in the worse case
v O(n log n)
´ Little additional memory is needed
v Drawbacks:
´ Complex code"
"23
.2 Merge Sort
. Divide the array in two subarrays
of approximately the samelength (half the original array)
. Divide each subarray recursivelyuntil we have subarrays of length1, in which case that array isreturned"
"3. Merge the two subarrays in a
new sorted subarray recursively
http://www.algostructure.com/sorting/mergesort.php
http://www.cs.armstrong.edu/liang/animation/web/MergeList.html"
"24
.2 Merge Sort. Example (I)
• Ascending order (from the lowest to the highest)
 95 14 98
 49 66
 95
 98
 49







"
"25
.2 Merge Sort. Example (II)






 95
 98
 49


 80 95 98
 49 66
 29 49 66 80 95 98"
"26
.2 Merge Sort. Recursive division andmerging with auxiliary array
. Recursive division (Step 1)
o Given an array (or part of it) with l the first position, r the last
position and m the half position ((l+r)/2)"
"o Divide the array recursively in two until l and r are equal
•
•
From l to m
From m+1 to r
. Sorting by merging subarrays (Step 2)
o Create an auxiliary array containing the two subarrays to sort
o Compare the elements to sort of each subarray"
"•
Elements are not in their final correct position until wefinish merging subarray"
"27
.2 Merge Sort. Code (I)
public static void mergeSort (int[] a) {
mSort(a, 0, a.length-1);
}
public static void mSort (int[] a, int l, int r) {
if (l>=r){
return;
}
int m = (l+r)/2;
mSort(a, l, m);
mSort(a, m+1, r);
merge(a, l, m, r);
}"
"28
.2 Merge Sort. Code (II)
public static void merge (int[] a, int l, int m, int r){
if (m+1>r){ return; }
int[] b = new int[a.length];
for (int i=l; i<m+1; i++) {
• The left subarray is copied as it is in the auxiliary
b[i] = a[i];
array"
"}
for (int i=m+1; i<r+1; i++){
b[i] = a[r+m+1-i];
}
int k=l;
int j=r;
for (int i=l; i<r+1; i++) {
if (b[k] <= b[j]){
a[i] = b[k];
k++;
} else {
a[i] = b[j];
j--;
}
}
}
• The right subarray is copied in the auxiliary array
in reverse order"
"• The merging starts from the two ends of the
auxiliary array, which contain the elements withthe lowest values of each subarray"
"29
Exercise 2
´ Using the sorting algorithm Merge Sort, describe the
process needed to sort the following array in ascendingorder.
´ Unlike in other cases, with Merge Sort there are no
swapping in the arrays, as we are using an auxiliary array"
"{7,3,13,1,11,5}"
"30
.2 Merge Sort: Conclusions
v Advantages:
´ Efficient for arrays with many elements, even in the worse case
v O(n log n)
´ Highly parallelizable
v Drawbacks:
´ Complex code
´ Requires more memory space to store more auxiliary variables"
"(e.g., auxiliary array)"
"31
.3 Quick Sort
. Choose an element: the pivot
. Reorder the data structure so that
´ elements lower than the pivot are on its left
´ elements higher than the pivot are on its right
. Sort recursively"
"´ the part whose elements are lower than the pivot
´ the part whose elements are higher than the pivot
http://www.algostructure.com/sorting/quicksort.php
http://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html"
"32
.3 Quick Sort. Example (I)
• Ascending order (from the lowest to the highest)
q 80 is the pivot
q Move forward from the left until a
value is higher than 80
q Move forward from the right until a
value is lower than 80"
"q Swap the two values
q Repeat until converging"
"33
.3 Quick Sort. Example (II)"
"34
.3 Quick Sort. Example (III)
q Repeat recursively for theleft and right partitions"
"35
.3 Quick Sort. Recursive partition andsorting by swapping
. Recursive partition (Step 1):
o Given an array (or part of it) with l the first position, and r the
last position
o
o"
"We have to run an algorithm that tell us where to do the partition (elements on theleft lower than the pivot, and elements on the right higher than the pivot)
The next partition is computed recursively
. Sorting by swapping (Step 2):"
"o Moving forward from the left, and from the right, comparting
with the pivot and swapping as needed
o
Placing the pivot in its correct location
. Pivots are always placed in their final sorted position"
"36
.3 Quick Sort. Code (I)
public static void quickSort (int[] a) {
qSort(a, 0, a.length-1);
}
public static void qSort (int[] a, int l, int r) {
if (l>=r){
return;
}
int m = partition(a, l, r);
qSort(a,l,m-1);
qSort(a,m+1,r);
}"
"37
.3 Quick Sort. Code (II)
public static int partition (int[] a, int l, int r) {
int i=l+1; // left
int j=r; // right
int p=a[l]; // pivot
while (i<=j) {
if (a[i]<=p){
i++;
} else if (a[j]>p){
j--;
} else{
swap(a,i,j);"
"• Comparing with a[i]. When we find anelement higher than a[i] on the left, andan element lower than a[i] on the right:swap(a,i,j)
• Before finishing the pivot must be placed
its the correct location: swap(a,l,j)
}
}swap(a,l,j);
return j;"
"}
public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
"38
Exercise 3
´ Using the sorting algorithm Quick Sort, how many swapsare needed to sort the following array from the lowestelement to the highest element (ascending order)?
{7,3,13,1,11,5}"
"39
.3 Quick Sort: Conclusions
v Advantages:
o Very efficient for arrays with many elements
v O(n log n)
v But the worse case is O(n2)!
o Little additional memory
o Highly parallelizable
v Drawbacks:
´ Complex code"
"40
Comparison"
"41
Comparison
v Basic algorithms (Bubble, Insertion, Selection)
o
o
o
Average complexity O(n2)
v Inefficient with many elements
Simple code
Little use of memory
v Advanced algorithms (Heap, Merge, Quick)
o
o
o
Average complexity O(n log n)"
"v Efficient with many elements
Complex code
Little use of memory (except Merge Sort)
https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html
https://www.cs.usfca.edu/~galles/visualization/HeapSort.html"
"Overview
 ""Overview"" outlines advanced sorting algorithms, specifically Heap Sort, Merge Sort, and Quick Sort."
"1. Sorting (Advanced)
The image shows a long narrow room with wooden shelves on both sides. The shelves are empty and the room is dimly lit. The floor is made of concrete and there is a window at the far end of the room."
1.1 Heap
"A heap is a hierarchical data structure in the form of a tree, with the root on top and the leaves at the bottom. Every parent node, also known as an ascendant, can have 0, 1, or 2 children, which are also known as descendants"
". All the levels of the tree are complete, except maybe for the last one, where nodes are arranged from left to right."
"There are two types of heaps: max-heap and min-heap. In a max-heap, parent nodes contain larger values than their children, while in a min-heap, parent nodes contain smaller values than their children."
1.1 Heap: Example
We see a diagram representing a min-heap data structure. The nodes in the heap are numbered from 1 to 7. Node 1 is the root of the heap and has no parent. Node 2 is the parent of nodes 4 and 5. Node 4 is a child of node 2
". Nodes 4, 5, 6 and 7 are leaves and have no children."
"1.1 Heap: Example (completeness)
We see an example of a heap, which is not a heap because it's not complete. The heap is a binary tree with nodes 1, 2, 4 at the first level, 3, 5, 6, 9 at the second level, and 8, 7 at the third level."
"On the right side, we see two examples of trees that are not complete. The first tree is not complete because it's missing a node on the last level. The second tree is not complete because it's missing a node on the second to last level."
1.1 Heap: Example (values in the nodes)
We have a tree with nodes containing numerical values. The root node contains the value 1. The children of the root node are 3 and 4. The children of 3 are 2 and 5. The children of 4 are 6 and 9. The children of 2 are 8 and 7.
This is not a heap because the values in some children are lower than those of the parent.
"1.1 Heap: Example
 a min-heap data structure with an example.
The example is a tree with 7 nodes. The nodes, from top to bottom and left to right, contain the following values: 1, 2, 4, 3, 5, 6, 9, 8, 7."
"The text ""Min-Heap"" is found below the tree."
1.1 Heap: From the array to the heap
"We have a binary tree with nodes numbered 1 at the root, 2 and 3 on the next level, and 4, 5, 6, and 7 on the bottom level. The tree is also represented as an array with the same numbers in the same order. The array indices are 0 through 6"
". The relationship between a node's position in the tree, p, and its children is given by the following equations:"
"- p(root) = 0
- p(x.left) = 2 * p(x) + 1
- p(x.right) = 2 * p(x) + 2
where x.left is the left child and x.right is the right child."
"1.1 Heap Sort
 the Heap Sort algorithm, which is an improved version of Selection Sort."
"It has two steps:
. Build a heap
 - A heap is a binary tree that is complete, meaning all levels are full except for the last level, which is filled from left to right.
 - Values in parent nodes are higher than the values in their children."
"- The index of the parent node is i, the left child is 2*i+1, and the right child is 2*i+2.
. Swap the highest element of the heap, which is the root, with the last unsorted element. Update the heap after removing the root."
 provides three links to external resources.
"Heap Sort. Example (I)
The image describes the process of building a Max-heap from an array of numbers, as part of the Heap Sort algorithm. The goal is to sort the numbers in ascending order, from the lowest to the highest."
"The initial array contains the following numbers: 80, 95, 14, 98, 29, 49, and 66.
The first step is to build a Max-heap from this array. The heap is represented as a binary tree, where each node corresponds to an element of the array."
"The root of the heap is at position 0, which contains the number 80. The left child of a node at position 'i' is located at position '2*i + 1', and the right child is at position '2*i + 2'."
"The image shows the initial state of the heap, with the number 80 at the root. The arrows indicate the parent-child relationships between the nodes. The green arrows point to the left children, and the black arrows point to the right children."
"The next step is to ""heapify"" the tree, which involves rearranging the nodes to satisfy the Max-heap property: the value of each node should be greater than or equal to the values of its children."
"The image does not show the heapify process itself, but it indicates that the next step is to build the Max-heap."
"1.1 Heap Sort. Example (II)
The image describes the first step of the heap sort algorithm, which is ordering the heap. The main rule is that the root is higher than the children."
"The first step is to start from the penultimate row to the right, check if the children are higher than the parent, and if so, swap them.
 a binary tree with some nodes. The nodes contain the following values: 80, 95, 14, 98, 29, 49, 66."
"The algorithm performs the following swaps:
- Swap 66 and 14
- Swap 98 and 95
- Swap 98 and 80
- Swap 95 and 80
The final result of the heap ordering is shown in a table containing the following values: 98 95 66 80 29 49 14."
1.1 Heap Sort. Example (III)
" step 2 of extracting the root and reordering the heap in a heap sort example. The first point says that 98 is taken and placed at the end, which is considered sorted. The root then becomes 14"
". The second point says that 14 is replaced by the highest element of the array, which is 95, and then the heap is reordered. There are two diagrams with eight nodes each that illustrate these two points"
". The first diagram has, from left to right, the following values for its nodes: 14, 95, 66, 80, 29, 49, and 98. There is a black arrow pointing from node 14 to node 95 and a green arrow pointing from node 95 to node 29"
". There is also a black arrow pointing from node 14 to node 66 and a black arrow pointing from node 66 to node 49. The second diagram has, from left to right, the following values for its nodes: 95, 80, 66, 14, 29, and 49"
. There is a black arrow pointing from node 95 to node 80 and a green arrow pointing from node 80 to node 29. There is also a black arrow pointing from node 95 to node 66 and a black arrow pointing from node 66 to node 49.
"1.1 Heap Sort. Example (IV)
The image illustrates step 2 in the heap sort algorithm, which involves extracting the root and reordering the heap."
"We have two diagrams, each representing an array of numbers organized in a binary tree structure. The first diagram shows the initial state of the heap, while the second diagram shows the heap after the root has been extracted and reordered."
"In the first diagram, the root node contains the value 49, and its children are 80 and 66. The left child of 80 is 14, and the right child of 80 is 29. The left child of 66 is not shown, and the right child of 66 is not shown."
"In the second diagram, the root node contains the value 80, and its children are 49 and 66. The left child of 49 is 14, and the right child of 49 is 29. The left child of 66 is not shown, and the right child of 66 is not shown."
The process of extracting the root and reordering the heap involves the following steps:
"1. The root node (95) is swapped with the last element in the heap (49).
. The root node (49) is removed from the heap, and the heap is reordered to maintain the heap property.
. The highest element in the array (80) is moved to the root node."
4. The heap is reordered to maintain the heap property.
The red vertical line in the array representation separates the sorted part of the array from the unsorted part. The sorted part of the array is located to the right of the red line.
1.1 Heap Sort. Example (V)
"We are looking at step 2 of a heap sort example. Step 2 is extracting the root and reordering the heap. This step has two sub-steps: first, taking 80 and placing it at the end, which is now sorted. The root becomes 29"
". Second, replacing 29 by the highest element of the array, which is 66, and reordering the heap."
"On the left side, we see a diagram of the heap before the operation. The root is 80, its children are 49 and 66, and so on. On the right side, we see the heap after the operation. The root is now 66, its children are 49 and 29, and so on"
. The element 80 is not shown in the heap anymore.
1.1 Heap Sort. Example (VI)
"The image illustrates step two of a heap sort algorithm example. Step two is extracting the root and reordering the heap. This step has two sub-steps. The first sub-step is taking 66 and placing it at the end, which is sorted. The root then becomes 14"
". The second sub-step is replacing 14 by the highest element of the array, which is 49, and reordering the heap."
"There are two diagrams, one for each sub-step. Both diagrams are essentially the same, with the only difference being the numbers in the nodes. Each diagram consists of seven nodes"
. The top node has the value 14 in the first diagram and 49 in the second diagram
". The top node has two child nodes, the left child node has the value 49 in the first diagram and 14 in the second diagram, and the right child node has the value 29 in both diagrams"
". The left child node has two child nodes, with the values 14 and 29 in the first diagram, but in the second diagram, the values are not visible. The right child node does not have any child nodes"
". The nodes with values 66, 80, 95, and 98 are not part of the tree structure. The first diagram has the number one below it, and the second diagram has the number two below it"
. There is a red vertical line between the values 29 and 66 in the list of numbers above the diagrams
". In the first diagram, there is a black arrow pointing from the node with the value 14 to the node with the value 49, and there is a green arrow pointing from the node with the value 14 to the node with the value 29"
". In the second diagram, there is a black arrow pointing from the node with the value 49 to the node with the value 14, and there is a green arrow pointing from the node with the value 49 to the node with the value 29."
1.1 Heap Sort. Example (VI)
" step 2 of extracting the root and reordering the heap in a heap sort example. The first step is to take the root node with value 49 and place it at the end of the heap, which is now considered sorted. The root node then becomes 29"
". Next, take the new root node 29 and place it at the end of the heap before the previously placed 49. The root node is now 14. Finally, take the last root node 14 and place it at the end of the heap. The heap is now empty"
". The sorted array is 14, 29, 49, 66, 80, 95, and 98."
"1.1 Heap Sort. Two external loops
We are going to talk about the two external loops of the heap sort algorithm."
"The first external loop, which corresponds to step one of the algorithm, is about building the heap. For each node, we check that the children are smaller than the node. The number of iterations is half the length of the array"
". We are traversing all the nodes except for the leaves, because the leaves do not have children. The range of the index of this external loop one is from zero to length of the array minus two, divided by two."
"The second external loop, step two, is about extracting the root and reordering the data structure. The root is extracted and placed at the end of the data structure, and the heap is reordered. The number of iterations is the length of the array"
. The range of the index of this external loop two is from zero to the length of the array minus one.
"After m-th iteration, with index equals m minus one, of the external loop two: the elements from zero to length of array minus two minus i are unsorted, and the elements from length of array minus one minus i to length of array minus one are sorted."
1.1 Heap Sort. Code (I)
"The image shows two code snippets. The first one is a function called ""heapSort"" which takes an array of integers as input. It first iterates over the array from the middle to the beginning, calling the function ""heapify"" for each element"
". Then it iterates over the array from the end to the beginning, swapping the first element with the current one and calling ""heapify"" again for the first element and the index of the current element minus one."
"The second snippet is a function called ""swap"" which takes an array of integers and two integers as input. It swaps the elements at the indices given by the two integers."
1.1 Heap Sort. Code (II)
"The image shows a code snippet of a private static method called ""heapify"" which takes as input an integer array ""a"", an integer ""i"" and an integer ""m"". The method first declares an integer variable ""j"""
". Then, it enters a while loop with the condition ""2*i+1 less than or equal to m"". Inside the loop, ""j"" is assigned the value of ""2*i+1"". Then, there is an if statement with the condition ""j less than m"""
". Inside this if statement, there is another if statement with the condition ""a[j] less than a[j+1]"". If this condition is true, ""j"" is incremented. After the nested if statement, there is another if statement with the condition ""a[i] less than a[j]"""
". If this condition is true, the method calls another method called ""swap"" with the parameters ""a"", ""i"" and ""j"", and then assigns ""j"" to ""i"". If the condition ""a[i] less than a[j]"" is false, the else block assigns ""m"" to ""i"""
". The while loop continues until the condition ""2*i+1 less than or equal to m"" is false."
"Exercise 1
We are asked to calculate how many swaps are needed to sort an array from lowest to highest element using the Heap Sort algorithm. The array is: 7, 3, 13, 1, 11, and 5."
"1.1 Heap Sort: Conclusions
Heap sort has the following advantages: it is efficient for arrays with many elements, even in the worst case. Its time complexity is O(n log n). It requires little additional memory."
Heap sort has the following drawback: its code is complex.
"Merge Sort
The image describes the Merge Sort algorithm in 3 steps. The steps are visualized with a diagram representing an array of numbers as it is being sorted."
"Step 1: Divide the array in two subarrays of approximately the same length (half the original array).
Step 2: Divide each subarray recursively until we have subarrays of length 1, in which case that array is returned."
Step 3: Merge the two subarrays in a new sorted subarray recursively.
"The diagram shows the array being split in half repeatedly until each element is isolated. Then, the algorithm starts merging the elements back together in sorted order. For example, 38 and 27 are merged into 27 and 38"
". Then, 43 and 3 are merged into 3 and 43. This continues until the array is sorted."
The final sorted array is: 3 9 10 27 38 43 82.
"1.2 Merge Sort. Example (I)
 the merge sort algorithm, and shows an example of sorting a list of numbers in ascending order.
The list of numbers to be sorted is: 80, 95, 14, 98, 29, 49, 66."
The algorithm works by recursively dividing the list into smaller sub-lists until each sub-list contains only one element
". Then, the sub-lists are repeatedly merged together in pairs, sorting the elements in each pair, until the original list is reconstructed in sorted order."
The diagram shows the steps of the merge sort algorithm applied to the list of numbers. Each level of the diagram represents a step in the algorithm. The top level shows the initial list of numbers. The next level shows the list divided into two sub-lists
". The following levels show the sub-lists being merged together in pairs, until the final sorted list is obtained at the bottom level."
1.2 Merge Sort. Example (II)
" the merge sort algorithm with an example. The input is an unsorted list of numbers: 80, 95, 14, 98, 29, 49, 66. The algorithm recursively divides the list into smaller sub-lists until each sub-list contains only one element"
". Then, it repeatedly merges the sub-lists in a sorted manner until a single sorted list is obtained"
". The diagram shows the intermediate steps of the merging process, where the numbers are combined into larger sorted sub-lists until the final sorted list is produced: 14, 29, 49, 66, 80, 95, 98."
"1.2 Merge Sort. Recursive division and merging with auxiliary array
The image describes the Merge Sort algorithm."
The first step is the recursive division of the array
". Given an array, or part of it, defined by the first position ""l"", the last position ""r"" and the half position ""m"" which is equal to (l+r)/2, the array is divided recursively in two until l and r are equal"
". The two halves are ""from l to m"" and ""from m+1 to r""."
"The second step is the sorting by merging subarrays. First, an auxiliary array is created containing the two subarrays to sort. Then, the elements of each subarray are compared to sort them"
. It is important to note that the elements are not in their final correct position until the merging of the subarray is finished.
"1.2 Merge Sort. Code (I)
This code snippet shows the implementation of the merge sort algorithm in an unspecified programming language."
"The first function, `mergeSort`, takes an integer array `a` as input and calls the `mSort` function with the array, the index of the first element (0), and the index of the last element (a.length-1)."
"The `mSort` function recursively divides the input array into two halves until the base case is reached, which is when the left index `l` is greater than or equal to the right index `r`. In this case, the function returns without doing anything"
". Otherwise, it calculates the middle index `m`, recursively calls itself for the left and right halves of the array, and finally calls the `merge` function to merge the sorted halves."
"The `merge` function, which is not shown in this code snippet, is responsible for merging the two sorted subarrays back into a single sorted array."
1.2 Merge Sort. Code (II)
" ""1.2 Merge Sort. Code (II)"" shows a code snippet of the merge function in a merge sort algorithm. The function takes as input an array ""a"", and three integers: ""l"", ""m"", and ""r"""
". The code first checks if m+1 is greater than r, if so it returns. Otherwise, it creates a new array ""b"" of the same length as ""a"". The code then enters a for loop that iterates from 1 to m+1, copying the elements of ""a"" from index 1 to m into ""b"""
". Another for loop iterates from m+1 to r+1, copying the elements of ""a"" from index m+1 to r into ""b"" in reverse order."
"There are three bullet points explaining the code:
- The first bullet point states that the left subarray is copied as it is in the auxiliary array."
- The second bullet point states that the right subarray is copied in the auxiliary array in reverse order.
"- The third bullet point states that the merging starts from the two ends of the auxiliary array, which contain the elements with the lowest values of each subarray."
"The code then initializes two integer variables ""k"" and ""j"" to 1 and ""r"" respectively. A for loop then iterates from 1 to r+1, comparing the elements of ""b"" at indices ""k"" and ""j"""
". If the element at index ""k"" is less than or equal to the element at index ""j"", the element at index ""i"" of ""a"" is set to the element at index ""k"" of ""b"" and ""k"" is incremented"
". Otherwise, the element at index ""i"" of ""a"" is set to the element at index ""j"" of ""b"" and ""j"" is decremented."
Exercise 2
"Using the sorting algorithm Merge Sort, describe the process needed to sort the following array in ascending order. Unlike in other cases, with Merge Sort there are no swapping in the arrays, as we are using an auxiliary array"
". The array is: 7, 3, 13, 1, 11, 5."
"1.2 Merge Sort: Conclusions
Merge sort has some advantages. It is efficient for arrays with many elements, even in the worst case. It has a time complexity of O(n log n). It is also highly parallelizable."
"Merge sort also has some drawbacks. It has complex code. It requires more memory space to store more auxiliary variables, for example, an auxiliary array."
1.3 Quick Sort
"A numbered list describes the quick sort algorithm:1. Choose an element: the pivot
. Reorder the data structure so that:
- elements lower than the pivot are on its left
- elements higher than the pivot are on its right
. Sort recursively:"
"- the part whose elements are lower than the pivot
- the part whose elements are higher than the pivot"
Two URLs are provided at the bottom of the slide.
"1.3 Quick Sort. Example (1)
The image describes the Quick Sort algorithm with an example."
"The algorithm sorts an array of numbers in ascending order. The first step is to choose a pivot, in this case, the first element of the array, which is 80"
". Then, the algorithm iterates through the array from both ends, comparing each element with the pivot. If the element on the left is greater than the pivot, and the element on the right is smaller than the pivot, the two elements are swapped"
". The iteration continues until the two pointers meet. At this point, the pivot is in its final sorted position. The algorithm then recursively sorts the subarrays to the left and right of the pivot."
"The example shows the first iteration of the Quick Sort algorithm on the array [80, 95, 14, 98, 29, 49, 66]. The pivot is 80. The algorithm first compares 95 and 66. Since 95 is greater than 80 and 66 is smaller than 80, they are swapped"
". The array becomes [80, 66, 14, 98, 29, 49, 95]. The algorithm then continues to iterate and compare the elements until the pointers meet."
1.3 Quick Sort. Example (II)
"The image illustrates an example of the Quick Sort algorithm. We have a list of numbers: 80, 66, 14, 98, 29, 49, and 95. The pivot is 80, which is the first element of the list. We compare each element of the list with the pivot"
". If the element is greater than the pivot, we move to the next element. If the element is smaller than the pivot, we swap it with the first element that is greater than the pivot. In this case, we swap 48 and 98"
. We repeat this process until the list is sorted.
1.3 Quick Sort. Example (III)
"We have two arrays of numbers. The first array is: 80, 66, 14, 49, 29, 98, 95. The pivot element is 80. After converging, 29 is less than 80, so we place the pivot in its correct location with a swap"
". The second array shows the result after the swap: 29, 66, 14, 49, 80, 98, 95. All the elements to the left of 80 are less than 80, and all the elements to the right of 80 are greater than 80. We repeat recursively for the left and right partitions."
"1.3 Quick Sort. Recursive partition and sorting by swapping
Quick sort has two steps: recursive partition and sorting by swapping."
"The first step, recursive partition, takes an array, or part of an array, with the first and last positions defined"
". An algorithm is run on the array to determine the partition, where elements on the left are lower than the pivot, and elements on the right are higher than the pivot. The next partition is then computed recursively."
"The second step, sorting by swapping, involves moving forward from both the left and right of the array, comparing elements with the pivot, and swapping them as needed. Finally, the pivot is placed in its correct location."
"Finally, the algorithm notes that pivots are always placed in their final sorted position."
1.3 Quick Sort. Code (I)
"This code snippet presents a Java implementation of the Quick Sort algorithm. The first function `quickSort` takes an integer array `a` as input and calls the `qSort` function with the array, the starting index `0`, and the ending index `a.length-1`."
"The `qSort` function implements the recursive part of the Quick Sort algorithm. It takes the array `a`, the starting index `l`, and the ending index `r` as input. It first checks if `l` is greater than or equal to `r`"
". If it is, it means the subarray has only one element or is empty, so it returns. Otherwise, it calls the `partition` function with the array, `l`, and `r` to partition the subarray around a pivot element"
". The `partition` function returns the index `m` of the pivot element. Finally, the `qSort` function recursively calls itself twice with the subarrays to the left and right of the pivot element: `qSort(a, l, m-1)` and `qSort(a, m+1, r)`."
1.3 Quick Sort. Code (II)
"The image shows code for a quicksort algorithm. The first function is called ""partition"" and takes an array of integers ""a"", an integer ""l"" and an integer ""r"" as input. It returns an integer"
". The function first initializes three integer variables: ""i"" to ""l+1"", ""j"" to ""r"" and ""p"" to ""a[l]"". The variable ""p"" represents the pivot element. The function then enters a while loop that continues as long as ""i"" is less than or equal to ""j"""
". Inside the loop, the function compares the value of the element at index ""i"" with the pivot element ""p"". If the value of the element at index ""i"" is less than or equal to ""p"", the value of ""i"" is incremented by 1"
". Otherwise, if the value of the element at index ""j"" is greater than ""p"", the value of ""j"" is decremented by 1. If neither of these conditions is true, the function calls the ""swap"" function with the array ""a"", ""i"" and ""j"" as input"
". This function swaps the values of the elements at indices ""i"" and ""j"" in the array ""a"". After the while loop, the function calls the ""swap"" function again with the array ""a"", ""l"" and ""j"" as input"
". This swaps the pivot element with the element at index ""j"". Finally, the function returns the value of ""j""."
"The second function is called ""swap"" and takes an array of integers ""a"", an integer ""i"" and an integer ""j"" as input. It does not return any value"
". The function first initializes an integer variable ""aux"" to the value of the element at index ""i"" in the array ""a"". Then, the function assigns the value of the element at index ""j"" to the element at index ""i"""
". Finally, the function assigns the value of ""aux"" to the element at index ""j"". This effectively swaps the values of the elements at indices ""i"" and ""j"" in the array ""a""."
"There are two bullet points describing the code. The first bullet point states that the code compares elements with the pivot element ""a[i]"""
". When the code finds an element higher than ""a[i]"" on the left side of the pivot and an element lower than ""a[i]"" on the right side of the pivot, it swaps these two elements"
". The second bullet point states that before finishing, the pivot must be placed in its correct location by swapping the pivot element with the element at index ""j""."
"Exercise 3
Using the sorting algorithm Quick Sort, how many swaps are needed to sort the following array from the lowest element to the highest element (ascending order)?
The array is: 7, 3, 13, 1, 11, 5."
"1.3 Quick Sort: Conclusions
Let's talk about the advantages and drawbacks of using the Quick Sort algorithm."
"Some of the advantages are: it is very efficient for arrays with many elements, its time complexity is Big O of n log n, it requires little additional memory, and it is highly parallelizable.
However, one of the drawbacks is that the code is complex."
Comparison
" the performance of different sorting algorithms: Insertion, Selection, Bubble, Shell, Merge, Heap, Quick, and Quick3"
". Each algorithm is tested on five different types of input data: Random, Nearly Sorted, Reversed, Few Unique, and a control group"
". The performance of each algorithm is visualized using bar graphs, with the length of the bar representing the time taken to sort the data."
Comparison
"There are two types of sorting algorithms: basic algorithms and advanced algorithms. Basic algorithms include bubble sort, insertion sort, and selection sort. These algorithms have an average complexity of O(n^2) and are inefficient with many elements"
". However, they are simple to code and use little memory. Advanced algorithms include heap sort, merge sort, and quick sort. These algorithms have an average complexity of O(n log n) and are efficient with many elements"
". However, they are more complex to code. With the exception of merge sort, they use little memory."
"3

. Representation of Data
Flip Flop
input
set (to 1)
reset (to 0)
output (0 or 1)
"
"5
Binary, Boolean
set (to 1)
reset (to 0)
set (to 1)
reset (to 0)


true
false

Binary, Boolean
=4 combinations
      0     1   1
      1     0      1
set (to 1)
reset (to 0)
set (to 1)
reset (to 0)
"
"7
Byte
000000
000001
000010
000011
000100
…
111110
111111
 = 256
combinations

Natural Numbers from 0 to 255
000000
…
000010
000011
000100
…
111110
111111




4
5
"
"9
Red Levels
000000
…
000010
000011
000100
…
111110
111111

Characters
000000
(special symbol)
…
000010
000011
000100
…
111110
111111
A
B
C
n
(special symbol)
"
"11
Weight System (Decimal)
Base 10
2 = 9*102 + 7*101 + 2*100
	*
0
+	7	*

+	2	*

 Decimal Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

Weight System (Binary)
Base 2
1 = 1*22 + 0*21 + 1*20
	*
+	0	*
+	1	*
 Binary Digits (Bits): 0, 1"
6
"13
Natural Numbers from 0 to 255
000000
000001
…
111111
000000
…
111110
111111


7
8
4
5
 = 256
combinations

Integers from -128 to 127
'scomple-
ment
 = 256
combinations
000000
000001


…"
"01111111 127
000000 -128
…
111110
111111
-2
-1
"
"15
Java Data Types for Integers
byte
 bits: -128..127
short
 bits: -32,768..32,767
int
 bits: -231..231-1
long
 bits: -263..263-1

Java Data Types for Reals
float
single-precision 32-bit
IEEE 754 floating point
double"
"double-precision 64-bit
IEEE 754 floating point
"
"17
Primitive Data Types
boolean
char
byte
short
int
long
float
double
integers
reals

Play with Unsigned & Signed Integers
´ 2.3.3 and 2.3.4
"
"2. Representation
of Programs


Edition and Execution together
"
"21
Edition and Execution separated
Execution
6
Edition

Interpretation
input
Interpretation
output
program
"
"23
Compilation
input
Compi-
lation
executable
Execu-
tion
output
Pro-
program
gram

Compilation
input
Compi-
lation
machine code
Execu-
tion
output
source
Pro-
code
gram
"
"25
Java Virtual Machine
input
Compi-
lation
byte code
JVM
machine code
Execu-
tion
output
source
Pro-
code
gram
class
librarie
s
JRE

Java Virtual Machine
input
Compi-
lation
byte code
JVM
machine code
source
Pro-
code
gram"
"class
libra-
ries
JRE
WORA
Execu-
tion
output
Execu-
tion
output
Execu-
tion
output
"
"27
Java Development Kit
input
Compi-
lation
byte code
JVM
machine code
Execu-
tion
output
source
Pro-
code
gram
class
libra-
ries
JRE
JDK
Program
public class HelloWorld {"
"public static void main(String[] args) {
System.out.println(""Hello, World!"");
}
}
"
"Program as Data
public class HelloWorld {
public static void main(String[] args) {
System.out.println(""Hello, World!"");
}
}
compiler"
"1010001001001001001001001001001010101010101
11001010010010010010001001001001000101101
10101010111010100010101001000100100100100
01001010100101000100001001000100100101001
Program as Instructions
public class HelloWorld {"
"public static void main(String[] args) {
System.out.println(""Hello, World!"");
}
}
computer
Hello, World!
"
"Secondary storage
Primary storage
4
x
5
y
6
z
run
get
set
load
output
input
I/O devices
Processing unit
"
"Slide 3
. Representation of Data
Slide 4
Flip Flop"
"The image shows a diagram of a flip flop, with two inputs and one output. The first input is labeled ""set (to 1)"" and the second input is labeled ""reset (to 0)"". The output is labeled ""output (0 or 1)""."
"Binary, Boolean
 the concept of binary values and their relation to boolean values."
"A binary value can be either 0 or 1. In this example, the value 1 is associated with the boolean value ""true"" and is represented by a lit light bulb. The value 0 is associated with the boolean value ""false"" and is represented by an unlit light bulb."
" shows that with 2 bits, we can have 2^2=4 combinations, which are: 00, 01, 10, and 11. These combinations are represented in a table with two rows and four columns. Each column represents a different combination of the two bits."
"Slide 7: Byte
 the concept of a byte. It shows a list of binary numbers, from 00000000 to 11111111, and mentions that a byte, which consists of 8 bits, can have 2⁸ = 256 different combinations.
Slide 8: Natural Numbers from 0 to 255"
 how natural numbers from 0 to 255 can be represented in binary format using a byte. It presents a list of binary numbers and their corresponding decimal values
". For example, 00000000 corresponds to 0, 00000010 corresponds to 65, and so on, up to 11111111, which corresponds to 255."
Red Levels
 how to encode characters using red levels.  The special symbol is encoded with all zeros and the color black.  A is encoded with 00000010 and a dark shade of red. B is encoded with 00000011 and a slightly lighter shade of red
. C is encoded with 00000100 and an even lighter shade of red. Another special symbol is encoded with 11111110 and a light shade of red.  The final special symbol is encoded with 11111111 and the lightest shade of red.
**Weight System (Decimal)**
" the weight system in the decimal system, or base 10. It shows the equation 972 = 9*10<sup>2</sup> + 7*10<sup>1</sup> + 2*10<sup>0</sup>. There are three bags illustrated below the equation"
". The first bag on the left has the number 100 on it and has many colorful balls in it, representing the first part of the equation, 9 * 100. The second bag has the number 10 on it and has 7 red balls in it, representing 7 * 10"
". The third bag has the number 1 on it and has 2 red balls in it, representing 2 * 1. Below the bags is the text ""10 Decimal Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9""."
**Weight System (Binary)**
" the weight system in the binary system, or base 2. It shows the equation 101 = 1*2<sup>2</sup> + 0*2<sup>1</sup> + 1*2<sup>0</sup>. There are three bags illustrated below the equation"
". The first bag on the left has 4 balls in it: one blue, one black, one purple, and one red, representing the first part of the equation, 1 * 1. The second bag has 2 yellow balls in it, representing 0 * 1"
". The third bag has 1 red ball in it, representing 1 * 1. Below the bags is the text ""2 Binary Digits (Bits): 0, 1""."
Natural Numbers from 0 to 255
 how natural numbers from 0 to 255 are represented in computer memory. It shows a table with binary numbers and their decimal representation. The first row shows the binary number 00000000 which corresponds to the decimal number 0
. The second row shows the binary number 00000001 which corresponds to the decimal number 1. The third row shows the binary number 01111111 which corresponds to the decimal number 127
. The fourth row shows the binary number 10000000 which corresponds to the decimal number 128. The fifth row shows the binary number 11111110 which corresponds to the decimal number 254
". The sixth row shows the binary number 11111111 which corresponds to the decimal number 255.  shows that 2 to the power of 8 equals 256, which is the number of possible combinations of 8 bits."
Integers from -128 to 127
 how integers from -128 to 127 are represented in computer memory using two's complement. It shows a table with binary numbers and their decimal representation
. The first row shows the binary number 00000000 which corresponds to the decimal number 0. The second row shows the binary number 00000001 which corresponds to the decimal number 1
. The third row shows the binary number 01111111 which corresponds to the decimal number 127. The fourth row shows the binary number 10000000 which corresponds to the decimal number -128
. The fifth row shows the binary number 11111110 which corresponds to the decimal number -2. The sixth row shows the binary number 11111111 which corresponds to the decimal number -1
".  shows that 2 to the power of 8 equals 256, which is the number of possible combinations of 8 bits. A callout mentions ""2's complement""."
"Java Data Types for Integers
 the Java data types for integers."
"- byte: 8 bits, ranging from -128 to 127
- short: 16 bits, ranging from -32,768 to 32,767
- int: 32 bits, ranging from -2<sup>31</sup> to 2<sup>31</sup>-1
- long: 64 bits, ranging from -2<sup>63</sup> to 2<sup>63</sup>-1
Java Data Types for Reals"
" the Java data types for reals.
- float: single-precision 32-bit IEEE 754 floating point
- double: double-precision 64-bit IEEE 754 floating point"
Primitive Data Types
"A list of primitive data types is presented, separated in two groups: integers and reals. The integers are: byte, short, int, long. The reals are: float, double.  In addition to those two groups, there are also the char and boolean primitive data types."
Play with Unsigned & Signed Integers
" how to convert between decimal and binary numbers. It shows the place values for each digit in a binary number, which are powers of 2 (2^7, 2^6, 2^5, etc.)"
". It also shows the place values for each digit in a decimal number, which are powers of 10 (10^2, 10^1, 10^0)."
"Slide 1: 2. Representation of Programs
Slide 2: Edition and Execution together"
" a calculator with a hand pressing the ""2"" key. Above the calculator, there is a piece of paper with the number ""153"" printed on it, and an arrow pointing down towards the calculator"
". Below the calculator, there is another piece of paper with the numbers ""153"" and ""2"" printed on it, separated by a horizontal line, and an arrow pointing up from the calculator."
Slide 21: Edition and Execution separated
" the concepts of edition and execution.
There are two columns, one for edition and one for execution.
In the edition column, we see a hand using a calculator to enter the numbers 153 and 2."
"An upwards arrow indicates that the result of this edition will be used as input for the execution.
In the execution column, we see a point-of-sale terminal displaying the number 256, which is the result of 153 to the power of 2."
An arrow indicates that the input of the execution is 153 to the power of 2.
Slide 22: Interpretation
" a diagram explaining the concept of interpretation.
The diagram shows a left-to-right flow going through three boxes, respectively labeled ""input"", ""interpretation"" and ""output""."
"The ""interpretation"" box has an upwards arrow pointing to a box labeled ""program""."
Compilation
"The first diagram shows the process of compilation. The input is a program, which is fed into the compilation stage. The output of the compilation stage is an executable. The executable is then fed into the execution stage, which produces the output."
"The second diagram shows the same process, but with more detail. The input is now labeled as source code. The compilation stage now produces machine code, which is then fed into the execution stage."
Java Virtual Machine
The first diagram shows the process of running a Java program. The source code is first compiled into byte code. The byte code is then executed by the Java Virtual Machine (JVM). The JVM uses the class libraries to execute the byte code
. The output of the program is then displayed.
"The second diagram shows the same process, but with the addition of the Write Once Run Anywhere (WORA) principle. WORA means that a Java program can be compiled on one platform and then run on any other platform that has a JVM"
". This is possible because the byte code is platform-independent. The second diagram shows that the same byte code can be executed on multiple platforms, each with its own JVM and machine code."
Java Development Kit
The diagram shows the process of compiling and executing a Java program. The input source code is compiled into byte code. The byte code is then executed by the Java Virtual Machine (JVM)
. The JVM uses class libraries to execute the byte code and produces output. The Java Development Kit (JDK) includes the compiler and the JRE. The JRE includes the JVM and class libraries.
"The code snippet is a simple Java program that prints the text ""Hello, World!"" to the console. The program consists of a single class called ""HelloWorld"" with a main method"
". The main method is the entry point for the program and is executed when the program is run. The System.out.println() method is used to print the text ""Hello, World!"" to the console."
"**Program as Data**
We see a snippet of Java code defining a class called ""HelloWorld"". This class has a main method that prints the text ""Hello, World!"" to the console."
"Below the code, there is a red arrow pointing to a box containing a sequence of 0s and 1s. This represents the compiled form of the Java code, where the program exists as data.
**Program as Instructions**"
"The second part shows the same Java code snippet as before. This time, a red arrow labeled ""computer"" points to a box containing the output of the program, which is the text ""Hello, World!""."
"This part illustrates that when the compiled program (the 0s and 1s) is executed by the computer, it acts as a set of instructions, leading to the desired output."
"The image shows a diagram representing the interaction between secondary storage, primary storage, the processing unit, and I/O devices."
"Starting with secondary storage, represented as a blue square containing a green circle, data is loaded into primary storage, another blue square with a green circle, labeled as ""load"". Primary storage contains three memory locations: 254, 255, and 256"
". The processing unit, depicted as a blue rectangle, interacts with primary storage through three operations: ""run,"" ""get,"" and ""set"
"."" The processing unit receives input from and sends output to I/O devices, which include a smartphone, a printer, and a keyboard."
"The image also includes two smartphone screens displaying various applications, including contacts, educational content, and utility apps."
"1. Conditional Statement
Conditional Statement
…
…
if (n<0) n=-n;
…
…

Conditional Statement
- if n is less than 0, then n equals negative n."
"Conditional Statement
…
…
if (n<0) n=-n;
…
…
n
-3

Conditional Statement
…
…
if (n<0) n=-n;
…
…
n


"
"We have a table with one column and three rows. The header of the column is ""n"". The first row contains the value ""-3"". The second row is empty. The third row contains the value ""3""."
"We also have a conditional statement: if n is less than 0, then n is equal to -n."
"We have a table with one column and three rows. The header of the column is ""n"". The first row contains the value ""3"". The second row is empty. The third row contains the value ""3""."
"We also have a conditional statement: if n is less than 0, then n is equal to -n.

We have a conditional statement and a table with two columns: n, x. The conditional statement says: if n is less than 0, then n becomes -n and x becomes 0."
"Conditional Statement
…
…
if (n<0) {
n=-n;
x=0;
}
…
…
n
-3



x




Conditional Statement
…
…
if (n<0) {
n=-n;
}
…
…
"
"We have a table with one column and three rows. The header of the column is ""n"". The first row contains the value ""-3"". The second row is empty. The third row contains the value ""3""."
"We also have a conditional statement: if n is less than 0, then n is equal to -n."
"We have a table with one column and three rows. The header of the column is ""n"". The first row contains the value ""3"". The second row is empty. The third row contains the value ""3""."
"We also have a conditional statement: if n is less than 0, then n is equal to -n.

We have a conditional statement and a table with two columns: n, x. The conditional statement says: if n is less than 0, then n becomes -n and x becomes 0."
"Conditional Statement
…
…
if (n<0); {
n=-n;
}
…
…
Conditional Statement
if (Boolean Expression) {
Statements;
}
"
"We have a table with one column and three rows. The header of the column is ""n"". The first row contains the value ""-3"". The second row is empty. The third row contains the value ""3""."
"We also have a conditional statement: if n is less than 0, then n is equal to -n."
"We have a table with one column and three rows. The header of the column is ""n"". The first row contains the value ""3"". The second row is empty. The third row contains the value ""3""."
"We also have a conditional statement: if n is less than 0, then n is equal to -n.

We have a conditional statement and a table with two columns: n, x. The conditional statement says: if n is less than 0, then n becomes -n and x becomes 0."
"2. Alternative
Alternative
…
if (n<0) {
x=-n;
n
-3
x

n

}
else {
x=n;
}
…
-3


x



 an alternative way of writing a piece of code. On the left side of the slide, we see the code snippet:"
"```
...
if (n<0) {
  x=-n;
}
else {
  x=n;
}
...
```
This code checks if the variable `n` is less than 0. If it is, then `x` is assigned the value of `-n`. Otherwise, `x` is assigned the value of `n`."
"On the right side of the slide, we see two tables that visualize the execution of this code snippet. The first table shows the case where `n` is -3. In this case, the condition `n<0` is true, so the code inside the `if` block is executed"
". This means that `x` is assigned the value of `-(-3)`, which is 3."
"The second table shows the case where `n` is 3. In this case, the condition `n<0` is false, so the code inside the `else` block is executed. This means that `x` is assigned the value of 3."
"Alternative
…
if (n<0) {
x=-n; s=""n<0""; b=true;
}
else {
x=n; s=""n>=0""; b=false;
}
…
Nested Conditionals
if (n<0) {
x=-n; s=""n<0"";
}
else {
n<0
if (n==0) {
x=0; s=""n==0"";
!(n<0)&&(n==0)
}
else {
x=n; s=""n>0"";
}
}
!(n<0)&&!(n==0)
"
" two code snippets, both aiming to achieve the same result."
"The first snippet uses an ""if"" statement followed by an ""else"" statement. If ""n"" is less than 0, ""x"" is assigned the negative value of ""n"", ""s"" is assigned the string ""n\<0"", and ""b"" is assigned the boolean value ""true"""
". Otherwise, ""x"" is assigned the value of ""n"", ""s"" is assigned the string ""n>=0"", and ""b"" is assigned the boolean value ""false""."
"The second snippet, titled ""Nested Conditionals"", aims to achieve the same outcome but uses nested conditionals. It starts with an ""if"" statement checking if ""n"" is less than 0. If true, it executes the same code as the first snippet's ""if"" block"
". The ""else"" block is left incomplete, marked by a red rectangle. Two speech bubbles offer potential conditions to complete the ""else"" block. The first bubble suggests ""!(n\<0) && (n==0)"", while the second bubble proposes ""!(n\<0) && !(n==0)"""
". Both options aim to cover the remaining scenarios where ""n"" is not less than 0."
"Nested Conditionals
if (n<0) {
x=-n; s=""n<0"";
} else if (n==0) {
x=0; s=""n==0"";
} else {
x=n; s=""n>0"";
}
n<0
!(n<0)&&(n==0)
!(n<0)&&!(n==0)
Nested Conditionals
if (n<0) {"
"x=-n; s=""n<0"";
} else if (n==0) {
x=0; s=""n==0"";
} else if (n<5) {
x=n; s=""0<n<5""
} else {
x=n; s=""n>=5"";
}
n<0
!(n<0)&&(n==0)
!(n<0)&&!(n==0)&&(n<5)
!(n<0)&&!(n==0)&&!(n<5)
"
"We have some code snippets visualizing nested conditional statements. The first snippet has three branches. The first branch checks if 'n' is less than zero. If so, 'x' is assigned the negative value of 'n' and 's' is assigned the string ""n<0"""
". Otherwise, it moves to the next branch and checks if 'n' is equal to zero. If so, 'x' is assigned zero, and 's' is assigned the string ""n==0"". If none of the above conditions are met, the last branch assigns 'n' to 'x' and ""n>0"" to 's'"
".  The conditions that are not met in each branch are shown on the right side. For example, the condition not met in the second branch is ""not (n<0) and (n==0)""."
"The second snippet has four branches. It has the same first two branches as the first snippet. The third branch checks if 'n' is less than 5. If so, 'x' is assigned 'n' and 's' is assigned the string ""0<n<5"""
". Otherwise, the final 'else' branch assigns 'n' to 'x' and ""n>=5"" to 's'. Similar to the first snippet, the conditions that are not met in each branch are shown on the right side"
". For example, the condition not met in the fourth branch is ""not (n<0) and not (n==0) and not (n<5)""."
"We see two code snippets, both implementing the same logic in slightly different ways.
The first snippet uses a single `if` statement with nested `else if` and `else` blocks to handle different ranges of the variable `n`."
"- If `n` is less than 0, `x` is assigned the negative of `n` and `s` is assigned the string ""n<0"".- If `n` is equal to 0, `x` is assigned 0 and `s` is assigned the string ""n==0""."
"- If `n` is less than 5, `x` is assigned the value of `n` and `s` is assigned the string ""0<n<5""."
"- Finally, if none of the above conditions are met, meaning `n` is greater than or equal to 5, `x` is assigned the value of `n` and `s` is assigned the string ""n>=5""."
The second snippet refactors the logic into two separate `if-else` statements.
"- The first `if-else` statement checks if `n` is less than 0. If true, `x` is assigned the negative of `n`. Otherwise, `x` is assigned the value of `n`."
"- The second `if-else` statement is nested within the `else` block of the first statement and is only executed if `n` is not less than 0. This statement checks if `n` is equal to 0. If true, `x` is assigned 0. Otherwise, `x` is assigned the value of `n`."
"Both snippets achieve the same result: assigning values to `x` and `s` based on the value of `n`. The first snippet is more compact, while the second snippet might be considered more readable due to its flatter structure."
"Nested Conditionals
if (n<0) {
x=-n; s=""n<0"";
} else if (n==0) {
x=0; s=""n==0"";
} else if (n<5) {
x=n; s=""0<n<5""
} else {
x=n; s=""n>=5"";
}
n<0
n==0
(0<n)&&(n<5)
n>=5
if (n<0) {
x=-n;
}
else {
x=n;
}
if (n<0) {
x=-n;
}
else if (n==0) {
x=0;"
"}
else {
x=n;
}
"
"We have some code snippets visualizing nested conditional statements. The first snippet has three branches. The first branch checks if 'n' is less than zero. If so, 'x' is assigned the negative value of 'n' and 's' is assigned the string ""n<0"""
". Otherwise, it moves to the next branch and checks if 'n' is equal to zero. If so, 'x' is assigned zero, and 's' is assigned the string ""n==0"". If none of the above conditions are met, the last branch assigns 'n' to 'x' and ""n>0"" to 's'"
".  The conditions that are not met in each branch are shown on the right side. For example, the condition not met in the second branch is ""not (n<0) and (n==0)""."
"The second snippet has four branches. It has the same first two branches as the first snippet. The third branch checks if 'n' is less than 5. If so, 'x' is assigned 'n' and 's' is assigned the string ""0<n<5"""
". Otherwise, the final 'else' branch assigns 'n' to 'x' and ""n>=5"" to 's'. Similar to the first snippet, the conditions that are not met in each branch are shown on the right side"
". For example, the condition not met in the fourth branch is ""not (n<0) and not (n==0) and not (n<5)""."
"We see two code snippets, both implementing the same logic in slightly different ways.
The first snippet uses a single `if` statement with nested `else if` and `else` blocks to handle different ranges of the variable `n`."
"- If `n` is less than 0, `x` is assigned the negative of `n` and `s` is assigned the string ""n<0"".- If `n` is equal to 0, `x` is assigned 0 and `s` is assigned the string ""n==0""."
"- If `n` is less than 5, `x` is assigned the value of `n` and `s` is assigned the string ""0<n<5""."
"- Finally, if none of the above conditions are met, meaning `n` is greater than or equal to 5, `x` is assigned the value of `n` and `s` is assigned the string ""n>=5""."
The second snippet refactors the logic into two separate `if-else` statements.
"- The first `if-else` statement checks if `n` is less than 0. If true, `x` is assigned the negative of `n`. Otherwise, `x` is assigned the value of `n`."
"- The second `if-else` statement is nested within the `else` block of the first statement and is only executed if `n` is not less than 0. This statement checks if `n` is equal to 0. If true, `x` is assigned 0. Otherwise, `x` is assigned the value of `n`."
"Both snippets achieve the same result: assigning values to `x` and `s` based on the value of `n`. The first snippet is more compact, while the second snippet might be considered more readable due to its flatter structure."
"3. Conditional Expression
Expression with Ternary Operator
Boolean Expression ? Expression : Expression
(n>0) ? 1 : 2
Has to be boolean type
Arbitrary but same type
Arbitrary but same type
"
" conditional expressions with ternary operators. The syntax is: Boolean Expression question mark Expression colon Expression. For example, open parenthesis n greater than 0 close parenthesis question mark 1 colon 2"
". The first expression, in this case, open parenthesis n greater than 0 close parenthesis, has to be a Boolean type. The other two expressions, in this case, 1 and 2, can be of arbitrary type but must be the same type."
"Expression with Ternary Operator
Boolean Expression ? Expression : Expression
(n>0) ? 1 : 2
(true) ? 1 : 2     1
(false) ? 1 : 2


Example: Absolute Value
int x=…;
int absx = (x>0) ? x : -x;"
"absx is always non-negative,
it is the absolute value of x.

"
"A ternary operator uses a boolean expression followed by a question mark, then an expression followed by a colon, and lastly another expression. If the boolean expression is true, the entire ternary operator evaluates to the first expression"
". If the boolean expression is false, the entire ternary operator evaluates to the second expression. For example, if n > 0, then the expression (n > 0) ? 1 : 2 evaluates to 1. If n is less than or equal to 0, the expression evaluates to 2."
Example: Absolute Value
"We can use the ternary operator to calculate the absolute value of a variable x. First, x is declared as an integer variable. Then, the variable absx is declared as an integer and assigned to the ternary operator (x > 0) ? x : -x"
". If x is greater than 0, then absx will take on the value of x. If x is less than or equal to 0, then absx will take on the value of -x. Therefore, absx will always be non-negative, and it will be the absolute value of x."
"Example: Absolute Value
absx = (x>0) ? x : -x;
is equivalent to
if (x>0) absx=x; else absx=-x;
Conditional Statement andConditional Expression
if (b) {x=m;}
else {x=n;}
x=
(b) ? m : n
;
Conditional Statement
Conditional Expression
"
"The expression ""absx = (x greater than 0) ? x : -x;"" is equivalent to ""if (x greater than 0) absx=x; else absx=-x;"".
Conditional Statement and Conditional Expression"
"The conditional statement ""if (b) {x=m;} else {x=n;}"" is equivalent to the conditional expression ""x = (b) ? m : n;""."
"Never-ending Computations
(true)  ? 1 : never-end
(false) ? 1 : never-end

never-end
(true)  ? never-end : 2   never-end
(false) ? never-end : 2          2
never-end ? 1 : 2         never-end





if (b==true) {S1;} else {S2;}"
"if (b)       {S1;} else {S2;}
"
We see a few conditional expressions that evaluate to never-ending computations
". For example, ""never-end ? 1 : 2"" will result in a never-ending computation because ""never-end"" will never terminate, so the expression will never be able to evaluate to either 1 or 2."
"We then see two conditional statements. The first statement checks if the variable ""b"" is equal to true. If it is, then the statement {S1} is executed. Otherwise, the statement {S2} is executed"
". The second statement is similar, but it only checks if the variable ""b"" is true."
"if (b==false) {S1;} else {S2;}
if (!b)       {S1;} else {S2;}
if (b)
{S2;} else {S1;}
b
b ? true : false
b
"
"b
b ? false : true
!b
c
b
b ? c : false
b && c
"
"c
b
b ? true : c
b || c
. Expressions and Statements
for Assignment
"
"Expressions and Statements
´Assume x=3
´Expression
x+2
´Statement

x
x=x+1;


Expressions and Statements
´Assume x=3
´Expression
x+2
´Statement

x
x=x+1;


Evaluates
(has a value)
Produces an effect
(does something)
"
"We are presented with information about expressions and statements.
An example of an expression is ""x+2"". Assuming that x equals 3, the expression evaluates to 5."
"An example of a statement is ""x=x+1"". Assuming x equals 3, the statement produces an effect: it assigns the value 4 to x.

We are presented with information about expressions and statements."
"An example of an expression is ""x+2"". Assuming that x equals 3, the expression evaluates to 5.
An example of a statement is ""x=x+1"". Assuming x equals 3, the statement produces an effect: it assigns the value 4 to x."
"Statement with Value?

x=x+1;
y=x=x+1;
y=(x=x+1);

x


x=x+1;
y=x;
Increment x
x = x+1;
x += 1;
x += 1;
x -= 2;
x *= 3;
x /= 4;
x %= 5;
"
"We see four different statements, each assigned a number. The first statement is ""x equals x plus 1"". The second statement is ""y equals x equals x plus 1"". The third statement is ""x equals 3"""
". The fourth statement is a block containing two statements: ""x equals x plus 1"" and ""y equals x""."
Increment x
"We see six different statements. The first statement is ""x equals x plus 1"". The second statement is ""x plus equals 1"". The third statement is ""x minus equals 2"". The fourth statement is ""x times equals 3"". The fifth statement is ""x divided equals 4"""
". The sixth statement is ""x modulo equals 5""."
"Increment x by 1
x = x+1;
x += 1;
++x;
x++;
x


(prefix)
(postfix)
Increment x by 1
x = x+1;
x += 1;


++x;
x++;


(prefix)
(postfix)
x


"
"The first slide shows four ways to increment the value of a variable x by 1. The first two use the assignment operator, = and +=, while the last two use the increment operator, ++. The increment operator can be used as a prefix or postfix operator"
". When used as a prefix operator, the increment happens before the value of the variable is used in the expression. When used as a postfix operator, the increment happens after the value of the variable is used in the expression."
"The second slide shows the values of x after each of the four increment operations is performed. The initial value of x is 3. After the first two increment operations, the value of x is 4"
". After the third increment operation, the value of x is 4 because the increment operator is used as a prefix operator. After the fourth increment operation, the value of x is 3 because the increment operator is used as a postfix operator."
"Pre- and Post-fix Increment
x



x=3;
y=++x;z=x++;
y

z

x=3;
x=x+1; y=x;
z=x; x=x+1;
Summary
´Expression: has value
´Statement: does sth (changes state)
++x; value after increment
x++; value before increment
"
"We have a table that shows the values of x, y, and z after executing different code snippets."
"On the left-hand side, the code snippet is:
- x is assigned the value 3
- y is assigned the value of x incremented by 1 using the pre-increment operator
- z is assigned the value of x incremented by 1 using the post-increment operator"
"On the right-hand side, the code snippet is:
- x is assigned the value 3
- x is incremented by 1
- y is assigned the value of x
- z is assigned the value of x
- x is incremented by 1"
"The table shows the values of x, y, and z after each line of code is executed.
Summary
- An expression has a value.
- A statement does something, which changes the state.
++x: the value after increment
x++: the value before increment"
"Slide 1: Conditional Statement
We have a code snippet showing an example of a conditional statement. The condition is ""if n is less than zero"" then we have a statement ""n equals minus n"". There is a warning sign next to the code snippet."
"Slide 2: Conditional Statement
We see a code snippet showing the generic syntax of a conditional statement. The statement is ""if Boolean Expression"" then we have ""statements"" in between curly brackets."
There are three different conditional statements that all result in the same logic
". The first statement, ""if (b equals false) then {S1} else {S2}"" The second statement, ""if (not b) then {S1} else {S2;}"" The third statement"
", ""if (b) then {S2} else {S1;}""  All three statements are logically equivalent and will execute the same code block based on the truth value of the boolean variable 'b'"
.
"There are two truth tables, one with one variable and one with two. The first table shows a single variable, b. The expression ""b?"" evaluates to false, while the expression ""!b"" evaluates to true. The second table shows two variables, b and c"
". The expression ""b?c"" evaluates to false, while the expression ""b&&c"" also evaluates to false."
"There are two code snippets, ""b ? true : c"" and ""b || c"".  The first snippet is a ternary operator that will evaluate to ""true"" if ""b"" is true, and ""c"" if ""b"" is false"
". The second snippet is a logical OR operator that will evaluate to ""true"" if either ""b"" or ""c"" is true."
4. Expressions and Statements for Assignment
"3
Overview
.Values
.Programs
.Expressions
.Data Types
.Statements
.Identifiers

. Display for Values
"
"5
Values
´ For the moment, we will just consider numeric integer values
´ They might consist of several digits and possibly a minus sign
´ Examples:

-1

7654321

. Display for Expressions
"
"7
Expressions
operand
operand
 * 12
operator

Expressions
expression
expression
(1 + 2) * 12
operator
"
"9
Expressions (with Integers)

-1
-1
%3
(3*4)+2

✓9
Math.pow(3,2)
Math.sqrt(9)
Needs to be defined
!
fac(3)
Infix
Infix
operator
operator
Postfix
operator
Prefix
operator

Expressions evaluate to a Value"
"(3*4)+2
*(4+2)
*4+2
fac(3)
Math.pow(3,2)





"
"11
. Display for Statements
x=x×12;

y

x
set
get
set
get

Variables
´ Now, we are able to buy extensions (memory cells) for our calculator
that are able to store a value for future usage
´ Each memory cell comes with a predefined name"
"´ We'll call each memory cell, a variable
´ We can store a value in the variable (set)
or retrieve the stored value (get)

x
set
get
"
"13
Expressions with Variables (get)
´ To get the value stored you just write the name of the variable
´ Assuming variable x is set to 3 and y is set to 2, evaluate these expressions
(x*4)+2
(x*4)+y
(x*4)+(x-1)

Variable Assignment (set)"
"´ To set a variable to a value,
we write the name of the variable followed by =,
then the expression the value of which we want to store and a semicolon
´ This is not to be read as an equation to solve or equality to be computed!"
"´ First evaluate the expression on the right,
then assign the value obtained to the variable on the left
x=3;
y=3*2;
y=x*2;
x=x*y;

"
"15
Statement
´ An assignment is not an expression, it is a statement
(later on there will be some surprise)
´ Statements have effects (on the set of values stored, the state)
y
x
x
y
x
y


x=3;






old
y=x*2;
x=x*y;


"
"6
new

State Transformation
u

v

w

x

y

z



















w=2;
z=u+v+w+x;
x=x-y;
"
"17
Display for Statements
x=x×12;

y

x
set
get
set
get

. Display
for Programs
x=3;   
x=x×12;
C ;










.
⁄
×
−
+

x
set
get
"
"19

Program
´ A program is a recorded computation
´ It is a record of the computation
´ It can be
´ stored for later use,
´ run several times,
´ checked for correctness,
´ modified, …
´ The program is the software,
the device, the hardware
"
"21
Recipe for
Spanish Potato Omelet
The recipe
(the program)
The result
(the omelet)

Instructions to Draw a Triangle
The instructions
(the program)
The result
(the drawing)
"
"23
Value
Expression

 + 4
Statement
d = 3 + 4;
Program
d = 2 – 1;
x = d;
d = x * d;
d = 3 + 4;

. Data Types
´ Arithmetic: Numbers (to be refined later)
 + 2
´ Logic: Boolean values
´ Text: Strings
true && false
""he"" + ""llo""
"
"25
Arithmetic Calculator

Logic Calculator
d =      0;
C ;










.
⁄
*
−
+
d =  false;
C ;
T
F
&&
||
!
"
"27
Boolean Algebra
´ Values
´ true
´ false
´ Operations
´ Negation (not): !
´ Conjunction (logical and): &&
´ Disjunction (logical or): ||

Logic Gates
"
"29
Negation (not)
!a
!true  equals false
!false equals true

Conjunction (logical and)
a && b
true  && true   equals
true
equals false
true  && false
false && true   equals false
equals false
false && false
"
"31
Disjunction (logical or)
a || b
true  || true   equals
equals
true  || false
false || true   equals
false || false
true
equals false
true
true

Arithmetic & Logic
Calculator
C ;
d =    0;






 2 3
⁄
*
−
. +

T
F
&&
||
!
>="
">
==
!=
<=
<
"
"33
Comparison Operations
´ n<m
´ n>m
´ n<=m
´ n>=m
´ n==m
´ n!=m
(less than, n<m)
(greater than, n>m)
(less or equal than, n≤m)
(greater or equal than, n≥m)
(equal than, n=m)
(not equal than, n≠m)

Functionality
+:  x"
"+: (3, 4)      7
&&: B x B     B
&&: (true, false)     false
>:     x        B
>: (3, 4)     false
"
"35
Text
Characters
'a'
'A'
'1'
'.'
' '
Strings
""Java""
""Hello, World!""
""2015""
"" ""
""""

Escaping
""\""Hello\""""
""Hello\n""
""\\ and \""""
"
"37
Identifiers and Strings
String s = ""s"";
Identifier
String

Concatenation
String s = ""s"";
String t = ""top"";
String p = s + t;
String q = t + s;
""stop""
""tops""
"
"39
Concatenation and Addition
int
n = 1;
String s = ""1"";
int m = n + n;
String p = s + s;
String q = s + n;

""11""
""11""

Length
String s = ""s"";
String t = ""top"";
String p = """";
String q = "" "";
int n = s.length();
int m = t.length();"
"int j = p.length();
int k = q.length();




"
"41
Substring
String s = ""Hello!"";
String t = s.substring(2,4); ""ll""
String p = s.substring(0,2); ""He""
String q = s.substring(2,6);""llo!""
String r = s.substring(2);  ""llo!""
""Hello!""
  1  2  3  4  5

Printing
System.out.print(…)"
"System.out.println(…)
"
"43
. Identifiers (Freely Chosen Names)
for Variables

x

set
get
set
get

Declaration of Variables
int number;
int veryLongName;
boolean b;
String s;
"
"45
What are Legal Names?
Correct
Incorrect
int n;
int _n;
int n1;
int int;
int n?;
int 1n;
int noMore;
int no More;
int no; int more;
int no; int no;

Recommendations for Names
Recommended
Not Recommended
int average;
int sjdflsJDJF;"
"int finalBalance;
int finalbalance;
int ONE;
int one;
For variables that areFor variables that arenot going to change
not going to change
"
"47
Declaration and Assignment
boolean b;
int n;
boolean b=true;
int n=1;
b=true;
n=1;
boolean b=1;
int n=true;

See you in the next class!
´Remember
to watch videos anddo exercises before
you come to class!
"
"Overview
 titled ""Overview"" and lists six items: Values, Expressions, Statements, Programs, Data Types, and Identifiers.
. Display for Values
 a calculator with the number 36 in the display."
"Values
 the concept of numeric integer values.- They can have multiple digits.- They can be positive or negative.
Examples are provided: 0, -1, 36, 987654321
. Display for Expressions"
" a basic calculator with the expression ""3 x 12"" in the display."
"Expressions
In the first expression, we have the operand 3, the operator ""*"", and the operand 12.
In the second expression, we have the expression ""(1 + 2)"", the operator ""*"", and the operand 12."
Expressions (with Integers)
"The image shows examples of expressions with integers and their values. In the first part, we see examples of expressions written in infix, postfix, and prefix notation. In the second part, we see a list of expressions and their corresponding values"
". For example, the expression (3*4)+2 evaluates to 14, the expression 3*(4+2) evaluates to 18, and so on."
**3. Display for Statements**
"The image shows a calculator with a display showing ""x=x*12;"". There are two memory cells labeled ""2 y"" and ""3 x"". The ""2 y"" memory cell has buttons labeled ""set"" and ""get"". The ""3 x"" memory cell also has buttons labeled ""set"" and ""get"".
**Variables**"
"- We can buy extensions (memory cells) for our calculator that are able to store a value for future usage.
- Each memory cell comes with a predefined name.
- We'll call each memory cell, a variable."
- We can store a value in the variable (set) or retrieve the stored value (get).
Expressions with Variables (get)
" the concept of expressions with variables. It explains that to get the value stored in a variable, you simply need to write the name of the variable"
". Assuming that the variable ""x"" is set to 3 and ""y"" is set to 2,  three expressions for evaluation: ""(x * 4) + 2"", ""(x * 4) + y"", and ""(x * 4) + (x - 1)""."
Variable Assignment (set)
" how to assign values to variables. It states that to set a variable to a value, you write the name of the variable followed by ""="", then the expression whose value you want to store, and finally a semicolon"
. It emphasizes that this should not be interpreted as an equation to solve or an equality to be computed. The process involves first evaluating the expression on the right side and then assigning the obtained value to the variable on the left side
".  three examples: ""x = 3;"", ""y = 3 * 2;"", and ""y = x * 2; x = x * y;"". In the second example, an arrow points to the number 6, indicating the result of the expression ""3 * 2""."
"**Statement**
An assignment is not an expression, it is a statement. Statements have effects on the set of values stored, called the state."
"For example, if x and y both equal 1, then the statement x=3 will change the value of x to 3, while y remains equal to 1. If we then have the statement y=x*2, the value of y will change to 6, which is 3 multiplied by 2, while x remains equal to 3"
". Finally, if we have the statement x=x*y, the value of x will change to 18, which is 3 multiplied by 6, while the value of y remains at 6."
"**State Transformation**
There is a table with columns labeled u, v, w, x, y, and z. Each column has a value of 1 in the first row."
"The first transformation we will make is w=2, which changes the value of w to 2 in the second row, while all other values remain at 1."
"The second transformation is z=u+v+w+x, which changes the value of z to 5 in the third row, as this is the sum of u, v, w, and x in the second row. All other values remain the same as the second row."
"The third transformation is x=x-y, which changes the value of x to 0 in the fourth row, as this is the difference between the values of x and y in the third row. All other values remain the same as the third row."
Display for Statements
" a calculator with the statement ""x = x * 12"" displayed on the screen. The buttons ""2"", ""y"", ""set"", ""get"", ""3"", ""x"" are highlighted to illustrate the sequence of keys that need to be pressed to execute the statement."
Display for Programs
" a calculator with the statements ""x = 3"" and ""x = x * 12"" displayed on the screen. The buttons ""3"", ""x"", ""set"", ""get"" are highlighted to illustrate the sequence of keys that need to be pressed to execute the program."
There are two slides.
The first slide numbered 19 shows a calculator with two blue up arrows around it. The calculator displays the number 153 and then the number 2. A piece of paper is shown above the calculator with the same numbers 153 and 2 printed on it
. Another piece of paper is shown below the calculator with the same numbers 153 and 2 printed on it.
The second slide numbered 20 is titled **Program**. It contains a definition of a computer program and an example of a simple program written in a C-like programming language.
"The definition of a program lists the following points:
- A program is a recorded computation
- It is a record of the computation
- It can be:
  - stored for later use
  - run several times
  - checked for correctness
  - modified"
"- The program is the software, the device, the hardware"
The example program shown in  a function called `processData` that reads data using the function `getData` and then calls either the function `performOperation1` or `performOperation2` depending on whether the data is negative or not
". The function `processData` repeats this process in a loop as long as there is more data to process, which is determined by the function `hasMoreData`."
"**Recipe for Spanish Potato Omelet**
The recipe for Spanish potato omelet lists the ingredients: 1lb/450g waxy potatoes, 1 large white/Spanish onion (optional), about 1 liter of oil (olive oil is best), 6 eggs, and a pinch of salt."
"The procedure is as follows: Peel and slice the potatoes thinly. Meanwhile, heat the oil on low heat in a large sauté pan. Add the potatoes to the pan and fry until soft and cooked through but not browned"
". Slice the onion thinly and fry lightly in a frying pan, stirring frequently for a few minutes or until sweet. Beat the eggs in a large bowl and add salt. Add the hot cooked potatoes and onion to the egg in the bowl, gently mix, and leave for five minutes"
". Drain the oil and reserve for another time. Pour the potatoes, onion, and egg mix back into the pan and cook for about 5 minutes on low heat"
". When the edge of the tortilla looks cooked, place a large, flat plate over the pan like a lid, put one hand on the plate to hold it in place, and turn the whole thing over"
". Check the pan, clean and scrape any bits that have stuck in the pan, and add a bit of oil if it is looking dry. Slide the omelet back into the pan to cook the bottom. Cook for another few minutes"
". Repeat the turning process a couple of times to make sure it is cooked evenly. Serve on a large plate, cut into wedges, and serve with more tapas."
"There is an image of the finished omelet on the right side.
**Instructions to Draw a Triangle**"
"The instructions to draw a triangle are presented as a code sequence. The code sequence consists of the following blocks: ""repeat 3"", ""move 100 steps"", ""wait 1 sec"", ""turn right 120 degrees"", and ""wait 1 sec""."
"The output of the code sequence is shown in the image on the right side, which is a drawing of an equilateral triangle."
"There are four concepts being described: value, expression, statement, and program. A value is 7. An expression is 3 + 4. A statement is d = 3 + 4;. A program is d = 2 - 1; x = d; d = x * d; d = 3 + 4;"
"The next topic is data types, which include arithmetic, logic, and text. Arithmetic refers to numbers, and an example is 1 + 2. Logic refers to Boolean values, and an example is true and false. Text refers to strings, and an example is ""he"" + ""llo""."
"Arithmetic Calculator
An arithmetic calculator with a display showing ""d = 0;"". The calculator has buttons for digits 0-9, arithmetic operators for addition, subtraction, multiplication, and division, and buttons for ""C"" and "";""."
"Logic Calculator
A logic calculator with a display showing ""d = false;"". The calculator has buttons for ""C"" and "";"", as well as buttons for logical operators ""&&"", ""||"", and ""!""."
"**Boolean Algebra**
- Values: true, false
- Operations: Negation (not): !, Conjunction (logical and): &&, Disjunction (logical or): ||
**Logic Gates**"
"The first figure shows four truth tables for the following logical operations: AND, OR, XOR, and NOT. Each table lists the inputs x and y, and the output for each combination of inputs."
The second figure shows the logic gates corresponding to the truth tables in the first figure. The AND gate outputs a 1 only if both inputs are 1. The OR gate outputs a 1 if at least one input is 1. The XOR gate outputs a 1 if only one input is 1
. The NOT gate outputs the opposite of its input.
"The third figure shows the De Morgan equivalents of the AND and OR gates. The De Morgan's theorem states that the negation of a conjunction is the disjunction of the negations, and the negation of a disjunction is the conjunction of the negations."
"The fourth figure shows the Venn diagrams for the AND and OR operations. In the AND diagram, the overlapping area represents the cases where both x and y are true"
". In the OR diagram, the shaded area represents the cases where either x or y is true, or both."
"Negation (not)
- The negation of a boolean value 'a' is denoted by '! a'.
- If 'a' is true, then '! a' is false.
- If 'a' is false, then '! a' is true.
Conjunction (logical and)"
"- The conjunction of two boolean values 'a' and 'b' is denoted by 'a && b'.
- The conjunction is true only if both 'a' and 'b' are true.
- In all other cases, the conjunction is false.
- The truth table for conjunction is as follows:"
"- true && true equals true
    - true && false equals false
    - false && true equals false
    - false && false equals false
- There are three diagrams illustrating the concept of conjunction:"
"- The first diagram is a truth table for conjunction, with inputs 'x' and 'y' and output 'x∧y'.
    - The second diagram shows a logic gate representation of conjunction, with inputs 'x' and 'y' and output 'x∧y'."
"- The third diagram shows a Venn diagram representation of conjunction, with two overlapping circles representing 'x' and 'y' and the overlapping region representing 'x∧y'."
**Disjunction (logical or)**
"The image describes the disjunction operator, also known as the logical OR. It presents a truth table for the operator, which shows that the result of a disjunction is true if at least one of the operands is true"
. The result is false only if both operands are false.
**Arithmetic & Logic Calculator**
"The image shows a calculator with arithmetic and logic functions. The arithmetic functions include addition, subtraction, multiplication, and division. The logic functions include AND, OR, and NOT"
. The calculator also has a display that shows the current value.
**Comparison Operations**
"- We have the less than operator, written as 'n' less than 'm'.
- We have the greater than operator, written as 'n' greater than 'm'.
- We have the less than or equal operator, written as 'n' less than or equal to 'm'."
"- We have the greater than or equal operator, written as 'n' greater than or equal to 'm'.
- We have the equal operator, written as 'n' equal to 'm'.
- And last, we have the not equal operator, written as 'n' not equal to 'm'."
**Functionality**
"- The plus operator maps from the Cartesian product of the set of real numbers with itself to the set of real numbers. For example, 3 plus 4 maps to 7."
"- The logical and operator maps from the Cartesian product of the set of Boolean values with itself to the set of Boolean values. For example, true and false maps to false."
"- The greater than operator maps from the Cartesian product of the set of real numbers with itself to the set of Boolean values. For example, 3 greater than 4 maps to false."
Text
" the concept of characters and strings.
There are examples of characters enclosed in single quotes like the letter a lowercase, the letter A uppercase, the number 1, and a single quote."
"There are examples of strings enclosed in double quotes like the words Java, Hello, World, the number 2015, a single space, and an empty string."
Escaping
 the concept of escaping characters in strings.
"There are three examples, the first one shows how to escape a double quote inside a string, the second one shows how to escape a newline character, and the third one shows how to escape a backslash."
"Identifiers and Strings
We have a code snippet that shows how to declare a string variable in a program. The string variable 's' is assigned the value ""s"".
Concatenation"
" a code snippet that demonstrates string concatenation. We first declare and assign values to string variables 's' and 't'. Variable 's' is assigned the string ""s"" and variable 't' is assigned the string ""top"""
". We then create two new string variables 'p' and 'q' by concatenating the values of 's' and 't'. Variable 'p' is assigned the concatenated string ""stop"" which is the result of combining ""s"" and ""top"""
". Similarly, variable 'q' is assigned the concatenated string ""tops"" which is the result of combining ""top"" and ""s""."
**Concatenation and Addition**
"We have four variable declarations. Integer variable `n` is initialized to 1. String variable `s` is initialized to string ""1"". Integer variable `m` is initialized to the sum of `n` and `n`, which is 2"
". String variable `p` is initialized to the concatenation of `s` and `s`, which is ""11"". String variable `q` is initialized to the concatenation of `s` and `n`, which is ""11""."
**Length**
"We have four string variable declarations and four integer variable declarations. String variable `s` is initialized to string ""s"". String variable `t` is initialized to string ""top"". String variable `p` is initialized to an empty string"
". String variable `q` is initialized to a string containing a single space. Integer variable `n` is initialized to the length of `s`, which is 1. Integer variable `m` is initialized to the length of `t`, which is 3"
". Integer variable `j` is initialized to the length of `p`, which is 0. Integer variable `k` is initialized to the length of `q`, which is 1."
"Substring
We have a string ""Hello!"" and we are showing how to use the substring method to extract different parts of the string."
"- The first substring starts at index 2 and ends at index 4, resulting in ""11"".
- The second substring starts at index 0 and ends at index 2, resulting in ""He"".
- The third substring starts at index 2 and ends at index 6, resulting in ""llo!""."
"- The last substring starts at index 2 and continues until the end of the string, resulting in ""llo!""."
"Printing
 on printing in a programming context.
It presents two commonly used methods:"
"- System.out.print: This method prints its arguments without appending a newline character.
- System.out.println: This method prints its arguments and appends a newline character, moving the cursor to the beginning of the next line."
Identifiers (Freely Chosen Names) for Variables
"We have two diagrams representing variables. The first one is a variable named ""x"" containing the value ""3"". The second one is a variable with a longer name containing the value ""1"". Both variables can be set and retrieved using the corresponding buttons."
"Declaration of Variables
There are four variable declarations: an integer variable named ""number"", an integer variable named ""veryLongName"", a boolean variable named ""b"", and a String variable named ""s"". Each declaration ends with a semicolon."
What are Legal Names?
"Here are some examples of correct and incorrect variable names.
Correct variable names include: ""n"", ""_n"", ""n1"", ""noMore"", ""no"", and ""more"".
Incorrect variable names include: ""int"", ""n?"", ""1n"", ""no More"", and two variables named ""no""."
Recommendations for Names
"Here are some recommendations for variable names.
Recommended variable names include: ""average"", ""finalBalance"", and ""ONE"".
Variable names that are not recommended include: ""sjdflsJDJF"", ""finalbalance"", and ""one""."
"The text ""For variables that are not going to change"" is pointing to the variable name ""ONE""."
Declaration and Assignment
"We see two columns of code, both showing examples of declaration and assignment. On the left side, we see the declaration of a boolean variable 'b' and an integer variable 'n'"
". Then, we see the assignment of the value 'true' to 'b' and the assignment of the value '1' to 'n'. On the right side, we see the declaration of a boolean variable 'b' and an integer variable 'n' with assignment of values in the same line"
". 'b' is assigned 'true' and 'n' is assigned '1'. The last two lines are crossed out. They show an attempt to assign the value '1' to the boolean 'b' and the value 'true' to the integer 'n', which is incorrect."
"See you in the next class!
Remember to watch videos and do exercises before you come to class!"
"2
Summary
´ Partial functions
´ Recursive methods"
"3
Partial Functions"
"4
Total Function
X   g Y"
"5
Partial Function
X   g Y"
"6
Total Function
X'  g Y"
"7
Mathematics and Programming
´ In Mathematics,
we can freely finetune the sets
in order to make the functions total
´ In Programming,
with types instead of sets,
we cannot adjust the elements as we wish"
"8
Square Root
sqrt(4)
Use
Definition
double sqrt (int x)
{
}
return …;
int
x
sqrt
square
x*x
double"
"9
Square Root
sqrt(-4)
Use
Definition
double sqrt (int x)
{
}
return …;
int
x
sqrt
square
x*x
double"
"10
Square Root: Partial Definition
Not defined
Defined
g"
"11
What to do when a method is called
with a value for which there is no image?
. Expect an error!
´ The programmer should pay more attention
. Give information for correct use
´ Help the programmer pay attention
. Prepare useful documentation"
"´ Help building this documentation
.
Treat this case programmatically
´ Program the exceptional cases
Comments
Javadoc
Exceptions"
"12
Comments: one line
Comments
double sqrt (int x){
// x has to be non-negative
return …; // here comes the return value
}"
"13
Comments: multiple lines
Comments
double sqrt (int x){
/* x has to be
non-negative */
return …;
}"
"14
Javadoc
Javadoc
/**
* This method calculates the square root of the input value
*
* @author Carlos
* @version 1.0
* @param x an int value with x>=0
* @return the non-negative square root
*/
double sqrt (int x){
return …;
}"
"15
Javadoc
´ Method sqrt provided by Java
Javadoc
Math.sqrt(4)
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html"
"16
Exceptions
Exceptions
double sqrt (int x) throws Exception{
if (x<0) {throw new Exception();}
return …;
}"
"17
Exceptions: Examples
Exceptions
void method (int a[]){
for (int i = 0; i <= a.length; i++) {
System.out.println(a[i]);
}
}
ArrayIndexOutOfBoundException"
"18
Exceptions: Examples
Exceptions
void method (int a[]){
for (int i = 0; i < a.length; i++) {
System.out.println(a[i]);
}
}
If the array is not initialized
NullPointerException"
"19
Exceptions: Examples
Exceptions
void method (int a[]){
try{
for (int i = 0; i < a.length; i++) {
System.out.println(a[i]);
}
} catch (NullPointerException e){
System.err.println(""The array was not initialized"");
}
}"
"20
Exceptions: Examples
Exceptions
int method (int a, int b) {
return a/b;
}
If b is 0ArithmeticException"
"21
Exceptions: Examples
Exceptions
int method (int a, int b) throws Exception{
if (b==0) {throw new Exception();}
return a/b;
}"
"22
Recursive Methods"
"23
Square: x2
int square (int x)
{
}
return x*x;
int
x
square
square
x*x
int"
"24
Power: xy
int power (int x, int y)
{
}
…
int
int
x
x
power
square
x*x
int"
"25
Power: xy
int power (int x, int y){
if (y==0)
{return 1;}
else if (y==1) {return x;}
else if (y==2) {return square(x);}
else if (y==3) {return cube(x);}
… // until when?
}"
"26
Power: xy
int power (int x, int y){
if (y==0)
{return 1;}
else if (y==1) {return x;}
else if (y==2) {return square(x);}
else if (y==3) {return cube(x);}
… // not very intelligent!
}"
"27
Power: xy
Provided y>=0:
x0=1
xy = x * … * x
y"
"28
Power: xy
int power (int x, int y)
{ // y>=0
int z=1;
for (int i=1; i<=y; i++)
{z=x*z;}
return z;
}"
"29
Table for y equal 3
i




i<=y
true
true
true
false
z

x
x2
x3
return
x3"
"30
Table for y equal 0
i

i<=y
false
return
z

"
"31
Recurrence Equation
´ Precondition: y>=0
´ xy = 1
´ xy = x * xy-1
´ power(x,y)= 1
´ power(x,y)=
if (y==0)
if (y>0)
if (y==0)
x*power(x,y-1)
if (y>0)
Precondition satisfied ç y-1>=0 ç y>=1 ç y>0"
"32
Recursive Method
int power (int x, int y){ // y>=0
if (y==0)
return 1;
else
return x*power(x,y-1);
}
Can we
do that?"
"33
power(x,3)
´ power(x,3)´ if (3==0){return 1}
else return x*power(x,3-1)
´ if (false){return 1}
else return x*power(x,2)
´ return x*power(x,2)
´ power(x,3) è x*power(x,2)"
"34
power(x,2)
´ power(x,2)´ if (2==0){return 1}
else return x*power(x,2-1)
´ if (false){return 1}
else return x*power(x,1)
´ return x*power(x,1)
´ power(x,2) è x*power(x,1)"
"35
power(x,1)
´ power(x,1)´ if (1==0){return 1}
else return x*power(x,1-1)
´ if (false){return 1}
else return x*power(x,0)
´ return x*power(x,0)
´ power(x,1) è x*power(x,0)"
"36
power(x,0)
´ power(x,0)´ if (0==0){return 1}
else return x*power(x,0-1)
´ if (true){return 1}
else return x*power(x,-1)
´ return 1
´ power(x,0) è 1"
"37
Summary
´power(x,3) è x*power(x,2)
´power(x,2) è x*power(x,1)
´power(x,1) è x*power(x,0)
´power(x,0) è 1"
"38
All Together
´power(x,3)
´x*power(x,2)
´x*(x*power(x,1))´x*(x*(x*power(x,0)))
´x*(x*(x*1))
´x*(x*x)"
"39
power(x,y)
int power (int x, int y){ // y>=0
if (y==0)
return 1;
else
return x*power(x,y-1);
}"
"40
power(x,-2)
´power(x,-2)´if (-2==0){return 1}
else return x*power(x,-2-1)
´if (false){return 1}
else return x*power(x,-3)
´return x*power(x,-3)
´power(x,-2) è x*power(x,-3)"
"41
power(x,-3)
´power(x,-3)´if (-3==0){return 1}
else return x*power(x,-3-1)
´if (false){return 1}
else return x*power(x,-4)
´return x*power(x,-4)
´power(x,-3) è x*power(x,-4)"
"42
´power(x,-2) è x*power(x,-3)
´power(x,-3) è x*power(x,-4)
´power(x,-4) è x*power(x,-5)
´power(x,-5) è x*power(x,-6)
´…
´Non-termination"
"43
power(x,y)
int power (int x, int y){ // y>=0
if (y==0)
return 1;
else
return x*power(x,y-1);
}"
"44
Termination condition
int power (int x, int y){ // y>=0
if (y==0)
return 1;
else
return x*power(x,y-1);
}
Base case
Recursive case"
"45
Exercise 1
´ Implement the recursive method square(int n), which
calculates the square of n (when n > 1). We shallconsider the following formula in your implementation:
(N-1)2 = N2 - 2N + 1"
"46
Exercise 2
•"
"Implement the recursive method  riddle(int p, int q)with p and q > 0. Each time this method is called, the value ofq increases in one unit, while the value of p decreases in oneunit. When p is zero, the method returns the value of q."
"• How many time are the recursive and base cases executedwhen calling riddle(3,5) and what value is returned?"
"47
Factorial
Task: Write a recursive method
to compute the factorial of a natural number n
fac(n) = n! = n*(n-1)*…*2*1
fac(5) = 5! = 5*4*3*2*1
fac(4) = 4! =   4*3*2*1"
"48
Factorial
Trick: 1. Assume you have
the problem solved for a simpler task
fac(n)   =     n! = n*(n-1)*…*2*1
fac(n-1) = (n-1)! =   (n-1)*…*2*1
n! = n*(n-1)!
fac(n) = n*fac(n-1)"
"49
Factorial
Trick: 2. Check the border conditions
fac(0) = 0! = 1"
"50
Factorial
fac(n) =

(if n=0)
n*fac(n-1) (if n>0)"
"51
Factorial
fac(n) =

(if n≤1)
n*fac(n-1) (if n>1)
long fac (int n){
if (n<=1) return 1;
else
return n*fac(n-1);
}
Base case
Recursive case"
"52
Operational View
fac(3)è3*fac(2)
fac(2)è2*fac(1)
fac(1)è1
fac(3)è3*fac(2)è3*(2*fac(1))
è3*(2*1)è6"
"53
Mathematical View
fac(3) = 3*fac(2) = 3*2 = 6
fac(2) = 2*fac(1) = 2*1 = 2
fac(1) = 1"
"54
Exercise 3
•
Implement the recursive method gcd(int a, int b),which allows computing the greatest common divisor of twointeger numbers."
"55
Exercise 4
•
Implement the recursive methoddecToBin(int decimal, String binary),which receives a decimal number and returnsa String with the equivalent binary number."
"Summary
 titled ""Summary"" and lists two bullet points: ""Partial functions"" and ""Recursive methods""."
"The first bullet point ""Partial functions"" is accompanied by a diagram depicting two sets, X and Y, with several dots inside each set. Some dots in set X are connected with some dots in set Y with arrows pointing from X to Y."
"The second bullet point ""Recursive methods"" is accompanied by an image of a computer screen showing several open windows nested within each other, creating an illusion of an endless tunnel."
Partial Functions
"The image shows two ovals, labeled X and Y, with several dots in each oval. Arrows are drawn from some of the dots in oval X to some of the dots in oval Y"
". Not all dots in X have arrows pointing from them, and some dots in Y are receiving multiple arrows from X. An arrow points from X to Y."
Total Function
The diagram depicts two ovals representing sets 'X' and 'Y'.  Each oval contains several dots symbolizing elements within the sets
". Red arrows connect each dot in set 'X' to a corresponding dot in set 'Y', illustrating a function mapping every element in 'X' to an element in 'Y'."
Partial Function
"We see a diagram depicting a partial function from X to Y. The diagram shows two ovals representing the sets X and Y. Inside each oval, there are multiple dots representing the elements of the sets"
". Some dots in X are connected to dots in Y with arrows, indicating the mapping from X to Y. However, not all dots in X have corresponding arrows pointing to dots in Y."
Total Function
"We see two sets, X prime and Y. Each set contains several dots representing elements. All of the dots in the first set, X prime, have lines connecting them to dots in the second set, Y. Some dots in Y are connected to multiple dots in X prime."
"Mathematics and Programming
In mathematics, we can freely fine-tune the sets in order to make the functions total. In programming, with types instead of sets, we cannot adjust the elements as we wish."
Square Root
"The image describes the concept of the square root function in programming. The function, named ""sqrt"", takes an integer ""x"" as input and returns a double-precision floating-point number representing the square root of ""x"""
". The image illustrates this with an example: ""sqrt(4)"". The input, 4, is an integer, and the output is a double-precision floating-point number."
Square Root
"The image shows a code snippet that calculates the square root of a given integer. The function `double sqrt(int x)` takes an integer `x` as input and returns a double-precision floating-point number, which represents the square root of `x`"
". The code uses the `sqrt()` function from a library, as indicated by the blue box labeled ""sqrt"". The input to this library function is an integer (`int`) and the output is a double-precision floating-point number (`double`)."
Square Root: Partial Definition
"We have a number line ranging from minus five to plus five. There are two lines below the number line, one in red covering the negative numbers and zero, labeled ""Not defined"", and one in brown covering the positive numbers, labeled ""Defined"""
". Below, we see ""N arrow pointing to right R""."
What to do when a method is called with a value for which there is no image?
"We have four options: expect an error, give information for correct use, prepare useful documentation, or treat this case programmatically. Expecting an error means that the programmer should pay more attention"
. Giving information for correct use can be done with comments to help the programmer pay attention. Preparing useful documentation can be done with Javadoc. This helps when building documentation
". Lastly, treating this case programmatically means programming the exceptional cases with exceptions."
"Comments
 titled ""Comments: one line"" and shows an example of how to write single-line comments in code. The comment is marked with two forward slashes (//) and explains that the variable x in the square root function has to be non-negative."
Comments: multiple lines
"We have a function definition for a function called ""sqrt"" which takes an integer ""x"" as input and returns a double. There is a multi-line comment inside the function definition that says ""x has to be non-negative"""
". The body of the function simply returns ""..."" for now."
"Javadoc
 the concept and syntax of Javadoc in Java programming. It presents a code snippet with Javadoc comments, which are used to generate documentation for the code."
"The Javadoc comment block starts with `/**` and ends with `*/`. Inside the block, there are several tags starting with `@`, such as `@author`, `@version`, `@param`, and `@return`"
. These tags provide specific information about the code element they are documenting.
"- `@author` specifies the author of the code.
- `@version` indicates the version of the code.
- `@param` describes a parameter of a method, including its name and a brief description.
- `@return` describes the return value of a method."
The code snippet defines a method named `sqrt` that takes an integer `x` as input and returns a double-precision floating-point value
". The Javadoc comments explain that this method calculates the square root of the input value `x`, which should be greater than or equal to 0. The method returns the non-negative square root of `x`."
" shows a sample output of the Javadoc documentation for the `sqrt` method. The output includes the method's description, parameters, return value, version, and author, all extracted from the Javadoc comments in the code."
Javadoc
" titled ""Javadoc"" and focuses on the Java method ""sqrt"" provided by the Java language. The specific example shown is ""Math.sqrt(4)"".  a screenshot of the Javadoc documentation for the ""sqrt"" method"
". The method is named ""sqrt"" and is a public static method that returns a double. It takes a single double-precision floating-point number, ""a"", as an argument"
". The documentation describes the method's purpose, which is to return the correctly rounded positive square root of the input value. It also lists special cases: if the argument is NaN (Not a Number) or less than zero, the result is NaN"
". If the argument is positive infinity, the result is positive infinity. If the argument is positive zero or negative zero, the result is the same as the argument"
". Otherwise, the result is the double value closest to the true mathematical square root of the argument value. The documentation also provides the parameter ""a"", which is a value, and the return value, which is the positive square root of ""a"""
". If the argument is NaN or less than zero, the result is NaN. The URL for this Javadoc page is provided at the bottom of the slide."
Exceptions
" ""Exceptions"" shows a code snippet. The code defines a function called ""sqrt"" that takes an integer ""x"" as input and returns a double. The function throws an exception if the input ""x"" is less than 0"
". Otherwise, it returns a value represented by ""...""."
Exceptions: Examples
" a code snippet of a Java method. The method takes an integer array as input. The for loop iterates through the array and prints each element. However, the loop condition is incorrect: it should be ""i < a.length"" instead of ""i <= a.length"""
. This will cause an ArrayIndexOutOfBoundsException when i equals the length of the array.
"Exceptions: Examples
We have a code snippet that shows an example of an exception. The method takes an integer array as an argument and iterates through it, printing each element. If the array is not initialized, a NullPointerException will be thrown."
Exceptions: Examples
"We have a piece of code that shows an example of exception handling. The code defines a method that takes an integer array as input. Inside the method, there is a try block that iterates over the array and prints each element"
". If the array is not initialized, a NullPointerException will be thrown. This exception is caught by the catch block, which prints an error message to the standard error stream."
"Exceptions: Examples
We have a code snippet that shows an example of an exception. The code defines an integer method that takes two integer arguments, a and b, and returns the result of dividing a by b. If b is 0, an ArithmeticException will be thrown."
Exceptions: Examples
"We have a code snippet that shows an example of an exception. The method takes two integers, a and b, as input and is designed to return the result of a divided by b. However, there is a condition that checks if b is equal to zero"
". If b is zero, an exception is thrown using the ""throw new Exception"" statement. Otherwise, the method proceeds to return the result of a divided by b."
Recursive Methods
"The image shows a screenshot of a computer screen with multiple windows open. The windows are nested inside each other, creating a visual effect of infinite recursion"
". This image is a metaphor for recursive methods, which are functions that call themselves."
Square: x<sup>2</sup>
" to illustrate a function named ""square"". The function takes an integer ""x"" as input and returns an integer. The body of the function simply returns the square of the input, which is calculated as ""x*x"""
". The data flow of the function is illustrated with a diagram. The input of the function is an integer, which is represented by a downward arrow labeled ""int"". This input is then passed to the ""square"" function, which is represented by a blue box"
". The output of the function is also an integer, which is represented by a downward arrow labeled ""int""."
"Power: XY
We have a function definition for a function called ""power"" that takes two integer arguments, x and y, and returns an integer value. The function calculates the value of x raised to the power of y."
"Power: XY
We have a code snippet that shows a function definition in C programming language. The function is called ""power"" and takes two integer arguments: x and y. The goal of the function is to calculate x to the power of y."
"The function starts by checking if y is equal to 0. If it is, it returns 1. Otherwise, it checks if y is equal to 1. If it is, it returns x. Otherwise, it checks if y is equal to 2"
". If it is, it returns the result of calling the function ""square"" with x as an argument. Otherwise, it checks if y is equal to 3. If it is, it returns the result of calling the function ""cube"" with x as an argument"
". The code ends with a comment: ""// until when?"". This comment suggests that the code is incomplete and that there should be more else if statements to handle other values of y."
"Power: XY
We see a code snippet, apparently the beginning of a function definition written in C. The function is called ""power"" and takes two integer arguments, x and y. The goal of the function is to compute x to the power of y."
"The code implements this by checking for specific values of y: if y is 0, it returns 1. If y is 1, it returns x. If y is 2, it returns the result of calling a function named ""square"" with x as an argument"
". If y is 3, it returns the result of calling a function named ""cube"" with x as an argument."
"The comment at the end suggests that this implementation is not very intelligent, probably because it only handles a few specific cases for y and does not provide a general solution for all possible values of y."
"Power: XY
The expression X to the power of Y, provided Y is greater than or equal to zero, is equal to X multiplied by itself Y times."
Power: XY
"We have a code snippet that defines a function named ""power"" that takes two integer arguments, x and y. The function calculates x raised to the power of y. Inside the function, an integer variable z is initialized to 1"
". A for loop iterates from 1 to y, and in each iteration, z is updated by multiplying it with x. Finally, the function returns the value of z."
Table for y equal 3
"We have a table that describes the value of z and the return value of a function, for different values of i. The table has four columns: i, i less than or equal to y, z, and return. The first row of the table shows that the initial value of z is 1"
". For i equal to 1, 2, and 3, the condition i less than or equal to y is true, and the value of z is x, x squared, and x cubed, respectively. For i equal to 4, the condition i less than or equal to y is false. The return value of the function is x cubed."
"Table for y equal 0
The table has four columns: i, i less than or equal to y, z, and return. When i is 1, i less than or equal to y is false, z is unknown, and return is 1."
"Recurrence Equation
The image describes a recurrence equation for calculating the power of a number."
"- The precondition for this equation is that y should be greater than or equal to 0.
- If y is equal to 0, then x to the power of y is 1.
- If y is greater than 0, then x to the power of y is equal to x multiplied by x to the power of y minus 1."
"The equation is also presented in a functional form:
- If y is equal to 0, then power(x,y) is equal to 1.
- If y is greater than 0, then power(x,y) is equal to x multiplied by power(x, y-1)."
"The precondition is satisfied because y-1 is greater than or equal to 0, which implies that y is greater than or equal to 1, which in turn implies that y is greater than 0."
"Recursive Method
We see a code snippet for a recursive function called ""power"" that takes two integer arguments, x and y, and returns an integer. The function calculates x raised to the power of y."
"The function first checks if y is equal to 0. If it is, it returns 1. Otherwise, it returns x multiplied by the result of calling the power function recursively with x and y-1 as arguments."
"There is a red starburst shape with the text ""Can we do that?"" pointing to the recursive call of the power function."
"power(x,3)"
" to illustrate a recursive approach to calculate the power of a number. The expression ""power(x,3)"" suggests calculating x raised to the power of 3. The subsequent lines break down this calculation into recursive steps"
".  It first checks if the exponent, in this case ""3"", is equal to 0. If true, it would return 1. However, since it's not, it proceeds to the else condition"
".  The else condition multiplies ""x"" with the result of the function call ""power(x, 3-1)"", essentially reducing the exponent by 1 in each recursive step. This process continues until the base case (exponent equals 0) is reached"
". The final step simplifies the expression ""power(x,3)"" to ""x*power(x,2)"", highlighting the recursive nature of the calculation."
"power(x,2)
The image shows a code snippet for a recursive function named ""power"" that takes two arguments, x and 2. The function is designed to calculate the result of x raised to the power of 2."
"The code first checks if the second argument, 2, is equal to 0. If it is, the function returns 1."
"If the second argument is not 0, the code enters an ""else"" block. This block contains another ""if"" statement that always evaluates to false. As a result, the code always executes the ""else"" block within this nested ""if"" statement"
". This inner ""else"" block recursively calls the ""power"" function with arguments x and 2-1, multiplies the result by x, and returns the final value."
"Finally, the code includes a line that demonstrates the function call ""power(x,2)"" and indicates that it is equivalent to ""x*power(x,1)"". This highlights the recursive nature of the function."
"power(x,1)"
" to illustrate a recursive approach to calculate the power of a number. The base case is when the exponent is zero, in which case the result is 1"
". Otherwise, the result is obtained by multiplying the base by the result of calling the power function recursively with the same base and the exponent decremented by 1. The final result is x*power(x,0)."
"power(x,0)"
"The image shows a code snippet for a function named ""power"" that takes two arguments, x and 0. The function checks if the second argument is equal to 0. If it is, it returns 1"
". Otherwise, it multiplies x by the result of calling the ""power"" function recursively with x and 0-1 as arguments. However, there is a logical error in the code"
". The second if statement always evaluates to true, resulting in the function always returning 1. Finally, we see the expression ""power(x,0)"" which would evaluate to 1."
Summary
We see four mathematical equations that recursively define the power function for non-negative integer powers
". The equations are:  power(x,3) equals x times power(x,2), power(x,2) equals x times power(x,1), power(x,1) equals x times power(x,0), and power(x,0) equals 1."
"All Together
- power(x,3)
- x * power(x,2)
- x * (x * power(x,1))
- x * (x * (x * power(x,0)))
- x * (x * (x * 1))
- x * (x * x)"
"power(x,y)"
"This code defines a function called ""power"" that takes two integer arguments, x and y. The function returns an integer value"
". The function has a comment that says ""// y>=0"", which means that the function assumes that the value of y is greater than or equal to 0. The function body contains an if statement that checks if the value of y is equal to 0"
". If it is, the function returns 1. Otherwise, the function returns the value of x multiplied by the result of calling the power function recursively with the arguments x and y-1."
"power(x,-2)
The image shows a code snippet for a recursive function named ""power"" that calculates the result of x raised to the power of -2.
The function first checks if the exponent (-2 in this case) is equal to 0. If it is, it returns 1."
"If the exponent is not 0, the function checks if a condition, which is always false, is true"
". Since the condition is always false, the function executes the code in the else block, which returns x multiplied by the result of calling the ""power"" function again with the arguments x and -3 (the original exponent minus 1)."
"Finally, the last line of code shows that the initial call to the ""power"" function with the arguments x and -2 can be simplified to x multiplied by the result of calling the ""power"" function with the arguments x and -3."
"power(x,-3)"
" to illustrate a recursive approach to calculate the power of a number. The expression ""power(x,-3)"" is being simplified to ""x*power(x,-4)"""
". There are also code snippets that seem to implement this logic, using conditional statements to handle the base case where the exponent is zero."
"The image shows a list of recursive calls to a function named ""power"". Each call takes two arguments: ""x"" and a negative integer. The first call is power(x, -2), which leads to x*power(x, -3)"
". Similarly, power(x, -3) leads to x*power(x, -4), power(x, -4) leads to x*power(x, -5), and power(x, -5) leads to x*power(x, -6). The ellipsis indicates that this pattern continues indefinitely."
"Finally, the text ""Non-termination"" highlights that this recursive process will not terminate."
"A code snippet shows a function named ""power"" that takes two integer arguments, x and y.The function returns an integer value.There is a comment ""//y>=0"" next to the function definition."
"Inside the function, there is an if statement that checks if y is equal to 0.If y is equal to 0, the function returns 1."
"Otherwise, the function returns the product of x and the result of calling the power function recursively with arguments x and y-1."
Termination condition
"We see a code snippet that shows a function called power. The function takes two integer arguments, x and y. There is a comment that y is greater than or equal to zero. There is an if statement that checks if y is equal to zero"
". If it is, the function returns one. This is labeled as the base case. Otherwise, the function returns x times the result of calling power recursively with x and y minus one. This is labeled as the recursive case."
Exercise 1
"Implement the recursive method ""square"" of integer n, which calculates the square of n when n is greater than 1. The formula to consider in the implementation is: open parenthesis N minus 1 close parenthesis squared, equals N squared minus 2N plus 1."
Exercise 2
"We are asked to implement a recursive method called ""riddle"" that takes two integer arguments, p and q, both greater than zero. Each time the method is called, the value of q increases by one, while the value of p decreases by one"
". When p reaches zero, the method returns the value of q."
"The second question asks how many times the recursive and base cases are executed when calling riddle with arguments 3 and 5, and what value is returned."
"Factorial
 the concept of factorial and presents a recursive method to compute the factorial of a natural number."
"The factorial of a natural number n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1."
" a recursive method to compute the factorial of a natural number n, denoted by fac(n). The method defines fac(n) as n multiplied by the factorial of n-1, which is fac(n-1)"
". This recursive definition continues until n becomes 1, at which point fac(1) is defined as 1."
" two examples to illustrate the recursive method:
- fac(5) = 5! = 5 * 4 * 3 * 2 * 1
- fac(4) = 4! = 4 * 3 * 2 * 1"
"Factorial
Trick: Assume you have the problem solved for a simpler task.
Fac of n equals n factorial, which equals n times n minus 1 times 2 times 1.
Fac of n minus 1 equals n minus 1 factorial, which equals n minus 1 times 2 times 1."
"n factorial equals n times n minus 1 factorial.
Fac of n equals n times fac of n minus 1."
"Factorial
 about factorials. The second trick to remember about factorials is to check the border conditions. The factorial of zero is equal to zero factorial, which is equal to one."
"Factorial
 a factorial function, called ""fac"".
If the input ""n"" is equal to zero, the function returns one.
If the input ""n"" is greater than zero, the function returns n multiplied by the factorial of n minus one."
"Factorial
 the concept of factorial and shows a possible implementation in C programming language."
"The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120. The value of 0! is 1."
" a mathematical definition of the factorial function:
- If n is less than or equal to 1, then the factorial of n is 1.
- Otherwise, the factorial of n is calculated by multiplying n by the factorial of n-1."
" provides the C code implementation of the factorial function:
- The function `fac` takes an integer `n` as input and returns a long integer.
- It first checks if `n` is less than or equal to 1. If it is, it returns 1 (base case)."
"- Otherwise, it recursively calls the `fac` function with `n-1` and multiplies the result by `n` (recursive case)."
"The code implementation highlights the two key aspects of recursion: the base case and the recursive case. The base case stops the recursion, while the recursive case breaks down the problem into smaller subproblems."
Operational View
" the operational view of a factorial function. It shows two ways to calculate the factorial of 3. The first way is to calculate the factorial of 2, then multiply the result by 3"
". The factorial of 2 is calculated by multiplying 2 by the factorial of 1. The factorial of 1 is 1. The second way is to calculate 2 multiplied by the factorial of 1, then multiply the result by 3. The factorial of 1 is 1"
". Both ways result in the same answer, which is 6."
Mathematical View
We see three equations that describe a way to calculate the factorial of a number. The first equation shows that the factorial of 3 is equal to 3 multiplied by the factorial of 2
. The second equation shows that the factorial of 2 is equal to 2 multiplied by the factorial of 1. The third equation shows that the factorial of 1 is equal to 1.
"Exercise 3
Implement the recursive method gcd(int a, int b), which allows computing the greatest common divisor of two integer numbers.
The method is defined as follows:
gcd(x, y) = x if y = 0
gcd(x, y) = gcd(y, remainder(x, y)) if y > 0"
"Exercise 4
Implement the recursive method ""decToBin"" that takes an integer ""decimal"" and a String ""binary"" as parameters. This method receives a decimal number and returns a String containing the equivalent binary representation of that number."
"2
Overview
. Searching
. Sorting (basic algorithms)
A. Bubble Sort
B. Selection Sort
Insertion Sort
C."
"3
. Searching"
"4
. Searching
. One of the most common operations in computer science
. The efficiency of the searching algorithm depends on
whether the information is sorted or not
. Searching algorithms may internally call a sorting algorithm"
"5
. Searching: Practical example
. Think of a number between 0 and 999
. Tell someone to guess your number
.
In every try your colleague tells you a number and youcan answer:
´ If the number is correct"
"´ If the number is higher than your number
´ If the number is lower that you number"
"6
. Searching: Linear search
. Starting from:
´ An array of elements a[ ] and
´ An element x we want to search
. We traverse the array from left to right comparing each
of its elements with x"
"´ If they are equal, then we return the position of the element
and the search ends
´ If they are different, then we keep searching until the end
of the array.
If we do not find the element x we return value -1"
"3.
ü Complexity of linear order => O(n)
http://www.cs.armstrong.edu/liang/animation/web/LinearSearch.html"
"7
. Searching: Linear search
public static int linearSearch(int a[], int x) {
for (int i = 0; i < a.length ; i++) {
if (a[i] == x){
return i;
}
}
return -1;
}
 8

-2 31 3 12 9 10 -5
"
0     1     2     3     4     5     6     7     8     9     10
"8
. Searching: Binary search
.
Starting from:
´ A sorted array of elements a[ ] and
´ An element x we want to search
. We store in a variable “half” the position of the element which is in the middle of
the array"
"3. We compare the element which is in “half” with x
´ If they are equal, then we return “half”
´ If it is lower, then we repeat the search between “half+1” and the end of the array"
"´ If it is higher, then we repeat the search between the beginning of the array and “half-1”
In each iteration we get a subarray which is approximately half the size
If we do not find the element x we return value -1
.
."
"ü Complexity of logarithmic order (more efficient) => O(log n)
http://www.cs.armstrong.edu/liang/animation/web/BinarySearch.html"
"9
. Searching: Binary search
public static int binarySearch(int a[], int x) {
int half;
int first = 0;
int last = a.length -1;
while (first <= last) {
half = (first + last)/2;
if(a[half] == x){
return half;"
"}else if(a[half] < x){
first = half+1;
}else if(a[half] > x){
last = half-1;
}
}
return -1;
}
First iteration
•
•
If a[half]>x, we search in [0...half-1]
If a[half]<x, we search in a[half+1, a.length-1]
-5 -2




 10 12 26 31"
0     1     2     3     4     5     6     7     8     9     10
"10
Exercise 1
´ Implement the method public static int"
"binarySearchString(String[] s, String x),which does a binary search of element x in the arrayof strings s. Use the method compareTo() of classString, which compares two stringslexicographically."
"´ Given the array {""a"",""b"",""d"",""f"",""h"",""n"",""p"",""q"",""r"",""v"",""z""}how many iterations are needed to search “f”, “r”and “w” with binary search? And with linear search?"
"11
. Searching: Conclusions
. For smaller sizes (e.g., N<6)
´ It is not worthy using a binary search since it usesapproximately the same number of comparisonsas a linear search"
"2. Last iterations in a binary search are slower
. A hybrid approach could be interesting
´ We apply binary search until the range is small
´ Then, we apply linear search"
"12
. Sorting"
"13
. Sorting
. Sorted data structures makes searching easier
(e.g., book, dictionary…)
. Binary search takes advantage of the order"
"14
.1 Bubble Sort
. The algorithm moves forward through the data
structure swapping pairs of contiguous elementswhich are not in the correct order"
"´ If we sort from the lowest to the highest, the highestelement moves to the end (as it was a bubble)
. These passes are repeated until no more swapping
is needed
. Elements which advanced to their correct position"
"do not need to be checked again´ Each pass needs to check one less element
http://www.cs.armstrong.edu/liang/animation/web/BubbleSort.html
http://www.algostructure.com/sorting/bubblesort.php"
"15
.1 Bubble Sort. Example (I)
• Ascending order (from the lowest to the highest)
q Two loops: internal and external
q External loop: first iteration
q Internal loop from 0 to length-1 (6 in
this example)"
"v Swapping if element in position j ishigher than element in position j+1
v Ends with 1 element in its correct
position
q External loop: second iteration
q Internal loop from 0 to length-2 (5 in
the example)"
"v Swapping if element in position j ishigher than element in position j+1
v Ends with 2 elements in their correct
position"
"16
.1 Bubble Sort. Example (II)
• Ascending order (from the lowest to the highest)
q External loop: third iteration
q Internal loop from 0 to length-3 (4 in
the example)
v …
v 3 elements in the correct position"
"q External: fourth iteration.q Internal: from 0 to length-4
q External: fifth iteration.q Internal: from 0 to length-5"
"q External: sixth iteration.q Internal: from 0 to length-6
v In the example with six iterations of the externalloop all the elements are in their correct position"
"17
.1 Bubble Sort
. External loop:
o
Number of iterations: length of array - 1 (in each iteration one element issorted, except for the last one in which two elements are sorted)
•
Range of the index in the external loop [0, length of array – 1)"
"2.
Internal loop:
o
o
o
In the first iteration of the external (i=0), length of array - 1 iterations
In the second iteration of the external (i=1), length of array - 2 iterations"
"In the m-th iteration of the external (i=m-1), length of array - i - 1 iterations
•
Range of the index in the internal loop [0,  length of array - 1 - i)
. After m-th iteration (i=m-1) of the external loop:
o
o"
"Elements from 0 to length of array - 2 - i are unsorted
Elements from length of array - 1 - i to length of array - 1 are sorted"
"18
.1 Bubble Sort
public static void bubbleSort (int[] a) {
for (int i=0; i<a.length-1; i++) {
for (int j=0; j<a.length-1-i; j++) {
if (a[j]>a[j+1]){
swap(a, j, j+1);
}
}
}
}
q Alternative:"
"v External loop from 1 to a.length and   Internal loop from 0 to a.length-i
public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
"19
Exercise 2
´ Starting from the implementation of Bubble Sortprovided, which sorts the elements in an array inascending order, make the necessary changes to sortthe array received as parameter in descending order"
"20
Exercise 3
´ Using the sorting algorithm Bubble Sort, how many
swaps are needed to sort the following array from thehighest element to the lowest element (descendingorder)?
{1,3,5,7,11,13}"
"21
.1 Bubble Sort: Conclusions
v Advantages:
´ Little additional memory is needed
´ Few lines of code
´ Efficient for arrays with few elements
v Drawbacks:
´ Inefficient for arrays with many elements
v
v
v"
"O(n2) => quadratic order (two nested loops for an array of n elements)
For a given array there are always the same number of iterations/comparisons (even though it is alreadysorted), even though there are no swaps
Too many swaps"
"´ Larger elements move fast to the end (they can reach the end in one iteration of
the external loop), but lower elements move slower to the beginning (they gain oneposition per iteration)
v"
Improvement: Cocktail sort (double internal loop to pass from left to right and from right to left in eachiteration of the external loop)
"22
.2 Selection Sort
.
In ascending order
´ Searches the minimum element and puts it in the first position (swap)
´ Searches the next minimum element and puts it in the second position
(swap)"
"´ In general, searches the minimum element between i and the end ofthe data structure and puts in the i-th position through swapping
."
"In descending order
´ Searches the maximum element and puts it in the first position (swap)
´ Searches the next maximum element and puts it in the second position
(swap)
´ In general, searches the maximum element between i and the end of"
"the data structure and puts in the i-th position through swapping
http://www.cs.armstrong.edu/liang/animation/web/SelectionSort.html
http://www.algostructure.com/sorting/selectionsort.php"
"23
.2 Selection Sort. Example (I)
• Ascending order (from the lowest to the highest)
 is the minimum unsorted element: swapping with element in position 0
q Two loops: internal and external"
"29 is the minimum unsorted element: swapping with element in position 1
 is the minimum unsorted element: swapping with element in position 2
q External loop: sorts the first position."
"As part of this loop there is aswapping between the element inposition i and the minimum unsortedelement
q Internal loop: searches the minimumelement from position i until the endof the data structure"
"24
.2 Selection Sort. Example (II)
• Ascending order (from the lowest to the highest)
 is the minimum unsorted element: swapping with element in position 3
 is the minimum unsorted element: swapping with element in position 4"
"95 is the minimum unsorted element. It is in the correct position. No swapping.
 is the minimum unsorted element. It is in the correct position. No swapping."
"25
.2 Selection Sort
. External loop:
o
Number of iterations: length of array (in each iteration one element issorted, although the last iteration is not strictly needed)
•
Range of the index in the external loop [0, length of array – 1]
."
"Internal loop (searching the minimum / maximum):
o
o
o
In the first iteration of the external (i=0), length of array - 1 iterations
In the second iteration of the external (i=1), length of array - 2 iterations"
"In the m-th iteration of the external (i=m-1), length of array - i iterations
•
Range of the index in the internal loop [i,  length of array – 1]
. After m-th iteration (i=m-1) of the external loop:
o
o
Elements from 0 to i are sorted"
Elements from i+1 to length of array - 1 are unsorted
"26
.2 Selection Sort
public static void selectionSort (int[] a) {
for (int i=0; i<a.length; i++) {
int m = i;
for (int j=i; j<a.length; j++) {
if (a[j]<a[m]){
m = j;
}
}
swap(a, i, m);
}
}
q Alternative:"
"v External loop to a.length - 1
v Internal loop from j+1 to a.length
saves one unnecessary comparison
public static void swap (int[] a, int i, int j) {
int aux=a[i];
a[i]=a[j];
a[j]=aux;
}"
"27
Exercise 4
´ Starting from the implementation of Selection Sortprovided, which sorts the elements in an array inascending order, make the necessary changes to sortthe array received as parameter in descending order"
"28
Exercise 5
´ Using the sorting algorithm Selection Sort, how many"
"swaps are needed to sort the following array from thehighest element to the lowest element (descendingorder)? Use the algorithm we saw in the class, whichmoves to the left the maximum unsorted element
{1,3,5,7,11,13}"
"29
.2 Selection Sort: Conclusions
v Advantages:
´ Little additional memory is needed
´ Few lines of code
´ Efficient for arrays with few elements
v Drawbacks:
´ Inefficient for arrays with many elements
v
v
v Variant:"
"O(n2) => quadratic order (two nested loops for an array of n elements)
For a given array there are always the same number of iterations (even though it is alreadysorted), even though there are no swaps
ü
But much less swaps than with Bubble Sort"
"´ Placing the maximum/minimum at the end, instead of placing the
maximum/minimum at the beginning"
"30
.3 Insertion Sort
. The data structure is divided in two parts:
´ the first part (e.g., left side) is already sorted,
´ the second part (e.g., right side) is unsorted.
´ At the beginning the first part is empty and the second part full"
"2. We extract the first element of the second part, inserting it in
its correct position in the first part (sorted)
. This step is repeated until all the elements are (sorted) in the
first part."
"http://www.cs.armstrong.edu/liang/animation/web/InsertionSort.html
http://www.algostructure.com/sorting/insertionsort.php"
"31
.3 Insertion Sort. Example (I)
• Ascending order (from the lowest to the highest)
We take 80 from the unsorted part and insert it in its correct position in the sorted part"
We take 95 from the unsorted part and insert it in its correct position in the sorted part.
"We take 14 from the unsorted part and insert it in its correct position in the sorted part.
Additionally, 80 and 95 are moved one position to the right to fill the gap left by 14
q Two loops: internal and external"
"q External loop: it traverses the array,leaving sorted what is behindposition i. As part of the externalloop the element to be sorted ismoved to its right position"
q Internal loop: it moves one positionto the right all the elements that arelocated between where the newsorted element is inserted and theposition it left in the unsorted part ofthe array (now that position issorted)
"32
.3 Insertion Sort. Example (II)
• Ascending order (from the lowest to the highest)
We take 98 from the unsorted part and insert it in its correct position in the sorted part"
"We take 29 from the unsorted part and insert it in its correct position in the sorted part.
Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 29"
"33
.3 Insertion Sort. Example (III)
• Ascending order (from the lowest to the highest)"
"We take 49 from the unsorted part and insert it in its correct position in the sorted part.
Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49"
"We take 66 from the unsorted part and insert it in its correct position in the sorted part.
Additionally, 80, 95 and 96 are moved one position to the right to fill the gap left by 66"
"34
.3 Insertion Sort
. External loop:
o Number of iterations: length of array (in each iteration one
element is sorted, including in the last iteration)
•
Range of the index in the external loop [0, length of array – 1]
."
"Internal loop (finding the correct position to insert):
o
o
The number of iterations depends on the position “advanced” bythe element which is inserted"
"If the element inserted moves k positions to the left, then there arek elements that are moved one position to the right
. After m-th iteration (i=m-1) of the external loop:
o
o
Elements from 0 to i are sorted"
Elements from i+1 to length of array - 1 are unsorted
"35
.3 Insertion Sort
public static void insertionSort (int[] a){
for (int i=0; i<a.length; i++){
int tmp=a[i];
int j=i;
while (j>0 && tmp<a[j-1]){
a[j]=a[j-1];
j--;
}
a[j]=tmp;
}
}
q Alternative:
v External loop from i=1, since the"
first element always stays in thesame position
"36
.3 Insertion Sort with auxiliary method
public static void insertionSort (int[] a) {
for (int i=0; i<a.length; i++) {
insert (a, i);
}
}
private static void insert (int[] a, int i) {
int tmp=a[i];
int j=i;
while (j>0 && tmp<a[j-1]){"
"a[j]=a[j-1];
j--;
}
a[j]=tmp;
}
v Auxiliary method insert(int[a], int i),
inserts the element at position i inthe appropriate place of a, movingthe needed elements one position tothe right"
"37
Exercise 6
´ Starting from the implementation of Insertion Sortprovided, which sorts the elements in an array inascending order, make the necessary changes to sortthe array received as parameter in descending order"
"38
Exercise 7
´ Using the sorting algorithm Insertion Sort, how many
swaps are needed to sort the following array from thehighest element to the lowest element (descendingorder)?
{1,3,5,7,11,13}"
"´ Of the three algorithms seen so far, which was the most efficientone for this array? Try with other arrays with different values andlengths"
"39
.3 Insertion Sort: Conclusions
v Advantages:
´ Little additional memory is needed
´ Few lines of code
´ Efficient for arrays with few elements
´ More efficient than Selection Sort for (partially) sorted arrays"
"v For a given array there are always the same number of iterations in the external loop
(even though it is already sorted), but the internal loop is adaptable
v Drawbacks:
´ Inefficient for arrays with many elements"
"v O(n2) => quadratic order (two nested loops for an array of n elements)
´ Inefficient when the array to sort in the reverse sorted order"
"Overview
 ""Overview"" presents two main topics: Searching and Sorting. The Sorting section focuses on basic algorithms, specifically Bubble Sort, Selection Sort, and Insertion Sort."
"1. Searching
The image shows wooden letter tiles spelling out the word ""SEARCH"". The tiles are scattered among many other blank tiles."
"1. Searching
- One of the most common operations in computer science.
- The efficiency of the searching algorithm depends on whether the information is sorted or not.
- Searching algorithms may internally call a sorting algorithm."
"**1. Searching: Practical example**
 a practical example of searching.
The first step is to think of a number between 0 and 999.
The second step is to tell someone to guess your number."
"The third step is to have your colleague guess a number and for you to tell them if the number is correct, higher than your number, or lower than your number."
1. Searching: Linear search
"Linear search starts with an array of elements and an element we want to search for.
We traverse the array from left to right comparing each of its elements with the element we are searching for."
"If the elements are equal, then we return the position of the element and the search ends.
If they are different, then we keep searching until the end of the array.
If we do not find the element we return value -1.
The complexity of linear order is O(n)."
1. Searching: Linear search
" how to search for an element in an array using linear search. The algorithm is implemented in a function called ""linearSearch"" which takes as input an array of integers ""a"" and an integer ""x"""
". The function iterates over the array and checks if the current element is equal to ""x"". If it is, the function returns the index of the current element. Otherwise, the function continues to the next element"
". If the element is not found in the array, the function returns -1."
" shows an example of an array with 10 elements. The elements are: 26, 8, 0, -2, 31, 3, 12, 9, 10, -5, and 6. The indices of the elements are: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10."
"1. Searching: Binary search
The image describes the binary search algorithm."
"We start from a sorted array of elements and an element we want to search for. We store in a variable called ""half"" the position of the element which is in the middle of the array"
". We compare the element in position ""half"" with the element we are searching for. If they are equal, then we return ""half"""
". If the element in position ""half"" is lower than the element we are searching for, then we repeat the search between ""half+1"" and the end of the array"
". If the element in position ""half"" is higher than the element we are searching for, then we repeat the search between the beginning of the array and ""half-1"". In each iteration we get a sub-array which is approximately half the size"
". If we do not find the element we are searching for, we return value -1."
"The complexity of the binary search algorithm is logarithmic order, which is more efficient than linear order."
"1. Searching: Binary search
The image shows a code snippet for a binary search algorithm in Java."
"```java
public static int binarySearch(int a[], int x) {
  int half;
  int first = 0;
  int last = a.length - 1;
  while (first <= last) {
    half = (first + last) / 2;
    if (a[half] == x) {
      return half;
    } else if (a[half] < x) {"
"first = half+1;
    } else if (a[half] > x) {
      last = half-1;
    }
  }
  return -1;
}
```"
"The code searches for a given value `x` in a sorted array `a`. It initializes two pointers, `first` and `last`, to the first and last indices of the array, respectively."
"The algorithm then enters a loop that continues as long as `first` is less than or equal to `last`. In each iteration, it calculates the middle index `half` and compares the value at `a[half]` with `x`."
"- If `a[half]` is equal to `x`, the search is successful, and the index `half` is returned.
- If `a[half]` is less than `x`, the search continues in the right half of the array by updating `first` to `half+1`."
"- If `a[half]` is greater than `x`, the search continues in the left half of the array by updating `last` to `half-1`.
If the loop completes without finding `x`, the algorithm returns -1, indicating that the value is not present in the array."
"The image also includes a visual representation of the first iteration of the algorithm. The array contains the following sorted values: -5, -2, 0, 3, 6, 8, 9, 10, 12, 26, and 31."
"- If the value of `x` is greater than the value at `a[half]`, the search continues in the subarray from index `half+1` to `a.length-1`."
"- If the value of `x` is less than the value at `a[half]`, the search continues in the subarray from index 0 to `half-1`."
Exercise 1
"We will implement the method ""binarySearchString"" which takes as input an array of strings and a string. This method performs a binary search of the string in the array of strings"
". The method uses the ""compareTo"" method of the string class, which compares two strings lexicographically."
"Given the array of strings ""a"", ""b"", ""d"", ""f"", ""h"", ""n"", ""p"", ""q"", ""r"", ""v"", ""z"", we are asked to count the number of iterations needed to search for the strings ""f"", ""r"" and ""w"" using binary search and linear search."
Searching: Conclusions
"There are three conclusions about searching algorithms. First, for smaller data sizes, for example, N less than 6, it is not worth using a binary search since it uses approximately the same number of comparisons as a linear search"
". Second, the last iterations in a binary search are slower than the last iterations in a linear search. Finally, a hybrid approach could be interesting. In this approach, we apply binary search until the range is small, then we apply linear search."
2. Sorting
"The image shows five glasses containing liquids of different colors. From left to right, the colors are orange, blue, yellow, turquoise, and red. The glasses are identical in shape and size, and are arranged in a row on a surface"
". The background of the image is blurred, but appears to be an outdoor setting with snow on the ground and trees in the distance."
"2. Sorting
- Sorted data structures make searching easier, for example, books and dictionaries.
- Binary search takes advantage of the order."
2.1 Bubble Sort
"The algorithm moves forward through the data structure swapping pairs of contiguous elements which are not in the correct order. If we sort from the lowest to the highest, the highest element moves to the end (as it was a bubble)"
. These passes are repeated until no more swapping is needed. Elements which advanced to their correct position do not need to be checked again. Each pass needs to check one less element.
"2.1 Bubble Sort. Example (I)
We have an example of a bubble sort algorithm, sorting in ascending order from the lowest to the highest. The original array is 80 95 14 98 29 49 66."
"The algorithm uses two loops: internal and external. The external loop iterates over the array multiple times. The internal loop iterates over the unsorted portion of the array, comparing adjacent elements and swapping them if they are in the wrong order."
"In the first iteration of the external loop, the internal loop iterates from index 0 to length-1, which is 6 in this example. The algorithm swaps elements if the element in position j is higher than the element in position j+1"
". At the end of the first iteration, the largest element, 98, is in its correct position at the end of the array."
"The second iteration of the external loop is similar to the first, but the internal loop iterates from index 0 to length-2, which is 5 in this example"
". At the end of the second iteration, the two largest elements, 95 and 98, are in their correct positions at the end of the array"
". The algorithm continues in this manner, with each iteration of the external loop placing one more element in its correct position, until the entire array is sorted."
"2.1 Bubble Sort. Example (II)
The image describes the Bubble sort algorithm with an example.
The algorithm sorts an array of numbers in ascending order, from the lowest to the highest."
"The example shows 7 arrays, each array represents an iteration of the external loop of the algorithm.
The first array contains the following unsorted elements: 14, 80, 29, 49, 66, 95, 98."
"The second array shows the status after the first iteration of the external loop: 14, 29, 80, 49, 66, 95, 98.
The third array shows the status after the second iteration of the external loop: 14, 29, 49, 80, 66, 95, 98."
"The fourth array shows the status after the third iteration of the external loop: 14, 29, 49, 66, 80, 95, 98.
The fifth, sixth and seventh arrays are identical to the fourth array, meaning that the array was fully sorted after 4 iterations."
"The image also describes the internal loop for each iteration:
- The internal loop for the third iteration of the external loop iterates from element at index 0 to the element at index length-3, which is 4 in this example."
- The internal loop for the fourth iteration of the external loop iterates from element at index 0 to the element at index length-4.
- The internal loop for the fifth iteration of the external loop iterates from element at index 0 to the element at index length-5.
- The internal loop for the sixth iteration of the external loop iterates from element at index 0 to the element at index length-6.
"After 3 iterations, the last 3 elements are in the correct position.
After 6 iterations, all the elements are in the correct position."
"2.1 Bubble Sort
The image describes the Bubble Sort algorithm."
"- The **external loop** iterates length of array - 1 times. In each iteration, one element is sorted, except for the last iteration in which two elements are sorted. The index in the external loop ranges from 0 to length of array - 1."
"- The **internal loop** iterates a different number of times depending on the iteration of the external loop. In the first iteration of the external loop (i=0), the internal loop iterates length of array - 1 times"
". In the second iteration of the external loop (i=1), the internal loop iterates length of array - 2 times. In the m-th iteration of the external loop (i=m-1), the internal loop iterates length of array - i - 1 times"
. The index in the internal loop ranges from 0 to length of array - 1 - i.
"- After the m-th iteration (i=m-1) of the external loop, the elements from index 0 to length of array - 2 - i are unsorted, and the elements from index length of array - 1 - i to length of array - 1 are sorted."
2.1 Bubble Sort
The image shows code for a bubble sort algorithm in Java. The first function *bubbleSort* takes an integer array as input. It then iterates through the array with two nested for loops. The outer loop iterates from 0 to the length of the array minus 1
". The inner loop iterates from 0 to the length of the array minus 1 minus the index of the outer loop. Inside the inner loop, if the element at the current index is greater than the element at the next index, the two elements are swapped."
The second function *swap* takes as input an integer array and two integer indices. It swaps the elements at the two given indices in the array.
There is also an alternative implementation of the algorithm where the external loop iterates from 1 to the length of the array and the internal loop iterates from 0 to the length of the array minus the index of the outer loop.
"Exercise 2
Starting from the implementation of Bubble Sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order."
"Exercise 3
Using the sorting algorithm Bubble Sort, how many swaps are needed to sort the following array from the highest element to the lowest element (descending order)? The array is: 1, 3, 5, 7, 11, 13."
"2.1 Bubble Sort: Conclusions
 the advantages and disadvantages of the bubble sort algorithm.
Advantages:
- Little additional memory is needed
- Few lines of code
- Efficient for arrays with few elements"
"Drawbacks:
- Inefficient for arrays with many elements
  - O(n^2) => quadratic order (two nested loops for an array of n elements)"
"- For a given array there are always the same number of iterations/comparisons (even though it is already sorted), even though there are no swaps
- Too many swaps"
"- Larger elements move fast to the end (they can reach the end in one iteration of the external loop), but lower elements move slower to the beginning (they gain one position per iteration)"
Improvement: Cocktail sort (double internal loop to pass from left to right and from right to left in each iteration of the external loop)
"2.2 Selection Sort
 the selection sort algorithm.
Selection sort can be performed in ascending or descending order."
"In ascending order, the algorithm first searches for the minimum element and puts it in the first position by swapping it with the element currently in the first position"
". It then searches for the next minimum element and puts it in the second position, again by swapping"
". In general, the algorithm searches for the minimum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping."
"In descending order, the algorithm first searches for the maximum element and puts it in the first position by swapping it with the element currently in the first position"
". It then searches for the next maximum element and puts it in the second position, again by swapping"
". In general, the algorithm searches for the maximum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping."
Two URLs are provided at the bottom of the slide.
"2.2 Selection Sort. Example (1)
 how the selection sort algorithm works, showing an example of sorting elements in ascending order, from the lowest to the highest."
"The algorithm uses two loops: an external loop and an internal loop. The external loop sorts the first position. As part of this loop, there is a swapping between the element in position i and the minimum unsorted element"
. The internal loop searches the minimum element from position i until the end of the data structure.
"The example shows a list of numbers: 80, 95, 14, 98, 29, 49, and 66. The algorithm starts by finding the minimum unsorted element, which is 14. Then, it swaps 14 with the element in the first position, which is 80"
". The list now becomes: 14, 95, 80, 98, 29, 49, 66."
"The algorithm continues in the same way, finding the minimum unsorted element and swapping it with the element in the correct position. The next minimum unsorted element is 29, which is swapped with 95. The list becomes: 14, 29, 80, 98, 95, 49, 66."
"The process repeats until the list is sorted in ascending order: 14, 29, 49, 98, 95, 80, 66."
"2.2 Selection Sort. Example (II)
The image illustrates the ascending selection sort algorithm.
The unsorted array is: 14, 29, 49, 98, 95, 80, 66."
"First, 66 is selected as the minimum value and swapped with the element in position 3. The array becomes: 14, 29, 49, 66, 95, 80, 98."
"Next, 80 is selected as the minimum value and swapped with the element in position 4. The array becomes: 14, 29, 49, 66, 80, 95, 98.
The next two elements, 95 and 98, are already in the correct position, so no swapping is needed."
"The final sorted array is: 14, 29, 49, 66, 80, 95, 98."
"2.2 Selection Sort
We're going to talk about the selection sort algorithm. The algorithm consists of two nested loops: an external loop and an internal loop."
"The external loop iterates over the array, and for each iteration, one element is sorted. The number of iterations is equal to the length of the array. The range of the index in the external loop is from 0 to the length of the array minus 1."
"The internal loop searches for the minimum or maximum value in the unsorted part of the array. In the first iteration of the external loop, the internal loop performs length of the array minus 1 iterations"
". In the second iteration of the external loop, the internal loop performs length of the array minus 2 iterations. In the m-th iteration of the external loop, the internal loop performs length of the array minus m iterations"
. The range of the index in the internal loop is from i to the length of the array minus 1.
"After the m-th iteration of the external loop, the elements from index 0 to index i are sorted, and the elements from index i plus 1 to the length of the array minus 1 are unsorted."
"2.2 Selection Sort
The image shows a code snippet for the Selection Sort algorithm in Java."
The first function `selectionSort` takes an integer array `a` as input. It has two nested for loops. The outer loop iterates through the array from index 0 to the end. The inner loop iterates through the unsorted subarray from index `i` to the end
". The inner loop finds the index `m` of the minimum element in the unsorted subarray. After the inner loop, the function swaps the elements at indices `i` and `m` using the `swap` function."
The second function `swap` takes an integer array `a` and two integer indices `i` and `j` as input. It swaps the elements at indices `i` and `j` using an auxiliary variable `aux`.
"There is also an ""Alternative"" note that suggests two optimizations for the `selectionSort` function:
- Change the outer loop to iterate up to `a.length - 1`.
- Change the inner loop to iterate from `j + 1` to `a.length`."
These optimizations save one unnecessary comparison because the last element will already be in its sorted position.
"Exercise 4
Starting from the implementation of Selection Sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order."
Exercise 5
"Using the sorting algorithm Selection Sort, how many swaps are needed to sort the following array from the highest element to the lowest element (descending order)"
"? Use the algorithm we saw in the class, which moves to the left the maximum unsorted element"
.
"The array is: 1, 3, 5, 7, 11, 13."
"2.2 Selection Sort: Conclusions
Let's talk about the advantages and drawbacks of selection sort, as well as a variant of the algorithm."
"Some of the advantages of selection sort are that it requires little additional memory, only a few lines of code are needed to implement it, and it is efficient for arrays with few elements."
"However, selection sort also has some drawbacks. It is inefficient for arrays with many elements, as it has a time complexity of big O of n squared, meaning it has a quadratic order"
". This is because the algorithm uses two nested loops for an array of n elements. Additionally, for a given array, there are always the same number of iterations, even if the array is already sorted, and even though there are no swaps"
". However, it is worth noting that selection sort does perform much less swaps than bubble sort."
"Finally, let's discuss a variant of the selection sort algorithm. Instead of placing the maximum or minimum element at the beginning of the array, this variant places it at the end."
2.3 Insertion Sort
"The data structure is divided into two parts: the first part, for example the left side, is already sorted and the second part, for example the right side, is unsorted. At the beginning, the first part is empty and the second part is full"
". We extract the first element of the second part, inserting it in its correct position in the first part, which is sorted. This step is repeated until all the elements are sorted in the first part."
"The first diagram shows an example of this with the sorted partial result on the left, less than x and greater than x, and the unsorted data on the right"
". One element from the unsorted data, x, is highlighted in red with an arrow pointing to where it will be inserted in the sorted partial result."
"The second diagram shows the result after the insertion of x. The sorted partial result is now less than x, x, and greater than x. The unsorted data now has one less element."
"2.3 Insertion Sort. Example (1)
The image illustrates the insertion sort algorithm with an example, focusing on arranging numbers in ascending order, from lowest to highest. The initial unsorted array is: 80, 95, 14, 98, 29, 49, 66."
"The algorithm utilizes two loops: an external and an internal loop. The external loop iterates through the array, progressively leaving the elements behind its current position sorted"
". The internal loop shifts elements larger than the element being inserted one position to the right, creating space for the element to be placed in its correct sorted position."
"The example demonstrates this process step-by-step. Initially, 80 is considered sorted. Then, 95 is compared to 80 and remains in its position as it's larger. Next, 14 is encountered"
". The internal loop moves 95 and 80 one position to the right, and 14 is inserted at the beginning, resulting in the sequence: 14, 80, 95, 98, 29, 49, 66"
. This process continues for each remaining element in the unsorted part of the array until the entire array becomes sorted.
2.3 Insertion Sort. Example (II)
" the insertion sort algorithm in ascending order. It starts with the array ""14 80 95 98 29 49 66"""
". The algorithm takes the element 98, which is the first element of the unsorted part, and inserts it into its correct position in the sorted part. The sorted part is the sub-array that includes the elements before 98"
". The second step is to take the element 29 and insert it into its correct position in the sorted part. The elements 80, 95, and 98 are moved one position to the right to fill the gap left by 29. The final sorted array is ""14 29 80 95 98 49 66""."
"2.3 Insertion Sort. Example (III)
The image describes the insertion sort algorithm in ascending order, using an example."
"We take the number 49 from the unsorted part and insert it in its correct position in the sorted part. Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49."
"We take 66 from the unsorted part and insert it in its correct position in the sorted part. Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 66."
"2.3 Insertion Sort
The image describes the Insertion Sort algorithm."
"* **External loop**:    * The number of iterations is equal to the length of the array. In each iteration, one element is sorted, including the last iteration.
    * The range of the index in the external loop is from 0 to the length of the array - 1."
"* **Internal loop (finding the correct position to insert)**:
    * The number of iterations depends on the position ""advanced"" by the element which is inserted."
"* If the element inserted moves k positions to the left, then there are k elements that are moved one position to the right."
"* **After m-th iteration (i=m-1) of the external loop**:
    * Elements from index 0 to i are sorted.
    * Elements from index i+1 to the length of the array - 1 are unsorted."
"2.3 Insertion Sort
We have the code for an insertion sort algorithm in Java. The method signature is public static void insertionSort and it takes an integer array a as input."
"The algorithm iterates through the array with a for loop, starting from the second element (index 1). For each element a[i], it stores its value in a temporary variable tmp and initializes an index j to i."
"Then, a while loop compares tmp with the elements to its left (a[j-1]). If tmp is smaller than the element to its left, it shifts the left element one position to the right (a[j]=a[j-1]) and decrements j"
. This process continues until tmp is no longer smaller than the element to its left or j reaches 0.
"Finally, tmp is placed in its correct sorted position (a[j]=tmp).
An alternative implementation could start the external loop from i=1, as the first element is always considered sorted."
"2.3 Insertion Sort with auxiliary method
The image shows two code snippets."
"The first snippet shows a function called ""insertionSort"" which takes an integer array ""a"" as input. It iterates through the array from the first element to the last one"
". For each element at index ""i"", it calls the ""insert"" function with the array ""a"" and the index ""i"" as input."
"The second snippet shows a function called ""insert"" which takes an integer array ""a"" and an integer ""i"" as input. It first stores the value of the element at index ""i"" in a temporary variable ""tmp"""
". Then, it iterates through the array from index ""i"" down to the first element. For each element at index ""j"", if the value of ""tmp"" is less than the value of the element at index ""j-1"", it moves the element at index ""j-1"" to index ""j"""
". Otherwise, it breaks the loop. Finally, it assigns the value of ""tmp"" to the element at index ""j""."
"The auxiliary method ""insert(int[a], int i)"" inserts the element at position ""i"" in the appropriate place of ""a"", moving the needed elements one position to the right."
"Exercise 6
Starting from the implementation of insertion sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order."
"Exercise 7
We are asked to count the swaps needed to sort the array ""1, 3, 5, 7, 11, 13"" from highest to lowest using the Insertion Sort algorithm."
"Then, we are asked which of the three algorithms seen so far is the most efficient for this particular array and encouraged to try other arrays with different values and lengths."
"2.3 Insertion Sort: Conclusions
 the advantages and drawbacks of insertion sort."
"Advantages:
- Little additional memory is needed
- Few lines of code
- Efficient for arrays with few elements"
"- More efficient than Selection Sort for (partially) sorted arrays because for a given array there are always the same number of iterations in the external loop (even though it is already sorted), but the internal loop is adaptable"
"Drawbacks:
- Inefficient for arrays with many elements because it has quadratic order: two nested loops for an array of n elements
- Inefficient when the array to sort is in reverse sorted order"

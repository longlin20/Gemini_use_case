[{"filename": "5. LinkedLists.pdf", "text": "Systems Programming\n\nLinked lists\n\nDepartamento de Ingenier\u00eda\nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nCarlos Delgado Kloos, Jes\u00fas Arias Fisteus, Carlos Alario Hoyos,\nM. Carmen Fern\u00e1ndez Panadero, Julio Villena Rom\u00e1n\n\n1\n\n\fContents\n\nv *** Introduction to generics\nv Data structures\nv Linked lists\n\n\u2022 The class Node\n\n\u2022 The class LinkedList\n\n\u2022 Benefits and drawbacks of linked lists\n\n\fIntroduction to generics\n\n\u2022 Service provided by Java (J2SE 5.0 and above)\n\n\u2022 Generics allow checking object types during \n\ncompile time \no Errors are detected at compile time (guaranteeing \n\ncompatible types during runtime)\n\n\fIntroduction to generics\n\nWithout Generics\n\nList list = new ArrayList();\nlist.add(\u201ctest\u201d);\nInteger value = (Integer) list.get(0);\n\nError at runtime \n\n\u201cClassCastException\u201d.           \n\nThe program stops\n\nAbstractList\n\nList\n\nextends\n\nimplements\n\nArrayList\n\n\fIntroduction to generics\n\nWith Generics\n\nList<Integer> list = new ArrayList<Integer>();\nlist.add(\u201ctest\u201d);\nInteger value = list.get(0);\n\nError at compile time \n\u201cThe method add(Integer) in the type List<Integer> \nis not applicable for the arguments (String)\u201d   \nThe error is detected before running the program\n\nAbstractList<E>\n\nList<E>\n\nextends\n\nimplements\n\nArrayList<E>\n\n\fIntroduction to generics\n\nCreation of a class that uses generics\n\npublic class ArrayList<E>{\n\npublic boolean add(E e){\u2026}\npublic void add(int index, E element)\npublic E get(int index){\u2026}\npublic E remove(int index)\npublic set(int index, E element)\n\n\u2026\n}\n\n\fIntroduction to generics\n\nWorking with a class that uses generics\n\nArrayList<Employee> employees = new ArrayList<Employee>();\nemployees.add(new Employee());\nEmployee myEmployee = employees.get(0);\nemployees.add(new Secretary());\nemployees.add(new Person());\nemployees.add(new Object());\n\nCompilation errors\n\n\fData Structures\n\n\u2022 Abstraction that represents a \n\ncollection of data in a program in \norder to ease its manipulation\n\u2022 The suitability of a data structure \n\ndepends on the nature of the data \nto be stored, and how that data will \nbe manipulated\n\n8\n\n\fLinear Data Structures\n\n\u2022 They organize data as a sequence, where \neach piece of data has a preceding datum\n(except for the first one) and a succeeding \ndatum (except for the last one)\n\u2022 Examples of linear data structures:\n\n\u2013 Arrays\n\u2013 Linked lists\n\u2013 Stacks\n\u2013 Queues\n\u2013 Double-ended queues\n\n9\n\n\fArrays\n\n\u2022 Advantages for storing linear data \n\ncollections:\n\u2013 Random access: any position in the array \n\ncan be accessed in constant time.\n\u2013 Efficient use of memory when all the \n\npositions of the array are in use, because \nthe array is stored in consecutive memory \npositions.\n\n10\n\n\fArrays\n\n\u2022 Disadvantages (I):\n\n\u2013 Static size: The size must be defined when \nthe array is created and cannot be changed \nlater. The main problems this poses are:\n\n\u2022 Inefficient use of memory when more positions \n\nthan needed are reserved \n\n\u2022 It may happen at runtime that more positions than \n\nreserved are needed\n\n\u2013 Need of contiguous memory:\n\n\u2022 Even having the system enough free memory, it \nmay happen that there is not enough contiguous \nspace, due to memory fragmentation\n\n11\n\n\fArrays\n\n\u2022 Disadvantages (II):\n\n\u2013 Some operations on the array have a \n\nsub-optimum cost:\n\n\u2022 Insertions and extractions (removals) of data in the \nfirst position or intermediate positions need data to \nbe moved to consecutive memory positions\n\n\u2022 Concatenation of arrays: data must be copied to a \n\nnew array\n\n\u2022 Partition of an array in several pieces: data must be \n\ncopied to new arrays\n\n12\n\n\fExercise 1\n\n\u2022 Create a ten-element array of integers and initialize \n\nall the elements with value 1. Then, insert an \nadditional element with value 0 in the fourth \nposition of the array.\n\n\u2022 Note: Inserting a new element is different from replacing an \n\nelement by another one.\n\n\fLinked Lists\n\n\u2022 Ordered sequence of nodes in which \n\neach node stores:\n\u2013 A piece of data (info)\n\u2013 A reference pointing to the next node\n\n\u2022 Nodes do not need to be in \n\nconsecutive memory positions \n\nfirst\n\ninfo\n\ninfo\n\ninfo\n\nnext\n\nnext\n\nnext\n\nnull\n\n14\n\n\fThe Node Class\n\npublic class Node<E> {\n\nprivate E info; \nprivate Node<E> next;\n\nUse of generics to store \ninformation of different types\nTwo attributes: info and \nreference to the next node\n\npublic Node(E info) {\u2026}\n\nConstructor to \ninitialize info\n\npublic Node<E> getNext() {\u2026}\npublic void setNext(Node<E> next) {\u2026}\npublic E getInfo() {\u2026}\npublic void setInfo(E info) {\u2026}\n\n}\n\nGetters and setters for the attributes\n\n\fExercise 2\n\n\u2022 Complete the code in the class Node. \n\nProgram three constructors: one that does not \nreceive arguments to initialize the attributes; \none that serves to initialize the attribute \ninfo; and another one that serves to \ninitialize the two attributes.\n\n\fThe class MyLinkedList\n\npublic class MyLinkedList<E> {\nprivate Node<E> first;\n\npublic MyLinkedList() {\u2026}\n\npublic void insert(E info) {\u2026}\npublic E extract() {\u2026}\n\nprivate void insert(E info, Node<E> previous) {\u2026}\nprivate E extract(Node<E> previous) {\u2026}\n\npublic void insert(E info, int pos) {\u2026}\npublic E extract(int pos) {\u2026}\n\npublic void print() {\u2026}\npublic Node<E> searchLastNode() {\u2026}\npublic int search(E info) {\u2026}\n\n\u2026\n}\n\n\f1. Inserting a node at the beginning\n\npublic void insert(E info)\n\nfirst\n\nnewNode\n\nnull\n\nStep 1: Creating a new node\n\nnull\n\nNode<E> newNode = new Node<E>(info);\n\n18\n\n\f1. Inserting a node at the beginning\n\npublic void insert(E info)\n\nfirst\n\nnewNode\n\nnull\n\nStep 2: Assigning the first node as the next \none for the node just created\n\nnewNode.setNext(first);\n\n19\n\n\f1. Inserting a node at the beginning\n\npublic void insert(E info)\n\nfirst\n\nnewNode\n\nnull\n\nStep 3: Assigning as first node in the list the \nnode just created\n\nfirst = newNode;\n\n20\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\nStep 1: Checking that the list is not empty\n\nif (first != null)\n\nnull\n\n21\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\ndata\n\nStep 2: Getting the info from the node to extract\n\nE data = first.getInfo();\n\nnull\nnull\n\n22\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\ndata\n\nStep 3: Assigning the second node as the first one of the list\n\nfirst = first.getNext();\n\nnull\nnull\n\n23\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\ndata\n\nThe node is isolated and does \nnot belong to the list anymore\n\nStep 4: Returning the piece of data\n\nreturn data;\n\nnull\nnull\n\n24\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nStep 1: Checking that previous is not null\n\nif (previous != null)\n\nnull\n\n25\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nnewNode\n\nnull\n\nStep 2: Creating a new node\n\nnull\n\nNode<E> newNode = new Node<E>(info);\n\n26\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nnewNode\n\nnull\n\nStep 3: Assigning as the next for the node \njust created the next to previous\n\nnewNode.setNext(previous.getNext());\n\n27\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nnewNode\n\nnull\n\nStep 4: Assigning the node just created as  \nthe next to previous\n\nprevious.setNext(newNode);\n\n28\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 1: Checking that the list is not empty\nChecking that previous is not null. \nChecking that the next to previous is not null\n\nif (first != null && previous!= null && previous.getNext() != null)\n\nnull\n\n29\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 2: Retrieving the information in the node to \nextract\n\nE data = previous.getNext().getInfo();\n\nnull\n\n30\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 3: Assigning the next to the node to extract as \nthe next to previous\n\nprevious.setNext(previous.getNext().getNext());\n\nnull\n\n31\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 4: Returning the piece of data\n\nreturn data;\n\nnull\n\n32\n\n\f5. Inserting at an intermediate position \n(given the position)\n\npublic void insert(E info, int pos)\n\nfirst\n\nprevious \n\nnull\n\nIf position is 0 or linked list is empty, then insert at the beginning, \ncalling the insert (E info) method\n\nif (pos == 0 || first == null) {\n\ninsert(info);\n\n}\n\n33\n\n\f5. Inserting at an intermediate position \n(given the position)\n\npublic void insert(E info, int pos)\n\nfirst\n\nprevious \n\nnull\n\nAdvance from first to the position of the previous node, and then call \nthe method that inserts at an intermediate position given previous. If \nposition is larger than number of nodes, then insert at the end.\n\nelse {\n\nNode<E> tmp = first;\nfor (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {\n\ntmp = tmp.getNext();\n\n}\ninsert(info, tmp);\n\n}\n\n34\n\n\f6. Extracting an intermediate node \n(given the position)\n\npublic E extract(int pos)\n\nprevious \n\nfirst\n\nnull\n\nIf position is 0 or linked list is empty, then extract at the beginning, \ncalling the extract() method\n\nif (pos == 0 || first == null) {\n\nreturn extract();\n\n}\n\n35\n\n\f6. Extracting an intermediate node \n(given the position)\n\npublic E extract(int pos)\n\nprevious \n\nfirst\n\nnull\n\nAdvance from first to the position of the previous node, and then call \nAdvance from first to the position of previous, and call the method \nthe method that extracts at an intermediate position given previous. \nthat extracts an intermediate node given the previous node\nIf position is larger than number of nodes, then null is returned.\n\nelse {\n\nNode<E> tmp = first;\nfor (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {\n\ntmp = tmp.getNext();\n\n}\nreturn extract(tmp);\n\n}\n\n36\n\n\f7. Traversing the list:\nprinting the content\n\npublic void print()\n\ncurrent\n\nfirst\n\nnull\n\nif(first!=null){\n\nNode<E> current = first;\nwhile (current != null) {\n\nSystem.out.println(current.getInfo());    \ncurrent = current.getNext();\n\n}\n\n}\n\n37\n\n\f8. Traversing the list: \nsearching for the last node\n\npublic Node<E> searchLastNode()\n\n\u2022\n\nA reference steps the list until a node is reached \nwhose reference to the next node is null :\n\npublic Node<E> searchLastNode() { \n\nNode<E> current = first;\nif (current != null) {\n\nwhile (current.getNext() != null) { \ncurrent = current.getNext();\n\n}\n\n}\nreturn current;\n\n}\n\n38\n\n\f9. Traversing the list: \nsearching for a piece of data\n\npublic int search(E info)\n\n\u2022\n\nA reference steps the list until the piece of information is reached. \nA counter is used in order to return its position in the list:\n\npublic int search(E info) { \n\nint pos = 0;\nNode<E> current = first; \nwhile (current != null\n\n&& !current.getInfo().equals(info)) {    \npos++;\ncurrent = current.getNext();\n\n}\nif (current != null){\n\nreturn pos;\n\n} else{\n\nreturn -1;\n\n}\n\n}\n\n39\n\n\fExercise 3\n\n\u2022 Create the method\n\npublic int numberOfOcurrences(E info), \nwhich returns the number of nodes in a linked \nlist whose stored information is the same as the \none provided as argument. \n\n\fAdvantages of Linked Lists\n\n\u2022 Inserting and extracting nodes have a cost \nthat does not depend on the size of the list\n\u2022 Concatenation and partition of lists have a \n\ncost that does not depend on the size of the \nlist\n\n\u2022 There is no need for contiguous memory\n\u2022 Memory in use at a given instant depends \nonly on the number of data items stored in \nthe list at that instant\n\n41\n\n\fDisadvantages of Linked Lists\n\n\u2022 Accessing to arbitrary intermediate \n\npositions has a cost that depends on \nthe size of the list\n\n\u2022 Each node represents an overhead in \n\nmemory usage\n\n42\n\n\fExercise 4\n\n\u2022 Create a Linked List with ten elements of type \ninteger, and initialize them to 1. Then, insert an \nadditional element with value 0 in the fourth \npositon of the Linked List. Assume that classes \nNode and MyLinkedList already exist, and \nare implemented as we saw in this session. \n\n\f", "pages_description": ["Introduction to generics\n\nThis slide introduces the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow checking object types during compile time. Errors are detected at compile time, guaranteeing compatible types during runtime. \n", "Introduction to generics\n\nWithout Generics\n\nWe have a code snippet that shows how to create a list in Java. First, we create a new ArrayList object and assign it to the variable list. Then, we add a string \"test\" to the list. Finally, we try to get the first element of the list and cast it to an Integer. However, this will cause a ClassCastException at runtime because the list contains a String, not an Integer. The program will stop.\n\nBelow the code snippet, there is a diagram showing the relationship between the AbstractList and List interfaces. The ArrayList class extends the AbstractList class and implements the List interface.\n", "Introduction to generics\n\nThis slide introduces the concept of generics in programming, specifically focusing on Java's ArrayList.\n\n**With Generics**\n\nThe slide presents a code snippet:\n\n```java\nList<Integer> list = new ArrayList<Integer>();\nlist.add(\"test\"); \nInteger value = list.get(0);\n```\n\nThis code attempts to create an ArrayList of Integers, add a String \"test\" to it, and then retrieve the element at index 0. \n\nHowever, this code will result in a compile-time error:\n\n```\nError at compile time\n\"The method add(Integer) in the type List<Integer> is not applicable for the arguments (String)\"\nThe error is detected before running the program\n```\n\nThis error highlights the benefit of using generics: **type safety**. By declaring the ArrayList as `List<Integer>`, we specify that it can only hold Integer objects. Attempting to add a String violates this type constraint, and the compiler detects this error early on.\n\nThe slide also includes a diagram illustrating the inheritance hierarchy:\n\n- `ArrayList<E>` extends `AbstractList<E>`\n- `AbstractList<E>` implements `List<E>`\n\nThis diagram emphasizes that `ArrayList` is a specific implementation of the more general `List` interface, both utilizing generics with the type parameter `<E>`. \n", "Introduction to generics\n\nThis slide shows an example of how to create a class that uses generics. The example is a class called ArrayList that takes a type parameter E. The class has methods for adding, getting, removing, and setting elements in the list. The type of the elements in the list is specified by the type parameter E. For example, to create an ArrayList of Strings, you would use the following code: ArrayList<String> myList = new ArrayList<String>();\n", "Introduction to generics\n\nWe are working with a class that uses generics.\nWe have a code snippet that shows the creation of an ArrayList of Employees.\nThe code then adds a new Employee, gets the first employee and adds a new Secretary.\nThe last two lines of code are highlighted in red because they are causing compilation errors.\nThe first one tries to add a Person to the ArrayList, and the second one tries to add an Object.\nThe reason why these two lines of code are causing compilation errors is because the ArrayList was declared to only accept objects of type Employee.\nA diagram shows that Person is a superclass of Employee and Object is a superclass of Person.\nTherefore, you cannot add a Person or an Object to an ArrayList of Employees.\n", "Data Structures\n\n- Abstraction that represents a collection of data in a program in order to ease its manipulation\n- The suitability of a data structure depends on the nature of the data to be stored, and how that data will be manipulated \n", "Linear Data Structures\n\nLinear data structures organize data as a sequence, where each piece of data has a preceding datum, except for the first one, and a succeeding datum, except for the last one.\n\nSome examples of linear data structures are: arrays, linked lists, stacks, queues, and double-ended queues. \n", "Arrays\n\nThis slide lists advantages of arrays for storing linear data collections. The advantages are: random access - any position in the array can be accessed in constant time; efficient use of memory when all the positions of the array are in use, because the array is stored in consecutive memory positions. \n", "Arrays\n\nLet's talk about some disadvantages of arrays. \n\nFirst, arrays have static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed. \n\nAnother disadvantage is the need for contiguous memory. Even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation. \n", "Arrays\n\nLet's talk about some disadvantages of arrays.\nSome operations on the array have a sub-optimum cost:\n- insertions and extractions, that is removals, of data in the first position or intermediate positions need data to be moved to consecutive memory positions.\n- concatenation of arrays: data must be copied to a new array.\n- partition of an array in several pieces: data must be copied to new arrays. \n", "Exercise 1\n\nCreate a ten-element array of integers and initialize all the elements with value 1. Then, insert an additional element with value 0 in the fourth position of the array.\n\nNote: Inserting a new element is different from replacing an element by another one. \n", "Linked Lists\n\nA linked list is an ordered sequence of nodes. Each node stores a piece of data called info and a reference pointing to the next node in the list. The nodes do not need to be in consecutive memory positions. \n\nThe diagram shows a linked list with three nodes. The first node contains the value \"info\" and a reference to the next node. The second node also contains the value \"info\" and a reference to the next node. The third node contains the value \"info\" and a reference to null, indicating the end of the list. The variable \"first\" points to the first node in the list. \n", "The Node Class\n\nWe have a class definition for a generic class named Node. The class uses generics to store information of different types. It has two attributes: info, which stores the actual data of type E, and next, which is a reference to the next node in the structure. The class has a constructor that takes an argument of type E and initializes the info attribute. Additionally, there are getters and setters for both attributes: getNext and setNext for the next node, and getInfo and setInfo for the info attribute. \n", "Exercise 2\n\nComplete the code in the class **Node**. Program three constructors: one that does not receive arguments to initialize the attributes; one that serves to initialize the attribute **info**; and another one that serves to initialize the two attributes. \n", "The class MyLinkedList\n\nThe image shows the structure of a class named MyLinkedList in a programming language, likely Java. This class represents a linked list data structure. \n\nIt starts by declaring a private variable \"first\" of type Node, which will hold the reference to the first node in the list. The Node class is not shown here, but it would typically contain data and a reference to the next node in the list.\n\nThe class has a constructor and several public and private methods:\n\n- A constructor `MyLinkedList()` to initialize the linked list, likely by setting the \"first\" node to null.\n\n- Public methods:\n    - `insert(E info)`: Inserts a new node with the given data at the end of the list.\n    - `extract()`: Removes and returns the data from the first node of the list.\n    - `insert(E info, int pos)`: Inserts a new node with the given data at the specified position in the list.\n    - `extract(int pos)`: Removes and returns the data from the node at the specified position in the list.\n    - `print()`: Prints the contents of the linked list.\n    - `searchLastNode()`: Returns a reference to the last node in the list.\n    - `search(E info)`: Searches for a node containing the given data and returns its position in the list.\n\n- Private methods:\n    - `insert(E info, Node<E> previous)`: Inserts a new node with the given data after the specified \"previous\" node.\n    - `extract(Node<E> previous)`: Removes and returns the data from the node after the specified \"previous\" node.\n\nThe ellipses (...) within the method declarations indicate that the actual implementation details of these methods are not shown in this particular code snippet. \n", "1. Inserting a node at the beginning\n\nThe image shows the first step to insert a new node at the beginning of a linked list.\n\nThe code snippet shows the signature of the method: `public void insert(E info)`\n\nThe diagram shows four nodes. The first three nodes are already in the linked list. The fourth node is the new node to be inserted.\n\nThe first three nodes are light blue and contain an oval shape in a lighter color. They are connected with arrows. The first node is labeled \"first\". The last node's arrow points to the text \"null\".\n\nThe new node is red and contains an oval shape in a lighter color. An arrow points from the text \"newNode\" to this node. Another arrow points from this node to the text \"null\".\n\nBelow the diagram, we see the text \"Step 1: Creating a new node\" and the code `Node<E> newNode = new Node<E>(info);`\n", "Inserting a node at the beginning\n\nThe image describes the second step in the process of inserting a node at the beginning of a linked list. The code snippet \"public void insert(E info)\" shows the method signature for the insertion operation. The diagram illustrates the linked list with three existing nodes. Each node is represented by a rectangle with an oval inside. The leftmost rectangle is labeled \"first\" indicating the head of the linked list. The ovals inside the rectangles represent the data stored in each node. An arrow pointing to the right connects each node to its next node. The last node's arrow points to the text \"null\" indicating the end of the list.\n\nA new node, represented by a rectangle with a red oval inside, is labeled \"newNode\". The second step of the insertion process is to assign the \"first\" node as the next node for the newly created node. This step is represented by the code \"newNode.setNext(first);\" and visually by an arrow from the new node to the \"first\" node. \n", "Inserting a node at the beginning\n\nThe image shows how to insert a node at the beginning of a linked list.\n\nThe code snippet shows the method signature: public void insert, which takes a generic type E info as input.\n\nThe diagram shows a linked list with three nodes. The first node is labeled \"first\" and the last node points to null.\n\nA new node labeled \"newNode\" is added to the beginning of the list. The new node is colored in red. An arrow points from newNode to the previous first node. An arrow points from \"first\" to \"newNode\".\n\nStep 3 of the process is to assign the new node as the first node in the list. This is done by setting the \"first\" variable to the \"newNode\".\n", "**2. Extracting the first node**\n\nThe code snippet shows a function called \"extract\" which takes no arguments and returns a generic type E.\n\nThe diagram shows three nodes, each represented by a rectangle with rounded corners. The first node is highlighted in red and labeled \"first\". An arrow points from the label \"first\" to the first node. The nodes are connected by arrows, indicating a linked list structure. The last node's arrow points to the word \"null\".\n\nThe first step in extracting the first node is checking that the list is not empty. This is done by checking if the variable \"first\" is not equal to null. \n", "**2. Extracting the first node**\n\nThis slide describes the second step of extracting the first node from a linked list.\n\nThe code snippet shows a method named \"extract\" that returns a generic type \"E\". \n\nThe diagram illustrates a linked list with three nodes. The first node is highlighted in red. An arrow labeled \"first\" points to the first node. Another arrow labeled \"data\" points to the data within the first node. The last node in the list points to \"null,\" indicating the end of the list.\n\nThe second step, as highlighted in the red box, involves retrieving the information from the node to be extracted. This is achieved using the line \"E data = first.getInfo();\", which retrieves the information from the first node and stores it in a variable named \"data\" of type \"E\". \n", "2. Extracting the first node\n\nThe code snippet shows the method signature for extracting the first node: public E extract().\n\nStep 3: Assigning the second node as the first one of the list\n\nThe diagram shows three nodes. The first node is highlighted in red. An arrow points from the word \"first\" to the second node. Another arrow points from the second node to the third node. A final arrow points from the third node to the word \"null\".\n\nThe code snippet shows the following instruction: first = first.getNext();\n", "2. Extracting the first node\n\nThe image shows step 4 of extracting the first node of a linked list. The code snippet shows the signature of the method: \"public E extract()\". The diagram shows three nodes. The first node is red and has an arrow pointing to it with the label \"first\". There is an arrow from the first node to the second node and an arrow from the second to the third. The third node has an arrow pointing away from it with the label \"null\". There is also an arrow pointing to the data of the first node with the label \"data\". There is a text box with the following text: \"The node is isolated and does not belong to the list anymore\". There is another text box with the label \"Step 4: Returning the piece of data\" and the text \"return data;\". \n", "**3. Inserting at an intermediate position (given the previous node)**\n\nThe code snippet shows the implementation of an insert method in Java. The method takes two arguments: info of type E and previous of type Node. The goal is to insert a new node with the value of info after the node pointed to by previous in a linked list.\n\nThe diagram illustrates the process. There are four nodes in the linked list. The first node is labeled \"first\" and the second node is labeled \"previous\". The last node points to null.\n\nThe first step of the insertion process is to check if the previous node is not null. This is done using the following code: if (previous != null)\n", "**3. Inserting at an intermediate position (given the previous node)**\n\nThe image illustrates step 2 of inserting a new node at an intermediate position in a linked list, given the previous node.\n\n- We have a code snippet: `private void insert(E info, Node<E> previous)` indicating a private method named \"insert\" that takes two arguments: \"info\" of type E and \"previous\" of type `Node<E>`.\n\n- There are four nodes visualized as rectangles with rounded corners. Each node, except the first one, has an arrow pointing to the next node.\n\n- The second node from the left is labeled \"previous\".\n\n- The first node is labeled \"first\" and points to the \"previous\" node.\n\n- The last node has an outgoing arrow pointing to the text \"null\", indicating the end of the list.\n\n- Below the \"first\" node, there's a red oval within a rectangle labeled \"newNode\" with an arrow pointing to it from the label. This node is not yet part of the list. An arrow from this node points to the text \"null\".\n\n- A red-bordered box highlights the text \"**Step 2: Creating a new node**\".\n\n- Below this box, we see the code: `Node<E> newNode = new Node<E>(info);` which creates a new node (`newNode`) of type `Node<E>` and initializes it with the data \"info\".\n", "3. Inserting at an intermediate position (given the previous node)\n\nThis slide explains how to insert a new node in a linked list at an intermediate position, given the previous node. \n\nThe code snippet shows the signature of the method: \"private void insert(E info, Node<E> previous)\".  The method takes two arguments: the information to be stored in the new node, and the previous node.\n\nThe diagram shows four nodes: \"first\", two unnamed nodes, and a node that points to \"null\". There is an arrow pointing from \"first\" to the first unnamed node, another arrow from the first unnamed node to the second unnamed node, and a final arrow from the second unnamed node to the node that points to \"null\".  The second unnamed node is labeled as \"previous\".  There is a new node, labeled as \"newNode\", that needs to be inserted between the two unnamed nodes.\n\nFinally, step 3 of the insertion process is described.  This step consists of assigning the next node for the newly created node to the next node of the previous node.  This is done with the line of code \"newNode.setNext(previous.getNext());\". \n", "3. Inserting at an intermediate position (given the previous node)\n\nThe image shows four boxes connected with arrows pointing to the right. The leftmost box is red and labeled \"newNode\". The next box is blue and labeled \"previous\". The remaining two boxes are blue and unlabeled. The last box has an arrow pointing to the right labeled \"null\". There is also a line of code: \"previous.setNext(newNode);\" and a caption: \"Step 4: Assigning the node just created as the next to previous\". This diagram shows the process of inserting a new node into a linked list after the node labeled \"previous\". The line of code \"previous.setNext(newNode);\" sets the \"next\" pointer of the \"previous\" node to the \"newNode\", effectively inserting the \"newNode\" into the linked list. \n", "Extracting an intermediate node (given the previous node)\n\nWe have some source code in a white box. The code is: \"private E extract(Node<E> previous)\".\n\nBelow the code, there is a diagram representing a linked list. The first node is empty and has an arrow pointing to it, labeled \"first\". The first node is followed by two empty nodes, then a red node labeled \"data\", another empty node, and finally an arrow pointing to the last node, labeled \"null\". The nodes are connected by arrows.\n\nBelow the diagram, there is a red box with the following text inside: \"Step 1: Checking that the list is not empty. Checking that previous is not null. Checking that the next to previous is not null\".\n\nFinally, there is more source code in a white box: \"if (first != null && previous != null && previous.getNext() != null)\".\n", "**4. Extracting an intermediate node (given the previous node)**\n\nThe code snippet shows the declaration of a private method called \"extract\" that takes a Node object of type E as input, named \"previous\".\n\nThe diagram illustrates a linked list with 5 nodes. Each node is represented by a rectangle. The first node is labeled \"first\" and points to the next node in the list. The second node is labeled \"previous\" and points to the next node, which is highlighted in red and labeled \"data\". The fourth and fifth nodes are empty, and the last node points to \"null\", indicating the end of the list.\n\nThe second step of the process, \"Retrieving the information in the node to extract\", involves getting the data from the node that is next to the \"previous\" node. This is done by calling the \"getNext()\" method on the \"previous\" node, which returns the next node in the list. Then, the \"getInfo()\" method is called on the next node to retrieve the data stored in that node. The retrieved data is then assigned to a variable of type E called \"data\". \n", "**4. Extracting an intermediate node (given the previous node)**\n\nThe code snippet `private E extract(Node<E> previous)` shows a method for extracting a node from a linked list given the previous node.\n\nThe diagram illustrates the process with four nodes. The first node is on the left and the last node is on the right. The third node, colored in red, is the one being extracted. The \"previous\" node is the second node. \n\n**Step 3: Assigning the next to the node to extract as the next to previous**\n\nThis step is implemented with the code `previous.setNext(previous.getNext().getNext());`. This line of code sets the \"next\" pointer of the \"previous\" node to the \"next\" pointer of the node being extracted. This effectively removes the extracted node from the linked list. \n", "**4. Extracting an intermediate node (given the previous node)**\n\nThe image illustrates step 4 of a process involving a linked list data structure. The goal is to extract an intermediate node from the list, given a reference to the previous node.\n\n- The code snippet \"private E extract(Node<E> previous)\" represents a method signature for extracting the data from a node. \"E\" likely denotes a generic type parameter, indicating that the method can handle nodes containing various data types.\n\n- The diagram depicts a linked list with four nodes. Each node is represented by a rectangle, except for the third node, which is highlighted in red.\n\n- An arrow labeled \"previous\" points to the second node, indicating that this is the node referenced as \"previous\" in the code.\n\n- The third node, colored red, is the target node to be extracted. An arrow labeled \"data\" points to this node, signifying that its data will be returned.\n\n- The first and fourth nodes are shown for context, representing the preceding and succeeding nodes in the list.\n\n- An arrow labeled \"first\" points to the first node, indicating the beginning of the linked list.\n\n- An arrow labeled \"null\" points away from the fourth node, indicating the end of the linked list.\n\n- The text \"Step 4: Returning the piece of data\" highlights the current step in the process.\n\n- The code snippet \"return data;\" indicates that the data from the extracted node (the third node) is being returned.\n", "5. Inserting at an intermediate position (given the position)\n\nWe see a code snippet that shows how to insert an element into a linked list at a given position. The code first checks if the position is 0 or if the linked list is empty. If either of these conditions is true, the code inserts the element at the beginning of the list. Otherwise, the code inserts the element at the specified position.\n\nThere is also a diagram that shows a linked list with five nodes. The first node is labeled \"first\" and the last node is labeled \"null\". The third node is colored red. An arrow points from the word \"previous\" to the second node in the list.  The diagram is meant to illustrate the process of inserting a new node into the linked list at a given position. The red node represents the new node that is being inserted. \n", "**5. Inserting at an intermediate position (given the position)**\n\nThe image shows a slide titled \"5. Inserting at an intermediate position (given the position)\". \n\nThe code snippet shows the implementation of the insert method in Java. The method takes two arguments: the information to be inserted (info) and the position where it should be inserted (pos).\n\nThe code first checks if the position is larger than the number of nodes in the list. If it is, the new node is inserted at the end of the list. Otherwise, the code advances from the first node to the position of the previous node. Once the previous node is found, the code calls the insert method, passing the information to be inserted and the previous node as arguments.\n\nThere is a diagram representing a linked list. The first node is on the left and the last node is on the right. The nodes are represented by rectangles. The first node is labeled \"first\" and the last node is labeled \"null\". The second node from the left is colored red. An arrow points from the text \"previous\" to the node before the red node.\nThis diagram illustrates the process of inserting a new node at a given position in a linked list. The red node represents the new node to be inserted. The code first finds the node before the position where the new node should be inserted (represented by the arrow pointing to the node before the red node). Then, the new node is inserted after the previous node.\n", "6. Extracting an intermediate node (given the position)\n\nWe have a piece of code that extracts an element from a linked list given its position. The code is a method called extract which takes an integer called pos as an argument. If the position is 0 or the linked list is empty, then the element is extracted at the beginning of the list, calling the method extract without arguments. There is a diagram showing a linked list with 5 elements. The third element is red, indicating that it is the element to be extracted. The second element is labeled \"previous\" and the first element is labeled \"first\". The last node points to null. \n", "Extracting an intermediate node (given the position)\n\nWe have some code and a diagram. The code is for a method called \"extract\" which takes an integer \"pos\" as input. The diagram shows a linked list with 5 nodes. The first node is labeled \"first\", the third node is colored red, and the last node's next pointer points to \"null\". An arrow points from the label \"previous\" to the second node, and an arrow points from the label \"first\" to the first node.\n\nThe code first checks if the position is larger than the number of nodes. If it is, then null is returned. Otherwise, the code advances from the first node to the position of the previous node. Then, the code calls the method that extracts at an intermediate position given the previous node. \n", "7. Traversing the list: printing the content\n\nWe have some source code that shows a function called print. This function takes no arguments. The code is as follows:\n\n```java\npublic void print() {\n  if (first != null) {\n    Node<E> current = first;\n    while (current != null) {\n      System.out.println(current.getInfo());\n      current = current.getNext();\n    }\n  }\n}\n```\n\nAlong with the code, there is a diagram that helps to explain how the code works. The diagram shows a linked list with five nodes. The first node is labeled \"first\" and the last node is labeled \"null\". Each node is represented by a rectangle. The rectangles are connected by arrows, which indicate the order of the nodes in the list. The first arrow points to the first node in the list, and the last arrow points to null. There is also an arrow labeled \"current\" that points to the first node.\n\nThe code works by first checking if the list is empty. If the list is not empty, the code creates a variable called \"current\" and sets it to the first node in the list. The code then enters a loop that continues as long as the \"current\" node is not null. Inside the loop, the code prints the information stored in the \"current\" node. The code then sets the \"current\" node to the next node in the list. The loop continues until the \"current\" node is null, which indicates that the end of the list has been reached.\n", "**8. Traversing the list: searching for the last node**\n\nThis slide presents a method written in Java that searches for the last node in a linked list.\n\nThe method is called `searchLastNode()` and it returns a `Node<E>` object. \n\nThe method starts by declaring a `Node<E>` variable called `current` and initializing it to the `first` node in the list. \n\nThen, it checks if `current` is not `null`. If it is not, it enters a `while` loop that iterates through the list until it finds a node whose `next` node is `null`. \n\nInside the loop, the `current` node is updated to the next node in the list by calling the `getNext()` method. \n\nOnce the loop has finished, the `current` node will be the last node in the list, so the method returns the `current` node.\n", "**9. Traversing the list: searching for a piece of data**\n\nThis slide presents a piece of code that defines the method *search* that traverses a linked list to search for a specific piece of data.\n\nThe method takes as input a parameter *info* of generic type *E* representing the data to be searched. It uses a *current* node reference to traverse the list, initialized to the *first* node, and a counter *pos* to keep track of the position of the node in the list.\n\nThe traversal is done in a *while* loop that iterates as long as the *current* node is not null and the information stored in the *current* node is not equal to the *info* we are looking for. For each iteration, the counter *pos* is incremented and the *current* node is moved to the next one.\n\nIf the loop terminates because the *current* node is not null, it means that the *info* has been found and the method returns the value of the counter *pos*. Otherwise, the *info* is not in the list and the method returns *-1*. \n", "Exercise 3\n\nWe need to create a method called \"numberOfOccurrences\" that takes an argument of type E called \"info\". This method will return an integer representing the number of nodes in a linked list where the stored information matches the \"info\" argument. \n", "Advantages of Linked Lists\n\nInserting and extracting nodes have a cost that does not depend on the size of the list.\nConcatenation and partition of lists have a cost that does not depend on the size of the list.\nThere is no need for contiguous memory.\nMemory in use at a given instant depends only on the number of data items stored in the list at that instant.\n", "Disadvantages of Linked Lists\n\n- Accessing to arbitrary intermediate positions has a cost that depends on the size of the list\n- Each node represents an overhead in memory usage \n", "Exercise 4\n\nCreate a linked list with 10 elements of type integer and initialize them to one. Then insert an additional element with value zero in the fourth position of the linked list. Assume that classes Node and MyLinkedList already exist and are implemented as we saw in this session. \n"]}, {"filename": "5. LinkedLists.pdf", "text": "Systems Programming\n\nLinked lists\n\nDepartamento de Ingenier\u00eda\nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nCarlos Delgado Kloos, Jes\u00fas Arias Fisteus, Carlos Alario Hoyos,\nM. Carmen Fern\u00e1ndez Panadero, Julio Villena Rom\u00e1n\n\n1\n\n\fContents\n\nv *** Introduction to generics\nv Data structures\nv Linked lists\n\n\u2022 The class Node\n\n\u2022 The class LinkedList\n\n\u2022 Benefits and drawbacks of linked lists\n\n\fIntroduction to generics\n\n\u2022 Service provided by Java (J2SE 5.0 and above)\n\n\u2022 Generics allow checking object types during \n\ncompile time \no Errors are detected at compile time (guaranteeing \n\ncompatible types during runtime)\n\n\fIntroduction to generics\n\nWithout Generics\n\nList list = new ArrayList();\nlist.add(\u201ctest\u201d);\nInteger value = (Integer) list.get(0);\n\nError at runtime \n\n\u201cClassCastException\u201d.           \n\nThe program stops\n\nAbstractList\n\nList\n\nextends\n\nimplements\n\nArrayList\n\n\fIntroduction to generics\n\nWith Generics\n\nList<Integer> list = new ArrayList<Integer>();\nlist.add(\u201ctest\u201d);\nInteger value = list.get(0);\n\nError at compile time \n\u201cThe method add(Integer) in the type List<Integer> \nis not applicable for the arguments (String)\u201d   \nThe error is detected before running the program\n\nAbstractList<E>\n\nList<E>\n\nextends\n\nimplements\n\nArrayList<E>\n\n\fIntroduction to generics\n\nCreation of a class that uses generics\n\npublic class ArrayList<E>{\n\npublic boolean add(E e){\u2026}\npublic void add(int index, E element)\npublic E get(int index){\u2026}\npublic E remove(int index)\npublic set(int index, E element)\n\n\u2026\n}\n\n\fIntroduction to generics\n\nWorking with a class that uses generics\n\nArrayList<Employee> employees = new ArrayList<Employee>();\nemployees.add(new Employee());\nEmployee myEmployee = employees.get(0);\nemployees.add(new Secretary());\nemployees.add(new Person());\nemployees.add(new Object());\n\nCompilation errors\n\n\fData Structures\n\n\u2022 Abstraction that represents a \n\ncollection of data in a program in \norder to ease its manipulation\n\u2022 The suitability of a data structure \n\ndepends on the nature of the data \nto be stored, and how that data will \nbe manipulated\n\n8\n\n\fLinear Data Structures\n\n\u2022 They organize data as a sequence, where \neach piece of data has a preceding datum\n(except for the first one) and a succeeding \ndatum (except for the last one)\n\u2022 Examples of linear data structures:\n\n\u2013 Arrays\n\u2013 Linked lists\n\u2013 Stacks\n\u2013 Queues\n\u2013 Double-ended queues\n\n9\n\n\fArrays\n\n\u2022 Advantages for storing linear data \n\ncollections:\n\u2013 Random access: any position in the array \n\ncan be accessed in constant time.\n\u2013 Efficient use of memory when all the \n\npositions of the array are in use, because \nthe array is stored in consecutive memory \npositions.\n\n10\n\n\fArrays\n\n\u2022 Disadvantages (I):\n\n\u2013 Static size: The size must be defined when \nthe array is created and cannot be changed \nlater. The main problems this poses are:\n\n\u2022 Inefficient use of memory when more positions \n\nthan needed are reserved \n\n\u2022 It may happen at runtime that more positions than \n\nreserved are needed\n\n\u2013 Need of contiguous memory:\n\n\u2022 Even having the system enough free memory, it \nmay happen that there is not enough contiguous \nspace, due to memory fragmentation\n\n11\n\n\fArrays\n\n\u2022 Disadvantages (II):\n\n\u2013 Some operations on the array have a \n\nsub-optimum cost:\n\n\u2022 Insertions and extractions (removals) of data in the \nfirst position or intermediate positions need data to \nbe moved to consecutive memory positions\n\n\u2022 Concatenation of arrays: data must be copied to a \n\nnew array\n\n\u2022 Partition of an array in several pieces: data must be \n\ncopied to new arrays\n\n12\n\n\fExercise 1\n\n\u2022 Create a ten-element array of integers and initialize \n\nall the elements with value 1. Then, insert an \nadditional element with value 0 in the fourth \nposition of the array.\n\n\u2022 Note: Inserting a new element is different from replacing an \n\nelement by another one.\n\n\fLinked Lists\n\n\u2022 Ordered sequence of nodes in which \n\neach node stores:\n\u2013 A piece of data (info)\n\u2013 A reference pointing to the next node\n\n\u2022 Nodes do not need to be in \n\nconsecutive memory positions \n\nfirst\n\ninfo\n\ninfo\n\ninfo\n\nnext\n\nnext\n\nnext\n\nnull\n\n14\n\n\fThe Node Class\n\npublic class Node<E> {\n\nprivate E info; \nprivate Node<E> next;\n\nUse of generics to store \ninformation of different types\nTwo attributes: info and \nreference to the next node\n\npublic Node(E info) {\u2026}\n\nConstructor to \ninitialize info\n\npublic Node<E> getNext() {\u2026}\npublic void setNext(Node<E> next) {\u2026}\npublic E getInfo() {\u2026}\npublic void setInfo(E info) {\u2026}\n\n}\n\nGetters and setters for the attributes\n\n\fExercise 2\n\n\u2022 Complete the code in the class Node. \n\nProgram three constructors: one that does not \nreceive arguments to initialize the attributes; \none that serves to initialize the attribute \ninfo; and another one that serves to \ninitialize the two attributes.\n\n\fThe class MyLinkedList\n\npublic class MyLinkedList<E> {\nprivate Node<E> first;\n\npublic MyLinkedList() {\u2026}\n\npublic void insert(E info) {\u2026}\npublic E extract() {\u2026}\n\nprivate void insert(E info, Node<E> previous) {\u2026}\nprivate E extract(Node<E> previous) {\u2026}\n\npublic void insert(E info, int pos) {\u2026}\npublic E extract(int pos) {\u2026}\n\npublic void print() {\u2026}\npublic Node<E> searchLastNode() {\u2026}\npublic int search(E info) {\u2026}\n\n\u2026\n}\n\n\f1. Inserting a node at the beginning\n\npublic void insert(E info)\n\nfirst\n\nnewNode\n\nnull\n\nStep 1: Creating a new node\n\nnull\n\nNode<E> newNode = new Node<E>(info);\n\n18\n\n\f1. Inserting a node at the beginning\n\npublic void insert(E info)\n\nfirst\n\nnewNode\n\nnull\n\nStep 2: Assigning the first node as the next \none for the node just created\n\nnewNode.setNext(first);\n\n19\n\n\f1. Inserting a node at the beginning\n\npublic void insert(E info)\n\nfirst\n\nnewNode\n\nnull\n\nStep 3: Assigning as first node in the list the \nnode just created\n\nfirst = newNode;\n\n20\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\nStep 1: Checking that the list is not empty\n\nif (first != null)\n\nnull\n\n21\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\ndata\n\nStep 2: Getting the info from the node to extract\n\nE data = first.getInfo();\n\nnull\nnull\n\n22\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\ndata\n\nStep 3: Assigning the second node as the first one of the list\n\nfirst = first.getNext();\n\nnull\nnull\n\n23\n\n\f2. Extracting the first node\n\npublic E extract() \n\nfirst\n\ndata\n\nThe node is isolated and does \nnot belong to the list anymore\n\nStep 4: Returning the piece of data\n\nreturn data;\n\nnull\nnull\n\n24\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nStep 1: Checking that previous is not null\n\nif (previous != null)\n\nnull\n\n25\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nnewNode\n\nnull\n\nStep 2: Creating a new node\n\nnull\n\nNode<E> newNode = new Node<E>(info);\n\n26\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nnewNode\n\nnull\n\nStep 3: Assigning as the next for the node \njust created the next to previous\n\nnewNode.setNext(previous.getNext());\n\n27\n\n\f3. Inserting at an intermediate position \n(given the previous node)\n\nprivate void insert(E info, Node<E> previous)\n\nfirst\n\nprevious\n\nnewNode\n\nnull\n\nStep 4: Assigning the node just created as  \nthe next to previous\n\nprevious.setNext(newNode);\n\n28\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 1: Checking that the list is not empty\nChecking that previous is not null. \nChecking that the next to previous is not null\n\nif (first != null && previous!= null && previous.getNext() != null)\n\nnull\n\n29\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 2: Retrieving the information in the node to \nextract\n\nE data = previous.getNext().getInfo();\n\nnull\n\n30\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 3: Assigning the next to the node to extract as \nthe next to previous\n\nprevious.setNext(previous.getNext().getNext());\n\nnull\n\n31\n\n\f4. Extracting an intermediate node \n(given the previous node)\n\nprivate E extract(Node<E> previous)\n\nprevious \n\ndata\n\nfirst\n\nStep 4: Returning the piece of data\n\nreturn data;\n\nnull\n\n32\n\n\f5. Inserting at an intermediate position \n(given the position)\n\npublic void insert(E info, int pos)\n\nfirst\n\nprevious \n\nnull\n\nIf position is 0 or linked list is empty, then insert at the beginning, \ncalling the insert (E info) method\n\nif (pos == 0 || first == null) {\n\ninsert(info);\n\n}\n\n33\n\n\f5. Inserting at an intermediate position \n(given the position)\n\npublic void insert(E info, int pos)\n\nfirst\n\nprevious \n\nnull\n\nAdvance from first to the position of the previous node, and then call \nthe method that inserts at an intermediate position given previous. If \nposition is larger than number of nodes, then insert at the end.\n\nelse {\n\nNode<E> tmp = first;\nfor (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {\n\ntmp = tmp.getNext();\n\n}\ninsert(info, tmp);\n\n}\n\n34\n\n\f6. Extracting an intermediate node \n(given the position)\n\npublic E extract(int pos)\n\nprevious \n\nfirst\n\nnull\n\nIf position is 0 or linked list is empty, then extract at the beginning, \ncalling the extract() method\n\nif (pos == 0 || first == null) {\n\nreturn extract();\n\n}\n\n35\n\n\f6. Extracting an intermediate node \n(given the position)\n\npublic E extract(int pos)\n\nprevious \n\nfirst\n\nnull\n\nAdvance from first to the position of the previous node, and then call \nAdvance from first to the position of previous, and call the method \nthe method that extracts at an intermediate position given previous. \nthat extracts an intermediate node given the previous node\nIf position is larger than number of nodes, then null is returned.\n\nelse {\n\nNode<E> tmp = first;\nfor (int i = 0; i < pos-1 && tmp.getNext() != null; i++) {\n\ntmp = tmp.getNext();\n\n}\nreturn extract(tmp);\n\n}\n\n36\n\n\f7. Traversing the list:\nprinting the content\n\npublic void print()\n\ncurrent\n\nfirst\n\nnull\n\nif(first!=null){\n\nNode<E> current = first;\nwhile (current != null) {\n\nSystem.out.println(current.getInfo());    \ncurrent = current.getNext();\n\n}\n\n}\n\n37\n\n\f8. Traversing the list: \nsearching for the last node\n\npublic Node<E> searchLastNode()\n\n\u2022\n\nA reference steps the list until a node is reached \nwhose reference to the next node is null :\n\npublic Node<E> searchLastNode() { \n\nNode<E> current = first;\nif (current != null) {\n\nwhile (current.getNext() != null) { \ncurrent = current.getNext();\n\n}\n\n}\nreturn current;\n\n}\n\n38\n\n\f9. Traversing the list: \nsearching for a piece of data\n\npublic int search(E info)\n\n\u2022\n\nA reference steps the list until the piece of information is reached. \nA counter is used in order to return its position in the list:\n\npublic int search(E info) { \n\nint pos = 0;\nNode<E> current = first; \nwhile (current != null\n\n&& !current.getInfo().equals(info)) {    \npos++;\ncurrent = current.getNext();\n\n}\nif (current != null){\n\nreturn pos;\n\n} else{\n\nreturn -1;\n\n}\n\n}\n\n39\n\n\fExercise 3\n\n\u2022 Create the method\n\npublic int numberOfOcurrences(E info), \nwhich returns the number of nodes in a linked \nlist whose stored information is the same as the \none provided as argument. \n\n\fAdvantages of Linked Lists\n\n\u2022 Inserting and extracting nodes have a cost \nthat does not depend on the size of the list\n\u2022 Concatenation and partition of lists have a \n\ncost that does not depend on the size of the \nlist\n\n\u2022 There is no need for contiguous memory\n\u2022 Memory in use at a given instant depends \nonly on the number of data items stored in \nthe list at that instant\n\n41\n\n\fDisadvantages of Linked Lists\n\n\u2022 Accessing to arbitrary intermediate \n\npositions has a cost that depends on \nthe size of the list\n\n\u2022 Each node represents an overhead in \n\nmemory usage\n\n42\n\n\fExercise 4\n\n\u2022 Create a Linked List with ten elements of type \ninteger, and initialize them to 1. Then, insert an \nadditional element with value 0 in the fourth \npositon of the Linked List. Assume that classes \nNode and MyLinkedList already exist, and \nare implemented as we saw in this session. \n\n\f", "pages_description": ["Introduction to generics\n\nThis slide introduces the concept of generics in Java. Generics are a service provided by Java from version J2SE 5.0 and above. They allow for checking object types during compile time. This means that errors related to incompatible types are detected at compile time, guaranteeing that only compatible types are used during runtime. \n", "Introduction to generics\n\nThis slide explains how to use generics in Java.\n\nWithout generics, the following code will compile but throw a ClassCastException at runtime:\n\n```java\nList list = new ArrayList();\nlist.add(\"test\");\nInteger value = (Integer) list.get(0);\n```\n\nThis is because we are adding a String to the list, but then trying to retrieve it as an Integer.\n\nThe diagram shows that the `ArrayList` class implements the `List` interface and extends the `AbstractList` class.\n", "Introduction to generics\n\nThis slide introduces the concept of generics in programming, specifically focusing on their use in Java with ArrayLists.\n\n**With Generics**\n\nThe slide presents a code snippet:\n\n```java\nList<Integer> list = new ArrayList<Integer>();\nlist.add(\"test\"); // Error!\nInteger value = list.get(0);\n```\n\nThis code attempts to create an `ArrayList` that should only contain `Integer` objects. However, it tries to add a `String` (\"test\") to the list, which is a type mismatch.\n\nA red box highlights the error message that would be generated at compile time:\n\n```\nError at compile time\n\"The method add(Integer) in the type List<Integer>\nis not applicable for the arguments (String)\"\nThe error is detected before running the program\n```\n\nThis emphasizes that generics provide compile-time type safety. The error is caught early because the compiler knows the `list` object is designed to hold only `Integer` types.\n\nFinally, a diagram illustrates the class hierarchy involved:\n\n- `ArrayList<E>` implements `AbstractList<E>`\n- `AbstractList<E>` extends a more general class (not shown)\n\nThis hierarchy, combined with generics (`<E>`), allows for type-safe collections in Java.\n", "Introduction to generics\n\nThis slide shows an example of how to create a class that uses generics. The class is called ArrayList and it takes a type parameter E. The class has several methods, including add, get, remove, and set. Each of these methods takes an argument of type E. This means that the ArrayList class can be used to store any type of object. For example, you could create an ArrayList of Strings, an ArrayList of Integers, or an ArrayList of any other type of object.\n", "Introduction to generics\n\nWe are working with a class that uses generics. We have some example code that creates a new ArrayList of Employees. Then it adds a new Employee. Then it gets the first employee from the list. Then it tries to add a new Secretary, a new Person, and a new Object. These last three lines of code are highlighted in red with a large red arrow pointing to the right. Below the code, there is a diagram showing the inheritance hierarchy of the classes involved. Person is the parent class of Employee. Employee is the parent class of Professor and Secretary. The text \"Compilation errors\" is written below the code, indicating that these three lines of code will result in compilation errors because the ArrayList is defined to only hold objects of type Employee or its subclasses. \n", "Data Structures\n\n- Data structures are abstractions that represent a collection of data in a program.\n- They are used to ease the manipulation of data.\n- The suitability of a data structure depends on the nature of the data to be stored and how that data will be manipulated. \n", "Linear Data Structures\n\nLinear data structures organize data as a sequence, where each piece of data has a preceding datum, except for the first one, and a succeeding datum, except for the last one.\n\nSome examples of linear data structures are: arrays, linked lists, stacks, queues, and double-ended queues. \n", "Arrays\n\nThis slide lists advantages for storing linear data collections with arrays. The advantages are: random access, meaning any position in the array can be accessed in constant time, and efficient use of memory when all the positions of the array are in use. This is because the array is stored in consecutive memory positions. \n", "Arrays\n\nLet's talk about some of the disadvantages of using arrays.\n\nFirst, arrays have a static size. This means the size of the array must be defined when the array is created and cannot be changed later. This can lead to two main problems. First, it can cause inefficient use of memory when more positions than needed are reserved. Second, it may happen at runtime that more positions than reserved are needed.\n\nThe second disadvantage is that arrays require contiguous memory. This means that even if the system has enough free memory, it may happen that there is not enough contiguous space due to memory fragmentation. \n", "Arrays\n\nLet's talk about some of the disadvantages of arrays. \nSome operations on arrays have a sub-optimum cost. For example, insertions and extractions, or removals, of data in the first position or intermediate positions require data to be moved to consecutive memory positions. Concatenation of arrays means that data must be copied to a new array. Partition of an array in several pieces means that data must be copied to new arrays. \n", "Exercise 1\n\nCreate a ten-element array of integers and initialize all the elements with value 1. Then, insert an additional element with value 0 in the fourth position of the array. Note: Inserting a new element is different from replacing an element by another one. \n", "Linked Lists\n\nA linked list is an ordered sequence of nodes. Each node stores a piece of data, called info, and a reference pointing to the next node in the list. The nodes do not need to be in consecutive memory positions.\n\nThe diagram shows a linked list with three nodes. The first node contains the value \"info\" and a reference to the second node. The second node contains the value \"info\" and a reference to the third node. The third node contains the value \"info\" and a reference to null, which indicates the end of the list. The variable \"first\" points to the first node in the list. \n", "The Node Class\n\nThis code snippet shows a Java implementation of a generic Node class. The class uses generics to store information of different types. \n\nIt has two attributes: \"info\" of type E and \"next\" which is a reference to the next node. The constructor initializes the \"info\" attribute. \n\nThe class also includes getters and setters for both attributes: getNext, setNext, getInfo, and setInfo. \n", "Exercise 2\n\nComplete the code in the class \"Node\". Program three constructors: one that does not receive arguments to initialize the attributes; one that serves to initialize the attribute \"info\"; and another one that serves to initialize the two attributes. \n", "The class MyLinkedList\n\nThis code defines a generic class called MyLinkedList in a programming language like Java. The class uses a data structure called a linked list to store a sequence of elements. \n\n- The class starts by declaring a private variable \"first\" of type Node<E>. This variable represents the first node in the linked list.\n- Then, we have a constructor for the MyLinkedList class.\n- The class includes public methods for inserting and extracting elements from the linked list. These methods are overloaded to allow insertion and extraction at the beginning of the list, at a specific position, or after a given node.\n- There are also private helper methods for inserting and extracting elements, which are used by the public methods.\n- Additionally, the class has a public method \"print\" for displaying the contents of the linked list, a method \"searchLastNode\" for finding the last node in the list, and a method \"search\" for searching for a specific element in the list. \n", "1. Inserting a node at the beginning\n\nThe image shows a code snippet for a method called \"insert\" that takes a generic type \"E\" called \"info\" as input. The goal of the code is to insert a new node at the beginning of a linked list.\n\nThe diagram shows a linked list with three nodes. The first node is labeled \"first\" and points to the second node. The second node points to the third node. The third node points to \"null\".\n\nThere is a new node labeled \"newNode\" that points to \"null\". This node will be inserted at the beginning of the linked list.\n\nStep 1: Creating a new node\nThe code first creates a new node of type \"Node\" with the value of \"info\" and assigns it to the variable \"newNode\".\n", "**1. Inserting a node at the beginning**\n\nThis slide explains how to insert a new node at the beginning of a linked list. The code snippet shows a method called \"insert\" that takes a generic type \"E\" called \"info\" as input. \n\nThere is a diagram showing four nodes. The first node is labeled \"first\" and points to the second node. The second node points to the third node, and so on. The last node points to \"null,\" indicating the end of the list.\n\nA new node labeled \"newNode\" is added to the beginning of the list. The \"newNode\" is colored red and contains data. \n\n**Step 2: Assigning the first node as the next one for the node just created**\n\nTo insert the \"newNode,\" we need to update the \"next\" pointer of the \"newNode\" to point to the current \"first\" node. This is done using the code \"newNode.setNext(first);\". \n", "Inserting a node at the beginning\n\nThe image shows step 3 of inserting a node at the beginning of a linked list. The code snippet shows the method signature: \"public void insert(E info)\".  There is a variable named \"first\" that points to the first node in the list. The diagram shows three nodes in the list, each with an arrow pointing to the next node. The last node has an arrow pointing to the text \"null\".  A new node, colored red, is being inserted at the beginning of the list. An arrow labeled \"newNode\" points to the new node. Step 3 of the process involves assigning the \"first\" variable to point to the \"newNode\". The text \"Step 3: Assigning as first node in the list the node just created first = newNode;\" describes this step. \n", "**2. Extracting the first node**\n\nThe code snippet shows a function called \"extract\" which takes no arguments and returns a generic type E.\n\nThe diagram shows three nodes. The first node is highlighted in red and labeled \"first\". The nodes are linked together in a singly linked list, with the last node pointing to \"null\".\n\nThe first step of the \"extract\" function is to check if the list is not empty. This is done by checking if the \"first\" node is not null. \n", "**2. Extracting the first node**\n\nThe code snippet shows a function called \"extract\" that takes no arguments and returns a generic type E.\n\nThe diagram shows a linked list with three nodes. The first node is highlighted in red. The second node is connected to the first node with an arrow. The third node is connected to the second node with an arrow. The last node points to null.\n\nThe second step of the extraction process involves getting the information from the node to extract. The code snippet shows that the data from the first node is retrieved using the \"getInfo()\" method and stored in a variable called \"data\" of type E. \n", "Extracting the first node\n\nThis slide describes how to extract the first node from a linked list. The code snippet shows a method called \"extract\" that returns a generic type E. The diagram shows three nodes in a linked list. The first node is colored red and labeled \"first\". An arrow points from the label \"first\" to the first node. The first node points to the second node and the second node points to the third node. The third node points to \"null\".\n\nStep 3 of the process is to assign the second node as the first one of the list. This is done by setting the \"first\" variable to the next node after the current \"first\" node, using the \"getNext\" method. \n", "2. Extracting the first node\n\nThe image shows step 4 of a process to extract the first node of a linked list.\n\nThe code snippet shows the signature of a method called \"extract\" that returns a generic type \"E\".\n\nThe diagram shows three nodes. The first node is filled in red and has an arrow pointing to it with the label \"first\". The first node is followed by another node, which is followed by a last node that points to \"null\". There is an arrow from the bottom left corner pointing to the data section of the first node.\n\nBelow the first node, there is a text box that reads: \"The node is isolated and does not belong to the list anymore\".\n\nFinally, below the diagram, we see \"Step 4: Returning the piece of data\" and the instruction \"return data;\".\n", "**3. Inserting at an intermediate position (given the previous node)**\n\nThe code snippet shows the implementation of an insert method in Java. The method takes two arguments: \"info\" of type E which represents the data to be inserted and \"previous\" of type Node<E> which represents the node previous to the insertion point.\n\nThe diagram illustrates a linked list with three nodes. The first node is labeled \"previous\" and has an arrow pointing to the second node. The second node has an arrow pointing to the third node. The third node has an arrow pointing to \"null,\" indicating the end of the list.\n\nThe first step of the insertion process is to check if the \"previous\" node is not null. This is done using an \"if\" statement that checks if \"previous\" is not equal to null. \n", "**3. Inserting at an intermediate position (given the previous node)**\n\nWe see four rectangular nodes, visually representing a linked list. The second node from the left is labeled \"previous\" and has an arrow pointing to the next node in the list. The next node has an arrow pointing to the last node, which has an arrow pointing to the word \"null\".  The word \"first\" has an arrow pointing to the first node. Below the first node is another node labeled \"newNode\" and colored red. This node has an arrow pointing to the word \"null\".\n\nBelow the diagram, we see the code \"Node<E> newNode = new Node<E>(info);\" which is labeled as \"Step 2: Creating a new node\". \n", "3. Inserting at an intermediate position (given the previous node)\n\nThe image shows the third step in the process of inserting a new node at an intermediate position in a linked list, given the previous node.\n\nWe see a code snippet:\n_private void insert(E info, Node<E> previous)_\n\nAnd a diagram with four nodes:\n- The first node is labeled \"first\".\n- The second node is labeled \"previous\".\n- The third node has no label.\n- The fourth node is labeled \"null\".\n\nThere is an arrow pointing from the word \"first\" to the first node, an arrow pointing from the word \"previous\" to the second node, and an arrow pointing from the word \"newNode\" to a red oval located below the first node. The nodes are connected by arrows. The arrow pointing from the third node is pointing to the fourth node labeled \"null\".\n\nFinally, there is a text box with the following text:\n_Step 3: Assigning as the next for the node just created the next to previous_\n_newNode.setNext(previous.getNext());_\n\nThis step sets the \"next\" pointer of the new node to the node that is currently after the \"previous\" node in the list. This effectively inserts the new node between the \"previous\" node and the node that was originally after it.\n", "3. Inserting at an intermediate position (given the previous node)\n\nThe image shows four nodes, the second one labeled \"previous\" and the new node colored in red. An arrow points from the word \"first\" to the first node. An arrow points from the word \"newNode\" to the red node. An arrow points from the last node to the word \"null\". Two more arrows connect the nodes in the following order: first node, \"previous\" node, red node, last node.\n\nThe code snippet shows the fourth step of the insertion process: \"previous.setNext(newNode);\". This line of code sets the next node of the \"previous\" node to the newly created node (the red one). \n", "Extracting an intermediate node (given the previous node)\n\nWe have some source code in a white box:\n\n```java\nprivate E extract(Node<E> previous)\n```\n\nFirst arrow is pointing to the first node of a linked list. Previous arrow is pointing to the previous node. Data arrow is pointing to the data we want to extract. The last node is pointing to null.\n\n<br/>\n\nThere are 3 steps to extract an intermediate node:\n1. Checking that the list is not empty\n2. Checking that previous is not null.\n3. Checking that the next to previous is not null\n\n<br/>\n\nFinally, we have a conditional statement:\n\n```java\nif (first != null && previous!= null && previous.getNext() != null)\n```\n", "**4. Extracting an intermediate node (given the previous node)**\n\nWe have a code snippet: \"private E extract(Node<E> previous)\"\n\nAnd a diagram showing a linked list with 5 nodes. The second node from the left is labeled \"previous\" and the fourth node is filled in red and labeled \"data\". There is an arrow pointing from \"first\" to the first node in the list. The last node has an arrow pointing to the right labeled \"null\".\n\n**Step 2: Retrieving the information in the node to extract**\n\nAnd another code snippet: \"E data = previous.getNext().getInfo();\"\n", "**4. Extracting an intermediate node (given the previous node)**\n\nThe code snippet shows the private method \"extract\" which takes a node, called \"previous\", as an argument. \n\nThe diagram shows a linked list with 5 nodes. The second node is colored light orange and labeled \"previous\". The fourth node is colored red and labeled \"data\". The last node points to \"null\".\n\n**Step 3: Assigning the next to the node to extract as the next to previous**\n\nThe code snippet shows how to assign the next node to the node to extract as the next to the previous node:\n\n```java\nprevious.setNext(previous.getNext().getNext());\n```\n", "**4. Extracting an intermediate node (given the previous node)**\n\nThe image shows step 4 of a process to extract an intermediate node from a linked list, given the previous node.\n\nWe see a code snippet: `private E extract(Node<E> previous)` which is a method definition for extracting the node.\n\nThere is a diagram showing four nodes. The first node is pointed by an arrow with the label \"first\". The second node is pointed by an arrow with the label \"previous\". The third node is colored in red and pointed by an arrow with the label \"data\". The fourth node is pointed by an arrow with the label \"null\".\n\nThe fourth step of the process, as indicated in the red box, is returning the piece of data. The code snippet for this step is `return data;`.\n", "5. Inserting at an intermediate position (given the position)\n\nThe image shows a code snippet for inserting an element into a linked list at a given position. The code first checks if the position is 0 or if the linked list is empty. If either of these conditions is true, the code inserts the element at the beginning of the list. Otherwise, the code inserts the element at the specified position.\n\nThe image also includes a diagram that illustrates the process of inserting an element into a linked list. The diagram shows a linked list with four nodes. The first node is labeled \"first\" and the last node is labeled \"null\". The code is inserting a new node with the value \"info\" at the third position in the list. The diagram shows the new node being inserted between the second and third nodes in the list.\n", "**5. Inserting at an intermediate position (given the position)**\n\nThe image shows a slide titled \"5. Inserting at an intermediate position (given the position)\". \n\nThe code snippet shows a method in Java that inserts a new node into a linked list at a given position. The method takes two arguments: the data to be stored in the new node (info) and the position where the new node should be inserted (pos).\n\nThe method first checks if the given position is larger than the number of nodes in the list. If it is, the new node is inserted at the end of the list. Otherwise, the method iterates through the list until it reaches the node before the desired position. Once it has found the correct position, it inserts the new node.\n\nThe diagram illustrates the process of inserting a new node into a linked list at a given position. The red circle represents the new node to be inserted. The arrows indicate the links between the nodes. The first arrow points to the first node in the list. The last arrow points to null, indicating the end of the list. The \"previous\" arrow points to the node before the position where the new node will be inserted.\n", "6. Extracting an intermediate node (given the position)\n\nWe have a code snippet showing how to extract an intermediate node from a linked list, given its position. The method signature is public E extract(int pos).\n\nIf the position is zero or the linked list is empty, then we extract the first element by calling the method extract() with no arguments. This is illustrated by the code:\n\n```java\nif (pos == 0 || first == null) {\n  return extract();\n}\n```\n\nThe diagram shows a linked list with five nodes. The first node is on the left and the last node is on the right. The third node is highlighted in red, indicating that it is the node to be extracted. The second node is labeled \"previous\". The last node points to null.\n", "Extracting an intermediate node (given the position)\n\nWe have some code and a diagram. The code is for a method called \"extract\" that takes an integer \"pos\" as input. The diagram shows a linked list with 5 nodes. The first node is labeled \"first\", the third node is red, and the last node has an arrow pointing to the word \"null\". The second node is labeled \"previous\" and has an arrow pointing to it from the word \"previous\".\n\nThe code first checks if the position is larger than the number of nodes. If it is, then null is returned. Otherwise, the code advances from the first node to the position of the previous node, and then calls the method that extracts at an intermediate position given previous. \n\nThe code does this by first creating a temporary node variable \"tmp\" and setting it to the first node. Then, it iterates from 0 to pos-1. For each iteration, it sets tmp to the next node. After the loop, tmp will be pointing to the node at position pos-1. Finally, the code returns the result of calling the extract method with tmp as input. \n", "7. Traversing the list: printing the content\n\nThe code snippet shows a function called \"print\" that takes no arguments. This function iterates through a linked list and prints the information stored in each node.\n\nThe diagram shows a linked list with five nodes. The first node is labeled \"first\" and the last node points to \"null\". Each node is connected to the next one by an arrow.\n\nThe code first checks if the list is empty by checking if \"first\" is null. If not, it creates a \"current\" node, initialized to the \"first\" node. Then, it iterates through the list using a while loop. For each node, it prints the information stored in the node using \"System.out.println(current.getInfo())\". Then, it moves to the next node by setting \"current\" to \"current.getNext()\". The loop continues until \"current\" becomes null, indicating the end of the list. \n", "**8. Traversing the list: searching for the last node**\n\nThe code snippet shows a method called \"searchLastNode\" that searches for the last node in a linked list.\n\nThe method starts by getting a reference to the first node in the list. Then, it iterates through the list until it finds a node whose \"next\" reference is null. This means that the current node is the last node in the list.\n\nThe method then returns a reference to the last node.\n", "**9. Traversing the list: searching for a piece of data**\n\nThe image shows a code snippet of a method called \"search\" that takes an argument of type E called \"info\" and returns an integer. \n\n- A reference steps the list until the piece of information is reached.\n- A counter is used in order to return its position in the list.\n\nThe code first initializes two variables: an integer called \"pos\" to 0 and a Node<E> called \"current\" to the first node in the list. \n\nThen, a while loop iterates as long as \"current\" is not null and the information stored in the current node is not equal to the \"info\" argument. Inside the loop, the counter \"pos\" is incremented and the current node is moved to the next node in the list.\n\nAfter the loop, the code checks if \"current\" is not null. If it is not null, it means that the information was found and the method returns the value of \"pos\". Otherwise, it means that the information was not found and the method returns -1.\n", "Exercise 3\n\nCreate the method public int number of occurrences E info which returns the number of nodes in a linked list whose stored information is the same as the one provided as argument. \n", "Advantages of Linked Lists\n\n- Inserting and extracting nodes have a cost that does not depend on the size of the list\n- Concatenation and partition of lists have a cost that does not depend on the size of the list\n- There is no need for contiguous memory\n- Memory in use at a given instant depends only on the number of data items stored in the list at that instant\n", "Disadvantages of Linked Lists\n\n- Accessing to arbitrary intermediate positions has a cost that depends on the size of the list\n- Each node represents an overhead in memory usage \n", "Exercise 4\n\nCreate a linked list with 10 integer elements, all initialized to 1. Then, insert an additional element with the value 0 in the fourth position of the linked list. Assume that the classes Node and MyLinkedList already exist and are implemented as previously discussed. \n"]}, {"filename": "8. SearchingAndSorting.pdf", "text": "Systems Programming\n\nSearching and Sorting\n\nDepartamento de Ingenier\u00eda\nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nCarlos Delgado Kloos, Carlos Alario Hoyos, Julio Villena Rom\u00e1n,\nNatividad Mart\u00ednez, Manuel Larre, Carmen Fern\u00e1ndez Panadero, \n\n1\n\n\fContents\n\nv Searching algorithms\n\no Linear search\no Binary search\n\nv Basic sorting algorithms\n\no Bubble Sort\no Selection Sort\no Insertion Sort\n\nv Advanced sorting algorithms\n\no Heap Sort\no Merge Sort\no Quick Sort\n\n2\n\n\fSearching algorithms\n\n\u2022 Why are they important?\n\u2022 Linear search\n\u2022 Binary search\n\n3\n\n\fWhy are they important?\n\n\u2022 One of the most frequent uses of computers are \n\n\u201cstatic\u201d searches of information in data structures \n(without modifying the stored values)\n\n\u2022 The efficiency of the searching algorithm is related to \nwhether the data structure in which we search is sorted \nor not. \n\n\u2022 Many searching algorithms internally call a sorting \n\nmethod, and the cost of the sorting algorithm \ndetermines the global cost of the searching algorithm.\n\n4\n\n\fActivity\n\n\u2022 Let\u2019s play a game\n\n\u00fc Think of a number between 0 and 999\n\u00fc Tell someone to guess your number\n\u00fc In every new try your colleague tells you a \n\nnumber and you can answer\no if that number is correct\no If that number is higher or lower than your number\n\n\u2022 What strategies optimize this game?\n\n5\n\n\fStrategies\n\n\u2022 Linear\n\no Start with one end (e.g., 0) and then move forward one \nelement by one, until reaching the correct number\n\no O(n) => linear order\n\no\n\nFor both the successful and unsuccessful searches\n\n\u2022 Binary\n\no Say a number which divides the range of numbers in two \n\napproximately equal parts. \n\no Whenever you get an answer you have a new range, which \n\nis approximately half the size of the previous range.\n\no O(log n) => logarithmic order (more efficient)\n\no\n\nFor both the successful and unsuccessful searches\n\n6\n\n\fLinear search\n\n\u2022 Starting from:\n\no An array of elements a[ ] and\no An element x\n\n\u2022 We traverse the array from left to right comparing each \n\nof its elements with x\no If they are equal, then we return the position of the element \n\nand the search ends\n\no If they are different, then we keep searching until the end of \nthe array, and if we do not find the element x we return \nvalue -1, or an exception\n\nhttp://www.cs.armstrong.edu/liang/animation/web/LinearSearch.html\n\n7\n\n\fLinear search\n\npublic static int linearSearch(int a[], int x) {\n\nfor (int i = 0; i < a.length ; i++) {\n\nif (a[i] == x){\n\nreturn i;\n\n}\n\n}\nreturn -1;\n\n}\n\n-5 -2\n\n0\n\n3\n\n6\n\n8\n\n9 10 12 26 31\n\n0       1       2      3      4       5      6       7      8       9     10    \n\n8\n\n\fBinary search\n\n\u2022\n\nStarting from:\no A sorted array of elements a[ ] and\no An element x\n\n\u2022 We store in a variable \u201chalf\u201d the position of the element which is in the \n\nmiddle of the array\n\n\u2022 We compare the element which is in \u201chalf\u201d with x\nIf they are equal, then we return \u201chalf\u201d\nIf it is lower, then we repeat the search between \u201chalf+1\u201d and the end of the array\nIf it is higher, then we repeat the search between the beginning of the array and \n\u201chalf-1\u201d\n\no\no\no\n\n\u2022\n\nIn each iteration we get a subarray which is approximately half the size\n\nhttp://www.cs.armstrong.edu/liang/animation/web/BinarySearch.html\n\n9\n\n\fBinary search\n\npublic static int binarySearch(int a[], int x) {\n\nint half;\nint first = 0;\nint last = a.length -1;\nwhile (first <= last) {\n\nhalf = (first + last)/2;\nif(a[half] == x){\n\nreturn half;\n\n}else if(a[half] < x){\nfirst = half+1;\n}else if(a[half] > x){\nlast = half-1;\n\n}\n\n}\nreturn -1;\n\n}\n\nFirst iteration\n\u2022\n\u2022\n\nIf a[half]>x, we search in [0...half-1]\nIf a[half]<x, we search in a[half+1, a.length-1]\n\n-5 -2\n\n0\n\n3\n\n6\n\n8\n\n9 10 12 26 31\n\n0       1       2      3      4       5      6       7      8       9     10    \n\n10\n\n\fExercise 1\n\n\u2022\n\nImplement the method public static int\nbinarySearchString(String[] s, String x), \nwhich does a binary search of element x in the array \nof strings s. Use the method compareTo() of class \nString, which compares two strings lexicographically.\n\n\u2022 Given the array {\"a\",\"b\",\"d\",\"f\",\"h\",\"n\",\"p\",\"q\",\"r\",\"v\",\"z\"} \nhow many iterations are needed to search \u201cf\u201d, \u201cr\u201d and \u201cw\u201d \nwith binary search? And with linear search?\n\n11\n\n\fExercise 2\n\n\u2022 Think about the differences between \n\nimplementing a linear search and a binary search \nin a stack/queue, and in a binary search tree.\n\u2022 How does it affect in each case the fact that the \n\nimplementation of the data structure can be done \nwith arrays or with linked lists?\n\n12\n\n\fRecursive binary search (linear tail recursion)\n\npublic static int binarySearchRecursive(int[] a, int x) {\nreturn binarySearchRecursive(a, 0, a.length-1, x);\n\n}\npublic static int binarySearchRecursive(int[] a, int first, int last, int x) {\n\nint half;\nif(first <= last) {\n\nhalf = (first + last) / 2;\nif(a[half]==x) {\nreturn half;\n}else if(a[half]<x){\n\nreturn binarySearchRecursive(a, half+1, last, x);\n\n}else if(a[half]>x){\n\nreturn binarySearchRecursive(a, first, half-1, x);\n\n}\n\n}\nreturn -1;\n\n}\n\npublic static int binarySearch(int a[], int x) {\n\nint half;\nint first = 0;\nint last = a.length -1;\nwhile (first <= last) {\n\nhalf = (first + last)/2;\nif(a[half] == x){\n\nreturn half;\n\n}else if(a[half] < x){\nfirst = half+1;\n}else if(a[half] > x){\nlast = half-1;\n\n}\n\n}\nreturn -1;\n\n}\n\n13\n\n\fExercise 3\n\n\u2022\n\nImplement the method public static int\nbinarySearchString(String[] s, String x), \nwhich does a binary search of element x in the array \nof String s recursively. Use the method \ncompareTo() of class String, which compares two \nstrings lexicographically\n\n14\n\n\fConclusions\n\n\u2022 For smaller sizes (e.g., N<6)\n\no It is not worthy using binary search since it uses approximately \n\nthe same number of comparisons as a linear search\n\u2022 Last iterations in a binary search are slower\n\u2022 A hybrid approach could be interesting\no We apply binary search until the range is small\no Then, we apply linear search\n\n15\n\n\fBasic sorting algorithms\n\n\u2022 Why are they important?\n\u2022 Bubble Sort\n\u2022 Selection Sort\n\u2022\nInsertion Sort\n\n16\n\n\fWhy are the important?\n\n\u2022 Binary search takes advantage of the order\n\u2022 Sorted data structures makes searching easier \n\n(e.g., telephone book, dictionary\u2026)\n\n\u2022 Order facilitates searching\n\n17\n\n\fBubble Sort\n\n\u2022 The algorithm moves forward through the data structure \n\nswapping pairs of contiguous elements which are not in the \ncorrect order.\no\n\nIf we sort from the lowest to the highest, the highest element \nmoves to the end (as it was a bubble).\n\n\u2022 These passes are repeated until no more swapping is \n\nneeded.\n\n\u2022 Elements which advanced to their correct position do not \nneed to be checked again. Each pass needs to check one \nless element.\n\nhttp://www.cs.armstrong.edu/liang/animation/web/BubbleSort.html\nhttp://www.algostructure.com/sorting/bubblesort.php\n\n18\n\n\fBubble Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n80 95 14 98 29 49 66\n\nq Two loops: internal and external\n\n80 14 95 98 29 49 66\n\nq External loop: first iteration\nq Internal loop from 0 to length-1 (6 in \n\n80 14 95 29 98 49 66\n80 14 95 29 49 98 66\n80 14 95 29 49 66 98\n\nthis example)\n\nv Swapping if element in position j is \nhigher than element in position j+1\nv Ends with 1 element in its correct \n\nposition\n\n14 80 95 29 49 66 98\n14 80 29 95 49 66 98\n14 80 29 49 95 66 98\n14 80 29 49 66 95 98\n\nq External loop: second iteration\nq Internal loop from 0 to length-2 (5 in \n\nthe example)\n\nv Swapping if element in position j is \nhigher than element in position j+1\n\nv Ends with 2 elements in their correct \n\nposition\n\n19\n\n\fBubble Sort. Example (II)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n14 80 29 49 66 95 98\n\n14 29 80 49 66 95 98\n14 29 49 80 66 95 98\n14 29 49 66 80 95 98\n\nq External loop: third iteration\nq Internal loop from 0 to length-3 (4 in \n\nthe example)\n\nv \u2026\nv 3 elements in the correct position\n\n14 29 49 66 80 95 98\n\n14 29 49 66 80 95 98\n\nq External: fourth iteration. \nq Internal: from 0 to length-4\n\nq External: fifth iteration. \nq Internal: from 0 to length-5\n\n14 29 49 66 80 95 98\n\nq External: sixth iteration. \nq Internal: from 0 to length-6\nv In the example with six iterations of \nthe external loop all the elements are \nin their correct position\n\n20\n\n\fBubble Sort. Two loops \n\n\u2022 External loop:\n\no Number of iterations: length of array - 1 (in each iteration one element is \n\nsorted, except for the last one in which two elements are sorted)\n\u2022\nRange of the index in the external loop [0, length of array \u2013 1)\n\n\u2022\n\nInternal loop:\no\no\no\n\nIn the first iteration of the external (i=0), length of array - 1 iterations\nIn the second iteration of the external (i=1), length of array - 2 iterations\nIn the m-th iteration of the external (i=m-1), length of array - i - 1 iterat.\n\u2022\nRange of the index in the internal loop [0,  length of array - 1 - i) \n\n\u2022 After m-th iteration (i=m-1) of the external loop:\n\no Elements from 0 to length of array - 2 - i are unsorted\no Elements from length of array - 1 - i to length of array - 1 are sorted \n\n21\n\n\fBubble Sort. Code\n\npublic static void bubbleSort (int[] a) {\nfor (int i=0; i<a.length-1; i++) {\n\nfor (int j=0; j<a.length-1-i; j++) {\n\nif (a[j]>a[j+1]){\n\nswap(a, j, j+1);\n\n}\n\n}\n\n}\n\n}\n\nq Alternative:\n\nv External loop from 1 to a.length and    \nInternal loop from 0 to a.length-i\n\nv Descending order a[j]<a[j+1]\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n22\n22\n\n\fBubble Sort. Conclusions \n\n\u2022 Advantages:\n\no Little additional memory is needed\no\no Efficient for arrays with few elements\n\nFew lines of code\n\n\u2022 Drawbacks:\n\no\n\nInefficient for arrays with many elements\nv O(n2) => quadratic order (two nested loops for an array of n elements)\nv For a given array there are always the same number of iterations (even though \n\nit is already sorted), even though there are no swaps\n\nv Too many swaps\n\no Larger elements move faster to the end (they can reach the end in one \niteration of the external loop), but lower elements move slower to the \nbeginning (they gain one position per iteration)\nv Improvement: Cocktail sort (double internal loop to pass from left to right \n23\n\nand from right to left in each iteration of the external loop)\n\n\fExercise 4\n\n\u2022 Using the sorting algorithm Bubble Sort, how \n\nmany swaps are needed to sort the following array \nfrom the highest element to the lowest element \n(descending order)?\n\n{1,3,5,7,11,13}\n\n24\n\n\fSelection Sort\n\n\u2022\n\n\u2022\n\no\n\no\n\nIn ascending order\no\no\n\nSearches the minimum element and puts it in the first position (swap)\nSearches the next minimum element and puts it in the second position \n(swap)\nIn general, searches the minimum element between i and the end of the \ndata structure and puts in the i-th position through swapping\n\nIn descending order\no\no\n\nSearches the maximum element and puts it in the first position (swap)\nSearches the next maximum element and puts it in the second position \n(swap)\nIn general, searches the maximum element between i and the end of the \ndata structure and puts in the i-th position through swapping\n\nhttp://www.cs.armstrong.edu/liang/animation/web/SelectionSort.html\nhttp://www.algostructure.com/sorting/selectionsort.php\n\n25\n\n\fSelection Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n80 95 14 98 29 49 66 q Two loops: internal and external\n\n14 is the minimum unsorted element: swapping with element in position 0\n\n80 95 14 98 29 49 66\n\n14 95 80 98 29 49 66\n\n29 is the minimum unsorted element: swapping with element in position 1\n\n14 95 80 98 29 49 66\n\n14 29 80 98 95 49 66\n\n49 is the minimum unsorted element: swapping with element in position 2\n\n14 29 80 98 95 49 66\n\n14 29 49 98 95 80 66\n\nq External loop: sorts the first position. \n\nAs part of this loop there is a swapping \nbetween the element in position i and \nthe minimum unsorted element\nq Internal loop: searches the minimum \n\nelement from position i until the end of \nthe data structure\n\n26\n\n\fSelection Sort. Example (II)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n66 is the minimum unsorted element: swapping with element in position 3\n\n14 29 49 98 95 80 66\n\n14 29 49 66 95 80 98\n\n80 is the minimum unsorted element: swapping with element in position 4\n\n14 29 49 66 95 80 90\n14 29 49 66 80 95 98\n\n95 is the minimum unsorted element. It is in the correct position. No swapping.\n\n14 29 49 66 80 95 98\n\n98 is the minimum unsorted element. It is in the correct position. No swapping.\n\n14 29 49 66 80 95 98\n\n27\n\n\fSelection Sort. Two loops \n\n\u2022 External loop:\n\no Number of iterations: length of array (in each iteration one element is \n\nsorted, although the last iteration is not strictly needed)\n\u2022\n\nRange of the index in the external loop [0, length of array - 1]\n\n\u2022\n\nInternal loop (searching the minimum / maximum):\no\no\no\n\nIn the first iteration of the external loop (i=0), length of array - 1 iterat.\nIn the second iteration of the external loop (i=1), length of array - 2 iterat.\nIn the m-th iteration of the external loop (i=m-1), length of array - i iterat.\n\u2022\n\nRange of the index in the internal loop [i, length of array - 1]\n\n\u2022 After m-th iteration (i=m-1) of the external loop :\n\no Elements from 0 to i are sorted\no Elements from i+1 to length of array - 1 are unsorted \n\n28\n\n\fSelection Sort. Code\n\npublic static void selectionSort (int[] a) {\n\nfor (int i=0; i<a.length; i++) {\n\nint m = i;\nfor (int j=i; j<a.length; j++) {\n\nif (a[j]<a[m]){\nm = j;\n\nq Alternative:\n\n}\n\n}\nswap(a, i, m);\n\n}\n\n}\n\nv External loop to a.length - 1\nv Internal loop from j+1 to a.length saves one \n\nunnecessary comparison\nv Descending order a[j]>a[m]\nv Avoid unnecessary swaps adding if(i!=m) \n\nbefore swap(a,i,m)\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n29\n29\n\n\fSelection Sort. Conclusions \n\n\u2022 Advantages:\n\no Little additional memory is needed\no\no Efficient for arrays with few elements\n\nFew lines of code\n\n\u2022 Drawbacks:\n\no\n\nInefficient for arrays with many elements\nv O(n2) => quadratic order (two nested loops for an array of n elements)\nv For a given array there are always the same number of iterations (even though \n\nit is already sorted), even though there are no swaps\n\u00fc But much less swaps than with Bubble Sort\n\n\u2022 Variant: \n\no\n\nPlacing the maximum/minimum at the end, instead of placing the \nmaximum/minimum at the beginning\n\n30\n\n\fExercise 5\n\n\u2022 Using the sorting algorithm Selection Sort, how \n\nmany swaps are needed to sort the following array \nfrom the highest element to the lowest element \n(descending order)? Use the algorithm we saw in \nthe class, which swaps the maximum with the first \nunsorted element.\n\n{1,3,5,7,11,13}\n\n31\n\n\fInsertion Sort\n\n\u2022 The data structure is divided in two parts:\nthe first part (e.g., left side) is already sorted,\nthe second part (e.g., right side) is unsorted.\n\no\no\no At the beginning the first part is empty and the second part full\n\u2022 We extract the first element of the second part, inserting it in \n\nits correct position in the first part (sorted)\n\n\u2022 This step is repeated until all the elements are (sorted) in the \n\nfirst part.\n\nhttp://www.cs.armstrong.edu/liang/animation/web/InsertionSort.html\nhttp://www.algostructure.com/sorting/insertionsort.php\n\n32\n\n\fInsertion Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n80 95 14 98 29 49 66\n\nq Two loops: internal and external\n\nWe take 80 from the unsorted part and insert it in its correct position in the sorted part\n\n80 95 14 98 29 49 66\n\n80 95 14 98 29 49 66\n\nWe take 95 from the unsorted part and insert it in its correct position in the sorted part. \n\n80 95 14 98 29 49 66\n\n80 95 14 98 29 49 66\n\nWe take 14 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80 and 95 are moved one position to the right to fill the gap left by 14\n\n80 95 14 98 29 49 66\n\n14 80 95 98 29 49 66\n\nq External loop: it traverses \n\nthe array, leaving sorted \nwhat is behind position i. As \npart of the external loop the \nelement to be sorted is \nmoved to its right position \nq Internal loop: it moves one \nposition to the right all the \nelements that are located \nbetween where the new \nsorted element is inserted \nand the position it left in the \nunsorted part of the array \n(now that position is sorted)\n\n33\n\n\fInsertion Sort. Example (II)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nWe take 98 from the unsorted part and insert it in its correct position in the sorted part\n\n14 80 95 98 29 49 66\n\n14 80 95 98 29 49 66\n\nWe take 29 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 29\n\n14 80 95 98 29 49 66\n\n14 29 80 95 98 49 66\n\n34\n\n\fInsertion Sort. Example (III)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nWe take 49 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49\n\n14 29 80 95 98 49 66\n\n14 29 49 80 95 98 66\n\nWe take 66 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80, 95 and 96 are moved one position to the right to fill the gap left by 66\n\n14 29 49 80 95 98 66\n\n14 29 49 66 80 95 98\n\n35\n\n\fInsertion Sort. Two loops \n\n\u2022 External loop:\n\no Number of iterations: length of array (in each iteration one element is \n\nsorted, including in the last iteration)\n\u2022\n\nRange of the index in the external loop [0, length of array - 1]\n\n\u2022\n\nInternal loop (finding the correct position to insert):\no The number of iterations depends on the position \u201cadvanced\u201d by the \n\no\n\nelement which is inserted\nIf the element inserted moves k positions to the left, then there are k \nelements that are moved one position to the right\n\n\u2022 After m-th iteration (i=m-1) of the external loop:\n\no Elements from 0 to i are sorted\no Elements from i+1 to length of array - 1 are unsorted \n\n36\n\n\fInsertion Sort. Code\n\npublic static void insertionSort (int[] a){\n\nfor (int i=0; i<a.length; i++){\n\nint tmp=a[i];\nint j=i;\nwhile (j>0 && tmp<a[j-1]){\n\na[j]=a[j-1];\nj--;\n\n}\na[j]=tmp;\n\n}\n\n}\n\nq Alternative:\n\nv External loop from i=1, since the first \nelement always stays in the same \nposition\n\nv Descending order tmp>a[j-1]\n\n37\n37\n\n\fInsertion Sort. Code with auxiliary method\n\npublic static void insertionSort (int[] a) {\n\nfor (int i=0; i<a.length; i++) {\n\ninsert (a, i); \n\n}\n\n}\n\nprivate static void insert (int[] a, int i) {\n\nint tmp=a[i];\nint j=i;\nwhile (j>0 && tmp<a[j-1]){\n\na[j]=a[j-1];\nj--; \n\n}\na[j]=tmp; \n\n}\n\nv Auxiliary method insert(int[a], int i), \ninserts the element at position i in the \nappropriate place of a, moving the \nneeded elements one position to the right\n\n38\n38\n\n\fInsertion Sort. Conclusions \n\n\u2022 Advantages:\n\nFew lines of code\n\no Little additional memory is needed\no\no Efficient for arrays with few elements\no More efficient than Selection Sort for (partially) sorted arrays\n\nv For a given array there are always the same number of iterations in the external \n\nloop (even though it is already sorted), but the internal loop is adaptable\n\n\u2022 Drawbacks:\n\no\n\no\n\nInefficient for arrays with many elements\nv O(n2) => quadratic order (two nested loops for an array of n elements)\nInefficient when the array to sort in the reverse sorted order\n\n39\n\n\fExercise 6\n\n\u2022 Using the sorting algorithm Insertion Sort, how \n\nmany swaps are needed to sort the following array \nfrom the highest element to the lowest element \n(descending order)?\n\n{1,3,5,7,11,13}\n\n\u2022 Of the three algorithms seen so far, which was the \nmost efficient one for this array? Try with other \narrays with different values and lengths\n\n40\n\n\fAdvanced sorting algorithms\n\n\u2022 Heap Sort\n\u2022 Merge Sort\n\u2022 Quick Sort\n\n41\n\n\fHeap Sort\n\nImproved version of Selection Sort.\n\n\u2022\n\u2022 Two steps:\n\n(In ascending order from low to high)\n\no\no Build a heap \n\n\u00a7\n\u00a7\n\u00a7\n\u00a7\n\nBinary tree, complete, key of the parent is higher than that of the children\nParent with index i\nLeft child with index 2*i +1\nRight child with index 2*i+2\n\no The highest element of the heap is removed (root) and is inserted at the \nend of the array. The heap must be updated after the removal of the root. \n\nhttps://www.cs.usfca.edu/~galles/visualization/HeapSort.html\nhttp://www.algostructure.com/sorting/heapsort.php\nhttp://www.cs.armstrong.edu/liang/animation/web/Heap.html\n\n42\n\n\fHeap Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest) (max-heap)\n\n80 95 14 98 29 49 66\n\n80\n\nq Build the heap from the array\nq Root in position i (starting from 0)\nq Left (child) node: 2*i + 1\nq Right (child) node: 2*i + 2\n\n95\n\n14\n\n98\n\n29\n\n49\n\n66\n\n43\n\n\fHeap Sort. Example (II)\n\n\u2022\n\nStep 1: Ordering the heap (root is higher than children)\n\u2022\n\nStarting from the penultimate row to the right, check if the children is higher than \nthe parent\nNodes go down to their corresponding position\nSwapping 66 and 14\nSwapping 98 and 95\nSwapping 98 and 80\nSwapping 95 and 80\n\n\u2022\n1.\n2.\n3.\n4.\n\n98\n\n98 95 66 80 29 49 14\n\n2-4\n\n95\n\n80\n\n29\n\n49\n\n66\n\n1\n\n14\n\n44\n\n\fHeap Sort. Example (III)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\nTaking 98 and placing it at the end (sorted). The root becomes 14.\n1.\nReplacing 14 by the highest element of the array (95) and reordering the heap\n2.\n\n1\n\n2\n\n45\n\n\fHeap Sort. Example (IV)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\nTaking 95 and placing it at the end (sorted). The root becomes 49.\n1.\nReplacing 49 by the highest element of the array (80) and reordering the heap\n2.\n\n1\n\n2\n\n46\n\n\fHeap Sort. Example (V)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\nTaking 80 and placing it at the end (sorted). The root becomes 29.\n1.\nReplacing 29 by the highest element of the array (66) and reordering the heap\n2.\n\n1\n\n2\n\n47\n\n\fHeap Sort. Example (VI)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\nTaking 66 and placing it at the end (sorted). The root becomes 14.\n1.\nReplacing 14 by the highest element of the array (49) and reordering the heap\n2.\n\n1\n\n2\n\n48\n\n\fHeap Sort. Example (VII)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\n\u2022\nTaking 49 and placing it at the end (sorted). The root becomes 29.\n\u2022\nTaking 29 and placing it at the end (sorted). The root becomes 14.\n\u2022\nTaking 14. The heap is empty\n\n14 29 49 66 80 95 98\n\n49\n\n\fHeap Sort. Two external loops\n\n\u2022 External loop 1 (Step 1): Building the heap\n\nFor each node, checking that the children are smaller\n\no\no Number of iterations: half the length of the array\n\n\u2022\n\u2022\n\nTraversing all the nodes except for the leaves (they do not have children)\nRange of the index of external loop 1 [0, length of array - 2)/2]\n\n\u2022 External loop 2 (Step 2): Extracting the root and reordering\n\no The root is extracted, placed at the end of the data structure, and the heap is \n\nreordered\n\no Number of iterations: length of array\n\n\u2022\n\nRange of the index of external loop 2 [0, length of array - 1]\n\n\u2022 After m-th iteration (i=m-1) of the external loop 2:\no Elements from 0 to length of array - 2 - i are unsorted\no Elements from length of array - 1 - i to length of array - 1 are sorted \n50\n\n\fHeap Sort. Code\n\npublic static void heapSort(int[] a) {\n\nfor (int i=(a.length-2)/2; i>=0; i--)\n\nheapify(a,i,a.length-1);\n\nfor (int i=a.length-1; i>=0; i--) {\n\nswap(a,0,i);\nheapify(a,0,i-1);\n\n}\n\n}\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n51\n51\n\n\fHeap Sort. Code (II)\n\nprivate static void heapify(int[] a, int i, int m) {\n\nint j;\nwhile(2*i+1<=m) {\nj=2*i+1;\nif(j<m) {\n\ni is the index of the parent\n\n\u2022\n\u2022 m is the index of the last unsorted node of the heap\n\u2022\n\nj is the index of the left child (if any)\n\nif(a[j]<a[j+1])\n\nj++;\n\n}\nif(a[i]<a[j]) {\n\nswap(a,i,j);\ni=j;\n\n} else\n\ni=m;\n\n\u2022 Getting the index of the child with highest value\n\n\u2022\n\nIf the child\u2019s value is higher than that of the \nparent, then we need to swap, and then check \nagain with its new children\n\n\u2022 Otherwise we are done\n\n}\n\n}\n\n52\n52\n\n\fHeap Sort. Conclusions \n\n\u2022 Advantages:\n\no Efficient for arrays with many elements, even in the \n\nworse case\nv O(n log n)\n\no Little additional memory is needed\n\n\u2022 Drawbacks:\n\no Complex code\n\n53\n\n\fExercise 7\n\n\u2022 Using the sorting algorithm Heap Sort, how many \nswaps are needed to sort the following array from \nthe lowest element to the highest element \n(ascending order)?\n\n{7,3,13,1,11,5}\n\n54\n\n\fMerge Sort\n\n1. Divide the array in two subarrays \nof approximately the same length \n(half the original array)\n\n2. Divide each subarray recursively \nuntil we have subarrays of length \n1, in which case that array is \nreturned\n\n3. Merge the two subarrays in a \n\nnew sorted subarray recursively\n\nhttp://www.algostructure.com/sorting/mergesort.php\nhttp://www.cs.armstrong.edu/liang/animation/web/MergeList.html\n\n55\n\n\fMerge Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n80 95 14 98 29 49 66\n\n80 95 14 98\n\n29 49 66\n\n80 95\n\n14 98\n\n29 49\n\n80\n\n95\n\n14\n\n98\n\n29\n\n49\n\n66\n\n66\n\n56\n\n\fMerge Sort. Example (II)\n\n80\n\n95\n\n14\n\n98\n\n29\n\n49\n\n80 95\n\n14 98\n\n29 49\n\n66\n\n66\n\n14 80 95 98\n\n29 49 66\n\n14 29 49 66 80 95 98\n\n57\n\n\fMerge Sort. Recursive division and \nmerging with auxiliary array\n\n\u2022\n\n\u2022\n\nStep 1: Recursive division\no Given an array (or part of it) with l the first position, r the last position and \n\nm the half position ((l+r)/2)\n\no Divide the array recursively in two until l and r are equal\n\n\u2022\n\u2022\n\nFrom l to m\nFrom m+1 to r\n\nStep 2: Sorting by merging subarrays\no Create an auxiliary array containing the two subarrays to sort\no Compare the elements to sort of each subarray\n\n\u2022 Elements are not in their final correct position until we finish \n\nmerging subarray\n\n58\n\n\fMerge Sort. Code (I)\n\npublic static void mergeSort (int[] a) {\n\nmSort(a, 0, a.length-1);\n\n}\n\npublic static void mSort (int[] a, int l, int r) {\n\nif (l>=r){\n\nreturn;\n\n}\nint m = (l+r)/2;\nmSort(a, l, m);\nmSort(a, m+1, r);\nmerge(a, l, m, r);\n\n}\n\n59\n59\n\n\fMerge Sort. Code (II). Merging (Option 1)\n\npublic static void merge (int[] a, int l, int m, int r){\n\nif (m+1>r){ return; }\nint[] b = new int[a.length];\nfor (int i=l; i<m+1; i++) { \n\nOption 1:\n\u2022 The left subarray is copied as it is in the auxiliary \n\nb[i] = a[i]; \n\narray\n\n}\nfor (int i=m+1; i<r+1; i++){\nb[i] = a[r+m+1-i]; \n\n}\nint k=l;\nint j=r;\nfor (int i=l; i<r+1; i++) {\nif (b[k] <= b[j]){\n\na[i] = b[k];\nk++;\n} else {\n\na[i] = b[j];\nj--; \n\n}\n\n}\n\n}\n\n\u2022 The right subarray is copied in the auxiliary array \n\nin reverse order\n\n\u2022 The merging starts from the two ends of the \n\nauxiliary array, which contain the elements with \nthe lowest values of each subarray\n\n60\n60\n\n\fMerge Sort. Code (III). Merging (Option 2)\n\npublic static void merge (int[] a, int l, int m, int r){\n\nif (m+1>r){ return; }\nint[] b = new int[a.length];\nfor (int i=l; i<r+1; i++) {\n\nb[i] = a[i];\n\n}\nint k=l;\nint j=m+1;\nint i=l;\nwhile(k<m+1 && j<r+1){\nif (b[k] <= b[j]){\n\na[i] = b[k];\nk++;\n} else {\n\na[i] = b[j];\nj++;\n\n}\ni++;\n\n}\nwhile(k<m+1) {\n\na[i] = b[k];\nk++; \ni++;\n\n}\nwhile (j<r+1) {\n\na[i] = b[j];\nj++; \ni++;\n\n}\n\n}\n\nOption 2:\n\u2022 The two subarrays are copied as they are in \n\nthe auxiliary array\n\n\u2022 The elements to merge are compared starting \n\nfrom the left side of each subarray\n\n\u2022 The last elements of the left subarray, which \nmay have not been merged yet, are added\n\n\u2022 The last elements of the right subarray, which \nmay have not been merged yet, are added\n\n61\n61\n\n\fMerge Sort. Conclusions \n\n\u2022 Advantages:\n\no Efficient for arrays with many elements, even in the \n\nworse case\nv O(n log n)\n\no Highly parallelizable\n\n\u2022 Drawbacks:\n\no Complex code\no Requires more memory space to store more \nauxiliary variables (e.g., auxiliary array)\n\n62\n\n\fExercise 8\n\n\u2022 Using the sorting algorithm Merge Sort, describe \nthe process needed to sort the following array in \nascending order. \n\n{7,3,13,1,11,5}\n\n\u2022 Unlike in other cases, with Merge Sort there are no \n\nswapping in the arrays, as we are using an \nauxiliary array\n\n63\n\n\fQuick Sort\n\n\u2022 Choose an element: the pivot\n\u2022 Reorder the data structure so that\n\no elements lower than the pivot are on its left \no elements higher than the pivot are on its right \n\n\u2022 Sort recursively\n\no the part whose elements are lower than the pivot\no the part whose elements are higher than the pivot\n\nhttp://www.algostructure.com/sorting/quicksort.php\nhttp://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html\n\n64\n\n\fQuick Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n80 95 14 98 29 49 66\n\n80 95 14 98 29 49 66\n\n95>80 (change side)\n\n80 95 14 98 29 49 66\n\n66<80 (time to swap, \nand then change side)\n\nq 80 is the pivot\nq Move forward from the left \nuntil a value is higher than \n80\n\nq Move forward from the \n\nright until a value is lower \nthan 80\n\n80 66 14 98 29 49 95\n\nq Swap the two values\nq Repeat until converging\n\n65\n\n\fQuick Sort. Example (II)\n\n80 66 14 98 29 49 95\n\n98 > 80 (change side)\n\n80 66 14 98 29 49 95\n\n48 < 80 (time to swap, \nand then change side)\n\n80 66 14 49 29 98 95\n\n80 66 14 49 29 98 95\n\n98 > 80 (change side)\n\n66\n\n\fQuick Sort. Example (III)\n\n80 66 14 49 29 98 95\n\n29 < 80 (after converging, \nplace the pivot in its correct \nlocation with a swap) \n\n29 66 14 49 80 98 95\n\n< 80\n\n> 80\n\nq Repeat recursively for the \nleft and right partitions\n\n67\n\n\fQuick Sort. Recursive partition and \nsorting by swapping\n\n\u2022\n\n\u2022\n\nStep 1: Recursive partition\no Given an array (or part of it) with l the first position, and r the \n\nlast position\no We have to run an algorithm that tell us where to do the partition \n(elements on the left lower than the pivot, and elements on the \nright higher than the pivot)\nThe next partition is computed recursively\n\no\n\nStep 2: Sorting by swapping\no Moving forward from the left, and from the right, comparting \n\nwith the pivot and swapping as needed\nPlacing the pivot in its correct location\n\no\n\n\u2022\n\nPivots are always placed in their final sorted position\n\n68\n\n\fQuick Sort. Code (I)\n\npublic static void quickSort (int[] a) {\n\nqSort(a, 0, a.length-1);\n\n}\n\npublic static void qSort (int[] a, int l, int r) {\n\nif (l>=r){ \n\nreturn; \n\n}\nint m = partition(a, l, r);\nqSort(a,l,m-1);\nqSort(a,m+1,r);\n\n}\n\n68\n69\n\n\fQuick Sort. Code (II)\n\npublic static int partition (int[] a, int l, int r) {\n\nint i=l+1; // left\nint j=r; // right\nint p=a[l]; // pivot\nwhile (i<=j) {\n\nif (a[i]<=p){\ni++;\n\n} else if (a[j]>p){\n\nj--;\n} else{ \n\n\u2022 Comparing with a[i]. When we find an \nelement higher than a[i] on the left, and \nan element lower than a[i] on the right: \nswap(a,i,j)\n\n\u2022 Before finishing the pivot must be placed \n\nswap(a,i,j); \n\nits the correct location: swap(a,l,j)\n\n}\n\n} \nswap(a,l,j);\nreturn j; \n\n}\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n69\n70\n\n\fQuick Sort. Conclusions \n\n\u2022 Advantages:\n\no Very efficient for arrays with many elements\n\nv O(n log n)\nv But the worse case is O(n2)!\n\no Little additional memory\no Highly parallelizable\n\n\u2022 Drawbacks:\n\no Complex code\n\n71\n\n\fExercise 9\n\n\u2022 Using the sorting algorithm Quick Sort, how many \nswaps are needed to sort the following array from \nthe lowest element to the highest element \n(ascending order)?\n\n{7,3,13,1,11,5}\n\n72\n\n\fSummary\n\n\u2022 Basic algorithms (Bubble, Insertion, Selection)\n\no Average complexity O(n2)\n\no\n\nInefficient with many elements \n\no Simple code\no Little use of memory \n\n\u2022 Advanced algorithms (Heap, Merge, Quick)\n\no Average complexity O(n log n)\no Efficient with many elements\n\no Complex code\no Little use of memory (except Merge Sort) \n\nhttps://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html\nhttps://www.cs.usfca.edu/~galles/visualization/HeapSort.html\n\n73\n\n\f", "pages_description": ["Searching algorithms\n\n- Why are they important?\n- Linear search\n- Binary search \n", "Why are they important?\n\n- One of the most frequent uses of computers is static searches of information in data structures without modifying the stored values.\n- The efficiency of the searching algorithm is related to whether the data structure in which we search is sorted or not.\n- Many searching algorithms internally call a sorting method, and the cost of the sorting algorithm determines the global cost of the searching algorithm. \n", "Activity\n\nWe are going to play a game. Think of a number between 0 and 999. Tell someone to guess your number. In every new try your colleague tells you a number and you can answer if that number is correct, or if that number is higher or lower than your number. What strategies optimize this game? \n", "Strategies\n\nThere are two strategies: linear and binary.\n\nLinear: you start at one end, for example at point 0, and then you move forward one element at a time until reaching the correct number. This strategy has a linear order, expressed as O(n). This applies to both successful and unsuccessful searches.\n\nBinary: you say a number that divides the range of numbers in two approximately equal parts. Whenever you get an answer you have a new range, which is approximately half the size of the previous range. This strategy has a logarithmic order, expressed as O(log n), which is more efficient. This applies to both successful and unsuccessful searches. \n", "Linear search\n\n- Starting from an array of elements and an element x.\n- We traverse the array from left to right comparing each of its elements with x.\n- If they are equal, then we return the position of the element and the search ends\n- If they are different, then we keep searching until the end of the array, and if we do not find the element x we return value -1, or an exception. \n", "Linear search\n\nWe see a code snippet for a linear search algorithm. The algorithm takes an array of integers and an integer as input. It iterates through the array, comparing each element to the input integer. If a match is found, the index of the matching element is returned. If no match is found, -1 is returned.\n\nBelow the code, there is an array of integers: -5, -2, 0, 3, 6, 8, 9, 10, 12, 26, and 31. Each number is in a separate cell. The index of each cell is displayed below the cell, ranging from 0 to 10. \n", "Binary search\n\nStarting from a sorted array of elements and an element x, we store in a variable \"half\" the position of the element which is in the middle of the array. We compare the element which is in \"half\" with x. If they are equal, then we return \"half\". If it is lower, then we repeat the search between \"half+1\" and the end of the array. If it is higher, then we repeat the search between the beginning of the array and \"half-1\". In each iteration we get a subarray which is approximately half the size. \n", "Binary search\n\nThis slide explains how the binary search algorithm works, and presents an example of its first iteration. The algorithm is implemented in a function called binarySearch, which takes an integer array a and an integer x as input. The function initializes three integer variables: half, first, and last. The variable first is initialized to 0, and last is initialized to the length of the array minus 1. The algorithm then enters a while loop that continues as long as the value of first is less than or equal to the value of last. Inside the loop, the algorithm calculates the middle index of the search range by assigning the average of first and last to half. If the value at the middle index of the array is equal to the search value x, the index half is returned. Otherwise, if the value at the middle index is less than x, the search range is narrowed to the right half by updating first to half+1. Otherwise, the search range is narrowed to the left half by updating last to half-1. If the loop completes without finding the search value, the function returns -1.\n\nThe example shows how the algorithm searches for a value in a sorted array. In the first iteration, the algorithm calculates the middle index as (0+10)/2 = 5. Since the value at index 5 is greater than the search value, the algorithm narrows the search range to the left half of the array, from index 0 to index 4. \n", "Exercise 1\n\nWe are asked to implement a method called \"binarySearchString\" in a programming language like Java. This method takes two arguments: an array of strings \"s\" and a string \"x\". It should perform a binary search to find the string \"x\" within the sorted array \"s\". The method should use the \"compareTo\" method of the String class, which compares two strings lexicographically.\n\nThe second part of the exercise asks us to determine the number of iterations required to search for the strings \"f\", \"r\", and \"w\" in the given array: \"{\"a\", \"b\", \"d\", \"f\", \"h\", \"n\", \"p\", \"q\", \"r\", \"v\", \"z\"} using both binary and linear search. \n", "Exercise 2\n\nThink about the differences between implementing a linear search and a binary search in a stack or queue, and in a binary search tree. How does it affect in each case the fact that the implementation of the data structure can be done with arrays or with linked lists? \n", "Recursive binary search (linear tail recursion)\n\nWe see two implementations of the binary search algorithm. The first one is a recursive implementation, and the second one is an iterative implementation. Both implementations take as input an integer array \"a\" and an integer \"x\". The goal is to find the index of \"x\" in the array \"a\". If \"x\" is not found, both functions return -1.\n\nThe recursive implementation uses a helper function that takes as input the array \"a\", the first index, the last index, and the integer \"x\". The helper function first checks if the first index is less than or equal to the last index. If not, it returns -1. Otherwise, it calculates the middle index. If the middle element is equal to \"x\", it returns the middle index. If the middle element is less than \"x\", it recursively calls the helper function with the first index set to the middle index plus 1. If the middle element is greater than \"x\", it recursively calls the helper function with the last index set to the middle index minus 1.\n\nThe iterative implementation uses a while loop that continues as long as the first index is less than or equal to the last index. Inside the loop, it calculates the middle index. If the middle element is equal to \"x\", it returns the middle index. If the middle element is less than \"x\", it sets the first index to the middle index plus 1. If the middle element is greater than \"x\", it sets the last index to the middle index minus 1. If the loop finishes without finding \"x\", it returns -1.\n", "Exercise 3\n\nImplement the method \"public static int binarySearchString(String() s, String x)\", which does a binary search of element x in the array of String s recursively. Use the method \"compareTo()\" of class String, which compares two strings lexicographically. \n", "Conclusions\n\n- For smaller sizes, for example, N smaller than 6, it is not worthy using binary search since it uses approximately the same number of comparisons as a linear search.\n- Last iterations in a binary search are slower.\n- A hybrid approach could be interesting: we apply binary search until the range is small, then we apply linear search. \n", "Basic sorting algorithms\n\n- Why are they important?\n- Bubble Sort\n- Selection Sort\n- Insertion Sort \n", "Why are the important?\n\n- Binary search takes advantage of the order\n- Sorted data structures makes searching easier (e.g., telephone book, dictionary...)\n- Order facilitates searching \n", "Bubble Sort\n\nThe algorithm moves forward through the data structure swapping pairs of contiguous elements which are not in the correct order. If we sort from the lowest to the highest, the highest element moves to the end, as it was a bubble. These passes are repeated until no more swapping is needed. Elements which advanced to their correct position do not need to be checked again. Each pass needs to check one less element. \nThere are two URLs at the bottom of the slide. The first one is: http://www.cs.armstrong.edu/liang/animation/web/BubbleSort.html and the second one is: http://www.algostructure.com/sorting/bubblesort.php. \n", "Bubble Sort. Example (I)\n\nWe are looking at an example of a bubble sort algorithm, with the goal of sorting numbers in ascending order, from the lowest to the highest.\n\nThe algorithm uses two loops: an internal loop and an external loop.\n\nThe first part of the process shows the first iteration of the external loop, where the internal loop goes from 0 to length-1, which is 6 in this example.\nThe algorithm works by swapping elements if the element in position J is higher than the element in position J+1.\nThis iteration ends with 1 element in its correct position: the highest number, 98, is now at the very end of the list.\n\nThe image then shows the second iteration of the external loop, where the internal loop goes from 0 to length-2, which is 5 in this example.\nAgain, elements are swapped if the element in position J is higher than the element in position J+1.\nThis iteration ends with 2 elements in their correct positions: 95 and 98.\n\nThe values in the list are: 80, 95, 14, 98, 29, 49, and 66.\nEach line shows the state of the list as the algorithm iterates through it, with arrows indicating which numbers are being compared and swapped.\nThe final state of the list after these two iterations is: 14, 80, 29, 49, 66, 95, 98.\n", "Bubble Sort. Example (II)\n\nThe image shows an example of a bubble sort algorithm in ascending order, from the lowest to the highest value. The initial array is: 14, 80, 29, 49, 66, 95, 98.\n\nThe algorithm iterates through the array multiple times. In each iteration, it compares adjacent elements and swaps them if they are in the wrong order. The largest element in the unsorted part of the array \"bubbles\" up to its correct position at the end of each iteration.\n\nThe image shows seven steps of the algorithm, each step representing an iteration. The numbers being compared are highlighted with a blue arrow. The numbers already in their correct position are shown in red.\n\nThe first iteration compares and swaps the first two elements (14 and 80), then the second and third (80 and 29), and so on. After the first iteration, the largest number, 98, is in its correct position at the end of the array.\n\nThe algorithm continues iterating, and with each iteration, one more element reaches its correct position. The internal loop iterates from 0 to length-n, where n is the iteration number. For example, in the third iteration, the internal loop iterates from 0 to length-3, which is 4 in this example.\n\nThe image also shows that after three iterations, three elements (80, 95, and 98) are in their correct positions. After six iterations, all the elements are in their correct positions, and the array is sorted.\n", "Bubble Sort. Two loops\n\nThe image describes the Bubble Sort algorithm, which uses two loops. \n\nThe external loop iterates length of array - 1 times. In each iteration, one element is sorted, except for the last one in which two elements are sorted. The range of the index in the external loop is from 0 to length of array - 1.\n\nThe internal loop iterates a different number of times depending on the iteration of the external loop. In the first iteration of the external loop, the internal loop iterates length of array - 1 times. In the second iteration of the external loop, the internal loop iterates length of array - 2 times. In the m-th iteration of the external loop, the internal loop iterates length of array - i - 1 times. The range of the index in the internal loop is from 0 to length of array - 1 - i.\n\nAfter the m-th iteration of the external loop, the elements from index 0 to length of array - 2 - i are unsorted, and the elements from length of array - 1 - i to length of array - 1 are sorted.\n", "Bubble Sort. Code\n\nThe image shows code for a bubble sort algorithm in Java. The first function is called \"bubble sort\" and takes an integer array as input. It has two for loops. The outer loop iterates from 0 to the length of the array minus 1. The inner loop iterates from 0 to the length of the array minus 1 minus the outer loop index. Inside the inner loop, there is an if statement that checks if the element at index j is greater than the element at index j plus 1. If it is, the swap function is called with the array, j, and j plus 1 as parameters. \n\nThe second function is called \"swap\" and takes an integer array and two integers, i and j, as input. It swaps the elements at indices i and j in the array. It first assigns the value at index i to a variable called aux, then assigns the value at index j to index i, and finally assigns the value of aux to index j.\n\nThere is also a red text note that provides an alternative implementation of the algorithm. The alternative implementation uses an external loop from 1 to the length of the array and an internal loop from 0 to the length of the array minus i. It also sorts the array in descending order by checking if the element at index j is less than the element at index j plus 1. \n", "Bubble Sort. Conclusions\n\nThe image shows a slide titled \"Bubble Sort. Conclusions\" that lists the advantages and drawbacks of the bubble sort algorithm.\n\nAdvantages:\n- Little additional memory is needed\n- Few lines of code\n- Efficient for arrays with few elements\n\nDrawbacks:\n- Inefficient for arrays with many elements\n  - O(n\u00b2) => quadratic order (two nested loops for an array of n elements)\n  - For a given array there are always the same number of iterations (even though it is already sorted), even though there are no swaps\n  - Too many swaps\n- Larger elements move faster to the end (they can reach the end in one iteration of the external loop), but lower elements move slower to the beginning (they gain one position per iteration)\n  - Improvement: Cocktail sort (double internal loop to pass from left to right and from right to left in each iteration of the external loop)\n", "Exercise 4\n\nWe are asked to calculate how many swaps are needed to sort an array from highest to lowest using the bubble sort algorithm. The array is 1, 3, 5, 7, 11, 13. \n", "Selection Sort\n\nThe image describes the selection sort algorithm. \n\nIt can be implemented in ascending or descending order.\n\nIn ascending order, the algorithm searches for the minimum element and puts it in the first position by swapping it with the element currently in that position. Then it searches for the next minimum element and puts it in the second position, also by swapping. In general, the algorithm searches for the minimum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping.\n\nIn descending order, the algorithm searches for the maximum element and puts it in the first position by swapping it with the element currently in that position. Then it searches for the next maximum element and puts it in the second position, also by swapping. In general, the algorithm searches for the maximum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping.\n", "Selection Sort. Example (I)\n\nThe image describes the ascending selection sort algorithm. The algorithm uses two loops: an external loop and an internal loop. The external loop sorts the first position of the data structure. As part of this loop, there is a swapping between the element in position i and the minimum unsorted element. The internal loop searches the minimum element from position i until the end of the data structure.\n\nThe image shows an example of the algorithm with the following data structure: 80, 95, 14, 98, 29, 49, 66. The algorithm starts by finding the minimum element in the data structure, which is 14. The element 14 is then swapped with the element in the first position, which is 80. The data structure is now: 14, 95, 80, 98, 29, 49, 66. The algorithm then finds the minimum element in the remaining unsorted part of the data structure, which is 29. The element 29 is then swapped with the element in the second position, which is 95. The data structure is now: 14, 29, 80, 98, 95, 49, 66. The algorithm continues in this way until the entire data structure is sorted.\n", "Selection Sort. Example (II)\n\nThe image describes the ascending selection sort algorithm with an example. The input is a list of the following numbers: 14, 29, 49, 98, 95, 80, 66.\n\nThe algorithm iterates over the list, and for each iteration, it identifies the minimum element in the unsorted sublist and swaps it with the element at the current position.\n\nThe first iteration starts by considering the whole list as unsorted. The minimum element is 66, which is in the 7th position. The algorithm swaps the element in the first position (14) with the element in the 7th position (66). The list becomes: 66, 29, 49, 98, 95, 80, 14.\n\nThe second iteration starts considering the sublist from the second position. The minimum element is 80, which is in the 6th position. The algorithm swaps the element in the second position (29) with the element in the 6th position (80). The list becomes: 66, 80, 49, 98, 95, 29, 14.\n\nThe third iteration starts considering the sublist from the third position. The minimum element is 80, which is in the second position. Since the minimum element is already in the correct position, no swap is performed. The list remains: 66, 80, 49, 98, 95, 29, 14.\n\nThe fourth iteration starts considering the sublist from the fourth position. The minimum element is 14, which is in the 7th position. The algorithm swaps the element in the fourth position (98) with the element in the 7th position (14). The list becomes: 66, 80, 49, 14, 95, 29, 98.\n\nThe fifth iteration starts considering the sublist from the fifth position. The minimum element is 29, which is in the 6th position. The algorithm swaps the element in the fifth position (95) with the element in the 6th position (29). The list becomes: 66, 80, 49, 14, 29, 95, 98.\n\nThe sixth iteration starts considering the sublist from the sixth position. The minimum element is 95, which is in the sixth position. Since the minimum element is already in the correct position, no swap is performed. The list remains: 66, 80, 49, 14, 29, 95, 98.\n\nThe seventh iteration starts considering the sublist from the seventh position. The minimum element is 98, which is in the seventh position. Since the minimum element is already in the correct position, no swap is performed. The list remains: 66, 80, 49, 14, 29, 95, 98.\n\nThe final sorted list is: 14, 29, 49, 66, 80, 95, 98.\n", "Selection Sort. Two loops\n\nWe are going to see how the selection sort algorithm works. This algorithm uses two loops. The external loop iterates over the array, and in each iteration, one element is sorted. The number of iterations is equal to the length of the array, although the last iteration is not strictly needed. The range of the index in the external loop goes from zero to the length of the array minus one. The internal loop searches for the minimum or maximum value in the array. In the first iteration of the external loop, the internal loop iterates from zero to the length of the array minus one. In the second iteration of the external loop, the internal loop iterates from one to the length of the array minus two, and so on. In the m-th iteration of the external loop, the internal loop iterates from m minus one to the length of the array minus m. The range of the index in the internal loop goes from i, the index of the external loop, to the length of the array minus one. After the m-th iteration of the external loop, the elements from zero to i are sorted, and the elements from i plus one to the length of the array minus one are unsorted. \n", "Selection Sort. Code\n\nWe see the code for a selection sort algorithm in Java. The first function *selectionSort* takes an integer array as input. It iterates through the array with two nested for loops. The outer loop iterates through each element of the array, while the inner loop iterates through the remaining unsorted subarray to find the minimum element. The index of the minimum element is stored in the variable *m*. After the inner loop completes, the function swaps the element at index *i* with the element at index *m*. \n\nThe second function *swap* takes an integer array and two integer indices as input. It swaps the elements at the given indices using an auxiliary variable *aux*.\n\nThere are some alternative implementations for this algorithm listed on the slide. The external loop could iterate up to the second to last element of the array. The internal loop could iterate from *j+1* to the end of the array, which would save one unnecessary comparison. The algorithm could be modified to sort in descending order by changing the comparison in the if statement to *a[j] > a[m]*. Finally, unnecessary swaps could be avoided by adding a condition to the swap function to only swap if *i* is not equal to *m*. \n", "Selection Sort. Conclusions\n\nThis slide describes the advantages, drawbacks and variants of the Selection Sort algorithm. \n\nThe advantages are:\n- Little additional memory is needed\n- Few lines of code\n- Efficient for arrays with few elements\n\nThe drawbacks are:\n- Inefficient for arrays with many elements\n- O(n^2) which means it's quadratic order because it uses two nested loops for an array of n elements\n- For a given array there are always the same number of iterations, even though it is already sorted and even though there are no swaps\n- However, there are much less swaps than with Bubble Sort\n\nVariant:\n- Placing the maximum or minimum at the end, instead of placing the maximum or minimum at the beginning\n", "Exercise 5\n\nWe are asked to calculate how many swaps are needed to sort the array {1, 3, 5, 7, 11, 13} from highest to lowest element using the Selection Sort algorithm. The algorithm should swap the maximum with the first unsorted element. \n", "Insertion Sort\n\nThe data structure is divided into two parts: the first part is already sorted and the second part is unsorted. At the beginning, the first part is empty and the second part is full. We extract the first element of the second part, inserting it in its correct position in the first part. This step is repeated until all the elements are sorted in the first part.\n\nThe first diagram shows the sorted partial result on the left, with elements less than x, then elements greater than x. The first element of the unsorted data, x, is about to be inserted into the sorted partial result. The second diagram shows the result after the insertion. The element x has been inserted into the correct position in the sorted partial result.\n", "Insertion Sort. Example (I)\n\nThe image describes the Insertion Sort algorithm with an example.\n\nThe algorithm sorts an array of numbers in ascending order, from the lowest to the highest.\n\nThe example shows the different steps of the algorithm, starting with the unsorted array: 80 95 14 98 29 49 66\n\nThe algorithm uses two loops: an external loop and an internal loop.\n\nThe external loop traverses the array, leaving sorted what is behind position i. As part of the external loop, the element to be sorted is moved to its right position.\n\nThe internal loop moves one position to the right all the elements that are located between where the new sorted element is inserted and the position it left in the unsorted part of the array (now that position is sorted).\n\nThe example shows how the algorithm works by moving the elements of the array to their correct position in each step. \n\nFor example, in the first step, the algorithm takes the element 80 from the unsorted part and inserts it in its correct position in the sorted part. \n\nIn the second step, the algorithm takes the element 95 from the unsorted part and inserts it in its correct position in the sorted part. \n\nThe algorithm continues in this way until the entire array is sorted.\n", "Insertion Sort. Example (II)\n\nThe image illustrates the insertion sort algorithm, specifically focusing on arranging numbers in ascending order. \n\nInitially, we have the sequence: 14, 80, 95, 98, 29, 49, and 66. The algorithm proceeds by progressively building a sorted sub-sequence on the left.\n\nFirst, the number 98 is selected. Since it's already in its correct position relative to the preceding element (95), no changes are made.\n\nNext, the number 29 is considered. To place it correctly, 80, 95, and 98 are shifted one position to the right, creating space for 29 to occupy the second position in the sequence. This results in the updated sequence: 14, 29, 80, 95, 98, 49, and 66. \n", "Insertion Sort. Example (III)\n\nWe are looking at an example of insertion sort in ascending order, from the lowest to the highest number.\n\nThe first step shows the numbers 14, 29, 80, 95, 98, 49 and 66. The algorithm takes the number 49 from the unsorted part and inserts it in its correct position in the sorted part. Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49. The resulting sequence is 14, 29, 49, 80, 95, 98 and 66.\n\nThe second step takes the number 66 from the unsorted part and inserts it in its correct position in the sorted part. Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 66. The resulting sequence is 14, 29, 49, 66, 80, 95 and 98. \n", "Insertion Sort. Two loops\n\nThe slide describes the two loops used in insertion sort. The external loop iterates over the array, with the number of iterations equal to the length of the array. In each iteration, one element is sorted, including the last iteration. The range of the index in the external loop is from 0 to the length of the array minus 1. The internal loop finds the correct position to insert the element. The number of iterations in the internal loop depends on the position \"advanced\" by the element which is inserted. If the element inserted moves k positions to the left, then there are k elements that are moved one position to the right. After the m-th iteration (i=m-1) of the external loop, the elements from 0 to i are sorted and the elements from i+1 to the length of the array minus 1 are unsorted. \n", "Insertion Sort. Code\n\nThe image shows a code snippet for the Insertion Sort algorithm in Java. \n\nThe code defines a public static method called \"insertionSort\" that takes an integer array \"a\" as input. \n\nThe algorithm iterates through the array \"a\" from the second element (index 1) to the last element. For each element at index \"i\", it stores the value in a temporary variable \"tmp\" and initializes an index \"j\" to \"i\". \n\nThen, it enters a while loop that continues as long as \"j\" is greater than 0 and the value of \"tmp\" is less than the element at index \"j-1\". Inside the loop, it shifts the element at index \"j-1\" one position to the right (to index \"j\") and decrements \"j\" by 1. This process creates a space for the element at \"tmp\" to be inserted in its correct sorted position. \n\nOnce the while loop terminates, the element at \"tmp\" is inserted at index \"j\". \n\nThe code also provides an alternative implementation in a note. The note suggests that the external loop can start from index 1 instead of 0 because the first element is always in its correct sorted position. It also mentions that the code can be modified to sort the array in descending order by changing the comparison in the while loop from \"tmp < a[j-1]\" to \"tmp > a[j-1]\".\n", "Insertion Sort. Code with auxiliary method\n\nThe image shows two code snippets of a Java implementation of the insertion sort algorithm using an auxiliary method. The first snippet shows the method signature of the main sorting function called \"insertionSort\". This method takes an integer array as input. Inside the method, there is a for loop that iterates over the input array and calls the auxiliary method \"insert\" for each element. The second snippet shows the method signature of the \"insert\" method. This method takes as input an integer array and an integer. The integer represents the index of the element to be inserted in its correct position. The \"insert\" method iterates over the array from the given index down to the first element, shifting the elements to the right until it finds the correct position for the element to be inserted. Finally, the element is inserted in its correct position. There is also a comment explaining that the \"insert\" method inserts the element at the given position in the array, moving the needed elements one position to the right. \n", "Insertion Sort. Conclusions\n\nThe image shows a slide titled \"Insertion Sort. Conclusions\" about the advantages and disadvantages of using insertion sort.\n\nAdvantages:\n- Little additional memory is needed\n- Few lines of code\n- Efficient for arrays with few elements\n- More efficient than Selection Sort for partially sorted arrays because for a given array there are always the same number of iterations in the external loop, even though it is already sorted, but the internal loop is adaptable.\n\nDrawbacks:\n- Inefficient for arrays with many elements because its time complexity is O(n^2), which means it has a quadratic order with two nested loops for an array of n elements.\n- Inefficient when the array to sort is in reverse sorted order. \n", "Exercise 6\n\nWe are asked to determine how many swaps are needed to sort the array {1, 3, 5, 7, 11, 13} from highest to lowest using the Insertion Sort algorithm.\n\nThe second question asks us to compare the efficiency of the three sorting algorithms we have seen so far using this array and other arrays with different values and lengths. \n", "Advanced sorting algorithms\n\n- Heap Sort\n- Merge Sort\n- Quick Sort \n", "Heap Sort\n\nHeap sort is an improved version of selection sort. It has two steps. The first step is to build a heap. A heap is a binary tree that is complete, meaning that all levels of the tree are filled except for possibly the last level, which is filled from left to right. The key of the parent node is always higher than the keys of its children. The parent node has index i, the left child has index 2*i+1, and the right child has index 2*i+2. The second step is to repeatedly remove the highest element of the heap, which is always the root, and insert it at the end of the array. The heap must be updated after the removal of the root to maintain the heap property. \n", "Heap Sort. Example (I)\n\nThe image shows an example of a heap sort algorithm. The goal is to sort the following numbers in ascending order: 80, 95, 14, 98, 29, 49, 66. The first step is to build a max-heap from the array. The root of the heap is at position 0, which is 80 in this case. The left child of the root is at position 1, which is 95, and the right child is at position 2, which is 14. The left child of 95 is at position 3, which is 98, and the right child is at position 4, which is 29. The left child of 14 is at position 5, which is 49, and the right child is at position 6, which is 66. \nThe heap is represented as a binary tree, with the root at the top. The numbers are shown inside circles, and the lines connecting the circles represent the parent-child relationships. The arrows indicate the direction of the sorting process. \nThe algorithm starts by comparing the root node with its children. If the root node is smaller than any of its children, it is swapped with the larger child. This process is repeated until the root node is larger than both of its children. The algorithm then moves to the next node in the array and repeats the process. This continues until the entire array is sorted. \nIn this example, the first step is to compare 80 with its children, 95 and 14. Since 95 is larger than 80, they are swapped. The algorithm then moves to the next node, which is 95. 95 is compared with its children, 98 and 29. Since 98 is larger than 95, they are swapped. The algorithm then moves to the next node, which is 98. 98 is compared with its children, but since it is already the largest element in the array, no swaps are made. The algorithm continues in this manner until the entire array is sorted. \n", "Heap Sort. Example (II)\n\nThe image describes the first step of ordering a heap, where the root needs to be higher than the children.\nStarting from the penultimate row to the right, we need to check if the children are higher than the parent.\nThe nodes will go down to their corresponding position.\nThere is a visual representation of a binary tree with the values 80, 95, 14, 98, 29, 49 and 66.\nThe values are being swapped until the highest value, 98, becomes the root.\nThe values are also represented in an array in the following order: 98, 95, 66, 80, 29, 49, 14.\nThe swaps are visually indicated by arrows. The first swap is between 66 and 14, the second swap is between 98 and 95, the third swap is between 98 and 80 and the last swap is between 95 and 80.\n", "Heap Sort. Example (III)\n\nThe slide describes the second step of extracting the root and reordering the heap in a heap sort example. The first action is taking the root node with value 98 and placing it at the end of the array, which is the sorted section. The second action is replacing the root node with the highest element of the array, which is 95, and reordering the heap. Two diagrams illustrate the heap before and after the second step. The first diagram shows a binary tree representation of the heap before the second step. The root node is 14, and its children are 95 and 66. The left and right children of 95 are 80 and 29, respectively. The left and right children of 66 are 49 and 98, respectively. The second diagram shows the binary tree representation of the heap after the second step. The root node is 95, and its children are 80 and 66. The left and right children of 80 are 14 and 29, respectively. The left and right children of 66 are 49 and 98, respectively. The array representation of the heap is shown above each diagram. The last element of each array, 98, is marked in red, indicating that it is already sorted.", "Heap Sort. Example (IV)\n\nThe image illustrates step 2 of a heap sort algorithm, which involves extracting the root and reordering the heap.\n\nThe first point explains that we will take the value 95 and place it at the end of the array, which is considered the sorted portion. The root of the heap then becomes 49.\n\nThe second point explains that we will replace 49 with the highest element in the array, which is 80, and then reorder the heap.\n\nTwo diagrams illustrate this process. Both diagrams represent the heap as a binary tree, with the root at the top. The left diagram shows the heap before the operation, and the right diagram shows the heap after the operation.\n\nIn the left diagram, the root node is 95, and its children are 49 and 66. The left child of 49 is 80, and the right child of 49 is 29. The left child of 66 is 14, and the right child of 66 is 98.\n\nThe first step is to extract the root node, which is 95. This is indicated by a red line separating 95 from the rest of the array: 49 80 66 14 29 | 95 98.\n\nThe second step is to replace the root node with the highest element in the array, which is 80. This is indicated by a black arrow pointing from 80 to the root position.\n\nThe third step is to reorder the heap. This is done by comparing the new root node, 80, with its children, 49 and 66. Since 80 is greater than both of its children, the heap is already in order.\n\nThe right diagram shows the final state of the heap after step 2. The root node is now 80, and its children are 49 and 66. The left child of 49 is 14, and the right child of 49 is 29. The right child of 66 is 98.\n\nThe numbers 1 and 2 below the diagrams indicate the order in which the two heaps are shown. \n", "Heap Sort. Example (V)\n\nThe image describes step 2 of extracting the root and reordering the heap in a heap sort example. \n\nWe start with an array with the following values: 29, 49, 66, 14, 80, 95, 98. The array is visualized as a binary tree. The root of the tree has the value 29, its left child has the value 49 and its right child has the value 66. The left and right children of 49 have the values 14 and 80 respectively. The left and right children of 66 have the values 95 and 98 respectively.\n\nThe first step is to take the root of the tree, which has the value 80, and place it at the end of the array. The array now has the following values: 29, 49, 66, 14, 80, 95, 80. The root of the tree now has the value 29.\n\nThe second step is to replace the root of the tree with the highest element of the array, which is 66. The array now has the following values: 66, 49, 29, 14, 80, 95, 80. The root of the tree now has the value 66. The left child of the root is 49 and the right child is 29. The left and right children of 49 are 14 and 80 respectively. The left and right children of 29 are 95 and 80 respectively. \n", "Heap Sort. Example (VI)\n\nThe image illustrates step 2 of a heap sort algorithm, extracting the root and reordering the heap. The process involves two steps: first, taking the root node with value 66 and placing it at the end of the array, which is the sorted portion. The root node now becomes 14. Second, replacing 14 with the highest element of the array, which is 49, and reordering the heap. The image shows two trees representing the heap before and after the reordering. The first tree has 14 as the root, with 49 as its left child and 29 as its right child. The second tree has 49 as the root, with 14 as its left child and 29 as its right child. The array representation of the heap is shown above each tree, with a vertical red line separating the sorted portion from the unsorted portion. The sorted portion is on the right side of the red line. The numbers in the array are the same as the values in the corresponding nodes of the tree. The number 1 is below the left tree and the number 2 is below the right tree, indicating the step number. \n", "Heap Sort. Example (VII)\n\nThe image illustrates step 2 of the heap sort algorithm, extracting the root and reordering the heap. The process involves three sub-steps:\n\n1. **Taking 49 and placing it at the end (sorted). The root becomes 29.** This is depicted in the first array: 29 14 49 66 80 95 98. The number 49 is highlighted in red, indicating its removal from the heap and placement at the end of the array. The root node now contains the value 29, shown in a red circle with an arrow pointing to the new root, 14.\n\n2. **Taking 29 and placing it at the end (sorted). The root becomes 14.** The second array shows this step: 14 29 49 66 80 95 98. Similar to the previous step, 29 is highlighted in red, signifying its move to the sorted section. The root now holds the value 14, displayed in a red circle.\n\n3. **Taking 14. The heap is empty.** The final array illustrates the last step: 14 29 49 66 80 95 98. The number 14 is highlighted, indicating its removal, leaving an empty heap. \n", "Heap Sort. Two external loops\n\nThe image describes the Heap Sort algorithm, which uses two external loops.\n\nThe first loop builds the heap. For each node, the algorithm checks that the children are smaller than the parent node. This loop iterates over half the length of the array, traversing all the nodes except for the leaves, which do not have children. The range of the index of this external loop is from 0 to (length of the array - 2) / 2.\n\nThe second loop extracts the root and reorders the heap. The root is extracted and placed at the end of the data structure, and the heap is reordered. This loop iterates over the length of the array. The range of the index of this external loop is from 0 to length of the array - 1.\n\nAfter m-th iteration (i=m-1) of the external loop 2:\n- Elements from 0 to length of array - 2 - i are unsorted.\n- Elements from length of array - 1 - i to length of array - 1 are sorted.\n", "Heap Sort. Code\n\nThe image shows a code snippet for the Heap Sort algorithm in an unknown programming language. \n\nThe first function `heapSort` takes an integer array `a` as input. It first builds a max heap from the input array by calling the `heapify` function repeatedly on the first half of the array. Then, it iterates through the array from the last element to the second element, swapping the first element (the maximum element) with the current element, and then calling `heapify` on the remaining heap (excluding the last element, which is now in its sorted position).\n\nThe second function `swap` takes an integer array `a` and two integer indices `i` and `j` as input. It swaps the elements at indices `i` and `j` in the array using an auxiliary variable `aux`.\n", "Heap Sort. Code (II)\n\nThe image shows a code snippet of a private static void heapify function written in Java. The function takes as input an integer array a, an integer i and an integer m. The function iterates over the array a from index i to m. For each index i, the function checks if the value at index i is smaller than the value at index j, where j is the index of the child with the highest value. If the value at index i is smaller than the value at index j, the function swaps the values at indices i and j. The function then sets i to j and continues iterating. If the value at index i is not smaller than the value at index j, the function sets i to m and exits the loop. \nThe comments on the right side of the code snippet explain the meaning of the variables i, m and j. The variable i is the index of the parent, m is the index of the last unsorted node of the heap and j is the index of the left child. The comments also explain that the code snippet is getting the index of the child with the highest value and that if the child's value is higher than that of the parent, then we need to swap and then check again with its new children. Otherwise, we are done. \n", "Heap Sort. Conclusions\n\nWe can see the advantages and drawbacks of using heap sort.\nHeap sort is efficient for arrays with many elements, even in the worst case, with O(n log n) complexity.\nAlso, little additional memory is needed.\nOn the other hand, heap sort has a complex code. \n", "Exercise 7\n\nWe are asked to calculate how many swaps are needed to sort an array using the Heap Sort algorithm. The array to be sorted is 7, 3, 13, 1, 11, 5. The sorting should result in ascending order. \n", "Merge Sort\n\nThe image describes the Merge Sort algorithm.\n\nThe algorithm consists of 3 steps:\n1. Divide the array in two subarrays of approximately the same length (half the original array)\n2. Divide each subarray recursively until we have subarrays of length 1, in which case that array is returned\n3. Merge the two subarrays in a new sorted subarray recursively\n\nThe diagram shows an example of the algorithm with an array of 10 numbers: 38, 27, 43, 3, 9, 82, 10.\nThe first step is to divide the array in two subarrays of 5 numbers each: 38, 27, 43, 3, 9 and 82, 10.\nThe second step is to divide each subarray recursively until we have subarrays of length 1.\nThe third step is to merge the two subarrays in a new sorted subarray recursively.\nThe final sorted array is: 3, 9, 10, 27, 38, 43, 82.\n", "Merge Sort. Example (I)\n\nThis example shows the steps to sort the following list of numbers in ascending order using the Merge Sort algorithm: 80, 95, 14, 98, 29, 49, 66.\n\nThe algorithm recursively divides the list into sub-lists until each sub-list contains a single element. Then, it repeatedly merges the sub-lists to produce new sorted sub-lists until there is only one sorted list remaining.\n\nThe steps are illustrated in a tree diagram where each node represents a sub-list and the arrows indicate the merging process. \n", "Merge Sort. Example (II)\n\nThe image shows a diagram illustrating the merge sort algorithm. The input is a list of numbers: 80, 95, 14, 98, 29, 49, 66. \n\nThe diagram depicts the steps of the merge sort algorithm. First, the list is divided into sub-lists until each sub-list contains only one element. Then, the sub-lists are merged pairwise, sorting the elements during the merge operation. This process is repeated recursively until the entire list is sorted. \n\nThe diagram visually represents the merging process with arrows connecting the sub-lists being merged. The final sorted list is: 14, 29, 49, 66, 80, 95, 98. \n", "Merge Sort. Recursive division and merging with auxiliary array\n\nThe image describes the Merge Sort algorithm.\n\nThe first step of the algorithm is the recursive division: Given an array, or part of it, with *l* as the first position, *r* as the last position, and *m* as the half position calculated as *(l+r)/2*, divide the array recursively in two until *l* and *r* are equal. The two parts are from *l* to *m* and from *m+1* to *r*.\n\nThe second step is sorting by merging subarrays: Create an auxiliary array containing the two subarrays to sort, then compare the elements to sort each subarray.\n\nFinally, it is important to note that elements are not in their final correct position until we finish merging subarrays. \n", "Merge Sort. Code (I)\n\nWe see two code snippets. The first one is a function definition for merge sort that takes an integer array a as an argument. It calls the mSort function with the array, 0, and the length of the array minus 1. The second snippet is a function definition for mSort that takes an integer array a, an integer l, and an integer r as arguments. It checks if l is greater than or equal to r. If so, it returns. Otherwise, it calculates an integer m as the average of l and r. It then calls mSort with the array, l, and m, and then calls mSort again with the array, m plus 1, and r. Finally, it calls the merge function with the array, l, m, and r. \n", "Merge Sort. Code (II). Merging (Option 1)\n\nThe image shows a code snippet for the merge function used in the merge sort algorithm. This particular implementation uses Option 1 for merging. \n\nThe code first checks if the starting index of the second sub-array (m+1) is greater than the ending index of the second sub-array (r). If it is, the function returns, as this indicates that the sub-arrays are already sorted.\n\nIf not, a new array 'b' is created with the same size as the input array 'a'. The first loop iterates through the left sub-array (from index 'l' to 'm') and copies its elements to the auxiliary array 'b'.\n\nThe second loop iterates through the right sub-array (from index 'm+1' to 'r') in reverse order and copies its elements to the auxiliary array 'b'. This reverse order copying is specific to Option 1.\n\nTwo index variables, 'k' and 'j', are initialized to point to the beginning and end of the auxiliary array 'b' respectively. The final loop iterates through the merged array 'a' and compares the elements at indices 'k' and 'j' in the auxiliary array 'b'. The smaller element is copied to the merged array 'a', and the corresponding index ('k' or 'j') is incremented or decremented accordingly.\n\nThis process continues until all elements from both sub-arrays are placed in the merged array 'a' in sorted order. The three bullet points on the right side of the image provide a textual description of the code's functionality. They explain that the left sub-array is copied as is, the right sub-array is copied in reverse order, and the merging process starts from the two ends of the auxiliary array, comparing and placing the smallest elements first. \n", "Merge Sort. Code (III). Merging (Option 2)\n\nThis slide shows the code for the merging step of the merge sort algorithm, specifically option 2. \n\nThe code is a function called \"merge\" that takes as input an array of integers \"a\", and three integers: \"l\", \"m\", and \"r\". The function first checks if m+1 is greater than r. If it is, the function returns. Otherwise, it creates a new array of integers \"b\" with the same length as \"a\". It then copies the elements of \"a\" from index 1 to index r to \"b\".\n\nThe function then initializes three integer variables: \"k\" to 1, \"j\" to m+1, and \"i\" to 1. It then enters a while loop that continues as long as both k is less than m+1 and j is less than r+1. Inside the loop, it compares the element at index k of \"b\" with the element at index j of \"b\". If the element at index k is less than or equal to the element at index j, the element at index i of \"a\" is set to the element at index k of \"b\", k is incremented, and i is incremented. Otherwise, the element at index i of \"a\" is set to the element at index j of \"b\", j is incremented, and i is incremented.\n\nAfter the while loop, the function enters another while loop that continues as long as k is less than m+1. Inside the loop, the element at index i of \"a\" is set to the element at index k of \"b\", k is incremented, and i is incremented.\n\nAfter the second while loop, the function enters a third while loop that continues as long as j is less than r+1. Inside the loop, the element at index i of \"a\" is set to the element at index j of \"b\", j is incremented, and i is incremented.\n\nOn the right side of the slide, we have a description of the code. The first bullet point states that in option 2, the two subarrays are copied as they are in the auxiliary array. The second bullet point states that the elements to merge are compared starting from the left side of each subarray. The third bullet point states that the last elements of the left subarray, which may have not been merged yet, are added. The fourth bullet point states that the last elements of the right subarray, which may have not been merged yet, are added. \n", "Merge Sort. Conclusions\n\nThere are two main advantages of using merge sort: it is efficient for arrays with many elements, even in the worst case, with a time complexity of O(n log n), and it is highly parallelizable.\n\nThe drawbacks are that it requires complex code and more memory space to store auxiliary variables, such as an auxiliary array. \n", "Exercise 8\n\nWe are asked to describe the process of sorting an array using the merge sort algorithm. The array to be sorted is 7, 3, 13, 1, 11, 5.  It is important to note that unlike other sorting algorithms, merge sort does not involve swapping elements within the array. Instead, an auxiliary array is used during the sorting process. \n", "Quick Sort\n\n- Choose an element: the pivot\n- Reorder the data structure so that \n - elements lower than the pivot are on its left\n - elements higher than the pivot are on its right\n- Sort recursively\n - the part whose elements are lower than the pivot\n - the part whose elements are higher than the pivot\n\nTwo URLs are provided as reference: http://www.algostructure.com/sorting/quicksort.php and http://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html. \n", "Quick Sort. Example (I)\n\nThe image illustrates an example of a quick sort algorithm. The goal is to sort the following numbers in ascending order: 80, 95, 14, 98, 29, 49, and 66.\n\nThe first step is to choose a pivot, which in this case is 80. The algorithm then iterates through the list, comparing each number to the pivot. If a number is greater than the pivot, it is moved to the right. If a number is less than the pivot, it is moved to the left.\n\nIn this example, the algorithm first compares 95 to 80. Since 95 is greater than 80, it is moved to the right. The algorithm then compares 14 to 80. Since 14 is less than 80, it is moved to the left. This process continues until the algorithm reaches the end of the list.\n\nAt this point, the list is divided into two sub-lists: one containing all the numbers less than the pivot (14, 29, 49, 66) and one containing all the numbers greater than the pivot (95, 98). The algorithm then recursively sorts the two sub-lists.\n\nThe final step is to swap the pivot (80) with the first element of the right sub-list (95). This results in the following sorted list: 14, 29, 49, 66, 80, 95, 98.\n", "Quick Sort. Example (II)\n\nThe figure shows four steps in a Quick Sort example. The numbers to be sorted are 80, 66, 14, 98, 29, 49, and 95. The first element, 80, is chosen as the pivot. The algorithm starts by comparing the pivot to the last element, 95. Since 98 is greater than 80, the algorithm moves to the next element. The algorithm compares the pivot to the second to last element, 49. Since 48 is less than 80, the algorithm swaps the pivot and the second to last element. The algorithm then changes the direction of comparison and continues comparing the pivot to the remaining elements. \n", "Quick Sort. Example (III)\n\nWe see two arrays of numbers. The first array is: 80, 66, 14, 49, 29, 98, 95. The second array is the same as the first, except that the numbers 29 and 80 have been swapped. There is a red arrow pointing from the 29 in the first array to the space between the 49 and the 80 in the second array. There is text that says: \"29 < 80 (after converging, place the pivot in its correct location with a swap)\". There are red lines below both arrays, with \"< 80\" below the line on the left and \"> 80\" below the line on the right. Below the arrays, there is text that says: \"Repeat recursively for the left and right partitions\". \n", "Quick Sort. Recursive partition and sorting by swapping\n\nThe image describes the Quick Sort algorithm, which uses recursive partition and sorting by swapping.\n\nStep 1: Recursive partition. Given an array, or part of it, with *l* the first position and *r* the last position, we have to run an algorithm that tells us where to do the partition. The elements on the left should be lower than the pivot, and the elements on the right should be higher than the pivot. The next partition is computed recursively.\n\nStep 2: Sorting by swapping. Moving forward from the left, and from the right, comparing with the pivot and swapping as needed. Placing the pivot in its correct location.\n\nFinally, it states that pivots are always placed in their final sorted position. \n", "Quick Sort. Code (I)\n\nThe image shows two code snippets. The first one is a function definition for \"quickSort\" which takes an integer array \"a\" as input. It calls the function \"qSort\" with the array \"a\", 0 and the length of the array minus 1 as input. \n\nThe second snippet shows the function definition of \"qSort\". It takes as input an integer array \"a\", and two integers \"l\" and \"r\". If \"l\" is greater or equal than \"r\" the function returns. Otherwise, it calls the function \"partition\" with the array \"a\", \"l\" and \"r\" as input and stores the result in the integer \"m\". Then it calls the function \"qSort\" two times, the first time with the array \"a\", \"l\" and \"m\" minus 1 as input, and the second time with the array \"a\", \"m\" plus 1 and \"r\" as input. \n", "Quick Sort. Code (II)\n\nThe image shows a code snippet for the Quick Sort algorithm in Java. The code defines two methods: `partition` and `swap`.\n\nThe `partition` method takes three arguments: an integer array `a`, and two integers `l` and `r` representing the left and right indices of the subarray to be partitioned. The method first initializes three integer variables: `i` to `l+1`, `j` to `r`, and `p` to `a[l]`. The variable `p` represents the pivot element. The method then enters a `while` loop that continues as long as `i` is less than or equal to `j`. Inside the loop, the method compares the value of `a[i]` with `p`. If `a[i]` is less than or equal to `p`, the method increments `i`. Otherwise, it compares `a[j]` with `p`. If `a[j]` is greater than `p`, the method decrements `j`. If neither of these conditions is true, the method swaps the elements at indices `i` and `j` using the `swap` method and then increments `i` and decrements `j`. After the loop completes, the method swaps the elements at indices `l` and `j` using the `swap` method and then returns the value of `j`.\n\nThe `swap` method takes three arguments: an integer array `a`, and two integers `i` and `j` representing the indices of the elements to be swapped. The method first declares an integer variable `aux` and assigns it the value of `a[i]`. The method then assigns the value of `a[j]` to `a[i]` and the value of `aux` to `a[j]`.\n\nThe code also includes two comments that explain the logic of the `partition` method. The first comment explains that the method compares the elements of the array with the pivot element `a[l]`. When the method finds an element that is higher than the pivot element on the left side of the array and an element that is lower than the pivot element on the right side of the array, it swaps these two elements. The second comment explains that before the method finishes, the pivot element must be placed in its correct location, which is done by swapping the elements at indices `l` and `j`.\n", "Quick Sort. Conclusions\n\nWe can see a list of advantages and drawbacks of the Quick Sort algorithm.\n\nAdvantages are: it is very efficient for arrays with many elements, its performance is O(n log n), although the worst case is O(n^2). It requires little additional memory and it is highly parallelizable.\n\nThe main drawback is that it requires complex code. \n", "Exercise 9\n\nUsing the sorting algorithm Quick Sort, how many swaps are needed to sort the following array from the lowest element to the highest element (ascending order)?\n\n{7, 3, 13, 1, 11, 5}\n", "Summary\n\nThere are two types of sorting algorithms: basic algorithms and advanced algorithms. Basic algorithms include bubble sort, insertion sort, and selection sort. These algorithms have an average complexity of O(n^2), which means that they are inefficient with many elements. However, they are simple to code and use little memory. Advanced algorithms include heap sort, merge sort, and quick sort. These algorithms have an average complexity of O(n log n), which means that they are efficient with many elements. However, they are more complex to code. With the exception of merge sort, they use little memory. \n"]}, {"filename": "1. Recap.pdf", "text": "Systems Programming\n\nRecap\n\nDepartment of Telematic Engineering\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero and Natividad Mart\u00ednez Madrid\n\n1\n\n\fSystems Programming\n\nFirst steps in Java\n\nDepartment of Telematic Engineering\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero and Natividad Mart\u00ednez Madrid\n\n2\n\n\fScenario I: \nInstall and configure the environment\n\n\u2022 Today is your first day at work in the programming department \nof PROTEL. Your department has to update an old application \nwith new functionality\n\n\u2022 You are provided with a laptop to work and a URL from where to \n\ndownload the code developed up to date\n\n\u2022 Objective: Be able to edit, compile execute and debug an \n\nexisting program.\n\n\u2022 Workplan: Download, install and configure the software in order \n\nto test (edit, compile, execute and debug) the application\n\n3\n\n\fDevelopment\nArchitecture\n\nStep I: Edit\nStep II: Compile\n\nEditors\n\nCompilers\n\nIDEs\n\nGrasp\n\n\u2022 Eclipse\n\u2022 Netbeans\n\u2022 J Builder\n\u2022 Visual Caf\u00e9\n\u2022 Java Workshop\n\u2022 Visual Age\n\u2022 J++\n\nNotepad\n\nEditPlus\n\nOthers\n\nJDK\n\nOthers\n\nJava\ncode\n\nfile.java\n\njavac file.java\n\nBytecode\n\nfile.class\n\n4\n\n\fExecution\nArchitecture\n\nStep III: Load\nStep IV: Verify\nStep V: Execute\n\ne\nn\ni\nh\nc\na\n\nM\n\nl\na\nu\nt\nr\ni\n\nV\na\nv\na\nJ\n\nApplets or Aplications in Bytecode format\n\nClass Loader\nBytecode Verifier\n\nJava Class Libraries\n(Java extension APIs)\n\nJava Class Libraries\n(Java Base APIs)\n\nJava Interpreter\n\nJIT (Just in Time Compiler)\n\nJava Runtime\n\nOperating System\n\nHardware\n\njava file\n\n5\n\n \n \n\fWhat can go wrong?\n\n\u2022 Compile\n\u2022 Load\n\u2022 Verify\n\u2022 Execute\n\n\u201cSyntax Error\u201d\n\u201cClass not found Exception\u201d\n\u201cSecurity Exception\u201d\n\u201cNull Pointer Exception\u201d\n\n6\n\n\fWhere do I start?\n\n\u2022 Development environment: JDK\n\nhttp://www.oracle.com/technetwork/Java/index.html\n\n\u2022 Editor: Eclipse\n\nhttp://www.eclipse.org\n\n\u2022 Documentation: Java API\n\nhttp://docs.oracle.com/Javase/8/docs/api/ \n\n7\n\n\fConfig (if needed)\n\n\u2022 Configuration:\n\n\u2013 CLASSPATH: Set of directories containing the files.class\n\nyou  want to execute (not necessary since v1.2). \nIt must contain, at least, $JAVA_HOME/lib/files.class\n\n\u2013 PATH: Directories to search for executable files\nIt must contain, at least, $JAVA_HOME/bin\n\n8\n\n\fHow to configure \nEnvironment Variables\n\nWindows 7, 8, 8.1\n\n\u2013 Start \u2013 Control panel \u2013 System and Security \u2013 system\n\u2013 System advanced configuration \u2013 Advanced options \u2013 Environment\n\nvariables\n\nLinux (Type in a terminal prompt  or modify in .bash file to make it permanent:\nPATH=$JAVA_HOME/bin:/usr/bin\nCLASSPATH=$JAVA_HOME/lib/classes.zip:.\n\nPreserving the old value of environment variables :\nPATH=$JAVA_HOME/Java/bin:$PATH\nCLASSPATH=$JAVA_HOME/lib/classes.zip:$CLASSPATH\n\n9\n\n\fSystems Programming\n\nJava Language Code Structure\n\nDepartment of Telematic Engineering\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero and Natividad Mart\u00ednez Madrid\n\n10\n\n\fScenario II: \nUnderstanding Java code \n\n\u2022 Your first meeting as a programmer will be in an hour. By this \ntime, you must have reviewed the code and you must have \nunderstood how the application works.\n\n\u2022 Objective: Be fluent in reading Java structures related with \n\nclasses, attributes and methods. Understand, at a glance, a \ncomplex Java program with several files\n\n\u2022 Work plan: \n\n\u2013 Review Java syntax (identifiers, reserved words, etc.) in order to distinguish between \n\nwords from Java language and naming for a specific application\n\n\u2013 Identify language structures related with class declaration, attribute declaration \n\n(basic and reference types) and method declaration\n\n\u2013 Draw class diagrams to represent a set of Java files in order to identify object types, \n\ntheir characteristics (attributes) and behaviors (methods)\n\n\u2013 Understand and explain the main method (if it exists) to see the order in which \n\nobjects are created, methods are called, and sentences are executed\n\n11\n\n\fCode Structure\n\nProgram\n\nMembers\n\nClasses (files.java) \n\nAttributes\n\nMethods\n\nPrimitive\nType\n\nReference \nType\n\nNormal\nMethods\n\nSpecial\nmethods\n\nObject\n\nArrays\n\nConstructor Main\n\nString\n\n12\n\n\fHow to represent classes \nand objects in Java\n\n\u2022 Class declaration\n\u2022 Attribute declaration \n\nOO\n\n(constants or variables)\n\n\u2022 Method declaration\n\u2022 Object creation\n\u2022 Identifiers\n\u2022 Reserved words\n\u2022 Primitive and reference types in Java\n\nJava\n\n13\n\n\fIdentifiers\n\n\u2022\n\nIdentifiers are used to give a name to variables, \nmethods, classes, objects, and everything that the \nprogrammer needs to identify\n\n\u2022 Starting with a letter, an underscore or a $ sign\n\u2022 Case-sensitive, no maximum length\n\n\u2022 By convention:\n\n\u2013 Names of variables, methods and objects begin with \n\nlowercase.\n\n\u2013 Class names begin with uppercase\n\u2013 If there are several words, use camelCase\n\nlikeInThisExample (avoid spaces, underscores and \nhyphens)\n\nIdentifiers cannot be reserved words\n\n14\n\n\fReserved words\n\ni nt\ni nt er f ac e\nl ong\nnat i v e\nnew\nnul l\npac k age\npr i v at e\npr ot ec t ed\n\nReserved:\nabs t r ac t\nbool ean\nbr eak\nby t e\nc as e\nc at c h\nc har\nc l as s\nc ons t   *\nc ont i nue\ndef aul t\ndo\nReserved (although not used):\nc as t\noper at or\n\ndoubl e\nel s e\nex t ends\nf i nal\nf i nal l y\nf l oat\nf or\ngot o\ni f\ni mpl ement s publ i c\nr et ur n\ni mpor t\ns hor t\ni ns t anc eOf\n\ngener i c\nr es t\n\nf ut ur e\nout er\n\ns t at i c\ns uper\ns wi t c h\ns y nc hr oni z ed\nt hi s\nt hr ow\nt hr ows\nt r ans i ent *\nt r y\nv oi d\nv ol at i l e\nwhi l e\n\ni nner\nv ar\n\n15\n\n\fComments\n\nThree types:\n\n// Implementation comment (1 line)\n\n/* Implementation block comment. \n\ncontinue \nfinish */\n\nFor classes \nand methods\n\noptional\n\nFor classes\n\nFor methods\n\n/**Documentation comment to generate javadoc\n\n@see ref to other class or method\n@version information about version number\n@author author name\n@since Date since code is available\n@param Parameters received by the method\n@return Information and data type returned by the method\n@throws Exceptions that are thrown by this method\n@deprecated The method is old and shall not be used\n\n*/\n\n16\n\n\fClass declaration\n\npublic class Car {\n\n// Attribute declaration\n//  (color, speed, etc.)\n// Method declaration\n//  (start, stop, etc.)\n\n}\n\nSyntax\n\n(modifiers) class className {\n\n// class implementation\n\n} \n\nBreaking this rule is considered in many compilers as a \nsyntax error\n\nCar.java\n\nStyle\n\n\u2022 File name = class name\n\u2022 1st letter capitalized\n\u2022 No blanks or hyphens\n\u2022 CamelCase: \ne.g. MyFirstClass\n\u2022 Indentation\n\n17\n\n\fVariable Declaration\n\npublic class Car{\n\n//Atribute declaration\n\nString color;\nint speed;\n\n//Method declaration\n// (start, stop, etc.)\n\n}\n\nSyntax\ntype name;\ntype name1, name2, name3;\ntype name = value;\n\nInitializing the variable\n\nCar.java\n\nStyle\n\u2022 Intuitive names\n\u2022 1st letter capitalized\n\u2022 No blanks\n\u2022 CamelCase:\ne.g. myVariable\n\u2022 Indentation\n\n18\n\n\fVariables\n\n\u2022 Variables are fields in which programs store \n\ninformation\n\n\u2022 \u201cTo declare a variable\u201d means to specify its \n\nname and type\n\n\u2022 We can find variables:\n\n\u2013 As members of a class: Instance and class variables \n\n(within a class)\n\n\u2013 As  local variables (within a method) \n\u2013 As parameters (within a method declaration)\n\n19\n\n\fVariables\n\n\u2022 Three types:\n\n\u2013 Instance variables \n\u2013 Class variables \n\u2013 Local variables \n\n\u2022 Variables\n\nDefault values:\nnumbers = 0\nbooleans = false\nreferences = null\n\n\u2013 can be initialized in the declaration\n\u2013 may be declared uninitialized\n\n\u2022 when have been not initialized they have a default \n\nvalue (except local variables)\n\n\u2022 Constants (variables that cannot be modified):\n\n\u2013 Use reserved word: final\n\u2013 Mandatory to initialize it in declaration\n\n20\n\n\fScope\n\n\u2022\n\n\u2022 The scope of a variable is the part of the program \nover which the variable name can be referenced\nInstance or class variables can be referenced \ninside the body of the class {} or from other classes \ndepending on the permissions set: \n\u2013 private\n\u2013 protected\n\u2013 public\n\u2013 friendly (package)\n\n\u2022 Local variables can be referenced inside a statement \nblock in braces {}, such as inside a method or inside \na while or for loops\n\n\u2022 Parameters can be referenced only inside the body \n\nof the method {}\n\n21\n\n\fData Types in Java\n\n\u2022 All variables belong to a data type\n\u2022 The data type determines:\n\n\u2013 The values that the variable can take\n\u2013 The operators  that can be used\n\n\u2022 We will study:\n\n\u2013 Primitive types\n\u2013 Reference types (objects and arrays)\n\n22\n\n\fPrimitive types\n\n4 basic primitive types\ntype\n\nliteral\n\nReal\n\nInteger\n\ndoubl e\nf l oat\nl ong\ni nt\nshor t\nbyt e\nCharacter char\nBoolean\n\nbool ean\n\nnum of bits\n64-bits \n32-bits\n64-bits\n32 bits\n16 bits\n8 bits\nUnicode (16 bits)\n1 bit\n\ndoubl e\nX\nX\nX\nX\nX\nX\nX\n\nf l oat\n\nl ong i nt shor t byt e char\n\nX\nX\nX\nX\nX\nX\n\nX\nX\nX\nX\nX\n\nX\nX\nX\nX\n\nX\nX\n\nX\n\nX\n\n23\n\n\fStrings \nDeclaration, concatenation\n\n\u2022 Sequence of characters implemented in a class \n\nnamed String (in java.lang package) \n\n\u2022 Strings creation\n\nString emptyS = new String(); \n\nString emptyS = \u201c\u201d;\n\nString message = \u201chello\u201d \n\nString messageCopy = message; \n\n\u2022 Strings concatenation\n\n\u2013 String concatenation uses the overloaded + operator\n\u201cthis\u201d + \u201cthat\u201d        // result: \u201cthisthat\u201d \n\n\u201cabc\u201d + 5\n\n// result: \u201cabc5\u201d\n\n\u201ca\u201d + \u201cb\u201d + \u201cc\u201d\n\n// result: \u201cabc\u201d\n\n\u201ca\u201d + 1 + 2\n\n1 + 2 + \u201ca\u201d\n\n// result: \u201ca12\u201d\n\n// result: \u201c3a\u201d\n\n1 + (2 + \u201ca\u201d)\n\n// result: \u201c12a\u201d\n\n24\n\n\fStrings\nComparison\n\n\u2022 You must not use relational (<, >, <=, <=) and \n\nequality (==, !=) operators with Strings\n\u2013 These operators compare the object, not the content\n\u2022 There are specific methods to compare in the \n\nString class\n\u2013 Method: equals\n\nleftSide.equals(rightSide)\n\n\u2022 true, if leftSide and rightSide are identical\n\n\u2013 Method compareTo\n\nleftSide.compareTo(rightSide)\n\n\u2022 negative int value, if leftSide is lower than rightSide\n\u2022 0, if leftSide is equal to rightSide\n\u2022 positive int value, if leftSide is higher than rightSide\n\n25\n\n\fStrings \nUseful methods of String class\n\n\u2022 Length of a String \n\u2013 Method: length()\n\u2013 Do not forget parenthesis because it is a method\n\u2022 Accessing individual characters inside a String\n\n\u2013 Method: charAt(position),   \n\u2022 The first position is 0\n\n\u2022 SubStrings\n\n\u2013 Method substring(1stPosIncluded, 1stPosExcluded)\n\n\u2022 Returns the reference to a new String\n\u2022 Parameters: 1st position included and 1st position excluded\n\nString greeting = \u201chello\u201d; \n\nint len = greeting.length();\n\nchar ch = greeting.charAt(1); \n\n// len is 5\n\n// ch is \u2018e\u2019\n\nString sub = greeting.substring(2,4); // sub is \u201cll\u201d\n\n26\n\n\fStrings\nConversion between String and primitive types\n\n\u2022 Use calls to wrapper classes in java.lang\n\n\u2013 They are called wrappers because they wrap the primitive types: \n\nInteger, Double, Float, Double, Character, \u2026\n\n\u2013 String conversion \n\n\u2022 Methods: toString(\u2026), doubleValue()\n\n\u2013 String conversion to a primitive type \n\n\u2022 Methods: parseInt(\u2026), parseFloat(\u2026)\n\n\u2013 String conversion to an object of the wrapper class\n\n\u2022 valueOf(\u2026)\n\n\u2013 Conversion from an object of the wrapper class to a primitive \n\nvalue\n\n\u2022 doubleValue(), intValue()\n\nSystem.out.println(Integer.toString(55, 2)); \n\nint x = Integer.parseInt(\u201c75\u201d);\n\nDouble y = Double.valueOf(\u201c3.14\u201d).doubleValue();\n\n27\n\n\fConstants defined by user\n\nInvariant values of basic types (primitives + String)\n\n\u2022\n\u2022 Constants use the final modifier (and sometimes the static too)\n\n\u2013 static: Indicates global or class variable. This means that it is stored only \n\nonce. Objects can access this variable using the dot notation, \nClassName.variableName\n\n\u2013 final: This modifier indicates that the value never changes.\n\u2013 Constants can be public, private or protected\n\n\u2022 Depending on the degree of accessibility the programmer prefers\n\n\u2013 Style: All the characters in  UPPERCASE\n\nclass Circle {\n\nprivate static final float PI = 3.14159;\n\nprivate float radio;\n\nprivate float area;\n\npublic Circle (float radio) {\n\narea = 2 * PI * radio;\n\n} //constructor\n\n} //class Circle \n\n28\n\n\fReference types\n\n\u2022 The value is a reference (pointer) to the \n\nvalue represented by the variable.\n\u2022 Some examples of reference types:\n\n\u2013 Arrays \n\u2013 Classes\n\u2013 Interfaces\n\n29\n\n\fAn object as an attribute \nObject declaration\n\npublic class Car{\n\n//Attribute declaration\n\nString color;\nint speed;\nEquipment standardEquipment;\n\n//method declaration\n// (start, stop, etc.)\n\n}\n\nSyntax\n\nCar.java\n\nStyle\n\u2022 Remember that classes \n(type) start with capital \nletter, while identifiers \n(objectName) use lower-\ncase\n\nClassName name;\nClassName name1, name2;\nClassName name  =  new Equipment();\n\nObject declaration\nsimilar to variable declaration, where we put \nthe type, now we put the name of the class\n\nObject creation\nVariables are initialized, \nbut Objects are created!!\n30\n\n\fObjects\nDeclaration, creation, initialization\n\n\u2022 Objects are created with the reserved word new and a \n\ncall to the constructor\n\n\u2022 Once the object is created, the reference to the object is \nreassigned to the memory location where the object is \nlocated\n\nStudent student1;\n\nstudent1 = new Student();\n\nnull\n\nstudent1\n\nstudent1\n\nStudent\n\n31\n\n\fObjects\nNull reference\n\n\u2022\n\nIt may happen that a reference to an object has no instance assigned \n\u2013 Then the special value null is used\n\n\u2022 Example:\n\nStudent student1;           // null by default\nStudent student2;\nStudent student3;\n\nstudent1 = new Student();   // value != null\nstudent2 = new Student();   // value != null\nstudent3 = null;            // value null by assignment\n\nStudent\n\nStudent\n\nstudent1\n\nstudent2\n\nnull\n\nstudent3\n\n32\n\n\fObjects\nAlias\n\n\u2022 An object can have several references, known as alias\n\nStudent delegate;\ndelegate = student1;\n\n\u2022 What would be the result of comparing the different \n\nreferences in the figure? \n\nStudent\n\nJuan\n\nstudent1\n\ndelegate\n\nnull\n\nstudent2\n\nnull\n\nstudent3\n\nstudent5\n\nStudent\n\nJuan\n\nstudent4\n\nStudent\n\nClara\n\n33\n\n\fArrays \nWhat is an array?\n\n\u2022 It is a set of elements belonging to the same \n\ndata type and stored in one place\n\n\u2022 The index [ ] operator is used to retrieve \n\nindividual elements from the array\n\n\u2022 The length (attribute) returns the number of \n\nelements in the array. \n(not be confused with the method length() of the String class)\n\n\u2022 Range of index\n\n\u2013 From 0 to length \u2013 1\n\u2013 Be careful! Don\u2019t exceed the maximum length\n\u2022 Exception: IndexOutOfBoundsException\n\n34\n\n\fAn Array as an Attribute\nArray declaration\n\npublic class Car{\n\n//Array declaration\nString equipment[] = new String [10];\n// ...\n\nSyntaxis\n\n}\n\nWays to declare an array\ntype ArrayName[];\ntype [] ArrayName;\ntype ArrayName[] = new type [arraySize];\n\nArray creation\nWhen you create an array you \nmust specify its capacity!\n\nArray creation\nVariables are initialized, \nbut Arrays (like objects) \nare created!\n\n35\n\n\fArrays \nDeclaration, Creation, Initialization\n\n\u2022 Declaration: To assign an identifier to the array and specify \n\nthe data type of the elements that will be stored\n\u2013 It can be done in two ways:\n\nType ArrayName[];\nType[] ArrayName;\n\n\u2013 No memory to store the array is allocated in the declaration. \n\nTherefore, you can not access its contents yet\n\n\u2022 Creation: it consists on allocating memory \n\nfor the array\n\u2013 You must use the reserved word new and \n\nspecify the array size\n\nDefault values:\nint, short, long  = 0\nfloat, double = 0.0\nbooleans = false\nString = null\nObject = null\n\narrayName[] = new type[arraySize];\n\n\u2013 Once the array is created, its elements have \ndefault values until the array is initialized\n\n36\n\n\fArrays \nDeclaration, Creation, Initialization\n\n\u2022 Initialization: To assign values to each of the \n\nelements of the array. It can be done in several ways:\n\u2013 Element by element\n\narrayName[0] = element0;\narrayName[1] = element1;\n...\n\n\u2013 Using a Loop\n\nfor(int i = 0; i < arrayName.length; i++){\n\narrayName[i] = element-i;\n\n}\n\n\u2013 Direct assignment\n\narrayName = {elem1, elem2, elem3, ...};\n\n37\n\n\fArrays\n\nIndex 1st element = 0\n\nIndex last element \n= length - 1\n\nc[0]\nc[1]\nc[2]\nc[3]\nc[4]\nc[5]\nc[6]\nc[7]\nc[8]\nc[9]\n\n-7\n0\n3\n8\n5\n-4\n6\n6\n1\n2\n\nArray length= 10\n\nIndex nth element = n - 1\n\nIndex : integer expression: 0 <= index <= length - 1\n\n38\n\n\fArrays\nMemory usage in array declaration\n\nint[] integers;\n\nintegers null\n\nStack memory\n\nHeap memory\n\nPoint[] points;\n\npoints null\n\nclass Point {\n\nint x;\nint y;\nPoint (int x, int y){\n\nthis.x = x;\nthis.y = y;\n\n}\n\n}\n\n39\n\n\fArrays\nMemory usage in array creation\n\nintegers = new int[3];\n\nintegers\n\nStack memory\n\nHeap memory\n\npoints = new Point[2];\n\npoints\n\nWatch out! This is \nnot a constructor \ncall\n\nlength 3\nintegers[0] 0\n\nintegers[1] 0\n\nintegers[2] 0\n\nlength 2\npoints[0] null\n\npoints[1] null\n\n40\n\n\fArrays\nMemory usage in array initialization\n\nintegers[0] = 7;\n\nintegers\n\nStack memory\n\nHeap memory\n\npoints[0] = new Point(1,2);\n\npoints\n\nlength 3\nintegers[0] 7\n\nintegers[1] 0\n\nintegers[2] 0\n\nlength 2\n\npoints[0]\n\npoints[1] null\n\nx 1\n\ny 2\n\n41\n\n\fArrays (examples) \nDeclaration, Creation, Initialization\n\nArrays with primitive types\nint a[];              //declaration\na = new int[3]  //creation\na[0]=1;            //initialization\na[1]=2;\na[2]=3;\n\nint a[] = new int[3]  //declaration, creation\na[0]=1;                   //initialization\na[1]=2;\na[2]=3;\n\nint a[] = new int[3]  // declaration, creation\nfor(int i=0; i<a.length;i++){ //initialization\n\na[i]=i+1;\n\n}\n\nint a[] = {1, 2, 3};  / /Declaration, creation, initialization\n\nArrays with objects (reference types)\nMyClass a[];      //declaration\na = new MyClass[3] //creation\na[0]=new MyClass(param1);\na[1]=new MyClass(param2);\na[2]=new MyClass(param3);\n\nMyClass a[] = new MyClass[3] \n//initialization\na[0]=new MyClass(param1);\na[1]=new MyClass(param2);\na[2]=new MyClass(param3);\n\nMyClass a[] = new MyClass[3]\n//initialization\nfor(int i=0; i<a.length;i++){ \n\na[i]=new MyClass(param-i);\n\n}\n\nMyClass[] a = {new MyClass(param1), new MyClass(param2), new myClass(param3)}; \n\n42\n\n\fArrays (common errors): \nDeclaration, Creation, Initialization\n\npublic class ArrayExamples{\n\npublic static void main(String args[]){\n\ndouble myArray[];\nSyntaxis\nSystem.out.println(myArray[0]);\n\nWRONG\n\n}\n\n}\n\nvariable myArray may not have been initialized\n\ncompile\n\nCompilation \nfailure\n\nWhen an array has been declared but not created or \ninitialized, you have no access to its elements. The program \ndoes not compile and prints an error message\n\n43\n\n\fArrays (Common errors):\nDeclaration, creation, inicialization\n\npublic class ArrayExamples2{\n\npublic static void main(String args[]){\n\nint myArrayOfIntegers[] = new int[10];\nfloat myArrayOfReals[]= new float[10];\nboolean myArrayOfBooleans[] = new boolean[10];\nchar myArrayOfCharacters[] = new char[10];\nString myArrayOfStrings[] = new String[10];\nObject myArrayOfObjects[] = new Object[10]; \nSystem.out.println(\u201cInteger by default: \" + myArrayOfIntegers[0]);\n\nSystem.out.println(\"Real by default : \" + myArrayOfReals[0]);\n\nSystem.out.println(\"Boolean by default : \" + myArrayOfBooleans[0]);\n\nSystem.out.println(\u201cCharacter by default : \" + myArrayOfCharacters[0]);\n\ncompile\n\nExecute\n\nSystem.out.println(\"String by default : \" + myArrayOfStrings[0]);\n\nSystem.out.println(\"Object by default : \" + myArrayOfObjects[0]);\n\n}\n\nWhen the array has been declared and created\n}\nbut not initialized we can retrieve its elements but \nthey have their default value\n\nInteger by default: 0\nReal by default : 0.0\nBoolean by default : false\nCharacter by default :\nString by default : null\nObject by default : null\n\n44\n\n\fN-dimensional Arrays\n\n\u2022 When we need more than one index to \n\nretrieve the elements of an array\n\n0\n\n1\n\n2\n\n2\n1\n0\nA B C\nD E F\nG H I\na[0][2]=\u2018C\u2019\n\n0\nr\n\n2\n\n1\n\nj\n\na\n\nk\n\nb\n\ns\n\n1\n\nl\n\nc\n\na\n\nd\n\nb\n\ne\n\nc\n\nf\n\n0\n\n0\n\n1\n\nt\n\nc\n\nf\n\n2\n\nt\n\nl\n\n\u00f1\n\nq\n\nw\n\nz\n\ni\n\ni\n\nh\n\ng\n\n2\na[0][2][1]=\u2018l\u2019\n\nchar a[][];                   //declaration\na = new char[3][3]     //creation\na[0][0]=\u2018A\u2019;                 //initialization\n...\n\nchar a[][][];                   //declaration\na = new char[3][3][3]   //creation\na[0][0][0]=\u2018a\u2019                // initialization\n...\n\n45\n\n\fN-dimensional Arrays\nExamples\n\nDirect declaration and creation\nnull\n\n//Declaration and creation\nString [][]myArray = new String[3][4]\n\nnull\nDeclaration and creation step by step\n\nnull\n\nnull\n\nnull\n\nnull\n\nnull\n\nnull\n\nnull\n\nnull\n\nnull\n\nnull\n\nint [][] myArray ;                        \nmyArray = new int[numRows][]; \nfor(int i=0; i<numRows; i++)     \n\nmyArray[i]= new int[numColumns];\n\n// Array declaration\n// Creating the reference array for rows\n// Allocating memory for rows \n\nOther examples\n\n// Array 3x3 initialized to 0\nint [][] a= new int[3][3];\n\nint [][] b= {{1, 2, 3},\n{4, 5, 6}};\n\n0\n\n0\n\n0\n\n1\n\n4\n\n0\n\n0\n\n0\n\n2\n\n5\n\n0\n\n0\n\n0\n\n3\n\n6\n\nint [][] c = new[3][];\nc[0] = new int[5];\nc[1] = new int[4];\nc[2] = new int[3];\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n46\n\n\fArrays\nHomework\n\n\u2022 Write a program that multiplies two \nbi-dimensional arrays of integers\n\n47\n\n\fMethod declaration\n\npublic class Car{\n\n//Attribute declaration\nprivate String color;\nprivate int speed;\n//Method declaration\n\npublic void start(){\n//implementation\n\n}\npublic void goForward(int speed){\n\n//implementation\n\n}\npublic String getColor(){\n//implementation\n\nreturn color;\n\n}\n\n}\n\nCar.java\n\nCar.java\n\nStyle\n\u2022 Intuitive names\n\u2022 1st letter lower-case\n\u2022 No blanks\n\u2022 Camel-case myMethod()\n\u2022 Indentation\n\n48\n\n\fMethod declaration\n\npublic class Car{\n\n//...\n\npublic void goForward(int speed){\n\n//implementation\n\n}\n\n//...\n\n}\n\nparameters\n(param1, param2)\n\nMethod\n\nCar.java\n\n(modifiers) void methodName(type1 param1, type2 param2){\n\n// implementation\n\n} \n\n49\n\n\fMethod declaration\n\npublic class Car{\n\n//...\n\npublic String getColor(){\n\n//implementation\n\nreturn color;\n\n}\n\n//...\n\n}\n\nCar.java\n\nparameters\n(param1, param2)\n\nMethod\n\nResult\n\n(modifiers) returnType methodName(type1 param1, type2 param2){\n\n//implementation\nreturn expression; \n\n}\n\n50\n\n\fMethod declaration\n\n\u2022 Methods\n\n\u2013 Have 0, 1 or more arguments (parameters)\n\u2013 Define the data type of the result in their declaration \n\n(except constructors)\n\n\u2013 Can have local variables. These variables are not \n\ninitialized by default\n\n\u2022 A method cannot contain other methods inside \n\nits body\n\n\u2022 If one method produces a result, the last \n\nsentence of its execution must be a return \nsentence\n\n51\n\n\fConstructor methods\n\n\u2022 When an object is created, its members are initialized with a \n\nconstructor method\n\u2022 Constructor methods:\n\n\u2013 Have the same name as their container class\n\u2013 Do not have a returned data type in their declaration\n\n\u2022 There should be at least one constructor per class\n\u2022 There may be several constructors, which will be distinguished \n\n\u2022\n\n\u2022\n\nby the parameters accepted (overload)\nIf there are no declared constructors, a default constructor is \ncreated and this default constructor initializes all variables to \ntheir own default value\nIf the class has a constructor, the default constructor does not \nexists, but the programmer can declare a constructor without \nparameters with the same function than the default one.\n\n52\n\n\fThe main method\n\n\u2022 It is the first  method that the runtime system \n\ncalls to execute an application.\n\n\u2022 The parameters of the main (String args[ ])\nrepresent an array of Strings that stores the \narguments that are written in the command \nline to run the application\n\njava HelloWorld arg1 arg2...\n\n\u2022 void indicates that there are no return values\n\u2022 static indicates that it is a global method. This \nmethod is the same for every instance of the \nclass\n\n53\n\n\fSystems Programming\n\nImperative Java\n\nDepartment of Telematic Engineering\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero and Natividad Mart\u00ednez Madrid\n\n54\n\n\fScenario  III: \nMethod implementation \n\n\u2022 Once the programmers\u2019 meeting has finished, you have to show \nyour expertise before joining the team. Your boss asks you to \nimplement several methods. As your first task, the methods are \nsimple and work independently (do not invoke other attributes or \nmethods)\n\u2022 Objective: \n\n\u2013 Be able to decompose a problem in order to identify the basic steps for \n\nsolving it (algorithms design and representation) \n\n\u2013 Use the basic structures of a programming language, variables, operators \n\nand flow control statements (loops, conditionals) to implement an algorithm\n\n\u2022 Work plan: \n\n\u2013 Train yourself in the design of algorithms and their representation. Break problems in \n\nsmall steps in order to solve them without using code.\n\n\u2013 Memorize the syntax of Java in terms of (operators, loops and conditionals)\n\u2013 Train in use Java to implement previously designed algorithms\n\u2013 Get implementing ease and speed. Resolve typical problems (e.g.: in arrays, print all \n\nits elements, retrieve an specific element, swap elements between two positions, sorting)\n\n55\n\n\fStep I: Thinking of the algorithm \nWhat tools do we have to represent algorithms?\n\n\u2022 Once we have thought about the \nalgorithm structure, we need to \nrepresent the steps to solve it:\n\u2013 Pseudocode\n\u2013 Flowcharts, organigrams\n\n\u2022 Figures: representing sentences\n\u2022 Flow lines: representing the order in which \n\nthey are executed\n\n56\n\n\fStep I: Thinking of the algorithm \nFlowcharts vs Pseudocode\n\n57\n\n\fStep II: Algorithm implementation\nWhat kind of expressions can we use in the method body?\n\n\u2022 Variables\n\u2022 Operators\n\u2013 By type\n\n\u2022 Assignment\n\u2022 Arithmetical\n\u2022 Relational \n\u2022 Logical\n\u2022 Conditional\n\n\u2013 By number of operands\n\n\u2022 Unary\n\u2022 Binary\n\n\u2022 Operations with objects \n(not for this scenario)\n\u2013 Object creation\n\u2013 Attribute and method \n\ninvocation\n\n\u2022 Flow control structures \n(can be stacked and nested)\n\u2013 Sequence\n\u2013 Iteration (loops)\n\n\u2022 For\n\u2022 While\n\u2022 Do-while\n\n\u2013 Selection (conditionals) \n\n\u2022\n\u2022\n\nIf\nIf-else\n\n\u2022 Switch\n\n\u2022 Breaking up the flow of \n\nexecution\n\u2022 Break\n\u2022 Continue\n\u2022 Exception (not in this scenario)\n\n58\n\n\fOperators\n\n\u2022 By number of operands\n\n\u2013 Unary (one operand e.g.: ++, --)\n\u2013 Binary (two operands e.g.: &&, %)\n\n\u2022 By type of operator\n\u2013 Assignment (=)\n\u2013 Arithmetical (+, -, *, /, %)\n\u2013 Relational (>, >=, <, <=, ==, !=)\n\u2013 Logical (&&, II, !)\n\u2013 Conditional operator (condition?sentence1:sentence2)\n\nSystem.out.println( studentGrade >= 5 ? \u201cpass\u201d : \u201cnot pass\u201d ); \n\n59\n\n\fOperators\nNotes to remember\n\n\u2022 Unary\n\n\u2013 i++ (first evaluates then increments)\n\u2013 ++i (first increments then evaluate)\n\u2013 E.g. if i=3\n\n\u2022 a = i++ results in a = 3\n\u2022 a = ++i result in a = 4\n\n\u2022 Binary (can be abbreviated)\n\u2013 x+=3 equals to  x= x+3\n\u2022 Assignment vs. comparison\n\n\u2013 The \u201c=\u201d operator assigns a value\n\u2022 E.g. var = 5, assigns 5 to  var\n\n\u2013 The \u201c == \u201c operator compares\n\n\u2022 E.g. var == 5, returns true (after the previous assignment)\n\u2022 The conditional operator is harder to understand than a simple \n\nif-else. Try not to use it\n\n60\n\n\fSelection sentences\n(Conditionals)\n\n\u2022\n\n\u2022\n\nIf \n\nif( condition) {\nsentences1;\n\n}\n\nIf-else\n\n\u2022 switch\n\nswitch ( expression ) {\ncase value1:\nsentences1;\nbreak;\n\ncase value2:\nsentences2;\nbreak; \n\ndefault:\n\nsentences3;\n\n} \n\nif( condition) {\nsentences1;\n\n}else{\n\nsentences2;\n\n}\n\nif( condition) {\nsentences1;\n\n}else if(condition2){\n\nsentences2;\n\n}else{\n\nsentences3;\n\n}\n\n61\n\n\fSelection sentences\nNotes to remember for if and if-else\n\nIndenting the code contributes to its readability\n\u2022\n\u2022 Braces { } fix the scope of every element declared \n\nbetween them\n\n\u2022 No braces { } is like to put them only in the first \n\nsentence \n\nif (studentGrade >= 5)\n\nSystem.out.println ( \u201cPass\u201d ); \n\nelse\n\nSystem.out.println (\u201cNot pass\u201d);\n\n62\n\n\fSelection sentences\nNotes to remember for switch\n\n\u2022 Valid expression types: byte, short, int, long, \n\nchar,  String\n\n\u2022 Examples:\n\n\u2013 int num=5; switch(num){}\n\u2013 char character=\u2018z\u2019 switch(character){}\n\u2013 String string=\u201cmyString\u201d switch(myString){}\nIf you do not use breaks, all the following code-blocks \nwill be executed until a break or end of the switch is \nfound\nIt is not necessary to place the block-code associated \nwith each case between braces { }\n\n\u2022\n\n\u2022\n\n63\n\n\fIteration sentences\n(Loops)\n\n\u2022 For:\n\nfor( initialization;condition;update) {\n\nsentences;\n\n}\n\n\u2022 While:\n\nwhile( condition) {\n\nsentences;\n\n}\n\n\u2022 Do-while:\n\ndo {\n\nsentences;\n\n}while(condition);\n\n64\n\n\fIteration sentences\n(Examples: for)\n\n\u2022 Examples\n\nint i=0;\n\nint i=0;\n\nfor (i =0;i<10;)\n\nfor (i=13;i<10; i++)\n\n{ i=i+2;}\n\n{ i=i+2;}\n\nint i=4;\n\nfor (;i<10;)\n\n{ i=i+2;}\n\nint i=0;\n\nfor ( ; ; )\n\n{ i=i+2;}\n\nint i sum;\n\nfor (i =0, sum=5;i<10;sum+=i)\n\n{ i=i+8;}\n\nHow many times are these loops executed?\nWhat is the value of \u201ci\u201d in each example at the end of the loop?\n\n65\n\n\fIteration sentences\n(Examples: for)\n\nint i=0;\n\nfor (i =0;i<10;)\n\nT h e   o n e  \n\n{ i=i+2;}\n\nt e n   u s e d  \nint i=0;\nl\n)\nl\n  w i\nt h a t\nfor (i=13;i<10; i++)\nl e a r n  \n(\nf o r   ( i n t\n\n  o f\n  b e   m o s t\n!\n  b y   h e a r t\nt\ni\ni = 0 ;   i < 5 ;   i + + )   {\n{ i=i+2;}\n\nint i sum;\n\n/ / s e n t e n c e s\n\nfor (i =0, sum=5;i<10;sum+=i)\n\nint i=4;\n\nfor (;i<10;)\n\n{ i=i+2;}\n\nint i=0;\n\nfor ( ; ; )\n\n{ i=i+2;}\n\n}\n\n{ i=i+8;}\n\n66\n\n\fIteration sentences\nNotes to remember \n\n\u2022 When the loop has several sentences (in initialization, \n\ncomparison or update), they will be separated by commas\n\nfor(i=0, sum=0;  i<=n;  i++, sum+=n)  {\n\nsentences;\n\n}\n\n\u2022 Nested loops:\n\n\u2013 Program slows down\n\u2013 They are used to cover n-dimensional arrays (one loop per \n\ndimension)\n\n\u2022 The sentences in a while might never run; in a do-while\n\nsentences are executed at least once\n\n\u2022 Avoid infinite loops (always check termination condition)\n\u2022 A  for loop always can be converted into a  while loop, and  \n\nvice versa\n\n67\n\n\fIteration sentences\nComparative\n\n\u2022 for vs. while vs do-while\nMin \nExe\n0\n\nUpd Condition\n\nContinue\n\nInit\n\nYes\n\nYes\n\nfor\n\nwhile\n\nNot\n\nNot\n\nContinue\n\ndo-while Not\n\nNot\n\nContinue\n\n0\n\n1\n\n\u2022\nInit: Initialize variables\n\u2022 Upd: Update variables\n\u2022 Condition: Continue or exit\n\u2022 Min exe: minimum number of times the block of code is executed\n\u2022 Usage: frequency of use of the control structure\n\nUsage\n\nHigh\n\nHigh\n\nLow\n\n68\n\n\fIteration sentences\nUsage patterns\n\n\u2022 When to use while or for\n\nfor while\n\nThe number of iterations is known (e.g. array) X\nThe number of iterations is unknown\n\nIncrease of variables in each cycle\n\nVariable initialization\n\nX\nX\n\nE.g.: reading a file with while\nE.g.: cover an array with for\n\nX\n\nX\n\n69\n\n\fBreaking up the flow of execution: \nBreak sentence\n\n\u2022 break: causes to break the execution and exit the \n\nstructure in a while, for, do-while or switch\n\nint j=0;\nwhile(j<10){\nj++;\nbreak;\nSystem.out.println(\u201cThis message is never printed\u201d);\n\n}\nSystem.out.println(\u201cj = \u201d+j);\n\nThe loop runs only once and prints the message \u201cj = 1\u201d\n\n70\n\n\fBreaking up the flow of execution: \nContinue sentence\n\n\u2022 continue: when continue appears in a while, for or \ndo-while block of code, it skips the rest of the sentences \nof the loop and continues with the next iteration\n\nint j=0\nwhile(j<10){\n\nj++;\ncontinue;\nSystem.out.println(\u201cThis message is never printed\u201d);\n\n}\n\nThe message is never printed\n\n71\n\n\fImplementing a method: \nStep 1.1: Think about the algorithm\n\n\u2022 Problem: Write a program that calculates \n\nwhether a number n is prime\n\n1  2  3  4  .  .  .  n/2   .  .  .  n\n\n\u2022 Step 1: Think about the algorithm (split the \n\nproblem into simpler steps)\n\u2013 Starting by 2, we check for each number if it is an \n\ninteger divisor of n\n\n\u2013 We only needs to repeat it until n/2\n\u2013 Or until we find an integer divisor\n\u2013 We will use a sentinel\n\n\u2022 Boolean variable that will help us control the loop\n\n72\n\n\fImplementing a method: \nStep 1.2: Represent the algorithm\n\ndivisor = 2\nisPrime = true\n\nFlowchart\n\nfalse\n\ndivisor < n / 2\n&&\nisPrime\n\ntrue\n\nn % divisor == 0\n\ntrue\n\nisPrime= false\n\nfalse\n\ndivisor++\n\n73\n\n\fImplementing a method: \nStep 2: Write the code\n\npublic boolean isAPrimeNumber (int number) {\n\nint divisor =2;\nboolean isPrime = true;\n\nwhile ((divisor < number/2) && isPrime){\n\nif (number % divisor == 0)\n\nisPrime = false;\n\ndivisor++;\n\n}\n\nSystem.out.println(\u201cThe number \u201c +number);\nif (isPrime)\n\nSystem.out.println(\u201c is prime.\u201d);\n\nelse\n\nSystem.out.println(\u201c is not prime.\u201d);\n\nreturn isPrime;\n\n}\n\n74\n\n\fImplementing a method: \nExamples: working with arrays\n\n\u2022 Let\u2019s practice\n\u2022\n\nImagine that you have to implements methods to:\n\u2013 Print an array (practice loops)\n\u2013 Retrieve a specific element in an array \n\u2022 Practice: conditionals and nested loops\n\u2022 Practice comparison using different data types \n\u2013 Basic types (numbers, characters booleans)\n\u2013 String comparison\n\u2013 Object comparison\n\n\u2013 Swap two elements in an array (practice auxiliary variables)\n\u2013 Sort an array (copy elements between two arrays)\n\n75\n\n\fReview\nLearning outcomes\n\n\u2022 After this session you must be able to:\n\n\u2013 Install and configure an environment to work with Java \n\u2013 Understand a program with several files, be able to draw a class \ndiagram, and identify the first method that the runtime system calls \nto execute the program\n\n\u2013 Identify basic structures associated with classes and objects\n\nsuch as declarations of:\n\n\u2022 Classes\n\u2022 Members\n\n\u2013 Attributes\n\n\u00bb Basic types (primitives, String)\n\u00bb Reference types (objects and arrays)\n\n\u2013 Methods\n\n\u00bb main\n\u00bb constructors\n\u00bb Regular methods\n\n\u2013 Design and implement simple algorithms inside the body of a \n\nmethod using operators and basic control structures (loops and \nconditionals)\n\n76\n\n\f", "pages_description": ["Scenario I: Install and configure the environment\n\nThis slide presents a scenario about installing and configuring an environment. The objective is to be able to edit, compile, execute, and debug an existing program. The work plan involves downloading, installing, and configuring the software in order to test the application. The scenario is as follows: It's your first day working in the programming department of a company named PROTEL. Your department needs to update an existing application with new functionality. You are provided with a laptop and a URL to download the existing code. \n", "Development Architecture\n\nThe image describes the two steps involved in developing software: editing and compiling. \n\nSeveral IDEs, or Integrated Development Environments, are listed for editing, including Eclipse, Netbeans, J Builder, Visual Cafe, Java Workshop, Visual Age, and J++.  Other editors, such as Grasp, Notepad, and EditPlus, can also be used.\n\nThe code, saved as \"file.java\", is then compiled, in this example by JDK or other compilers. The output of the compilation process is \"bytecode\", saved as \"file.class\".\n", "Execution Architecture\n\nThe diagram illustrates the execution architecture of Java applets or applications. \n\nAt the bottom, a \"java file\" serves as the input. This file is processed by the Java Virtual Machine, which consists of several components.\n\nFirst, the \"Class Loader\" and \"Bytecode Verifier\" work together, loading the necessary \"Java Class Libraries\" (both extension and base APIs) and ensuring the bytecode's integrity. \n\nNext, the code can be executed by the \"Java Interpreter\" or the \"JIT (Just in Time Compiler).\" Both interact with the \"Java Runtime\" environment.\n\nThe \"Java Runtime\" further relies on the underlying \"Operating System\" and \"Hardware\" for execution. \n", "What can go wrong?\n\nWe have a list of four possible software execution stages and the corresponding errors that can occur. During compilation we can have a \"Syntax Error\". During load, we can have a \"Class not found Exception\". During verification, we can have a \"Security Exception\". Finally, during execution, we can have a \"Null Pointer Exception\". \n", "Where do I start?\n\nTo start developing in Java, you need a development environment, an editor, and documentation. The recommended development environment is the Java Development Kit (JDK), available at http://www.oracle.com/technetwork/Java/index.html. The suggested editor is Eclipse, which can be found at http://www.eclipse.org. For documentation, refer to the Java API at http://docs.oracle.com/Javase/8/docs/api/. \n", "Config (if needed)\n\nWe are going to talk about the configuration. There are two important variables: CLASSPATH and PATH. The CLASSPATH variable is a set of directories containing the files.class you want to execute. This is not necessary since version 1.2. It must contain, at least, the directory $JAVA\\_HOME/lib/files.class. The PATH variable contains the directories to search for executable files. It must contain, at least, $JAVA\\_HOME/bin. \n", "How to configure Environment Variables\n\nThis slide explains how to configure environment variables in Windows and Linux.\n\nIn Windows 7, 8 and 8.1, you need to go to the Control Panel, then System and Security, then System, then Advanced system settings, and finally Advanced options. There, you will find the Environment Variables option.\n\nIn Linux, you can type the commands in a terminal prompt or modify the bash file to make it permanent.\n\nTo set the PATH variable, you can use the following command:\n```\nPATH=$JAVA_HOME/bin:/usr/bin\n```\nTo set the CLASSPATH variable, you can use the following command:\n```\nCLASSPATH=$JAVA_HOME/lib/classes.zip:.\n```\n\nTo preserve the old value of environment variables, you can use the following commands:\n```\nPATH=$JAVA_HOME/Java/bin:$PATH\nCLASSPATH=$JAVA_HOME/lib/classes.zip:$CLASSPATH\n```\nIn these commands, $JAVA_HOME is the path to the directory where Java is installed. \n", "Systems Programming\n\nJava Language Code Structure\n\nDepartment of Telematic Engineering\n\nContents are mostly based on the work by: M. Carmen Fern\u00e1ndez Panadero and Natividad Mart\u00ednez Madrid\n", "Scenario II: Understanding Java code\n\nThe objective of this scenario is to be fluent in reading Java structures related to classes, attributes, and methods. The goal is to be able to understand, at a glance, a complex Java program with several files.\n\nThe work plan for this scenario is as follows:\n- Review Java syntax, including identifiers, reserved words, etc., in order to distinguish between words from the Java language and naming conventions for a specific application.\n- Identify language structures related to class declaration, attribute declaration (both basic and reference types), and method declaration.\n- Draw class diagrams to represent a set of Java files in order to identify object types, their characteristics (attributes), and behaviors (methods).\n- Understand and explain the main method (if it exists) to see the order in which objects are created, methods are called, and sentences are executed.\n\nThis scenario involves a first meeting as a programmer in one hour. By that time, the code should be reviewed and understood, including how the application works. \n", "Code Structure\n\nA diagram illustrating the structure of code. At the top level, we have a \"Program\". A program consists of \"Classes\", which are represented as files with the \".java\" extension. Each class has \"Members\", which are further categorized into \"Attributes\" and \"Methods\". \n\nAttributes can be of \"Primitive Type\" or \"Reference Type\". Examples of primitive types include \"String\". Reference types encompass \"Object\" and \"Arrays\". \n\nMethods are categorized as \"Normal Methods\" and \"Special methods\". Special methods consist of \"Constructor\" and \"Main\". \n", "How to represent classes and objects in Java\n\nThis slide lists the concepts related to classes and objects in Java. These concepts are: class declaration, attribute declaration, method declaration, object creation, identifiers, reserved words, primitive and reference types. \n", "Identifiers\n\nIdentifiers are used to give a name to variables, methods, classes, objects, and everything that the programmer needs to identify. They start with a letter, an underscore, or a dollar sign. They are case-sensitive and have no maximum length. By convention, names of variables, methods, and objects begin with lowercase. Class names begin with uppercase. If there are several words, use camel case, like \"likeInThisExample\". Avoid spaces, underscores, and hyphens. Identifiers cannot be reserved words. \n", "Reserved words\n\nThe image shows a table of reserved words in Java. The table is divided into two sections: \"Reserved\" and \"Reserved (although not used)\". The \"Reserved\" section lists keywords that cannot be used as identifiers in a Java program. The \"Reserved (although not used)\" section lists keywords that are reserved but not currently used by the Java language.\n\nThe \"Reserved\" section of the table lists the following keywords:\n\n* abstract\n* boolean\n* break\n* byte\n* case\n* catch\n* char\n* class\n* const *\n* continue\n* default\n* do\n* double\n* else\n* extends\n* final\n* finally\n* float\n* for\n* goto\n* if\n* implements\n* import\n* instanceof\n* int\n* interface\n* long\n* native\n* new\n* null\n* package\n* private\n* protected\n* public\n* return\n* short\n* static\n* super\n* switch\n* synchronized\n* this\n* throw\n* throws\n* transient *\n* try\n* void\n* volatile\n* while\n\nThe \"Reserved (although not used)\" section of the table lists the following keywords:\n\n* cast\n* future\n* generic\n* inner\n* operator\n* outer\n* rest\n* var\n", "Comments\n\nThis slide describes the three types of comments in Java.\n\n- Implementation comment: A single-line comment, marked by \"//\" at the beginning.\n- Implementation block comment: A multi-line comment, starting with \"/*\" and ending with \"*/\".\n- Documentation comment: A multi-line comment used to generate Javadoc documentation. It starts with \"/**\" and ends with \"*/\". This type of comment includes special tags like \"@see\", \"@version\", \"@author\", \"@since\", \"@param\", \"@return\", \"@throws\", and \"@deprecated\" to provide specific information about the code. \n  - @see provides a reference to another class or method.\n  - @version includes information about the version number.\n  - @author specifies the author's name.\n  - @since indicates the date since the code is available.\n  - @param describes the parameters received by the method.\n  - @return specifies the information and data type returned by the method.\n  - @throws lists the exceptions that are thrown by the method.\n  - @deprecated indicates that the method is old and should not be used.\n\nThe slide also specifies that documentation comments can be used for both classes and methods, while the other two types are generally used for methods. However, it does mention that documentation comments can be optionally used for classes as well. \n", "Class declaration\n\nThis slide explains how to declare a class in Java, both the syntax and the style.\n\nThe syntax is as follows: first the modifiers, then the keyword \"class\", then the class name followed by curly braces. Inside the curly braces we have the class implementation.\n\nWhen choosing a class name, make sure that the file name matches the class name, the first letter is capitalized, there are no blanks or hyphens in the name and camel case is used. For example, \"MyFirstClass\". Finally, remember to indent the code.\n", "Variable Declaration\n\nWe have a code snippet illustrating variable declaration in Java. The code defines a class named \"Car\" with attributes for \"color\" of type \"String\" and \"speed\" of type \"int\".  There's a comment indicating the area for method declarations, taking parameters like \"start\" and \"stop\".\n\nThe syntax for variable declaration is shown as \"type name;\" for a single variable and \"type name1, name2, name3;\" for multiple variables declared together. Initializing a variable during declaration is shown as \"type name = value;\".\n\nThe slide emphasizes good coding style with intuitive names, camel case for variable names, indentation, and no blanks in variable names. \n", "Variables\n\nVariables are fields in which programs store information. \n\nTo declare a variable means to specify its name and type.\n\nWe can find variables as members of a class: Instance and class variables within a class, as local variables within a method, and as parameters within a method declaration. \n", "Variables\n\nThere are three types of variables: instance variables, class variables, and local variables.\n\nVariables can be initialized in the declaration or may be declared uninitialized. If they are not initialized, they will have a default value, except for local variables. The default values are: 0 for numbers, false for booleans, and null for references.\n\nConstants are variables that cannot be modified. They are declared using the reserved word \"final\" and must be initialized in the declaration.\n", "Scope\n\nThe scope of a variable is the part of the program over which the variable name can be referenced. Instance or class variables can be referenced inside the body of the class or from other classes depending on the permissions set, which are private, protected, public, and friendly package. Local variables can be referenced inside a statement block in braces, such as inside a method or inside a while or for loops. Parameters can be referenced only inside the body of the method. \n", "Data Types in Java\n\nAll variables belong to a data type. The data type determines the values that the variable can take and the operators that can be used. We will study primitive types and reference types, which include objects and arrays. \n", "Primitive types\n\nThis table describes 4 basic primitive types. \n\nThe first type is **Real**, which can be represented as a **double** or a **float**. A **double** uses 64 bits and a **float** uses 32 bits. \n\nThe second type is **Integer**, which can be represented as an **int**, **short**, or **byte**. An **int** uses 32 bits, a **short** uses 16 bits, and a **byte** uses 8 bits.\n\nThe third type is **Character**, which is represented as a **char** and uses Unicode (16 bits).\n\nThe fourth type is **Boolean**, which is represented as a **boolean** and uses 1 bit. \n\nThe last 7 columns indicate whether each type can be represented as a **double**, **float**, **long**, **int**, **short**, **byte**, or **char**. An \"X\" indicates that the type can be represented in that way. \n", "Strings Declaration, concatenation\n\n- A sequence of characters implemented in a class named String in java.lang package.\n- Strings creation:\n  - String emptyS = new String();\n  - String emptyS = \"\";\n  - String message = \"hello\"\n  - String messageCopy = message;\n- Strings concatenation:\n  - String concatenation uses the overloaded + operator.\n  - \"this\" + \"that\" // result: \"thisthat\"\n  - \"abc\" + 5 // result: \"abc5\"\n  - \"a\" + \"b\" + \"c\" // result: \"abc\"\n  - \"a\" + 1 + 2 // result: \"a12\"\n  - 1 + 2 + \"a\" // result: \"3a\"\n  - 1 + (2 + \"a\") // result: \"12a\"\n", "Strings Comparison\n\n- You must not use relational operators such as less than, greater than, less than or equal to, and greater than or equal to, nor the equality operators such as equal to and not equal to with Strings. These operators compare the object, not the content.\n- There are specific methods to compare in the String class.\n    - Method: equals. leftSide.equals(rightSide) returns true if leftSide and rightSide are identical.\n    - Method: compareTo. leftSide.compareTo(rightSide) returns a negative integer value if leftSide is lower than rightSide, 0 if leftSide is equal to rightSide, and a positive integer value if leftSide is higher than rightSide. \n", "Strings\n\nThis slide describes useful methods of the String class. \n\nThe first method is length(). This method returns the length of a string. It's important to remember to include the parentheses after the method name, as this is how Java knows that it is a method call. \n\nThe next method is charAt(). This method allows you to access individual characters inside a string. You pass in the position of the character you want to access as an argument to the method. The first position in a string is 0. \n\nThe final method discussed is substring(). This method returns a reference to a new string that is a substring of the original string. The substring() method takes two arguments: the first position included in the substring and the first position excluded from the substring. \n\nThe slide then provides some example code that demonstrates how to use these methods. The code first creates a string called \"greeting\" and sets it equal to \"hello\". Then, the code uses the length() method to get the length of the string and stores it in a variable called \"len\". The code then uses the charAt() method to get the character at position 1 of the string and stores it in a variable called \"ch\". Finally, the code uses the substring() method to get the substring of \"greeting\" from position 2 to position 4 and stores it in a variable called \"sub\". The code then includes comments that indicate what the values of each variable will be after the code is executed. \n", "Strings\nConversion between String and primitive types\n\n- Use calls to wrapper classes in java.lang\n  - They are called wrappers because they wrap the primitive types: Integer, Double, Float, Double, Character, ...\n  - String conversion\n    - Methods: toString(...), doubleValue()\n  - String conversion to a primitive type\n    - Methods: parseInt(...), parseFloat(...)\n  - String conversion to an object of the wrapper class\n    - valueOf(...)\n  - Conversion from an object of the wrapper class to a primitive value\n    - doubleValue(), intValue()\n\nHere is an example:\n\n```java\nSystem.out.println(Integer.toString(55, 2));\nint x = Integer.parseInt(\"75\");\nDouble y = Double.valueOf(\"3.14\").doubleValue();\n```\n", "Constants defined by user\n\n- Invariant values of basic types primitives plus String\n- Constants use the final modifier and sometimes the static too\n  - Static indicates global or class variable. This means that it is stored only once. Objects can access this variable using the dot notation, ClassName dot variableName\n  - Final: this modifier indicates that the value never changes\n- Constants can be public, private, or protected\n  - Depending on the degree of accessibility the programmer prefers\n- Style: all the characters in uppercase\n\nThere is a code example:\n\n```java\nclass Circle {\n  private static final float PI = 3.14159;\n  private float radio;\n  private float area;\n  public Circle (float radio) {\n    area = 2 * PI * radio;\n  } //constructor\n} //class Circle\n```\n", "Reference types\n\nThe value is a reference, or pointer, to the value represented by the variable. Some examples of reference types are: arrays, classes, and interfaces. \n", "An object as an attribute\nObject declaration\n\nThe image shows a code snippet in Java that declares an object as an attribute. \n\nThe code is for a class named \"Car\" that has attributes such as \"color\" of type String, \"speed\" of type int, and \"standardEquipment\" of type \"Equipment\". \n\nThe code also includes a comment indicating the syntax for object declaration, which is \"ClassName name;\" for a single object and \"ClassName name1, name2;\" for multiple objects. \n\nThe code then shows an example of object creation using the \"new\" keyword: \"ClassName name = new Equipment();\". \n\nThere is a comment explaining that object declaration is similar to variable declaration, where the type is specified, but in object declaration, the name of the class is used. \n\nThere is also a section on \"Style\" that reminds us that class names (type) should start with a capital letter, while identifiers (objectName) should use lowercase. \n\nFinally, there is a section on \"Object creation\" that explains that variables are initialized, but objects are created. \n", "Objects\nDeclaration, creation, initialization\n\n- Objects are created with the reserved word \"new\" and a call to the constructor\n- Once the object is created, the reference to the object is reassigned to the memory location where the object is located\n\nThe first diagram shows a yellow box with the text \"Student student1;\". To the right, there is an orange box with the text \"null\" and below it \"student1\". An arrow points from the orange box to a black dot.\n\nThe second diagram shows a blue box with the text \"student1 = new Student();\". To the right, there is an orange box with the text \"student1\" below it. An arrow points from the orange box to a green box with the text \"Student\" inside.\n", "Objects, null reference.\n\nIt may happen that a reference to an object has no instance assigned, in this case the special value null is used.\n\nFor example, if we have three student objects, student1, student2 and student3, by default they will be null. Then we assign values to student1 and student2, but student3 is assigned to null.\n\nThe diagram shows that student1 and student2 are pointing to Student objects, but student3 is pointing to a null object. \n", "Objects Alias\n\nAn object can have several references, known as aliases. For example, the code snippet \"Student delegate; delegate = student1;\" shows how a Student object can be referenced by both the \"delegate\" and \"student1\" variables.\n\nThe figure illustrates this concept with a diagram of objects and their references. There are five reference variables: \"student1\", \"delegate\", \"student2\", \"student3\", and \"student5\". \n\n- \"student1\" and \"delegate\" both reference the same Student object, which contains the value \"Juan\". \n- \"student5\" references a different Student object, also containing the value \"Juan\". \n- \"student4\" references a Student object containing the value \"Clara\". \n- \"student2\" and \"student3\" do not reference any object, indicated by the \"null\" value and a black dot. \n\nThis diagram demonstrates that multiple references can point to the same object, and that different objects can hold the same value. \n", "Arrays\nWhat is an array?\n\nAn array is a set of elements belonging to the same data type and stored in one place. The index operator, represented by square brackets, is used to retrieve individual elements from the array. The length attribute returns the number of elements in the array. It's important to note that this should not be confused with the length method of the String class.\n\nThe range of the index starts from 0 and goes up to length minus 1. It's crucial to be careful not to exceed the maximum length of the array, as doing so will result in an IndexOutOfBoundsException. \n", "An Array as an Attribute\nArray declaration\n\nThis slide explains how to declare and create arrays in a Java-like programming language.\n\nWe see a code snippet that shows the declaration of an array named \"equipment\" inside a class named \"Car\". The array is of type \"String\" and has a size of 10.\n\nThe slide also presents three different ways to declare an array:\n- \"type ArrayName[];\"\n- \"type [] ArrayName;\"\n- \"type ArrayName[] = new type [arraySize];\"\n\nThe last one is highlighted in red because it's also showing how to create an array, by using the \"new\" keyword and specifying the array size.\n\nFinally, the slide highlights the difference between variable and array creation:\n- Variables are initialized when they are declared.\n- Arrays, like objects, are created when they are declared, and their initial values depend on the array type. \n", "Arrays\nDeclaration, Creation, Initialization\n\nThis slide describes how to declare, create, and initialize arrays. \n\nDeclaration is the process of assigning an identifier to the array and specifying the data type of the elements that will be stored. This can be done in two ways: \n- Type ArrayName();\n- Type [] ArrayName;\n\nNo memory is allocated to store the array during the declaration. Therefore, you cannot access its contents yet.\n\nCreation consists of allocating memory for the array. You must use the reserved word \"new\" and specify the array size. For example:\narrayName [] = new type [arraySize];\n\nOnce the array is created, its elements have default values until the array is initialized. The default values are as follows:\n- int, short, long = 0\n- float, double = 0.0\n- booleans = false\n- String = null\n- Object = null \n", "Arrays, Declaration, Creation, Initialization\n\nThis slide explains how to initialize an array in programming, which means assigning values to each element.\n\nThere are three ways to initialize an array: element by element, using a loop, or direct assignment.\n\nTo initialize an array element by element, you would assign a value to each element individually. For example, to initialize the first two elements of an array named \"arrayName\", you would use the following code: \n\"arrayName[0] = element0;\" and \"arrayName[1] = element1;\".\n\nTo initialize an array using a loop, you would use a for loop to iterate through each element of the array and assign it a value. For example, the following code would initialize each element of the array \"arrayName\" to the value of \"element-i\":\n\"for(int i = 0; i < arrayName.length; i++) { arrayName[i] = element-i; }\"\n\nTo initialize an array using direct assignment, you would enclose the values for each element in curly braces and assign them to the array. For example, the following code would initialize the array \"arrayName\" with the values \"elem1\", \"elem2\", \"elem3\", and so on:\n\"arrayName = {elem1, elem2, elem3, ...};\"\n", "Arrays\n\nThis slide explains how arrays work. The index of the first element in an array is zero. The index of the last element in an array is the array length minus one. The index can be any integer expression that evaluates to a value between zero and the array length minus one. The example array has ten elements. The values of the elements are: -7, 0, 3, 8, 5, -4, 6, 6, 1, and 2. \n", "Arrays\nMemory usage in array declaration\n\nWe have two arrays declared: an array of integers and an array of points. Both arrays are declared but not initialized. \n\nOn the right, we see the memory representation for each array. The stack memory contains the array variables \"integers\" and \"points,\" which are currently set to null. The heap memory, on the other hand, is currently empty.\n\nThere is also a code snippet defining a class called \"Point.\" This class has two integer members, x and y, and a constructor that initializes these members. \n", "Arrays\nMemory usage in array creation\n\nWe have two code snippets and a diagram that illustrates memory allocation for arrays in stack and heap memory.\n\nThe first code snippet shows the declaration of an integer array named \"integers\" with a size of 3. In the stack memory, we have a reference to this array named \"integers\". The actual array is allocated in the heap memory. It has a length of 3 and contains three integer values: 0, 0, and 0, corresponding to the indices 0, 1, and 2.\n\nThe second code snippet declares an array named \"points\" of type \"Point\" with a size of 2. Similar to the previous example, the stack memory holds a reference \"points\" to the array allocated in the heap. The array in the heap has a length of 2 and contains two \"Point\" objects, both initialized to null.\n\nThere's a note stating that the \"new Point[2]\" expression does not invoke a constructor. This emphasizes that creating an array of objects only allocates memory for the objects but doesn't automatically call their constructors.\n", "Arrays\nMemory usage in array initialization\n\nThe slide illustrates memory allocation for arrays in stack and heap memory. \n\nOn the left, we have two code snippets. The first one initializes the first element of an integer array named \"integers\" with the value 7. The second snippet creates a new Point object with coordinates (1, 2) and assigns it to the first element of an array named \"points\".\n\nOn the right side, we see the memory representation of these arrays. The \"integers\" array, with a length of 3, is stored in the heap memory. It contains three elements, with the first element initialized to 7 and the remaining two initialized to 0. \n\nThe \"points\" array, with a length of 2, is also stored in the heap memory. The first element points to a Point object, which is stored separately in the heap memory and contains the values x=1 and y=2. The second element of the \"points\" array is initialized to null.\n\nThe stack memory stores the references to these arrays, namely \"integers\" and \"points\". \n", "Arrays (examples)\nDeclaration, Creation, Initialization\n\nThere are two code snippets, one for arrays with primitive types and one for arrays with objects, that show different ways to declare, create and initialize an array.\n\nThe first snippet shows how to declare, create and initialize an array of integers. \n- The first example shows how to declare an array variable called \"a\" of type integer, then create an array of integers of size 3 and assign it to the variable \"a\", and finally initialize the elements of the array. \n- The second example shows how to declare an array variable called \"a\" of type integer and create an array of integers of size 3 and assign it to the variable \"a\" in the same line, and finally initialize the elements of the array. \n- The third example shows how to declare an array variable called \"a\" of type integer and create an array of integers of size 3 and assign it to the variable \"a\" in the same line, and finally initialize the elements of the array using a for loop. \n- The fourth example shows how to declare, create and initialize an array of integers in the same line.\n\nThe second snippet shows how to declare, create and initialize an array of objects of type MyClass. \n- The first example shows how to declare an array variable called \"a\" of type MyClass, then create an array of MyClass of size 3 and assign it to the variable \"a\", and finally initialize the elements of the array. \n- The second example shows how to declare an array variable called \"a\" of type MyClass and create an array of MyClass of size 3 and assign it to the variable \"a\" in the same line, and finally initialize the elements of the array. \n- The third example shows how to declare an array variable called \"a\" of type MyClass and create an array of MyClass of size 3 and assign it to the variable \"a\" in the same line, and finally initialize the elements of the array using a for loop. \n- The fourth example shows how to declare, create and initialize an array of MyClass in the same line.\n", "Arrays (common errors): Declaration, Creation, Initialization\n\nThis slide explains a common error when working with arrays in Java. \n\nWe see a code snippet with a common error: an array variable is declared but not initialized, and the code attempts to print the value of its first element.\n\nThe code will not compile, as indicated by the diagram on the right, which shows the code going through a \"compile\" step that leads to \"Compilation failure\".\n\nBelow the code, there is a green rectangle with the message \"variable myArray may not have been initialized\".\n\nFinally, a red rectangle at the bottom summarizes the error: \"When an array has been declared but not created or initialized, you have no access to its elements. The program does not compile and prints an error message\". \n", "Arrays (Common errors): Declaration, creation, inicialization\n\nWe have a code snippet that shows how to declare and create arrays in Java. The code first declares six arrays, one for each of the following data types: int, float, boolean, char, String, and Object. Each array is initialized with a size of 10. The code then prints the default value for each data type. The default value for an int is 0, for a float is 0.0, for a boolean is false, for a char is a space, for a String is null, and for an Object is null. The code then has a note that states that when an array has been declared and created but not initialized, we can retrieve its elements, but they will have their default value.\n", "N-dimensional Arrays\n\nWhen we need more than one index to retrieve the elements of an array, we can use N-dimensional arrays. For example, a 2-dimensional array can be visualized as a table with rows and columns. The element in the first row and third column can be accessed using the indices [0][2]. Similarly, a 3-dimensional array can be visualized as a cube, where each element is identified by three indices: row, column, and depth. The element in the first row, third column, and second depth can be accessed using the indices [0][2][1].\n\nThe code snippets show how to declare, create, and initialize 2-dimensional and 3-dimensional arrays in a programming language. For instance, \"char a[][]\" declares a 2-dimensional array of characters, \"a = new char[3][3]\" creates a 3x3 array, and \"a[0][0]='A'\" assigns the character 'A' to the first element. Similarly, for a 3-dimensional array, \"char a[][][]\" declares it, \"a = new char[3][3][3]\" creates a 3x3x3 array, and \"a[0][0][0]='a'\" initializes the first element with 'a'.\n", "N-dimensional Arrays Examples\n\nThe image shows examples of how to create N-dimensional arrays in Java.\n\nThe first example shows how to declare and create a 2-dimensional array of Strings in one line. The array is called \"myArray\" and it's initialized with a new String array of size 3x4. The image shows a graphical representation of the array with all the values set to null.\n\nThe second example shows how to declare and create a 2-dimensional array of ints step by step. First, the array \"myArray\" is declared. Then, the reference array for rows is created with size \"numRows\". Finally, the memory for each row is allocated in a for loop, where each row has size \"numColumns\".\n\nThe last example shows three different ways to create 2-dimensional arrays of ints. The first one, \"a\", is a 3x3 array initialized to 0. The second one, \"b\", is initialized with the values 1, 2, 3 in the first row and 4, 5, 6 in the second row. The last one, \"c\", shows how to create a ragged array, where each row can have a different number of columns. In this case, the first row has 5 columns, the second row has 4 columns and the third row has 3 columns. The image shows a graphical representation of the three arrays.\n", "Arrays Homework\n\nWrite a program that multiplies two bi-dimensional arrays of integers. \n", "Method declaration\n\nThis slide explains how to declare methods in Java, using a code example of a class named \"Car\".\n\nThe code shows the structure of a class with attributes and methods.\n\nThere are two attributes declared as private: \"color\" of type String and \"speed\" of type int.\n\nThere are also three methods declared as public: \"start\" which takes no arguments and returns nothing, \"goForward\" which takes an integer \"speed\" as argument and returns nothing, and \"getColor\" which takes no arguments and returns a String.\n\nThe implementation of each method is marked as a comment \"//implementation\".\n\nThe code style recommendations for Java are listed on the right side of the slide: use intuitive names, start variable and method names with a lowercase letter, use camel case for names with multiple words, do not include blanks in names, and use indentation. \n", "Method declaration\n\nWe see a code snippet with a method declaration. The method is called goForward, it takes an integer called speed as input and returns nothing. The method is declared inside a class called Car.\n\nThe general syntax for a method declaration is: first the modifiers, then the return type, then the method name, then the parameters in parenthesis, and finally the implementation in curly braces. \n", "Method declaration\n\nWe see a code snippet showing the declaration of a method in Java. The method is named \"getColor\", it is public and returns a String. It takes no parameters. The implementation is not shown in this example, but we see a comment indicating where it should be. A diagram shows the concept of a method: it receives parameters as input and returns a result. The syntax of a method declaration is shown below the code: it consists of modifiers, a return type, a name, parameters in parentheses and a body in curly braces. \n", "Method declaration\n\nMethods have zero, one, or more arguments, also called parameters. They define the data type of the result in their declaration, except for constructors. They can have local variables, which are not initialized by default. \n\nA method cannot contain other methods inside its body.\n\nIf one method produces a result, the last sentence of its execution must be a return sentence. \n", "Constructor methods\n\n- When an object is created, its members are initialized with a constructor method.\n- Constructor methods:\n    - Have the same name as their container class.\n    - Do not have a returned data type in their declaration.\n- There should be at least one constructor per class.\n- There may be several constructors, which will be distinguished by the parameters accepted (overload).\n- If there are no declared constructors, a default constructor is created and this default constructor initializes all variables to their own default value.\n- If the class has a constructor, the default constructor does not exist, but the programmer can declare a constructor without parameters with the same function than the default one.\n", "The main method\n\n- The first method that the runtime system calls to execute an application is the main method. \n- The parameters of the main method are enclosed in parentheses after the word main. This is an array of Strings that stores the arguments that are written in the command line to run the application. For example, \"java HelloWorld arg1 arg2...\"\n- The word void before the main method indicates that there are no return values.\n- The word static indicates that it is a global method. This method is the same for every instance of the class.\n", "Systems Programming\nImperative Java\n\nDepartment of Telematic Engineering\n\nContents are mostly based on the work by M. Carmen Fern\u00e1ndez Panadero and Natividad Mart\u00ednez Madrid \n", "Scenario III: Method implementation\n\nWe have a scenario where after a programmers' meeting, the objective is to demonstrate expertise in method implementation. The first task involves implementing simple methods that function independently without invoking other attributes or methods.\n\nThe objective is to be able to break down a problem to identify the basic steps for solving it, which is essentially algorithm design and representation. It also includes using the basic structures of a programming language like variables, operators, and flow control statements such as loops and conditionals to implement an algorithm.\n\nThe work plan suggests training in the design of algorithms and their representation. This involves breaking down problems into smaller steps to solve them without writing code. It emphasizes memorizing the syntax of Java in terms of operators, loops, and conditionals. The focus is on practicing Java to implement previously designed algorithms, aiming for ease and speed in implementation. Finally, it recommends resolving typical problems related to arrays, such as printing all elements, retrieving a specific element, swapping elements between two positions, and sorting. \n", "Step I: Thinking of the algorithm\n\nWhat tools do we have to represent algorithms?\n\nOnce we have thought about the algorithm structure, we need to represent the steps to solve it:  We can use Pseudocode, flowcharts and organigrams.  Flowcharts and organigrams use figures to represent sentences and flow lines to represent the order in which they are executed. \n", "Step I: Thinking of the algorithm Flowcharts vs Pseudocode\n\nWe can see two different ways of representing an algorithm: a flowchart on the left and pseudocode on the right.\n\nThe flowchart describes the steps to fix a lamp:\n- It starts with the question \"Lamp doesn't work?\".\n- If the answer is yes, then it asks if the \"Lamp plugged in?\".\n- If not, then \"Plug in lamp\".\n- If yes, then it asks if the \"Bulb burned out?\".\n- If yes, then \"Replace bulb\".\n- If not, then \"Repair lamp\".\n\nThe pseudocode describes the steps to play the game \"One Potato, Two Potato\":\n- It starts with gathering all players in a circle.\n- Then, players put both fists in the circle.\n- A player is chosen to be the counter.\n- The counter begins chanting and repeats until one fist is left.\n- The counter repeats 8 times, hitting one fist at a time.\n- If the count is 1-3 or 5-7, the counter says the count plus \"potato\".\n- If the count is 4, the counter says \"Four!\".\n- If the count is 8, the counter says \"More!\", the current fist is taken out, the chant restarts on the next fist, and 1 is added to the count.\n- If there is only one fist left, that player is \"it\".\n- The game ends.\n\nThere is also a flowchart at the bottom center of the image. It describes an algorithm to calculate the factorial of a number:\n- It starts with reading the input number N.\n- Then, it initializes two variables: M=1 and F=1.\n- It enters a loop that continues as long as M is not equal to N.\n- In the loop, it multiplies F by M and stores the result in F.\n- Then, it increments M by 1.\n- Once the loop ends, it prints the value of F, which represents the factorial of N.\n- Finally, the algorithm ends.\n", "Step II: Algorithm implementation\n\nThis slide presents the different types of expressions that can be used in a method body.\n\nIt is structured in 4 sections: Variables, Operators, Operations with objects, and Flow control structures.\n\nVariables and Operators are not detailed, it is simply stated that they can be used.\n\nOperations with objects are not considered for this specific scenario, but the slide mentions Object creation as well as Attribute and method invocation.\n\nFinally, Flow control structures, which can be stacked and nested, are listed as follows:\n- Sequence\n- Iteration (loops): For, While, Do-while\n- Selection (conditionals): If, If-else, Switch\n- Breaking up the flow of execution: Break, Continue, Exception (not in this scenario) \n", "Operators\n\nThis slide lists different types of operators. \n\nOperators can be classified by the number of operands:\n- Unary operators: they take one operand, for example: ++, --\n- Binary operators: they take two operands, for example: &&, %\n\nOperators can also be classified by type:\n- Assignment: =\n- Arithmetical: +, -, *, /, %\n- Relational: >, >=, <, <=, ==, !=\n- Logical: &&, ||, !\n- Conditional: condition ? sentence1 : sentence2\n\nThere is an example of a conditional operator:\nSystem.out.println( studentGrade >= 5 ? \"pass\" : \"not pass\");\n", "Operators\nNotes to remember\n\n- Unary operators: \n  -  \"i++\" first evaluates then increments.\n  - \"++i\" first increments then evaluates.\n  - Example: if i equals 3, \"a equals i++\" results in a equals 3, while \"a equals ++i\" results in a equals 4.\n- Binary operators can be abbreviated: \"x+=3\" equals to \"x = x+3\".\n- Assignment vs. comparison:\n  - The \"=\" operator assigns a value. Example: \"var = 5\" assigns 5 to the variable var.\n  - The \"==\" operator compares. Example: \"var == 5\" returns true after the previous assignment.\n- The conditional operator is harder to understand than a simple if-else statement. Try not to use it.\n", "Selection sentences (Conditionals)\n\nWe have three code snippets that show different conditional statements.\n\nThe first one is an \"if\" statement. If the condition is true, the sentences1 will be executed.\n\nThe second one is an \"if-else\" statement. If the condition is true, the sentences1 will be executed. Otherwise, the sentences2 will be executed.\n\nThe third one is a \"switch\" statement. It evaluates an expression and executes the sentences associated with the matching case value. If no case value matches the expression, the default sentences will be executed. Each case block should end with a \"break\" statement to prevent the execution from falling through to the next case. \n", "Selection sentences\nNotes to remember for if and if-else\n\n- Indenting the code contributes to its readability\n- Braces { } fix the scope of every element declared between them\n- No braces is like to put them only in the first sentence\n\nWe can see a code snippet:\n\n```java\nif (studentGrade >= 5)\n  System.out.println ( \"Pass\" );\nelse\n  System.out.println(\"Not pass\");\n```\n\nThis code snippet checks if the variable `studentGrade` is greater than or equal to 5. If it is, it prints \"Pass\" to the console. Otherwise, it prints \"Not pass\" to the console. \n", "Selection sentences\nNotes to remember for switch\n\nValid expression types are: byte, short, int, long, char, String.\n\nSome examples are: int num equals 5 and then switch num, char character equals 'z' switch character, String string equals \"myString\" switch myString.\n\nIf you do not use breaks, all the following code blocks will be executed until a break or end of the switch is found.\n\nIt is not necessary to place the block code associated with each case between braces. \n", "Iteration sentences (Loops)\n\nWe have three code snippets, all of them showing different loop syntax:\n\n- The first one is a **for loop**:\n```\nfor( initialization;condition;update) {\nsentences;\n}\n```\n- The second one is a **while loop**:\n```\nwhile( condition) {\nsentences;\n}\n```\n- The third one is a **do-while loop**:\n```\ndo {\nsentences;\n}while(condition);\n```\n", "Iteration sentences (Examples: for)\n\nThere are 5 code snippets, each showing a for loop in C.\n\n- The first snippet initializes an integer \"i\" to 0. The loop iterates as long as \"i\" is less than 10. In each iteration, \"i\" is incremented by 2.\n\n- The second snippet initializes an integer \"i\" to 0. The loop iterates as long as \"i\" is less than 10, incrementing \"i\" by 1 in each iteration. However, the initial value of \"i\" is 13, which is already greater than 10. Therefore, the loop will not execute.\n\n- The third snippet initializes an integer \"i\" to 4. The loop iterates as long as \"i\" is less than 10. In each iteration, \"i\" is incremented by 2.\n\n- The fourth snippet initializes an integer \"i\" to 0. The loop iterates indefinitely because there is no condition specified in the for loop. In each iteration, \"i\" is incremented by 2.\n\n- The fifth snippet initializes two integers, \"i\" to 0 and \"sum\" to 5. The loop iterates as long as \"i\" is less than 10. In each iteration, \"sum\" is incremented by the value of \"i\", and then \"i\" is incremented by 8.\n\nThe question asks how many times each loop is executed and the value of \"i\" at the end of each loop.\n", "Iteration sentences (Examples: for)\n\nThe most often used iteration is the 'for' loop. The syntax is the following: 'for' open parenthesis, 'int' 'i' equals '0' semicolon, 'i' less than '5' semicolon, 'i' plus plus, close parenthesis. Then, between curly brackets, '//'sentences. \n", "Iteration sentences\nNotes to remember\n\n- When the loop has several sentences in initialization comparison or update they will be separated by commas An example of for loop with multiple statements is shown with the syntax for i equal to zero sum equals zero i less than or equal to n i plus plus comma sum plus equal to n Inside the for loop body we have sentences and the for loop is closed\n- Nested loops Program slows down They are used to cover n dimensional arrays one loop per dimension\n- The sentences in a while might never run in a do while sentences are executed at least once\n- Avoid infinite loops always check termination condition\n- A for loop always can be converted into a while loop and vice versa \n", "Iteration sentences\nComparative\n\nThis slide compares three different types of loops: for, while, and do-while.\n\nThe table shows that the \"for\" loop is the only one that initializes variables and updates them within the loop definition. All three loops have a condition that determines whether the loop continues to execute. The \"do-while\" loop is the only one that is guaranteed to execute at least once, because the condition is checked at the end of the loop.\n\nThe table also shows that the \"for\" loop is the most commonly used type of loop, followed by the \"while\" loop. The \"do-while\" loop is used less often.\n", "Iteration sentences\nUsage patterns\n\nThis slide describes when to use \"while\" and \"for\" loops.\n\nIf the number of iterations is known, for example when iterating over an array, we should use a \"for\" loop.\nIf the number of iterations is unknown, we should use a \"while\" loop.\nIf we need to increase variables in each cycle, we can use both \"for\" and \"while\" loops.\nIf we need to initialize variables, we can use both \"for\" and \"while\" loops.\n\nThe slide ends with two examples:\n- Reading a file with a \"while\" loop.\n- Covering an array with a \"for\" loop.\n", "Breaking up the flow of execution: Break sentence\n\nThis slide explains the break statement in programming.\n\n- The break statement causes the execution to break and exit the structure in a while, for, do-while or switch statement.\n\nThere is a code example that shows how the break statement works:\n\n```java\nint j=0;\nwhile(j<10){\n  j++;\n  break;\n  System.out.println(\"This message is never printed\");\n}\nSystem.out.println(\u201cj = \"+j);\n```\n\nThe loop runs only once and prints the message \"j = 1\" because the break statement is executed after the first iteration, which exits the loop.\n", "Breaking up the flow of execution: Continue sentence\n\nThis slide explains how to use the continue sentence in Java.\n\n- The continue sentence can be used in while, for or do-while blocks of code.\n- When it is executed, it skips the rest of the sentences in the block and continues with the next iteration.\n\nThe slide includes a code example to illustrate this:\n\n```java\nint j=0\nwhile(j<10){\n  j++;\n  continue;\n  System.out.println(\"This message is never printed\");\n}\n```\n\nIn this example, the message \"This message is never printed\" will never be printed because the continue sentence will always be executed before it.\n\nThe slide concludes by stating that the message is never printed.\n", "Implementing a method: Step 1.1: Think about the algorithm\n\nWe are looking at the first step in implementing a method to determine if a number is prime. The first step is to think about the algorithm.\n\nThe problem is to write a program that calculates whether a number n is prime.\n\nThe first step in thinking about the algorithm is to split the problem into simpler steps. We start by checking if each number from 2 to n/2 is an integer divisor of n. We only need to repeat this process until we find an integer divisor or until we reach n/2. To control the loop, we will use a sentinel, which is a Boolean variable. \n", "Implementing a method: Step 1.2: Represent the algorithm\n\nThe image shows a flowchart. \n- The first step is a rectangular box that sets the value of a variable named \"divisor\" to 2 and the value of a variable named \"isPrime\" to true. \n- Then, there is a diamond-shaped box that checks if the value of \"divisor\" is less than half the value of \"n\" and if \"isPrime\" is true. \n- If both conditions are true, the flow continues to another diamond-shaped box that checks if the remainder of the division of \"n\" by \"divisor\" is equal to 0. \n- If the remainder is 0, the flow continues to a rectangular box that sets \"isPrime\" to false. \n- If the remainder is not 0 or if either of the conditions in the first diamond-shaped box is false, the flow continues to a rectangular box that increments the value of \"divisor\" by 1. \n- Finally, the flow goes back to the first diamond-shaped box to repeat the process. \n", "Implementing a method:\nStep 2: Write the code\n\nThis slide shows a code snippet of a method written in Java that determines if a given number is a prime number. \n\nThe method is called \"Is A Prime Number\" and takes an integer called \"number\" as input. It initializes an integer variable called \"divisor\" to 2 and a boolean variable called \"isPrime\" to true. \n\nThe code then enters a while loop that continues as long as the divisor is less than half of the number and isPrime is true. Inside the loop, it checks if the number is divisible by the divisor. If it is, it sets isPrime to false and increments the divisor. \n\nAfter the loop, the code prints the number to the console and then checks the value of isPrime. If it's true, it prints \"is prime\", otherwise it prints \"is not prime\". Finally, the method returns the value of isPrime. \n", "Implementing a method:\nExamples: working with arrays\n\nThis slide presents several practice exercises related to implementing methods for working with arrays. The exercises include: printing an array using loops, retrieving a specific element from an array using conditionals and nested loops, comparing elements in an array using different data types (numbers, characters, booleans, strings, and objects), swapping two elements in an array using auxiliary variables, and sorting an array by copying elements between two arrays. \n", "Review\nLearning outcomes\n\nAfter this session you must be able to install and configure an environment to work with Java, understand a program with several files, be able to draw a class diagram, and identify the first method that the runtime system calls to execute the program. \n\nYou must also be able to identify basic structures associated with classes and objects such as declarations of: classes, members, attributes, basic types, reference types, methods, main, constructors, and regular methods. \n\nFinally, you must be able to design and implement simple algorithms inside the body of a method using operators and basic control structures such as loops and conditionals. \n"]}, {"filename": "2. OO.pdf", "text": "Systems Programming\n\nObject-Oriented Programming\n\nDepartamento de Ingenier\u00eda \nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero, Raquel M. Crespo Garc\u00eda\n\nCarlos Delgado Kloos, Natividad Mart\u00ednez Madrid,                                        \n\nCarlos Alario Hoyos, Julio Villena Rom\u00e1n\n\n\fSystems Programming\n\nObject-BASED Programming\n\nDepartamento de Ingenier\u00eda \nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero, Raquel M. Crespo Garc\u00eda\n\nCarlos Delgado Kloos, Natividad Mart\u00ednez Madrid,                                        \n\nCarlos Alario Hoyos, Julio Villena Rom\u00e1n\n\n2\n\n\fKey terms\n\n\u2022 Object and Class\n\u2022 State and Behavior\n\u2022 Attribute and Method\n\u2022 Data abstraction vs Functional abstraction\n\u2022 Private / Public (attribute / method + class)\n\u2022 Message passing\n\u2022 Overloading (method)\n\u2022 Constructor (method)\n\u2022 Static (attribute / method)\n\u2022 Get / Set (method)\n\u2022 Package\n\n3\n\n\fScenario IV: \nDeclare and implement a class\n\n\u2022 Now that you know how to read code and implement your own \n\nmethods you will have to design a new class in order to create a \nnew data type with its characteristics and behavior. \n\n\u2022 Objective: \n\n\u2013 Be able to declare a class with a set of characteristics (attributes) and \n\nbehavior (methods)\n\n\u2013 Be able to create objects and modify or restrict access to their state and \n\ntheir behavior\n\n\u2022 Work plan: \n\n\u2013 Memorize the basic nomenclature of the object-oriented programming \n\u2013 Practice modeling objects with simple examples to distinguish between a class, an \n\nobject, its state and behavior\n\n\u2013 Review the Java syntax for declaring classes, attributes, constructors and methods\n\u2013 Review the mechanism and syntax for message passing between objects\n\n4\n\n\fObjectives\n\n\u2022 Define basic concepts of object-based\n\nprogramming\n\u2013 Classes, objects\n\u2013 Members (attributes, methods)\n\u2013 Abstraction and Information hiding\n\n\u2022 Describe the relationship between object \n\nand class\n\n\u2022 Create a simple object and be able to model:\n\n\u2013 its characteristics (with attributes)\n\u2013 its behavior (with methods)\n\n5\n\n\fContents\n\n\u2022 Classes and Objects\n\n\u2022 Object encapsulation\n\n\u2013 Functional abstraction\n\n\u2013 Data abstraction\n\n\u2022 Class members (attributes and methods)\n\n\u2022 Message passing\n\n\u2022 Overloading\n\n\u2022 Constructors\n\n\u2022 Modifiers and access\n\n\u2022 Packages\n\n6\n\n\fWhat is an object?\n\n\u2022 Objects are (simple/complex) (real/imagined) \n\nrepresentations of things: clock, airplane, bird, etc.\n\n\u2022 Not everything can be considered as an object, \n\nsome things are simply characteristics or attributes\nof the objects: color, speed, etc.\n\n7\n\n\fWhat is an object?\n\n\u2022 Functional abstraction\n\u2013 Things that we know that \n\n\u2022 Data abstraction\n\n\u2013 Properties (attributes) \n\ncars do:\n\nq advance\nq stop\nq turn right\nq turn left\nq \u2026\n\nof a car:\nq color\nq speed\nq size\nq \u2026\n\n8\n\n\fWhat is an object?\n\n\u2022 It is a way to group a set of data (state) \nand functionality (behavior) in the same \nblock of code, which can then be \nreferred to from other parts of a \nprogram\n\n\u2022 The class to which the object belongs \ncan be considered a new data type\n\n9\n\n\fExample\n\nClass\n\nObjects\n\nAttributes\n(state)\n\nSpecial method: \nConstructor\n\nMethods\n(behavior)\n\n\u2022 new operator to create instances\n\u2022 this reference the the object of the current class\n\u2022 public/private access modifiers\n\n10\n\n\fExercise 1\n\n\u2022\n\nImplement the class Bicycle, which has three \nattributes, speed, cadence and gear, of type \ninteger and four methods speedUp(), brake(), \nsetCadence(int newCadence), and \nsetGear(int newGear), where the first method \ndoubles the current speed, the second method halves the \ncurrent speed, and the third and fourth methods set the \ncadence and gear according to the arguments received. \nThe class must have a constructor which initializes all \nthe attributes. \n\n\u2022 Create two objects of this class: myBicycle and \n\nyourBicycle\n\n11\n\n\fObject encapsulation\n\n\u2022 Encapsulation: explains the links between \n\nbehavior and state to a particular object\n\n\u2022 Information hiding: Defines which parts of the \nobject are visible (the public interface) and which \nparts are hidden (private)\n\n\u2022 The ignition key is a public interface mechanism to \nstart a vehicle\n\n\u2022 The implementation of how to really start a car is  \nprivate. We only can access this information using the \nignition key\n\ns\n\nP r o\n\nThe object may change but its public interface remains compatible \nwith the original. This fact facilitates code reuse\n\n12\n\n\fObject encapsulation\n\nCLASS MEMBERS\n\nObjects encapsulate attributes, allowing access to them \n\nonly through methods\n\n\u2022 Attributes (Variables): Containers of values\n\n\u2022 Methods: Containers of functions\n\nAn object has:\n\n\u2022 State: represented by the values of its attributes\n\n\u2022 Behavior: defined by its methods\n\nUsually:\n\n\u2022 Methods are public\n\n\u2022\n\n\u2022\n\n\u2022\n\nAttributes are private\n\nThere can be private methods\n\nIt is dangerous to have public attributes \n\n13\n\n\fObject Definition\n\nPublic Members\n\u2022 Public members \n\n(describe what an \nobject can do)\n\u2013 What it can do \n\n(methods)\n\u2013 What it is (its \nabstraction)\n\nPrivate Members\n\u2022 How the object does its \n\nwork (how it is \nimplemented)\n\u2013 For example, the ignition key \n\ninteracts with the electric circuit \nof the vehicle, the engine, etc.\n\n\u2013 In pure object-oriented \n\nsystems, state is completely \nprivate and can only be \nmodified through the public \ninterface\n\n\u2013 E.g.: public method brake()\ncan change the value of the \nprivate attribute speed\n\n14\n\n\fInteractions between objects\n\n\u2022 Object modeling describes:\n\n\u2013 Objects and\n\u2013 Their interrelations\n\n\u2022 To do a task, an object can delegate some \n\nwork to another object, which can be a part of \nitself, or any other object in the system\n\n\u2022 Objects interact with each other by sending \n\nmessages\n\n15\n\n\fMessage passing\n\ne\nc\na\nf\nr\ne\nt\nn\ni\n\nc\ni\nl\nb\nu\nP\n\nImplementation\n\nstart\n\n\u2022 An object sends a message to another object\n\nBy calling a method (method call / method invocation)\n\n\u2022 Messages are handled by the public interface of the receiving object\n\nWe can only call methods from another object that are public or accessible from \nthe calling object\n\n\u2022 The receiving (called) object will react:\n\n\u23bb Changing its state, i.e., modifying its attributes, and/or\n\n\u23bb Sending other messages, i.e., calling other (public or private) methods from the \nsame object (from itself) or calling other methods from other objects (public or \naccessible from that object)\n\n16\n\n \n\fExample\n\nClass Car\n\nClass Engine\n\nClass Wheel\n\n17\n\n\fClassification of objects\n\n\u2022 Class: Set of objects with similar states and \n\nbehaviors\n\u2013 We can refer to the \u201cCar\u201d class (any instance in \n\nthe classification of cars)\n\n\u2022 \u201cmyCar\u201d is an object, i.e. a particular  \n\ninstance of the Car class \n\n\u2022 The class to which the object belongs is \n\nconsidered as a new data type\n\n18\n\n\fObjects vs. Classes\n\nIt is a kind of data classification\n\nA class is an abstract entity\n\u2022\n\u2022 Defines the behavior and attributes of a group of \nobjects with similar structure and similar behavior\n\nClass car\nMethods: start, advance, stop, ...\nAttributes: color , speed, etc.\n\nClass name\nMethods (functions)\nAttributes (data)\n\nAn object is an instance of a class\n\u2022 An object can be distinguished from other members of the class \n\nby the value of its attributes\n\nObject myFerrari\nBelongs to the \nclass Car\n\nName: myFerrari\nMethods: start, advance, stop, ... \nAttributes : color = \u201cred\u201d; \n\nspeed = 300Km/h\n\n\u2022 A  class is declared, an object is created\n\n19\n\n\fOverloading\nWhat is it?\n\n\u2022 Two methods with the same name can be \n\ndefined in the same class if they have \ndifferent parameters\n\n\u2022 It is widely used for constructors\n\u2022 The method actually executed depends on \nthe parameters passed when it is called\n\n20\n\n\fOverloading\nWhat is it used for?\n\nClass\n\nObjects\n\nOverload\n\nAlthough they have equal names,       \nthey are two different methods, because \nthey have different parameters\n\n21\n\n\fExercise 2\n\n\u2022\n\nIn the class Bicycle, implement the \noverloaded methods setCadence(), and \nsetGear(), which do not receive arguments \nand change the values of cadence and gear to \none value by default: 1.\n\n22\n\n\fConstructors\n\n\u2022 When an object is created, its members are initialized \n\nusing a constructor method\n\n\u2022 Constructors:\n\n\u2013 Have the same name as the class\n\u2013 They have no return type (not even void)\n\n\u2022 At least one constructor should be defined per class\n\u2022 Several constructors can exist, and they are distinguished \n\nby their parameters (overloading)\n\n\u2022 A default constructor without parameters, which initializes \nthe attributes to their default values, is created if no explicit \nconstructors are defined, \nIf there is a constructor in the class, the default constructor \nno longer exits. In that case, if a constructor without \nparameters is desired, it needs to be explicitly declared\n\n\u2022\n\n23\n\n\fConstructors\n\nClass Car\n\nArray of objects of the Class Car\n\nOverload of \nconstructors\n\n24\n\n\fExercise 3\n\n\u2022\n\nIn the class Bicycle, implement an additional \nconstructor, which does not receive arguments, \nand that initializes the speed to 0, and the \ncadence and gear to 1. \n\n25\n\n\fModifiers and access\nStatic (static members)\n\n\u2022 static modifier\n\u2022 Static members exist only once per class, \n\nindependently of the number of instances (objects) of \nthe class that have been created or even if there no \ninstances have been created yet.\n\n\u2022 The method or attribute behaves always in the \n\nsame way\n\n\u2022 Static members can be accessed using the class \n\nname.\n\n\u2022 A static method cannot access non-static members \n\ndirectly; an object must be created first.\n\n26\n\n\fModifiers and access\nStatic (static members)\n\nStatic attribute\n\n\u2026\n\nstatic attribute\n\nOther examples\n\n=>  -231\n=>  231-1\n\nStatic method: It has access to static attributes.\nWe do not need to create instances\n\nhttps://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Math.html\n\n27\n\n\fModifiers and access\nStatic. Some rules\n\n\u2022 Static members are invoked with:\n\nClassName.staticMethod();\nClassName.staticAttribute;\n\n\u2022 Non static members require an instance (object) in order to be \n\naccessed.\n\nClassName objectName = new ClassName();\n\n\u2022 Non static members are invoked with:\nobjectName.normalMethod();\nobjectName.normalAttribute;\n\n\u2022 When a static member is invoked (called) from inside the same \n\nclass, the class name can be deleted. We can write:\ninstead of:\n\nstaticMethod();\nstaticAttribute;\n\nClassName.staticMethod();\nClassName.staticAttribute;\n\n28\n\n\fAccess\nget() and set() methods\n\n\u2022 Attributes in a class are typically private to avoid their access \n\nand modification from any other class.\n\n\u2022 Sometimes we want some classes to access the attributes\n\u2022 get() and set() methods to control access\n\n29\n\n\fExercise 4\n\n\u2022\n\nIn the class Bicycle, implement the \nnecessary get() and set() methods which \nallow accessing and modifying all the \nattributes. \n\n30\n\n\fPackages\n\n\u2022 A package groups classes (and interfaces)\n\u2022 Hierarchies in a package correspond to the hierarchies \n\nof folders in disk\n\n\u2022 Dots are used for referring to subpackages, classes \n\n(and interfaces) in a package\n\u2013 E.g.: When we import mathematical classes\nimport java.math.BigDecimal;\n\n\u2013 The BigDecimal class is in the java/math folder of the JDK\n\u2013 We do not need to import all the classes: e.g., java/lang\n\n\u2022 String\n\u2022 Integer\n\u2022 NullPointerException\n\u2022 ArrayIndexOutOfBoundsException\n\n31\n\n\fPackages\n\n\u2022 Creating my own packages\n\n\u2013 Save the classes in a folder named as the package\n\u2013 All classes belonging to the package must include the following \n\nsentence as the first one:\n\npackage myOwnPackage;\n\n\u2013 In the class using the package, the corresponding import \nsentence must be included before the class declaration\n\nimport myOwnPackage.Class1; // import one class\n\nimport myOwnPackage.*; // all the classes in the package\n\n32\n\n\fSummary of elements in a program\n\nProgram\n\nClasses (.java files)     \n(organized in packages)\n\nClass members\n\nAttributes\n\nMethods\n\nPrimitive \ntype\n\nReference   \n\ntype\n\nRegular \nmethods\n\nSpecial \nmethods\n\nObjects\n\nArrays\n\nConstructor Main\n\nString\n\n33\n\n\fSummary of modifiers (so far)\n\nMODIFIERS\n\nclass\n\nmethod\n\nattribute\n\npublic\n\n(friendly)\n\nprivate\n\nstatic\n\na\nc\nc\ne\ns\ns\n\no\nt\nh\ne\nr\n\nAccessible from any other class\n\nAccessible only to classes from the same package\n\nApplied to inner classes\n\nAccessible only inside the class\n\nMaximum level class.\n\nIt is the same for all the \nclass objects.\nUse: \n\nIt is the same for all the class \nobjects.\nUse: \n\nClassName.method ();\n\nClassName.attribute;\n\n34\n\n\fSystems Programming\n\nObject-ORIENTED programming \n(basic)\n\nDepartamento de Ingenier\u00eda \nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero, Raquel M. Crespo Garc\u00eda\n\nCarlos Delgado Kloos, Natividad Mart\u00ednez Madrid,                                        \n\nCarlos Alario Hoyos, Julio Villena Rom\u00e1n\n\n35\n\n\fKey terms\n\n\u2022\n\nInheritance\n\u2013 Naming\n\nq Generalization vs. specialization\nq Superclass vs. subclass\nq Parent class vs, child class\nq Base class vs. derived class\n\n\u2013 Java syntax\nq extends\nq super\nq protected\nq final\n\n\u2013 Java Hierarchy\n\u2013 Overriding\n\u2013 Constructors\n\u2013 Polymorphism\n\n36\n\n\fSome classes so far\u2026\n\nCar\n\nBicycle\n\nAttributes\n\nAttributes\n\nMethods\n\nMethods\n\n\fScenario V: \nReusing code. Inheritance\n\n\u2022 Once you can create your own classes, you are ready to work in teams \n\nand reuse code developed by your colleagues. Your team will provide you \nwith a set of classes and you are required to create specializations or \ngeneralizations of them.\n\n\u2022 Objective: \n\n\u2013 Be able to create a derived class adding some characteristics (attributes) and \n\nbehavior (methods) to an existing class. \n\n\u2013 Be able to extract all the common code from a set of similar classes in order to \n\ngroup it into a new parent class so that the code is easier to maintain.\n\u2013 Be able to create objects, and reference and access their attributes and \nmethods, depending on their position in the inheritance hierarchy and their \nmodifiers.\n\u2022 Work plan: \n\n\u2013 Memorize the naming related to inheritance\n\u2013 Memorize the Java syntax related to inheritance (extends), to reference (super, this) and \n\nto advanced access modifiers (protected). \n\n\u2013 Know basic inheritance mechanisms, such as attribute hiding, overriding of methods, and \n\nwhat they are used for and how they are used. \n\n38\n\n\fContents\n\n\u2022 Basic inheritance concepts\n\u2022 Inheritance hierarchy\n\u2022 Overriding I: Attribute Hiding\n\u2022 Overriding II: Method Overriding\n\u2022 Constructors of derived classes\n\u2022 Polymorphism\n\u2022 The final modifier\n\n39\n\n\fInheritance\nWhat is it? What is it for?\n\n\u2022 Mechanism for software reuse\n\u2022 Allows defining related classes from a given class \n\nas a:\n\u2013 Specialization of the given class. (e.g., \u201cCar\u201d class is a \n\nspecialization of the class \u201cVehicle\u201d)\n\n\u2022 Scenario: We must implement a new class that is very similar to a previous \n\none, but it needs additional information (characteristics and behavior)\n\u2022 Solution: Create a class that derives from the old one, and add it new \n\nfunctionality without having to rewrite the common code\n\n\u2013 Generalization of the given class (e.g., the \u201cVehicle\u201d class \n\nis a generalization of the \u201cCar\u201d class)\n\n\u2022 Scenario: We have a set of similar classes with code that is repeated in every \nclass and thus difficult to update and maintain (e.g., a letter should be added to \nthe serial number)\n\n\u2022 Solution: Move the code that is repeated to a single place (the parent class)\n\n40\n\n\fInheritance\nWhat is it?\n\nN o in h erita n ce\n\nResource\n\u2022 name\n\u2022 description\n\u2022 getName()\n\u2022 getDescription()\n\nResource\n\u2022 name\n\u2022 description\n\u2022 getName()\n\u2022 getDescription()\n\nI\n\nn\n\nh\n\ne\n\nrit\n\na\n\nn\n\nc\n\ne\n\nClassroom\n\u2022 name\n\u2022 description\n\u2022 location\n\u2022 getName()\n\u2022 getDescription()\n\u2022 getLocation()\n\nComputer\n\u2022 name\n\u2022 description\n\u2022 operatingSystem\n\u2022 getName()\n\u2022 getDescription()\n\u2022 getOS()\n\nClassroom\n\u2022 location\n\u2022 getLocation()\n\nComputer\n\u2022 operatingSystem\n\u2022 getOS()\n\npublic class Classroom extends Resource\n\npublic class Computer extends Resource\n\nThe attributes and methods that appear in blue in the parent class are repeated in the \nsubclasses. (Left picture)\nIt is not necessary to repeat the code, you only have to say that a class extends the other or \ninherits from it. (Right picture)\n\n41\n\n\fInheritance\nNaming\n\n\u2022 If we define the Car class from the Vehicle class, \n\nit is said that:\n\u2013 Car inherits attributes and methods from Vehicle\n\u2013 Car extends Vehicle\n\u2013 Car is a subclass of Vehicle\n\nDerived class\nChild class\n\n\u2013 Vehicle is a superclass of Car\n\nBase class\nParent class \n\n\u2022 Inheritance implements the is-a relation \n\u2013 A car is-a vehicle; a dog is-a mammal, etc.\n\n42\n\n\fInheritance\nDeclaration of subclasses\n\n\u2022 The syntax for declaring subclasses is:\n\nclass Subclass extends Superclass { ... }\n\nPerson\n\nStudent\n\nEmployee\n\nclass Person { ... }\n\nclass Student extends Person { ... }\n\nclass Employee extends Person { ... }\n\nclass Professor extends Employee { ... }\n\nclass Secretary extends Employee { ... }\n\nProfessor\n\nSecretary\n\nEach class in a different file and declared as public\n\n43\n\n\fInheritance\nSubclass\n\nAttributes\n\nMethods\n\nprint\n\nfirstName\n\nlastName\n\nbirthYear\n\nInherited from class Person\n\ngroup\n\ntimetable\n\nClass Student\n\nsetGroup\n\nsetTimetable\n\nprintGroup\n\n44\n\n\fInheritance\nHow is it used?\n\npublic class Person {\n\nprotected String firstName;\nprotected String lastName;\nprotected int birthYear;\n\npublic Person () {\n}\npublic Person (String firstName, String lastName, \n\nint birthYear){\n\nthis.firstName = firstName;\nthis.lastName = lastName;\nthis.birthYear = birthYear;\n\n}\n\npublic void print(){\n\nSystem.out.print(\"Personal data: \" + firstName \n\n+ \" \" + lastName + \" (\u201c\n+ birthYear + \")\");\n\n}\n\n}\n\nprotected \naccessible from \nsubclasses\n\n45\n\n\fInheritance\nHow is it used?\n\npublic class Student extends Person {\n\nprotected String group;\nprotected char timetable;\n\npublic Student() {}\n\npublic Student(String firstName, String lastName, \n\nint birthYear, String group, char timetable) {\n\nsuper(firstName, lastName, birthYear);\nsetGroup(group);\nsetTimetable (timetable);\n\n}\n\npublic void setGroup(String group){\n\nif (group == null || group.length() == 0){\nSystem.out.println (\"Invalid group\");\n\n} else { this.group = group; }\n\n}\npublic void setTimetable(char timetable){\n\nif (timetable != 'M' && timetable != 'A'){\nSystem.out.println (\"Invalid group\");\n\n} else { this.timetable = timetable; }\n\n}\npublic void printGroup(){\n\nSystem.out.print(\" Group \" + group + timetable);\n\n}\n\n}\n\nsuper \nto access attributes or \nmethods from the \nsuperclass\n\n46\n\n\fInheritance\nHow is it used?\n\npublic class Test {\n\npublic static void main (String[] args){    \n\nPerson neighbor = new Person (\"Luisa\", \"Asenjo Mart\u00ednez\", 1978);\nStudent aStudent = new Student (\"Juan\", \"Ugarte L\u00f3pez\", 1985,  \n\n\u201c65\u201d, \u2018A');\n\naStudent.setGroup(\"66\");\naStudent.setTimetable('M');     \nneighbor.print();\naStudent.print();\naStudent.printGroup();\n\n}\n\n}\n\nOutput on screen:\n\nPersonal data: Luisa Asenjo Mart\u00ednez (1978)\nPersonal data: Juan Ugarte L\u00f3pez (1985)\nGroup 66M\n\n47\n\n\fInheritance\nWhat if\u2026?\n\n\u2022 We define the attribute firstName of Person as \n\nprivate.\n\u23bb We inherit it, but we cannot access it, unless we implement \n\nmethods to do so (e.g., getFirstName())\n\u2022 We implement the constructor of the subclass \n\nStudent assigning the values directly to attributes \ninstead of calling to super\n\u23bb Not taking advantage of code reuse \n\u23bb It is valid in this case because attributes are defined as \n\nprotected (but this is not always the case!!)\n\npublic Student(String firstName,     \n\npublic Student(String firstName,     \n\nString lastName, int birthYear,    \nString group, char timetable){\n\nString lastName, int birthYear,    \nString group, char timetable){\n\nthis.firstName = firstName;  \nthis.lastName = lastName;\nthis.birthYear = birthYear;\n\nsuper(firstName, lastName, birthYear);\n\nthis.group = group;\nthis.timetable = timetable; \n\nthis.group = group;\nthis.timetable = timetable; \n\n}\n\n}\n\n\fInheritance\nConsequences of extension of classes\n\n\u2022\n\n\u2022\n\nInheritance of the interface\n\u23bb The public part of the subclass contains the public \n\npart of the superclass. The Student class \ncontains the method print()\n\nInheritance of the implementation\n\u23bb The implementation of the subclass contains the \n\nimplementation of the superclass. When calling \nthe method of the superclass on an object of the \nsubclass (aStudent.print()) the expected \nbehavior takes place\n\n49\n\n\fExercise 5\n\n\u2022\n\n\u2022\n\n\u2022\n\u2022\n\nStarting from the class Bicycle, which has three \nattributes, speed, cadence and gear, of type integer \nand four methods speedUp(), brake(), \nsetCadence(int newCadence), and \nsetGear(int newGear), implement the classes \nMountainBike and TandemBike.\nMountainBike has an attribute suspension of type \ninteger, and a method setSuspension(int\nsuspension)\nTandemBike has an attribute numSeats of type integer.\nProgram the constructors of these classes to initialize all \ntheir attributes, making use of super\n\n50\n\n\fInheritance\nInheritance hierarchy in Java\n\n\u2022 In Java, all classes are related through a \n\nsingle inheritance hierarchy\n\n\u2022 A class can:\n\n\u23bb Explicitly inherit from another class, or\n\u23bb Implicitly inherit from the Object class \n\n(defined in the Java core) \n\n\u2022 This is the case both for predefined \nclasses and for user-defined classes\n\n51\n\n\fInheritance\nInheritance hierarchy in Java\n\nObject\n\nBoolean\n\nCharacter\n\nNumber\n\nString\n\nPerson\n\n\u2026\n\nInteger\n\nLong\n\nFloat\n\nDouble\n\nStudent\n\nEmployee\n\nSecretary\n\nProfessor\n\nInteger i = new Integer(3); // Deprecated (Warning)\nInteger i = 3; // Autoboxing\n\n52\n\n\fInheritance\nOverriding\n\n\u2022 Modification of the elements of the base \n\nclass inside the derived class\n\u2022 The derived class can define:\n\n\u2013 An attribute with the same name as one of \n\nthe base class \u2192 Attribute hiding\n\n\u2013 A method with the same signature as one \nof the base class \u2192 Method overriding\n\n\u2022 The second case is more usual\n\n53\n\n\fOverriding I (Shadowing)\nAttribute hiding\n\n\u2022 If we define an attribute (variable) in a \n\nsubclass with the same name and type that \nanother attribute in the superclass, the \nvariable in the superclass remains hidden\n\u2022 We can access one variable or the other \n\nusing  this and super.\n\n54\n\n\fOverriding I (Shadowing)\nAttribute hiding\n\nAttributes\n\nMethods\n\nStudent s = new Student(...);\nSystem.out.println(s.firstName);\n\nprint()\n\nfirstName\nfirstName\n\nlastName\n\nyearBirth\n\nPerson p1 = new Person(...);\nSystem.out.println(p1.firstName);\n\nInherited from class Person\n\nPerson p2 = s;\nSystem.out.println(p2.firstName);\n\n\u2022 Same name but the \n\ntype might be different\n\nfirstName\n\ngroup\n\ntimetable\n\nsetGroup(String s)\n\nsetTimetable(char c)\n\nprintGroup()\n\nClass Student\n\n55\n\n\fOverriding I (Shadowing)\nAttribute hiding. Example\n\nclass Person {\n\nprotected String firstName = \u201dJuan\";\n\n}\n\nclass Student extends Person {\n\nprotected int firstName = 10003041;\n\n}\n\nclass Test {\n\npublic static void main (String[] args) {\nStudent s = new Student();\nPerson p = s;\nSystem.out.println(p.firstName);\nSystem.out.println(s.firstName);\n}\n\nprints \u201cJuan\u201d\n\nprints \n10003041\n\n}\n\n56\n\n\fOverriding I (Shadowing)\nAttribute hiding\n\n\u201cGranny\u201d class \n\nTransport\n\nString name = \u201cground\"\n\nParent class \n\nTrain\n\nVehicle\n\nString name = \u201ccar\"\n\nChild class \n\nScooter\n\nCar\n\nString name = \"Ferrari\"\n\n\u2022 How can I access hidden variables?\n\n\u2013 name (Car name)\n\u2013 this.name (Car name)\n\u2013 super.name (Vehicle name)\n\u2013 ((Vehicle)this).name (Vehicle name)\n\u2013 super.super.name (WRONG)\n\u2013 ((Transport)this).name (Transport name)\n\nVariables\nChild class:\nvisible\n\nVariables\nParent class\nhidden\n\n57\n\n\fOverriding II\nMethod overriding. What is it?\n\n\u2022 Method overriding is useful for:\n\n\u2013 Extending the functionality of a method\n\u2013 Particularizing the functionality of the method in the derived class\n\n\u2022 If the subclass defines a method with the same \n\nsignature (name + number and type of the \nparameters) the method in the superclass is hidden\n\n\u2022 How can we access hidden methods?\n\n\u2013 start() (runs the start method of the Car)\n\u2013 this.start() (runs the start method of the Car)\n\u2013 super.start() (runs the start method of the Vehicle)\n\u2013 super.super.start() (WRONG)\n\nMethods of \nthe child \nclass: visible\nMethods of \nthe parent \nclass: hidden\n\n58\n\n\fOverriding II\nMethod overriding. What is it for?\n\nResource\n\u2022 name\n\u2022 description\n\u2022 getName()\n\u2022 getDescription()\n\nResource\n\u2022 name\n\u2022 description\n\u2022 getName()\n\u2022 getDescription()\n\nClassroom\n\u2022 name\n\u2022 description\n\u2022 location\n\u2022 getName()\n\u2022 getDescriptoin()\n\u2022 getLocation()\n\nComputer\n\u2022 name\n\u2022 description\n\u2022 operatingSystem\n\u2022 getName()\n\u2022 getDescription()\n\u2022 getOS()\n\npublic class Classroom extends Resource\npublic class Computer extends Resource\n\nClassroom\n\u2022 description\n\u2022 location\n\u2022 getLocation()\n\u2022 getDescription()\n\nComputer\n\u2022 operatingSystem\n\u2022 getOS()\n\nthis.getDescription()\n\nsuper.getDescripcion\n\n59\n\n\fOverriding II\nMethod overriding\n\nerror\nno\n\nObject\n\n$ method(parameters)?\n\nno\n\nAnother ancestor\n\n$ method(parameters)?\n\nno\n\nSuperclass\n\n$ method(parameters)?\n\nno\n\nmessage\n\nmethod(parameters)\n\nobject\n\ninstance\n\nSubclass\n\n$ method(parameters)?\n\n60\n\n\fOverriding II\nMethod overriding\n\n\u2022 When sending a message to an object, \n\nthe selected method:\n\u2013 Depends on the class which the object is \n\nan instance of\n\n\u2013 Does not depend on the reference class \nto which it is assigned, as in the case of \nattributes\n\n61\n\n\fOverriding II\nMethod overriding. Example\n\nclass Person {\n\nprotected String firstName = \u201dJuan\";\npublic void print() {\n\nSystem.out.println(\u201dPerson: \" + firstName);\n\n}\n\n}\nclass Student extends Person {\n\nprotected String firstName = \u201dJuan Pablo\";\npublic void print() {\n\nSystem.out.println(\u201dStudent: \" + firstName);\n\n}\n\n}\nclass Test2 {\n\npublic static void main (String[] args) {\n\nStudent s = new Student();\nPerson p = s;\ns.print();\np.print();\n\nBoth print:\n\u201cStudent: Juan Pablo\u201d\n\n}\n\n}\n\n62\n\n\fExercise 6\n\n\u2022 Override the method speedUp() from Bicycle in the \nsubclasses MountainBike and TandemBike so that \nspeeding up means tripling the current speed in the first \ncase, and quadrupling the current speed in the second case.\n\n\u2022 Create two objects of classes MountainBike and \n\nTandemBike and call the method speedUp() on them, \nwhat is the result?\n\n\u2022 How would you access the implementation of the method \nspeedUp() of Bicycle from the two objects you have \njust created? \n\n63\n\n\fOverriding vs. overloading\n\n\u2022 Overriding: The subclass substitutes the \n\nimplementation of a method of the superclass\n\n\u2013 Both methods need to have the same signature\n\n\u2022 Overloading: There is more than one method \nwith the same name but different signature\n\n\u2013 The overloaded methods can be declared in the \n\nsame class or in different classes in the \ninheritance hierarchy\n\n64\n\n\fConstructors and inheritance\n\n\u2022 Steps to create an object:\n1. The base part is created\n2. The derived part is added\n\u2013 If the base class of the object inherits from another class, \nstep 1 is applied in the order of the inheritance chain, \nuntil we reach Object\n\n\u2022 For example, when creating a Student object, \n\nthat extends Person, the steps would be:\n1. The part corresponding to Person is created. To do so:\n\n1. The part corresponding to Object is created.\n2. The Person elements are added\n2. The Student elements are added\n\n65\n\n\fConstructors and inheritance\n\n\u2022 A call to the constructor of the base class\nis always done in the constructor of the \nderived class.\n\n\u2022 This is the first action of the constructor \n\n(always in the first line)\n\n\u2022 Two possibilities:\n\n\u2013 Not explicitly indicated\n\u2013 Explicitly indicated\n\n(mandatory in the first line)\n\n66\n\n\fConstructors and inheritance\n\n1.If it is not explicit, Java automatically \ninserts a call to super() in the first \nline of the constructor of the derived \nclass\n\npublic Student (String firstName, String lastName, \n\nint birthYear, String group, char timetable) {\n\n// Java inserts here a call to super()\nthis.firstName = firstName;\nthis.lastName = lastName;\nthis.birthYear = birthYear;\nthis.group = group;\nthis.timetable = timetable;\n\n}\n\n67\n\n\fConstructors and inheritance\n\n2. Explicitly indicated\n\npublic Student (String firstName, String lastName, \n\nint birthYear, String group, char timetable) {\n\nsuper(firstName, lastName, birthYear);\nthis.group = group;\nthis.timetable = timetable;\n\n}\n\n68\n\n\fMore on super\n\n\u2022 super\n\n\u2013 references the current object casted as if it was an instance \n\nof its superclass\n\n\u2013 With the super reference, the methods of the base class  \n\ncan be explicitly accessed\n\n\u2013 super is useful when overriding methods\n\npublic class Student extends Person {\n\n// the rest remains the same\npublic void print(){\n\nsuper.print();\nSystem.out.print(\"Group:\" + group+ schedule);\n\n}\n\n}\n\n69\n\n\fPolymorphism \nWhat is it?\n\n\u2022 Capacity of an object for deciding which method to apply, \n\ndepending on the class it belongs to\n\n\u2013 A call to a method on a reference of a generic type (e.g., base \n\nclass) executes different implementations of the method \ndepending on which class the object was created as\n\n\u2022 Allows designing and implementing extensible systems\n\n\u2013 Programs can process generic objects                                  \n\n(described by references of the superclass)\n\n\u2013 The specific behavior depends on the subclasses\n\n\u2013 New subclasses can be added later\n\n70\n\n\fPolymorphism \nExample\n\n\u2022 Student, Professor and Secretary\n\u2022 We create an array of Person where we include objects of \n\nStudent, Professor and Secretary.\n\n\u2022 When calling the method print(), overridden in classes \nStudent, Professor and Secretary, on the array of \nPerson, each object uses its own implementation of the \nmethod\n\nPerson[] group = {new Student(\u2026), new Professor(\u2026), \n\nnew Secretary(\u2026), new Student(\u2026)};\n\nfor (int i=0; i<group.length; i++){\n\ngroup[i].print();\n\n}\n\n71\n\n\fPolymorphism \nDynamic binding\n\n\u2022 The power of method overriding is that the correct \n\nmethod is properly called, even though the object of \nthe child class is referenced through the base class\n\n\u2022 This mechanism is called \u201cdynamic binding\u201d\n\n\u2013 Allows detecting the proper method to call during \n\nruntime \n\n\u2022 The compiler does not generate the calling code \n\nduring compile time\n\u2013 It only generates code for calculating which method to call\n\n*   Different from \u201cstatic binding\u201d (e.g., method \noverloading) where the proper method is detected at \ncompile time\n\n72\n\n\fExercise 7\n\n\u2022 Create an array of class Bicycle that contains \n\nobjects of classes Bicycle, MountainBike and \nTandemBike.\n\n\u2022 Call the method speedUp() on each of these \nobjects, taking advantage of the benefits of \npolymorphism and dynamic binding.  \n\n73\n\n\fModifiers and access\nFinal \n\n\u2022 If we do not want that derived classes can \nmodify (override) a method or attribute of \nthe base class, then the final modifier \nshall be used.\n\n74\n\n\fModifiers and access\nFinal \n\n\u2022 The final modifier can be applied to:\n\n\u2013 Parameters: Meaning that their value cannot be changed inside \n\nthe method\n\npublic void myMethod(final int[] p1, int p2){} //p1 values cannot be changed\n\n\u2013 Attributes: Meaning that their value cannot be changed in the \n\nclass. It is used together with static to define constants. \n\npublic static final double PI = 3.14; //PI value cannot be changed\n\n\u2013 Methods: Meaning that they cannot be overridden in derived \n\nclasses\n\npublic final void myMethod(){} //myMethod cannot be overridden\n\n\u2013 Classes: Avoid extending the class. It cannot be inherited.\n\npublic final class myClass(){} //myClass cannot be extended\n\n75\n\n\fMODIFIERS\n\nclass\n\nmethod\n\nattribute\n\npublic\n\na\nc\nc\ne\ns\ns\n\n(friendly)\n\nprotected\n\nprivate\n\nfinal\n\no\nt\nh\ne\nr\n\nstatic\n\nAccesible to any other class\n\nAccessible only to classes in the same package\n\nAccessible to the class, its subclasses and \nclasses in the same package\n\nApplied to inner classes\n\nAccessible only inside the class\n\nCannot be extended.\nIt is a leaf in the inheritance \ntree.\n\nCannot be overridden.\nIt is constant and cannot \nbe modified in the child \nclasses.\n\nIts value cannot be changed, it \nis constant .\nIt is normally used together \nwith static.\n\nMaximum level class.\n\nIt is the same for all the \nclass objects.\nUse: \n\nIt is the same for all the class \nobjects.\nUse: \n\nClassName.method ();\n\nClassName.attribute;\n\n76\n\n\fSystems Programming\n\nObject-ORIENTED programming \n(advanced)\n\nDepartamento de Ingenier\u00eda \nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nM. Carmen Fern\u00e1ndez Panadero, Raquel M. Crespo Garc\u00eda\n\nCarlos Delgado Kloos, Natividad Mart\u00ednez Madrid,                                        \n\nCarlos Alario Hoyos, Julio Villena Rom\u00e1n\n\n77\n\n\fKey terms\n\n\u2022 Casting\n\n\u2013 Upcasting vs Downcasting\n\u2013 Widening vs Narrowing\n\n\u2022 Abstract (classes and methods)\n\n\u2022\n\n\u2013 Inheritance\n\u2013 Polymorphism\nInterfaces\n\u2013 implements\n\u2013 Inheritance\n\u2013 Polymorphism\n\n78\n\n\fContents\n\n\u2022 Casting. Types compatibility\n\u2022 Abstract classes and methods\n\u2022 Interfaces\n\n79\n\n\fCasting (Type conversion)\nSyntax and terminology\n\n\u2022 Syntax:(type) identifier\n\n\u2022 Two types of casting:\n\n\u2013 Widening or upcasting: a subclass is used as an \ninstance of the superclass. Implicit conversion\n\u2013 Narrowing or downcasting: The superclass is \nused as an instance of a subclass. Explicit \nconversion.\n\n\u2022 Casting can only be applied to parent and \n\nchild classes, not to sibling classes\n\u2013 String s = \u201c3\u201d;\n\u2013 Integer i = (Integer) s;\n\u2013 Integer i = Integer.parseInt(s);\n\n80\n\n\fCasting (Type conversion)\nWidening or upcasting \n\n1. Upcasting: compatibility upwards \n\n(towards the base class)\n\u2013 An object of the derived class can always \nbe used as an object of the base class \n(because it implements an \u201cis-a\u201d \nrelationship)\nPerson p = new Student();\n\n81\n\n\fCasting (Type conversion)\nNarrowing or downcasting\n\n2. Downcasting: compatibility downwards \n\n(towards the derived classes)\n\u2013 Downcasting cannot be applied by default, \nbecause an object of the base class is not \nalways an object of the derived class \n\nStudent s = new Person(); // wrong\n\n\u2013 It is only possible when the reference of the base \nclass points to an object of the derived class\n\n\u2013 In these cases, an explicit casting must be \n\napplied\n\n82\n\n\fCasting (Type conversion)\nExample\n\npublic class Test2 {\n\npublic static void main (String[] args) {\n\nPerson p1;\n//implicit upcasting - works\nStudent s1 = new Student();\np1 = s1;                     \n\nA student is \nalways a person \n(implicit)\n\nStudent s2;\n//implicit downcasting \u2013 does not work\ns2 = p1; //error because no explicit casting is done\n\nA person is not \nalways a student\n\n//explicit downcasting - works\ns2 = (Student) p1;   // p1 actually references an \n\n// instance of class Student\n\nIf someone, besides being a person, is also a student \n(not always happens), (s)he can be required stuff as \na student, but must be explicitly stated that (s)he \nwill be treated as a student.\n\n83\n\n\fCasting (Type conversion)\nExample\n\nPerson p2 = new Person();\nStudent s3;\n\n//implicit downcasting \u2013 does not work\n\ns3 = p2;   //compiler error\n\n//explicit downcasting \u2013 does not works sometimes\n//ClassCastException will be thrown\n//because p2 does not refer to a Student object\n\ns3 = (Student) p2; //error\n\n//implicit downcasting \u2013 does not work\nStudent s4 = new Person(); //error\n\n}\n\n}\n\nA person is not always a student. It cannot be \nassumed implicitly.\n\nA person is not \nalways a \nstudent. It \ncannot be \nimplicitly\nassumed.\n\nA person is \nsometimes a  \nstudent, but if \nnot (it has not \nbeen created as \nsuch), it cannot \nbe treated as \nsuch, not even \nthough explicitly\ntrying.\n\n84\n\n\fCasting (Type conversion)\ninstanceof operator\n\n\u2022 Syntax:\n\nobject instanceof class\n\u2013 Checks if an object is really an instance of a \n\ngiven class\n\n\u2022 Example:\n\npublic Student check(Person p) {\n\nStudent s = null;\nif (p instanceof Student)\ns = (Student) p;\n\nreturn s;\n\n}\n\n85\n\n\fAbstract classes\nWhat is an abstract class?\n\n\u2022\n\nIt declares the structure of a given abstraction, \nwithout providing all the implementation details (i.e. \nwithout implementing completely every method)\n\u2022 An abstract class is a class that can have abstract \n\nmethods (not implemented, without code)\n\u2013 If the class has at least one abstract method, it will be \n\nabstract\n\nMessage\n\nEmail\n\nSMS\n\nWhatsApp\n\n86\n\n\fAbstract classes\nCharacteristics\n\n\u2022 Classes and methods are defined as abstract \n\nusing the reserved word abstract\n\npublic abstract class Figure{...}\n\n87\n\n\fAbstract classes\nCharacteristics\n\n\u2022 Abstract classes cannot be instantiated\n\n\u2013 References to abstract classes can exist\n\u2013 But they point to objects of classes derived of the \n\nabstract class\n\nFigure fig = new Rectangle(2,3);\n\n\u2022 Abstract classes can be extended\n\u2022 In an abstract class, there can be both\n\n\u2013 abstract methods\n\u2013 non abstract methods\n\n88\n\n\fAbstract classes\nWhat are they for? partial implementations\n\n\u2022 Abstract classes are normally used for representing \n\npartially implemented classes\n\u2013 Some methods are not implemented but declared\n\n\u2022 The objective of partial implementations is to provide \n\na common interface to all derived classes\n\u2013 Even though in cases when the base class has not enough \n\ninformation to implement the method\n\n89\n\n\fAbstract classes\nAbstract methods\n\n\u2022 Methods declared but not implemented in \n\nabstract classes\nabstract returnType name(parameters);\n\u2013 Abstract methods are declared using the reserved \n\nword abstract\n\n\u2022 Classes inheriting from the abstract class \n\nmust implement all the abstract methods of \nthe superclass\n\u2013 Or they will be abstract as well\n\nNOTE: No braces!! They are not \nimplemented, thus only a semicolon (;)\nfollows the declaration\n\n90\n\n\fAbstract classes\nAbstract methods\n\n\u2022 The abstract modifier cannot be applied to:\n\n\u2013 constructors\n\u2013 private methods\n\u2013 static methods\n\n91\n\n\fAbstract classes \nHow are they used? Example\n\npublic abstract class Figure { // any figure\n\nprotected double dim1;\nprotected double dim2;\n\npublic Figure(double dim1, double dim2) {\n\nthis.dim1 = dim1;\nthis.dim2 = dim2;\n\n}\n\npublic abstract double area();\n\n}\n\npublic class Rectangle extends Figure {\n\npublic Rectangle(double dim1, double dim2) {\n\nsuper(dim1,dim2);\n\n}\npublic double area() {\nreturn dim1*dim2;\n\n}\n\n}\n\n// rectangle area\n\n92\n\n\fExercise 8\n\n\u2022\n\n\u2022\n\n\u2022\n\nStarting from the class Bicycle which has three \nattributes, speed, cadence and gear, of type integer \nand four methods speedUp(), brake(), \nsetCadence(int newCadence), and \nsetGear(int newGear), implement the abstract class \nVehicle.\nThink about the attributes and methods that will be of \nBicycle, and those which can be inherited, considering \nthat besides Bicycle, we will have classes Car and\nTruck.\nThink about the methods that shall be abstract and those \nwhich shall not in class Vehicle.\n\n93\n\n\fAbstract classes\nPolymorphism\n\nAn array of objects of type \nFigure (abstract)\n\npublic static void main(String args[]){\nFigure[] myFigures = new Figure[3];\n\nmyFigures[0] = new Rectangle(1,3);\nmyFigures[1] = new Triangle(2,5);\nmyFigures[2] = new Square(3);\n\nArray elements are instances of \na concrete (non-abstract) class \n(Rectangle, Triangle, Square)\n\nfor(int i=0; i<myFigures.length; i++){\n\nSystem.out.println(myFigures[i].area());\n\n}\n\n}\n\nWe call the method area() on the objects of type \nFigure. During runtime it will be checked which \ntype of object is contained and the proper method \nwill be called. \u2013 Dynamic binding\n\n94\n\n\fInterfaces\nWhat is an interface?\n\n\u2022\n\n\u2022\n\n\u2022\n\nInterfaces take the abstract class concept one step \nfurther\n\u2013 All methods in the interface are abstract\nInterfaces are always public\n\u2013 Interface attributes are public by default\n\u2013 Interface methods are public by default\nInterfaces are implemented by classes\n\u2013 A class implements an interface defining the body of  all the \n\nmethods\n\n\u2013 An abstract class implements an interface implementing or \n\ndeclaring abstracts the methods\n\n\u2013 A class (abstract or not) can implement one or more \n\ninterfaces\n\n95\n\n\fInterfaces\nWhat is an interface?\n\n\u2022 An interface is a pure design element\n\n\u2013 What to do?\n\n\u2022 A class (including abstract ones) is a mix of design \n\nand implementation\n\u2013 What to do and how?\n\n\u2022 Different classes can implement the same interface \n\nin different ways\n\n96\n\n\fInterfaces\nDeclaration\n\n\u2022 Syntax:\n\npublic interface Name {\n\nstatic final type CONSTANTNAME = value;\nreturnType methodName(parameters);\n\n}\n\nNOTE 1: No braces!! As the method is \nnot implemented, only a semicolon (; )\nfollows the declaration\n\nNOTE 2: Constants and methods in \ninterfaces are always public \n(no need to make it explicit)\n\n97\n\n\fInterfaces\nImplementation\n\n\u2022\n\nIf a class implements an interface, it implements all \nabstract methods declared in such interface\n\n\u2022 Represented with the reserved word implements\n\npublic class MyClass implements Interface, Interface2 {...}\n\n98\n\n\fInterfaces\nWhat are they for?. Multiple inheritance\n\nmethodA\n\nmethodB\n\nmethodC\n\nClassA\n\nextends\n\nInterface B\n\nInterface C\n\nimplements\n\nimplements\n\nClassC\n\n\u2022 Java does not allow multiple inheritance\n\u2022 But it several interfaces can be implemented\n\n99\n\n\fInterfaces\nHow to use them?\n\nFigure\n\u2022area()\n\nDrawable\n\u2022draw()\n\nextends\n\nimplements\n\nCircle\n\u2022area()\n\u2022draw()\n\nRectangle\n\u2022area()\n\u2022draw()\n\npublic abstract class Figure {\u2026}\n\npublic interface Drawable {\u2026}\n\npublic class Circle extends Figure implements Drawable\n\npublic class Rectangle extends Figure implements Drawable\n\n\fInterfaces\nExample\n\npublic interface LowEmission {\n\n// Attributes\n// public char tag; // Not allowed as it is not initialized\npublic char tag = 'B';\nchar tag2 = 'B';\n// public static double emission // Not allowed, not initialized\npublic static double emission = 12.4;\nstatic double emission2 = 12.4;\n// public static final double maxEmission // Not allowed, not initialized\npublic static final double maxEmission = 12;\nstatic final double maxEmission2 = 12;\n// private int license // Private attributes are not allowed\n\n// Methods\npublic char getTag();\n// public static double getEmission(); // Not allowed\npublic static double getEmission() { return 0; }\nstatic double getEmission2() { return 0; }\n// private int getLicense() // Private methods are not allowed\n\n}\n\n\fExercise 9\n\n\u2022\n\nImplement the interface Printable, which contains \nthe method print(), which does not return any \nvalue. \n\n\u2022 Class Bicycle implements the interface \n\nPrintable, so that it prints on screen the values of \ncurrent speed, cadence and gear.\n\n102\n\n\fInterfaces\nInterface inheritance. Polymorphism\n\n\u2022 Interfaces can also have an inheritance \n\nhierarchy.\n\n\u2022 Classes  implementing the interfaces in \n\nthe hierarchy must include all the methods \ndefine in the interfaces.\n\n\u2022 Interfaces also support dynamic resolution \n\nof methods during runtime (dynamic \nbinding)\n\n103\n\n\fExercise 10\n\n\u2022\n\nImplement the interface Definible, which contains \nthe method getAttributes(). This method \nreturns the value of the attributes of the object. The \ninterface Printable inherits from Definible.\n\n\u2022 Which changes are needed in the interface \nPrintable? And in the class Bicycle.\n\n104\n\n\fObject Orientation Summary\n\n\u2022 Class (actual) \n\n\u2013 All methods are implemented\n\n\u2022 Abstract class\n\n\u2013 Can include methods which are not \n\nimplemented but just declared\n\n\u2013 abstract modifier \n\n\u2022 Interface\n\n\u2013 No implementation at all\n\u2013 Reserved word: interface\n\n105\n\n\fObject Orientation Summary\n\n\u2022 Class (actual or abstract) \n\n\u2013 Can extend (extends)  only one base class \n\n(simple inheritance)\n\n\u2013 Can implement (implements) one or more \n\ninterfaces (multiple inheritance)\n\n\u2022 Interface\n\n\u2013 Can extend (extends) one or more \n\ninterfaces \n\n106\n\n\fMODIFIERS\n\nclass\n\nmethod\n\nattribute\n\npublic\n\na\nc\nc\ne\ns\ns\n\n(friendly)\n\nprotected\n\nprivate\n\nabstract\n\nAccesible to any other class\n\nAccessible only to classes in the same package\n\nAccessible to the class, its subclasses and classes \nin the same package\n\nApplied to inner classes\n\nAccessible only inside the class\n\nCannot be instantiated\nFor inheriting from them\nAt least 1 abstract method\n\nHas no code \nIt is implemented in the \nsubclasses or child classes\n\nfinal\n\no\nt\nh\ne\nr\n\nCannot be extended.\nIt is a leaf in the inheritance \ntree.\n\nCannot be overridden.\nIt is constant and cannot be \nmodified in the child classes.\n\nIts value cannot be changed, it is \nconstant .\nIt is normally used together with \nstatic.\n\nstatic\n\nMaximum level class.\n\nIt is the same for all the class \nobjects.\nUse: \n\nIt is the same for all the class \nobjects.\nUse: \n\nClassName.method ();\n\nClassName.attribute;\n\n107\n\n\f", "pages_description": ["Key terms\n\nThe key terms are object and class, state and behavior, attribute and method, data abstraction versus functional abstraction, private/public attribute/method + class, message passing, overloading method, constructor method, static attribute/method, get/set method, and package. \n", "Scenario IV: Declare and implement a class\n\nThis slide introduces the fourth scenario of a programming course, which focuses on declaring and implementing a class. The scenario assumes prior knowledge of reading code and implementing methods. The objective is to design a new class that defines a new data type with its own characteristics and behavior. \n\nThere are two main learning objectives: first, to be able to declare a class with attributes (characteristics) and methods (behavior), and second, to be able to create objects from this class and manage access to their state and behavior. \n\nThe work plan for achieving these objectives includes: memorizing the basic nomenclature of object-oriented programming, practicing object modeling with simple examples to understand the distinction between a class, an object, its state, and its behavior, reviewing the Java syntax for declaring classes, attributes, constructors, and methods, and finally, reviewing the mechanism and syntax for message passing between objects. \n", "Objectives\n\nThis slide outlines the objectives for a lesson on object-based programming. The first objective is to define basic concepts such as classes, objects, members which include attributes and methods, abstraction, and information hiding. The second objective is to describe the relationship between an object and a class. Finally, the third objective is to create a simple object and be able to model its characteristics with attributes and its behavior with methods. \n", "Contents\n\nThis slide lists topics related to object-oriented programming: classes and objects, object encapsulation with functional and data abstraction, class members, message passing, overloading, constructors, modifiers and access, and packages. \n", "What is an object?\n\nObjects are simple or complex, real or imagined representations of things, for example, a clock, an airplane, or a bird. Not everything can be considered an object. Some things are simply characteristics or attributes of the objects, for example, color or speed. \n", "What is an object?\n\nWe see a definition of an object, which is divided into two abstractions: functional abstraction and data abstraction.\n\n- Functional abstraction refers to the things that we know an object can do. For example, we know that cars can advance, stop, turn right, and turn left.\n- Data abstraction refers to the properties or attributes of an object. For example, a car has properties such as color, speed, and size.\n", "What is an object?\n\nIt is a way to group a set of data, called state, and functionality, called behavior, in the same block of code, which can then be referred to from other parts of a program.\nThe class to which the object belongs can be considered a new data type. \n", "Example\n\nThe image shows a slide with the title \"Example\" about object-oriented programming concepts, in particular classes and objects.\n\nOn the left-hand side, we see an example of a class definition written in a programming language, likely Java. The class is named \"Car\" and it has three private attributes: \"color\" of type String, \"speed\" of type int, and \"size\" of type float. The class also has a constructor that takes the color, speed, and size as input and initializes the corresponding attributes. Additionally, the class has four public methods: \"advance\", \"stop\", \"turnLeft\", and \"turnRight\", all of which take no arguments and return void.\n\nOn the right-hand side, we see three instances of the \"Car\" class, represented by images of cars in different colors: green, red, and yellow. These instances are created in the \"main\" method, which is a special method in Java that is executed when the program starts. The \"main\" method creates three \"Car\" objects: \"myCar\" with color \"green\", speed 80, and size 3.2f, \"yourCar\" with color \"red\", speed 120, and size 4.1f, and \"hisCar\" with color \"yellow\", speed 100, and size 3.4f.\n\nThe slide also highlights three key concepts of object-oriented programming: the \"new\" operator is used to create instances of a class, the \"this\" keyword refers to the current object, and the \"public\" and \"private\" keywords are access modifiers that control the visibility and accessibility of class members.\n", "Exercise 1\n\nThe exercise asks to implement a class named \"Bicycle\" with three attributes: \"speed\", \"cadence\", and \"gear\", all of which are integers. The class should also have four methods: \"speedUp\", which doubles the current speed, \"brake\", which halves the current speed, \"setCadence\", which takes an integer argument and sets the cadence to that value, and \"setGear\", which takes an integer argument and sets the gear to that value. The class should also have a constructor that initializes all the attributes. Finally, the exercise asks to create two objects of this class: \"myBicycle\" and \"yourBicycle\". \n", "Object encapsulation\n\n- Encapsulation: explains the links between behavior and state to a particular object\n- Information hiding: Defines which parts of the object are visible (the public interface) and which parts are hidden (private)\n\nThere is an image of a key.\n\n- The ignition key is a public interface mechanism to start a vehicle\n- The implementation of how to really start a car is private. We only can access this information using the ignition key\n\nPros: The object may change but its public interface remains compatible with the original. This fact facilitates code reuse\n", "Object encapsulation\n\nObjects encapsulate attributes, allowing access to them only through methods.\n\n- Attributes (Variables): Containers of values\n- Methods: Containers of functions\n\nAn object has:\n\n- State: represented by the values of its attributes\n- Behavior: defined by its methods\n\nUsually:\n\n- Methods are public\n- Attributes are private\n- There can be private methods\n- It is dangerous to have public attributes\n\nThere is a diagram representing an object with a circle containing dots. The dots represent the object's attributes. The circle represents the encapsulation of the attributes, which can only be accessed through the object's methods.\n", "Object Definition\n\nThere are two types of members in object definition: public members and private members.\n\nPublic members describe what an object can do. This includes the methods of the object and its abstraction.\n\nPrivate members describe how the object does its work, or how it is implemented. For example, the ignition key interacts with the electric circuit of the vehicle, the engine, etc. In pure object-oriented systems, state is completely private and can only be modified through the public interface. For example, a public method brake() can change the value of the private attribute speed. \n", "Interactions between objects\n\nObject modeling describes objects and their interrelations. To do a task, an object can delegate some work to another object, which can be a part of itself, or any other object in the system. Objects interact with each other by sending messages. \n", "Message passing\n\nAn object sends a message to another object by calling a method. Messages are handled by the public interface of the receiving object. We can only call methods from another object that are public or accessible from the calling object. The receiving object will react by changing its state, i.e. modifying its attributes and/or sending other messages, i.e. calling other methods from the same object or calling other methods from other objects.\n\nThere is a diagram showing the message passing process. On the left side of the image, there is a square labeled \"start\". An arrow goes from this square to the right, passing through a rectangle labeled \"Public interface\" and pointing to an oval labeled \"Implementation\".\n", "Example\n\nWe have three classes: Car, Engine, and Wheel. The Car class has private attributes for color, speed, size, an array of wheels, and an engine. The constructor takes all of these attributes as arguments and initializes them. The advance method calls the injectFuel method on the engine and then calls the turn method on each wheel in the wheels array. The main method creates an array of wheels and a new car object with the specified attributes. The Engine class has private attributes for type and horsepower. The constructor takes the type and horsepower as arguments and initializes them. The injectFuel method does not have any implementation yet. The Wheel class has private attributes for diameter and manufacturer. The constructor takes the diameter and manufacturer as arguments and initializes them. The turn method does not have any implementation yet. \n", "Classification of objects\n\nWe have four cars: a red sports car, a police car, a yellow vintage car, and a red vintage car.\n\nA class is a set of objects with similar states and behaviors. We can refer to the \"Car\" class as any instance in the classification of cars. \"myCar\" is an object, that is, a particular instance of the Car class. The class to which the object belongs is considered as a new data type. \n", "Objects vs. Classes\n\nA class is an abstract entity, it is a kind of data classification. It defines the behavior and attributes of a group of objects with similar structure and similar behavior.\n\nAn object is an instance of a class. An object can be distinguished from other members of the class by the value of its attributes.\n\nThere is a diagram representing a class named \"car\" with its methods and attributes and an instance of that class which is an object named \"myFerrari\" with its own values for the attributes. \nThe class \"car\" has the methods start, advance, stop and the attributes color, speed.\nThe object \"myFerrari\" has the color red and the speed 300Km/h.\n\nA class is declared, an object is created.\n", "Overloading\nWhat is it?\n\n- Two methods with the same name can be defined in the same class if they have different parameters\n- It is widely used for constructors\n- The method actually executed depends on the parameters passed when it is called \n", "Overloading\nWhat is it used for?\n\nWe see the definition of a class named Car. This class has three private attributes: color of type String, speed of type int and size of type float.\nIt also has a constructor that receives as parameters a String, an int and a float, and it assigns each parameter to the corresponding attribute.\nThere are also three public methods named advance. The first one receives no parameters, the second one receives an int as a parameter, and the third one receives an int and another int.\nFinally, there are three public methods with no parameters: brake, turnLeft and turnRight.\n\nOn the right-hand side, we see an example of code that uses this class.\nWe see the definition of the main method, where three instances of the class Car are created: myCar, yourCar and hisCar.\nEach one is initialized with different values for the color, speed and size attributes.\nThen, the advance method is called on each of the objects. \nThe first call doesn't have any arguments, the second one receives one argument, and the third one receives two arguments.\n\nFinally, there is a text explaining that although the three methods have the same name (advance), they are considered different methods because they have different parameters. This is called overloading. \n", "Exercise 2\n\nIn the class Bicycle, implement the overloaded methods setCadence() and setGear(), which do not receive arguments and change the values of cadence and gear to one value by default: 1. \n", "Constructors\n\nWhen an object is created, its members are initialized using a constructor method. Constructors have the same name as the class. They have no return type, not even void. At least one constructor should be defined per class. Several constructors can exist, and they are distinguished by their parameters, this is called overloading. A default constructor without parameters, which initializes the attributes to their default values, is created if no explicit constructors are defined. If there is a constructor in the class, the default constructor no longer exists. In that case, if a constructor without parameters is desired, it needs to be explicitly declared. \n", "Constructors\n\nThe image shows an example of constructor overloading in Java.\n\nOn the left side, we see the definition of the class \"Car\". The class has three private attributes: \"color\" of type String, \"speed\" of type int, and \"size\" of type float. \n\nThe class \"Car\" has four constructors:\n- A constructor with no arguments.\n- A constructor with one argument of type String, which sets the \"color\" attribute.\n- A constructor with two arguments: a String for the \"color\" and an int for the \"speed\".\n- A constructor with three arguments: a String for the \"color\", an int for the \"speed\", and a float for the \"size\".\n\nThe class also has four public methods: \"advance\", \"brake\", \"turnLeft\", and \"turnRight\". However, these methods are empty and do not contain any implementation.\n\nOn the right side, we see an example of how to create an array of \"Car\" objects using the different constructors. The code defines a \"garage\" array of \"Car\" objects and initializes it with three \"Car\" objects:\n- The first \"Car\" object is created using the constructor with one argument \"green\", which sets the color of the car to green.\n- The second \"Car\" object is created using the constructor with two arguments: \"red\" for the color and 120 for the speed.\n- The third \"Car\" object is created using the constructor with three arguments: \"yellow\" for the color, 100 for the speed, and 3.4f for the size.\n\nThe text \"Overload of constructors\" emphasizes the concept of having multiple constructors with different parameters in the same class.\n", "Exercise 3\n\nIn the class \"Bicycle\", implement an additional constructor, which does not receive arguments, and that initializes the \"speed\" to 0, and the \"cadence\" and \"gear\" to 1. \n", "Modifiers and access\nStatic (static members)\n\n- Static modifier\n- Static members exist only once per class, independently of the number of instances (objects) of the class that have been created or even if there are no instances created yet\n- The method or attribute behaves always in the same way\n- Static members can be accessed using the class name\n- A static method cannot access non-static members directly; an object must be created first \n", "Modifiers and access\nStatic (static members)\n\nWe have a code snippet that shows how to declare a static attribute in Java. The example is a class named Car that has a private string attribute for color, a private int attribute for speed, a private float attribute for size, and a private static int attribute for the number of wheels. The static attribute is initialized to 4.\n\nThere is another code snippet showing a static method. The example is the main method, which is declared as public static void. It takes a string array as an argument. Inside the method, we see how to access the static attribute numberOfWheels using the class name Car followed by a dot and the attribute name.\n\nOn the right-hand side, we see other examples of static members. We have the mathematical constant PI, the minimum value of an integer, and the maximum value of an integer.\n\nThe last code snippet shows that the static method main can access other static members without creating instances of the class. In this case, we are using the static methods sqrt and cos from the Math class.\n", "Modifiers and access\nStatic. Some rules\n\n- Static members are invoked with \"ClassName.staticMethod();\" and \"ClassName.staticAttribute;\".\n- Non static members require an instance (object) in order to be accessed: \"ClassName objectName = new ClassName();\".\n- Non static members are invoked with \"objectName.normalMethod();\" and \"objectName.normalAttribute;\".\n- When a static member is invoked (called) from inside the same class, the class name can be deleted. We can write \"staticMethod();\" and \"staticAttribute;\" instead of \"ClassName.staticMethod();\" and \"ClassName.staticAttribute;\".\n", "Access\nget() and set() methods\n\nAttributes in a class are typically private to avoid their access and modification from any other class. Sometimes we want some classes to access the attributes. get() and set() methods to control access.\n\nThere is a code snippet defining a class named Car. The class Car has two private attributes: color of type String and speed of type int. The class also has four public methods: getColor, setColor, getSpeed and setSpeed. The method getColor returns the value of the attribute color. The method setColor assigns the input parameter color to the attribute color. The method getSpeed returns the value of the attribute speed. The method setSpeed assigns the input parameter speed to the attribute speed. \n", "Exercise 4\n\nIn the class Bicycle, implement the necessary get() and set() methods which allow accessing and modifying all the attributes. \n", "Packages\n\nA package groups classes and interfaces. Hierarchies in a package correspond to the hierarchies of folders in the disk. Dots are used for referring to subpackages, classes, and interfaces in a package. For example, when we import mathematical classes we use \"import java.math.BigDecimal;\". The BigDecimal class is in the java/math folder of the JDK. We do not need to import all the classes, for example, java/lang. Some of the classes in java/lang are: String, Integer, NullPointerException, and ArrayIndexOutOfBoundsException. \n", "Packages\n\n- Creating my own packages\n    - Save the classes in a folder named as the package\n    - All classes belonging to the package must include the following sentence as the first one: `package myOwnPackage;`\n    - In the class using the package, the corresponding import sentence must be included before the class declaration\n        - `import myOwnPackage.Class1;` // import one class\n        - `import myOwnPackage.*;` // all the classes in the package\n", "Summary of elements in a program\n\nA diagram shows the elements of a program.  At the top is a box labeled \"Program\".  Below that is a box labeled \"Classes (.java files) (organized in packages)\".  Below that is a box labeled \"Class members\".  Below that are two boxes, one labeled \"Attributes\" and the other labeled \"Methods\".  Below the \"Attributes\" box are three boxes: \"Primitive type\", \"Reference type\", and \"String\".  Below the \"Reference type\" box are two boxes: \"Objects\" and \"Arrays\".  Below the \"Methods\" box are three boxes: \"Regular methods\", \"Special methods\", and \"Constructor Main\".  The \"Special methods\" box is above the \"Constructor\" and \"Main\" boxes.  All boxes are connected with lines.  The \"Program\" box is connected to the \"Classes\" box.  The \"Classes\" box is connected to the \"Class members\" box.  The \"Class members\" box is connected to the \"Attributes\" and \"Methods\" boxes.  The \"Attributes\" box is connected to the \"Primitive type\", \"Reference type\", and \"String\" boxes.  The \"Reference type\" box is connected to the \"Objects\" and \"Arrays\" boxes.  The \"Methods\" box is connected to the \"Regular methods\", \"Special methods\", and \"Constructor Main\" boxes.  The \"Special methods\" box is connected to the \"Constructor\" and \"Main\" boxes.\n", "Summary of modifiers (so far)\n\nThe table shows Java modifiers and their effect on classes, methods and attributes. \nThe first modifier, public, can be applied to classes, methods and attributes and makes them accessible from any other class.\nThe next modifier, friendly, can also be applied to classes, methods and attributes and makes them accessible only to classes from the same package.\nThe private modifier, applicable to classes, methods and attributes, makes them accessible only inside the class.\nFinally, the static modifier can be applied to classes, methods and attributes. It defines the maximum level class. When applied to methods, it means that the method is the same for all the class objects and it can be used as ClassName.method();. When applied to attributes, it means that the attribute is the same for all the class objects and it can be used as ClassName.attribute;\n", "Systems Programming\n\nObject-ORIENTED programming (basic)\n\nThe title of this slide is \"Systems Programming\" and the subtitle is \"Object-ORIENTED programming (basic)\".  The name of the department is \"Departamento de Ingenier\u00eda Telem\u00e1tica\". The contents of this slide are based on the work of M. Carmen Fern\u00e1ndez Panadero, Raquel M. Crespo Garc\u00eda, Carlos Delgado Kloos, Natividad Mart\u00ednez Madrid, Carlos Alario Hoyos, and Julio Villena Rom\u00e1n. The logo of Universidad Carlos III de Madrid is displayed in the bottom left corner of the slide. The Creative Commons license logo is displayed in the top left corner of the slide. \n", "Key terms\n\nThis slide lists key terms related to inheritance. The terms are grouped into the following categories: naming, Java syntax, Java hierarchy, overriding, constructors, and polymorphism. \n\nThe naming category lists the following terms: generalization versus specialization, superclass versus subclass, parent class versus child class, and base class versus derived class. \n\nThe Java syntax category lists the following keywords: extends, super, protected, and final. \n\nThe remaining categories, Java hierarchy, overriding, constructors, and polymorphism, are listed as single terms. \n", "Some classes so far...\n\nWe have two classes, car and bicycle. Both classes have attributes and methods. \n", "Scenario V: Reusing code. Inheritance\n\nThis slide introduces the concept of inheritance in programming. It starts by stating that once you can create your own classes, you are ready to work in teams and reuse code developed by your colleagues. Your team will provide you with a set of classes and you are required to create specializations or generalizations of them.\n\nThe objective of this scenario is to be able to create a derived class adding some characteristics (attributes) and behavior (methods) to an existing class. You should also be able to extract all the common code from a set of similar classes in order to group it into a new parent class so that the code is easier to maintain. Finally, you should be able to create objects, and reference and access their attributes and methods, depending on their position in the inheritance hierarchy and their modifiers.\n\nThe work plan for this scenario is to memorize the naming related to inheritance, memorize the Java syntax related to inheritance (`extends`), to reference (`super`, `this`) and to advanced access modifiers (`protected`). You should also know basic inheritance mechanisms, such as attribute hiding, overriding of methods, and what they are used for and how they are used.\n", "Contents\n\n- Basic inheritance concepts\n- Inheritance hierarchy\n- Overriding I: Attribute Hiding\n- Overriding II: Method Overriding\n- Constructors of derived classes\n- Polymorphism\n- The final modifier \n", "Inheritance\nWhat is it? What is it for?\n\n- Mechanism for software reuse\n- Allows defining related classes from a given class as a:\n    - Specialization of the given class. (e.g., \"Car\" class is a specialization of the class \"Vehicle\")\n        - Scenario: We must implement a new class that is very similar to a previous one, but it needs additional information (characteristics and behavior)\n        - Solution: Create a class that derives from the old one, and add it new functionality without having to rewrite the common code\n    - Generalization of the given class (e.g., the \"Vehicle\" class is a generalization of the \"Car\" class)\n        - Scenario: We have a set of similar classes with code that is repeated in every class and thus difficult to update and maintain (e.g., a letter should be added to the serial number)\n        - Solution: Move the code that is repeated to a single place (the parent class)\n", "Inheritance What is it?\n\nWe see two class diagrams, one with no inheritance and one with inheritance.\n\nOn the left diagram titled \"No inheritance\", we have two classes, \"Classroom\" and \"Computer\", which both have the attributes \"name\", \"description\", \"getName()\", \"getDescription()\". Additionally, \"Classroom\" has the attribute \"location\" and the method \"getLocation()\", and \"Computer\" has the attribute \"operatingSystem\" and the method \"getOS()\".\n\nOn the right diagram titled \"Inheritance\", we have a parent class \"Resource\" with the attributes \"name\", \"description\", \"getName()\", \"getDescription()\". The child classes \"Classroom\" and \"Computer\" inherit from \"Resource\". \"Classroom\" also has the attribute \"location\" and the method \"getLocation()\", and \"Computer\" has the attribute \"operatingSystem\" and the method \"getOS()\".\n\nThe text explains that the attributes and methods that appear in blue in the parent class are repeated in the subclasses in the left diagram. It is not necessary to repeat the code, you only have to say that a class extends the other or inherits from it, as shown in the right diagram.\n", "Inheritance\nNaming\n\nIf we define the Car class from the Vehicle class, it is said that: Car *inherits* attributes and methods from Vehicle. Car *extends* Vehicle. Car is a *subclass* of Vehicle. Vehicle is a *superclass* of Car. \n\nThere is a list of terms: Derived class, Child class, Base class, Parent class.\n\nInheritance implements the *is-a* relation: A car *is-a* vehicle; a dog *is-a* mammal, etc. \n", "Inheritance\nDeclaration of subclasses\n\nThe syntax for declaring subclasses is:\n\n\"class\" Subclass \"extends\" Superclass { ... }\n\nThere is a diagram showing the inheritance hierarchy of some classes.\nThere is a base class \"Person\" from which two classes inherit: \"Student\" and \"Employee\".\n\"Employee\" has two subclasses: \"Professor\" and \"Secretary\".\n\nThere is also a code snippet showing how to declare the classes:\n\n\"class\" Person { ... }\n\"class\" Student \"extends\" Person { ... }\n\"class\" Employee \"extends\" Person { ... }\n\"class\" Professor \"extends\" Employee { ... }\n\"class\" Secretary \"extends\" Employee { ... }\n\nFinally, there is a note indicating that each class is in a different file and declared as public.\n", "Inheritance\nSubclass\n\nWe see a class diagram representing the concept of inheritance. The subclass \"Student\" inherits from the superclass \"Person\". The \"Person\" class has attributes: \"firstName\", \"lastName\", and \"birthYear\", and a method \"print\". The \"Student\" class inherits these attributes and method, and additionally has attributes: \"group\" and \"timetable\", and methods: \"setGroup\", \"setTimetable\", and \"printGroup\". \n", "Inheritance\nHow is it used?\n\nWe see the code for a class named Person. The class has three protected attributes: firstName, lastName and birthYear. It also has three methods: an empty constructor, a constructor with parameters to initialize the attributes and a print method. The print method outputs the text \"Personal data:\" followed by the value of the firstName attribute, then a space, then the lastName attribute, then a space, then an opening parenthesis, then the birthYear attribute and finally a closing parenthesis.\n\nOn the right-hand side, there is a diagram representing a class that inherits from the Person class. The subclass inherits the three attributes: firstName, lastName and birthYear, and the print method. \n", "Inheritance How is it used?\n\nWe see a code snippet defining a class named \"Student\" that inherits from a class named \"Person\". The \"Student\" class has two protected attributes: \"group\" of type String and \"timetable\" of type char. It also has three methods: \"setGroup\", \"setTimetable\", and \"printGroup\". The \"setGroup\" method checks if the group is null or empty and prints an error message if it is. Otherwise, it sets the group attribute to the given value. The \"setTimetable\" method checks if the timetable is 'M' or 'A' and prints an error message if it is not. Otherwise, it sets the timetable attribute to the given value. The \"printGroup\" method prints the group and timetable attributes. The \"Student\" class also has a constructor that takes the student's first name, last name, birth year, group, and timetable as arguments. This constructor calls the superclass constructor to initialize the first name, last name, and birth year attributes, and then it calls the \"setGroup\" and \"setTimetable\" methods to initialize the group and timetable attributes.\n\nOn the right-hand side, we have a diagram representing the \"Student\" class. It shows that the \"Student\" class inherits from the \"Person\" class and lists the attributes and methods of both classes. The \"Student\" class has two attributes: \"group\" and \"timetable\". It also has three methods: \"setGroup\", \"setTimetable\", and \"printGroup\". The \"Person\" class has three attributes: \"firstName\", \"lastName\", and \"birthYear\". It also has one method: \"print\". The diagram also shows that the \"Student\" class inherits the \"print\" method from the \"Person\" class.\n\nFinally, the keyword \"super\" is used to access attributes or methods from the superclass. \n", "Inheritance How is it used?\n\nWe see a code snippet of a program written in Java. The program defines a class named \"Test\" with a main method. Inside the main method, two objects are created: \"neighbor\" of type \"Person\" and \"aStudent\" of type \"Student\". The \"Student\" class inherits from the \"Person\" class. Both objects are initialized with data, and then several methods are called on them, including \"setGroup\", \"setTimetable\", \"print\", and \"printGroup\". \n\nThe expected output of the program is shown below the code, indicating that it will print personal data for both the \"Person\" and \"Student\" objects, including the student's group. This example demonstrates the concept of inheritance in object-oriented programming, where a subclass (Student) can inherit properties and methods from a superclass (Person).\n", "Inheritance\nWhat if...?\n\nWe are defining the attribute \"firstName\" of \"Person\" as private. We inherit it, but we cannot access it unless we implement methods to do so, for example: \"getFirstName\".\n\nWe implement the constructor of the subclass \"Student\", assigning the values directly to attributes instead of calling to \"super\". This means we are not taking advantage of code reuse. It is valid in this case because attributes are defined as protected, but this is not always the case.\n\nThere are two code snippets, one on the left and one on the right, both showing the constructor of the subclass \"Student\".\n\nThe code on the left shows the constructor \"Student\" with parameters \"firstName\", \"lastName\", \"birthYear\", \"group\" and \"timetable\". It then assigns each parameter to the corresponding attribute of the class.\n\nThe code on the right shows the constructor \"Student\" with the same parameters as before. However, in this case, it calls the constructor of the superclass, \"super\", with parameters \"firstName\", \"lastName\" and \"birthYear\". Then, it assigns the parameters \"group\" and \"timetable\" to the corresponding attributes of the class.\n\nFinally, there is a big \"OK\" at the bottom right of the image.\n", "Inheritance\nConsequences of extension of classes\n\nThere are two bullet points on this slide, both discussing the consequences of class extension: Inheritance of the interface and Inheritance of the implementation.\n\nThe first bullet point, Inheritance of the interface, states that the public part of the subclass contains the public part of the superclass. For example, the Student class contains the method print().\n\nThe second bullet point, Inheritance of the implementation, states that the implementation of the subclass contains the implementation of the superclass. When calling the method of the superclass on an object of the subclass, for example aStudent.print(), the expected behavior takes place. \n", "Exercise 5\n\nStarting from the class \"Bicycle\", which has three attributes: \"speed\", \"cadence\" and \"gear\" of type integer, and four methods: \"speedUp\", \"brake\", \"setCadence\" which takes an integer \"newCadence\" as input, and \"setGear\" which takes an integer \"newGear\" as input, implement the classes \"MountainBike\" and \"TandemBike\".\n\"MountainBike\" has an attribute \"suspension\" of type integer, and a method \"setSuspension\" which takes an integer \"suspension\" as input.\n\"TandemBike\" has an attribute \"numSeats\" of type integer.\nProgram the constructors of these classes to initialize all their attributes, making use of \"super\". \n", "Inheritance\nInheritance hierarchy in Java\n\nIn Java, all classes are related through a single inheritance hierarchy.\n\nA class can:\n- Explicitly inherit from another class, or\n- Implicitly inherit from the **Object** class (defined in the Java core)\n\nThis is the case both for predefined classes and for user-defined classes.\n", "Inheritance\nInheritance hierarchy in Java\n\nWe see a diagram depicting the inheritance hierarchy in Java. At the top is the Object class. Below that are Boolean, Character, Number, String, and Person. Below Number are Integer, Long, Float, and Double. Below Person are Student and Employee. Below Employee are Secretary and Professor. There are three dots to the right of Person, indicating that there are more classes that inherit from Object.\n\nBelow the diagram, we see two lines of code. The first line, \"Integer i = new Integer(3);\", is marked as deprecated with a warning. The second line, \"Integer i = 3;\", is an example of autoboxing. \n", "Inheritance\nOverriding\n\n- Modification of the elements of the base class inside the derived class\n- The derived class can define:\n  - An attribute with the same name as one of the base class, which is called attribute hiding\n  - A method with the same signature as one of the base class, which is called method overriding\n- The second case, method overriding, is more usual \n", "Overriding I (Shadowing)\nAttribute hiding\n\n- If we define an attribute (variable) in a subclass with the same name and type that another attribute in the superclass, the variable in the superclass remains hidden\n- We can access one variable or the other using this and super. \n", "Overriding I (Shadowing)\nAttribute hiding\n\nWe have a class named Student that inherits from class Person. \n\nThere are 3 code snippets that instantiate objects of these classes and access the firstName attribute. \n\nThe first one instantiates a Student object and accesses its firstName attribute. \n\nThe second one instantiates a Person object and accesses its firstName attribute. \n\nThe third one assigns the Student object to a Person variable and accesses its firstName attribute. \n\nAlthough the three snippets access an attribute with the same name, the type might be different.\n\nThe Person class has the following attributes: firstName, lastName, and yearBirth, all inherited from the Person class. It also has a print method. \n\nThe Student class has the following attributes: firstName, group, and timetable. It also has the following methods: setGroup, setTimetable, and printGroup. \n", "Overriding I (Shadowing)\nAttribute hiding. Example\n\nWe see code illustrating attribute hiding in Java.\n\nThere are three classes defined: Person, Student, and Test.\n\nThe Person class has a protected String attribute called firstName initialized to \"Juan\".\n\nThe Student class extends Person and declares a protected int attribute also named firstName, initialized to 10003041. This demonstrates attribute hiding, where the Student class's firstName attribute shadows the Person class's firstName attribute.\n\nThe Test class contains a main method. Inside the main method:\n- A new Student object is created and assigned to variable 's'.\n- A Person variable 'p' is declared and assigned the value of 's'. This is valid due to polymorphism, as Student is a subclass of Person.\n- Two print statements are called:\n    - The first prints the value of p.firstName. Since 'p' is of type Person, it accesses the firstName attribute from the Person class, resulting in \"Juan\" being printed.\n    - The second prints the value of s.firstName. As 's' is of type Student, it accesses the firstName attribute from the Student class, printing \"10003041\".\n\nThis example highlights how attribute hiding can lead to different values being accessed depending on the object's reference type.\n", "Overriding I (Shadowing)\nAttribute hiding\n\nThe image describes the concept of attribute hiding in object-oriented programming, specifically focusing on how to access hidden variables in a class hierarchy. \n\nThere are three classes: \"Transport\", \"Vehicle\", and \"Car\". \"Transport\" is the parent class of \"Vehicle\", which in turn is the parent class of \"Car\". Each class has a \"name\" attribute. The \"Car\" class overrides the \"name\" attribute inherited from its parent classes.\n\nThe image then lists different ways to access the hidden \"name\" variables:\n\n* **name:** This refers to the \"name\" variable of the current class, which is \"Car\" in this case.\n* **this.name:** This also refers to the \"name\" variable of the current class, \"Car\".\n* **super.name:** This refers to the \"name\" variable of the immediate parent class, \"Vehicle\".\n* **((Vehicle)this).name:** This explicitly casts the current object to the \"Vehicle\" type and accesses its \"name\" variable.\n* **super.super.name:** This is marked as WRONG because it attempts to access the \"name\" variable of the grandparent class, \"Transport\", which is not directly accessible.\n* **((Transport)this).name:** This explicitly casts the current object to the \"Transport\" type and accesses its \"name\" variable.\n\nThe image also visually separates the accessible variables from the hidden ones. The \"name\" variables of the \"Car\" and \"Vehicle\" classes are grouped together and labeled as \"visible\" because they can be accessed directly. The \"name\" variable of the \"Transport\" class is labeled as \"hidden\" because it's not directly accessible from the \"Car\" class. \n", "Overriding II\nMethod overriding. What is it?\n\nMethod overriding is useful for extending the functionality of a method and particularizing the functionality of the method in the derived class.\n\nIf the subclass defines a method with the same signature, which is the name plus number and type of the parameters, the method in the superclass is hidden.\n\nHow can we access hidden methods?\n\nWe can use start, which runs the start method of the car. This dot start runs the start method of the car. Super dot start runs the start method of the vehicle. Super dot super dot start is wrong.\n\nThe methods of the child class are visible. The methods of the parent class are hidden.\n", "Overriding II\nMethod overriding. What is it for?\n\nWe see two class diagrams. The first one shows two classes, \"Classroom\" and \"Computer\", both extending a class called \"Resource\". The \"Resource\" class has the following methods: \"getName\", \"getDescription\", \"name\" and \"description\". The \"Classroom\" class adds three methods: \"getLocation\", \"getDescriptoin\" and \"location\". The \"Computer\" class adds two methods: \"getOS\" and \"operatingSystem\". \n\nThe second class diagram also shows two classes, \"Classroom\" and \"Computer\", both extending a class called \"Resource\". The \"Resource\" class has the following methods: \"getName\", \"getDescription\", \"name\" and \"description\". The \"Classroom\" class adds two methods: \"getLocation\" and \"location\". The \"Computer\" class adds one method: \"getOS\". The \"getDescription\" method in the \"Classroom\" class is highlighted and two more methods are shown below: \"this.getDescription()\" and \"super.getDescripcion\". \n", "Overriding II\nMethod overriding\n\nThe diagram illustrates the concept of method overriding in object-oriented programming. \n\nWe see an object on the left side of the image, from which an arrow labeled \"message\" points to the right. The message contains the text \"method(parameters)\". On the right side, we see a flow chart with four boxes representing different classes: \"Subclass\", \"Superclass\", \"Another ancestor\", and \"Object\". These boxes are connected by upward arrows. \n\nThe \"Subclass\" box is connected to the \"object\" with a dashed arrow labeled \"instance\". Each connection between the boxes has a corresponding cloud above it, containing the text \"\u2203 method(parameters)?\". All connections except the one from \"Object\" are also labeled \"no\". The connection from \"Object\" is labeled \"no\" and points to a box labeled \"error\". \nThis diagram explains how the program searches for the correct method to execute when a message is sent to an object. It starts by checking the \"Subclass\" for a matching method. If not found, it moves up the inheritance hierarchy to \"Superclass\", then \"Another ancestor\", and finally \"Object\". If a matching method is found at any level, it is executed. If no matching method is found even in the \"Object\" class, an error is thrown. \n", "Overriding II\nMethod overriding\n\nWhen sending a message to an object, the selected method:\n- Depends on the class which the object is an instance of\n- Does not depend on the reference class to which it is assigned, as in the case of attributes \n", "Overriding II\nMethod overriding. Example\n\nWe see three code snippets. The first one defines a class named \"Person\" with a protected string attribute called \"firstName\" initialized to \"Juan\". This class has a public method called \"print\" that prints \"Person\" followed by the value of the \"firstName\" attribute.\n\nThe second snippet defines a class named \"Student\" that extends the \"Person\" class. This class also has a protected string attribute called \"firstName\", but it's initialized to \"Juan Pablo\". It also has a public method called \"print\" that prints \"Student\" followed by the value of the \"firstName\" attribute.\n\nThe third snippet defines a class named \"Test2\" with a main method. Inside the main method, a new \"Student\" object is created and assigned to a variable called \"s\". Then, a \"Person\" variable called \"p\" is declared and assigned the value of \"s\". Finally, the \"print\" method is called on both \"s\" and \"p\".\n\nBoth calls to the \"print\" method will output \"Student: Juan Pablo\" because the \"print\" method in the \"Student\" class overrides the \"print\" method in the \"Person\" class. This is an example of method overriding in Java.\n", "Exercise 6\n\nWe are asked to override the method speedUp, that takes no arguments, from the Bicycle class in the MountainBike and TandemBike subclasses. In the MountainBike subclass, tripling the current speed is how we are defining speeding up. In the TandemBike subclass, quadrupling the current speed is how we are defining speeding up.\n\nNext, we are asked to create two objects, one of class MountainBike and one of class TandemBike. We are then asked to call the speedUp method on both of these objects. Finally, we are asked what the result of calling this method on each of these objects is and how we would access the implementation of the speedUp method of the Bicycle class from the two objects that we just created. \n", "Overriding vs. overloading\n\n- Overriding: The subclass substitutes the implementation of a method of the superclass\n    - Both methods need to have the same signature\n- Overloading: There is more than one method with the same name but different signature\n    - The overloaded methods can be declared in the same class or in different classes in the inheritance hierarchy \n", "Constructors and inheritance\n\nThis slide describes the steps to create an object.\nFirst, the base part is created, then the derived part is added.\nIf the base class of the object inherits from another class, step 1 is applied in the order of the inheritance chain until we reach the object class.\n\nFor example, when creating a student object that extends person, the steps would be:\nFirst, the part corresponding to person is created. To do so, the part corresponding to object is created, then the person elements are added.\nFinally, the student elements are added.\n", "Constructors and inheritance\n\n- A call to the constructor of the base class is always done in the constructor of the derived class.\n- This is the first action of the constructor (always in the first line).\n- Two possibilities: \n    - Not explicitly indicated\n    - Explicitly indicated (mandatory in the first line) \n", "Constructors and inheritance\n\nIf a call to the superclass constructor is not made explicit, Java automatically inserts a call to \"super()\" in the first line of the constructor of the derived class.\n\nThe code example shows the constructor of the class \"Student\" which takes as arguments: a string \"firstName\", a string \"lastName\", an integer \"birthYear\", a string \"group\" and a character \"timetable\". \n\nThe comment in the code indicates that Java would insert a call to the superclass constructor at that position. \n", "Constructors and inheritance\n\nThis slide titled \"Constructors and inheritance\" presents a code snippet illustrating how to explicitly indicate inheritance in a constructor. The code defines a \"Student\" constructor in Java. This constructor takes a first name, last name, birth year, group, and timetable as arguments. It then calls the superclass constructor using the \"super\" keyword, passing in the first name, last name, and birth year. Finally, it sets the group and timetable fields of the \"Student\" object to the values passed in as arguments. The keyword \"super\" is highlighted in blue. \n", "More on super\n\n- The keyword 'super' references the current object casted as if it was an instance of its superclass\n- With the 'super' reference, the methods of the base class can be explicitly accessed\n- 'super' is useful when overriding methods\n\nWe see an example of a 'Student' class extending a 'Person' class. The 'print' method in the 'Student' class calls the 'print' method of the 'Person' class using 'super.print()' and then prints additional information. \n", "Polymorphism\nWhat is it?\n\nPolymorphism is the capacity of an object for deciding which method to apply, depending on the class it belongs to.\nA call to a method on a reference of a generic type, for example, a base class, executes different implementations of the method depending on which class the object was created as.\n\nPolymorphism allows designing and implementing extensible systems.\nPrograms can process generic objects described by references of the superclass.\nThe specific behavior depends on the subclasses.\nNew subclasses can be added later.\n", "Polymorphism\nExample\n\nWe have an example of polymorphism with Student, Professor and Secretary. We create an array of Person where we include objects of Student, Professor and Secretary. When calling the method print(), overridden in classes Student, Professor and Secretary, on the array of Person, each object uses its own implementation of the method.\n\nThe code snippet shows how to create an array of Person objects and how to call the print() method on each object in the array. \n- The first line of code declares an array of Person objects called group. \n- The second line of code initializes the array with four Person objects: a Student, a Professor, a Secretary, and another Student. \n- The third line of code is a for loop that iterates over the array of Person objects. \n- The fourth line of code calls the print() method on each Person object in the array. \n", "Polymorphism\nDynamic binding\n\nThe power of method overriding is that the correct method is properly called even though the object of the child class is referenced through the base class. This mechanism is called \"dynamic binding\". It allows detecting the proper method to call during runtime. The compiler does not generate the calling code during compile time, it only generates code for calculating which method to call. This is different from \"static binding\" (e.g., method overloading) where the proper method is detected at compile time. \n", "Exercise 7\n\nCreate an array of class Bicycle that contains objects of classes Bicycle, MountainBike and TandemBike.\nCall the method speedUp() on each of these objects, taking advantage of the benefits of polymorphism and dynamic binding. \n", "Modifiers and access\nFinal\n\n- If we do not want that derived classes can modify (override) a method or attribute of the base class, then the final modifier shall be used. \n", "Modifiers and access\nFinal\n\nThe final modifier can be applied to parameters, attributes, methods and classes.\n\nWhen applied to **parameters**, it means that their value cannot be changed inside the method. For example, in the code snippet 'public void myMethod(final int[] p1, int p2) { }', the values of p1 cannot be changed.\n\nWhen applied to **attributes**, it means that their value cannot be changed in the class. It is used together with 'static' to define constants. For example, in the code snippet 'public static final double PI = 3.14;', the value of PI cannot be changed.\n\nWhen applied to **methods**, it means that they cannot be overridden in derived classes. For example, in the code snippet 'public final void myMethod() { }', myMethod cannot be overridden.\n\nWhen applied to **classes**, it means that the class cannot be extended or inherited. For example, in the code snippet 'public final class myClass(){}', myClass cannot be extended.\n", "MODIFIERS\n\nThe table shows Java modifiers and their effect on classes, methods and attributes.\n\nRegarding access, we have:\n- public: accessible to any other class.\n- (friendly): accessible only to classes in the same package.\n- protected: accessible to the class, its subclasses and classes in the same package.\n- private: accessible only inside the class.\n\nOther modifiers are:\n- final: cannot be extended for classes, cannot be overridden for methods and its value cannot be changed for attributes. It is constant. It is normally used together with static.\n- static: maximum level class. It is the same for all the class objects. It is used as ClassName.method(); for methods and ClassName.attribute; for attributes. \n", "Systems Programming\n\nObject-ORIENTED programming (advanced)\n\nThe title of this slide is \"Systems Programming\" with a subtitle \"Object-ORIENTED programming (advanced)\".  It seems to be part of a presentation for the Telematics Engineering Department as indicated in the smaller text.  The footnote indicates this presentation is based mostly on the work of six individuals. \n", "Key terms\n\n- Casting which can be upcasting vs downcasting or widening vs narrowing\n- Abstract classes and methods, including inheritance and polymorphism\n- Interfaces, including implements, inheritance and polymorphism \n", "**Contents**\n\n- Casting and type compatibility\n- Abstract classes and methods\n- Interfaces \n", "Casting (Type conversion)\nSyntax and terminology\n\nLet's talk about casting in programming, specifically type conversion, its syntax, and terminology.\n\nCasting syntax follows this structure: within parentheses, you specify the desired data type, followed by the identifier representing the variable or value you want to cast.\n\nThere are two primary types of casting:\n\n- Widening or upcasting: This involves using a subclass as an instance of its superclass. This type of conversion is implicit, meaning the compiler handles it automatically.\n\n- Narrowing or downcasting: In this case, the superclass is treated as an instance of its subclass. This conversion is explicit, requiring you to explicitly instruct the compiler to perform the cast.\n\nIt's important to note that casting is applicable only between parent and child classes within the class hierarchy. Sibling classes cannot be cast to each other.\n\nTo illustrate, let's look at some examples:\n\n- The first example shows a string \"3\" assigned to a variable 's'.\n- The second example demonstrates an incorrect attempt to directly assign this string to an Integer variable 'i'.\n- The third example provides the correct way to achieve this conversion using Integer.parseInt(s), which correctly parses the string \"3\" into its integer equivalent.\n", "Casting (Type conversion)\nWidening or upcasting\n\nHere we are discussing the concept of casting, specifically widening or upcasting.\n\nThe first type of casting, upcasting, refers to compatibility upwards, towards the base class. An object of the derived class can always be used as an object of the base class because it implements an \u201cis-a\u201d relationship. For example, the code snippet \"Person p = new Student();\" shows how a variable of type Person can be assigned a new Student object. \n", "Casting (Type conversion)\nNarrowing or downcasting\n\nDowncasting: compatibility downwards (towards the derived classes)\n\n- Downcasting cannot be applied by default, because an object of the base class is not always an object of the derived class\n\nHere we have an example of wrong syntax: \"Student s = new Person(); // wrong\"\n\n- It is only possible when the reference of the base class points to an object of the derived class\n- In these cases, an explicit casting must be applied\n", "Casting (Type conversion)\nExample\n\nThe image shows an example of casting in Java. Casting is a type conversion that allows you to treat an object of one type as an object of another type. The example shows how to cast a Student object to a Person object and vice versa.\n\nThe first example shows implicit upcasting, which is allowed because a Student is always a Person. The second example shows implicit downcasting, which is not allowed because a Person is not always a Student. The third example shows explicit downcasting, which is allowed because the programmer is explicitly stating that the Person object is actually a Student object.\n\nThe image also includes a note that explains that if someone is both a person and a student, they can be required to do things that are specific to students, but only if it is explicitly stated that they will be treated as a student.\n", "Casting (Type conversion)\nExample\n\nThis slide explains the concept of casting in programming, specifically focusing on downcasting. It presents code examples in an attempt to illustrate why downcasting from a Person object to a Student object is problematic.\n\nThe first code snippet demonstrates implicit downcasting, which results in a compiler error. The code attempts to assign a Person object (p2) to a Student object (s3) without explicit conversion. The comment highlights that this approach doesn't work due to a compiler error.\n\nThe second code snippet explores explicit downcasting using type casting. While this approach might seem plausible, it can lead to a ClassCastException at runtime. The comment explains that this exception occurs because the Person object (p2) might not actually represent a Student object.\n\nThe third code snippet showcases another instance of implicit downcasting, attempting to create a new Person object and assign it to a Student object (s4). This approach also results in an error, as indicated by the comment.\n\nThe slide emphasizes the following points:\n\n- A Person object isn't always a Student object; assuming this implicitly is incorrect.\n- While a Person object can sometimes be a Student object, if it wasn't created as such, it cannot be treated as one, even with explicit casting.\n\nThe slide visually reinforces these points with arrows connecting code snippets to textual explanations. A red arrow links the first and third code snippets to a box stating that a Person object isn't always a Student object and cannot be implicitly assumed as such. Another red arrow connects the second code snippet to a box explaining that a Person object might sometimes be a Student object, but only if it was created as one. If not, treating it as a Student object will fail, even with explicit casting.\n", "Casting (Type conversion)\ninstanceof operator\n\n- Syntax: object instanceof class\n- Checks if an object is really an instance of a given class\n\nExample:\n In this example, we have a code snippet that defines a public method called \"check\" that takes a \"Person\" object as input and returns a \"Student\" object. Inside the method, a \"Student\" object \"s\" is initialized to null. Then, an \"if\" statement checks if the input \"Person\" object \"p\" is an instance of the \"Student\" class using the \"instanceof\" operator. If it is, the \"Student\" object \"s\" is assigned the value of \"p\" casted to the \"Student\" type. Finally, the \"Student\" object \"s\" is returned. \n```java\npublic Student check(Person p) {\n  Student s = null;\n  if (p instanceof Student)\n    s = (Student) p;\n  return s;\n}\n``` \n", "Abstract classes\nWhat is an abstract class?\n\nAn abstract class declares the structure of a given abstraction, without providing all the implementation details. In other words, it might not implement every method completely.\n\nAn abstract class is a class that can have abstract methods. Abstract methods are not implemented and have no code. If the class has at least one abstract method, it will be abstract.\n\nThere is a diagram representing the concept of abstraction with classes. The parent class is \"Message\" and it has three children classes: \"Email\", \"SMS\" and \"WhatsApp\". \n", "Abstract classes\nCharacteristics\n\nClasses and methods are defined as abstract using the reserved word abstract\n\nThere is a code snippet: public abstract class Figure\n\nThere is a diagram showing the class Figure with three subclasses: Circle, Rectangle and Triangle. Figure is pointing to its subclasses.\n", "Abstract classes\nCharacteristics\n\n- Abstract classes cannot be instantiated\n  - References to abstract classes can exist\n  - But they point to objects of classes derived of the abstract class\n  - Example: Figure fig = new Rectangle(2,3);\n- Abstract classes can be extended\n- In an abstract class, there can be both\n  - abstract methods\n  - non abstract methods\n\nThe diagram shows that the class \"Figure\" is an abstract class and it has 3 child classes: \"Circle\", \"Rectangle\", and \"Triangle\".\n", "Abstract classes\nWhat are they for? partial implementations\n\nAbstract classes are normally used for representing partially implemented classes.\nSome methods are not implemented but declared.\nThe objective of partial implementations is to provide a common interface to all derived classes, even though in cases when the base class has not enough information to implement the method. \n", "Abstract classes\nAbstract methods\n\n- Methods declared but not implemented in abstract classes: abstract return type name, parameters in parenthesis and semicolon. Abstract methods are declared using the reserved word 'abstract'.\n- Classes inheriting from the abstract class must implement all the abstract methods of the superclass or they will be abstract as well.\nNote: No braces. They are not implemented, thus only a semicolon follows the declaration. \n", "Abstract classes\nAbstract methods\n\nThe abstract modifier cannot be applied to:\n- constructors\n- private methods\n- static methods \n", "Abstract classes\nHow are they used? Example\n\nWe see an example of Java code showing the definition of an abstract class named \"Figure\" and a class named \"Rectangle\" that extends it.\n\nThe \"Figure\" class has two protected attributes of type double, \"dim1\" and \"dim2\", and a constructor that initializes them. It also has an abstract method called \"area\" that returns a double.\n\nThe \"Rectangle\" class extends the \"Figure\" class and provides an implementation for the \"area\" method, which returns the product of \"dim1\" and \"dim2\". \n", "Exercise 8\n\nStarting from the class \"Bicycle\" which has three attributes: \"speed\", \"cadence\", and \"gear\" of type integer, and four methods: \"speedUp\", \"brake\", \"setCadence\" which takes an integer \"newCadence\" as input, and \"setGear\" which takes an integer \"newGear\" as input, implement the abstract class \"Vehicle\".\n\nThink about the attributes and methods that will be specific to \"Bicycle\" and those that can be inherited, considering that besides \"Bicycle\" we will have classes \"Car\" and \"Truck\".\n\nThink about the methods that shall be abstract and those that shall not be abstract in the class \"Vehicle\". \n", "Abstract classes Polymorphism\n\nThe image shows a code snippet illustrating the concept of polymorphism in object-oriented programming using abstract classes. \n\nAn array named \"myFigures\" of type \"Figure\" is declared and initialized with a size of 3. The \"Figure\" class is abstract, meaning it cannot be instantiated directly.\n\nEach element of the array is then assigned an instance of a concrete subclass of \"Figure\": \"Rectangle\", \"Triangle\", and \"Square\". This demonstrates polymorphism, as the array can hold objects of different but related types.\n\nThe code then iterates through the \"myFigures\" array and calls the \"area()\" method on each element. Since \"area()\" is declared in the abstract \"Figure\" class, each concrete subclass must provide its own implementation. This ensures that the correct area calculation is performed based on the actual type of object at runtime, showcasing dynamic binding.\n\nAn annotation highlights that calling the \"area()\" method on objects of type \"Figure\" during runtime will determine the specific object type and execute the appropriate method. This dynamic behavior is referred to as \"Dynamic binding\".\n\nAnother annotation points out that although the array \"myFigures\" is of type \"Figure\" (abstract), its elements are instances of concrete classes, namely \"Rectangle\", \"Triangle\", and \"Square\", which are non-abstract subclasses of \"Figure\".\n", "Interfaces\nWhat is an interface?\n\n- Interfaces take the abstract class concept one step further\n- All methods in the interface are abstract\n- Interfaces are always public\n    - Interface attributes are public by default\n    - Interface methods are public by default\n- Interfaces are implemented by classes\n    - A class implements an interface defining the body of all the methods\n    - An abstract class implements an interface implementing or declaring abstracts the methods\n    - A class (abstract or not) can implement one or more interfaces\n", "Interfaces\nWhat is an interface?\n\n- An *interface* is a pure design element: what to do.\n- A *class* (including abstract ones) is a mix of design and implementation: what to do and how.\n- Different classes can implement the same interface in different ways. \n", "Interfaces\nDeclaration\n\nLet's talk about the syntax for declaring interfaces.\n\nWe start with the keywords \"public interface\" followed by the name of the interface. The body of the interface is enclosed in curly braces.\n\nInside the interface, we can define constants and methods.\n\nConstants are declared using the keywords \"static final\" followed by the type, the constant name, the assignment operator, and the value. Constant declarations end with a semicolon.\n\nMethods are declared with the return type, the method name, and the parameters in parentheses. Note that method declarations in interfaces do not include braces or a method body. Instead, they end with a semicolon.\n\nThere are two important notes to keep in mind.\n\nFirst, as mentioned earlier, method declarations in interfaces do not include braces. This is because the method is not implemented in the interface itself. The implementation is provided by the classes that implement the interface.\n\nSecond, constants and methods in interfaces are always public, even if the \"public\" keyword is not explicitly used. This is because interfaces are meant to be accessed by other classes.\n", "Interfaces\nImplementation\n\n- If a class implements an interface, it implements all abstract methods declared in such interface\n- Represented with the reserved word 'implements'\n\nThere is a code snippet: \n\npublic class MyClass implements Interface, Interface2 {...}\n\nThe snippet shows how to implement interfaces in a class declaration.\n", "Interfaces\nWhat are they for?. Multiple inheritance\n\nWe have a class diagram showing the concept of multiple inheritance using interfaces. \n\nThere are three boxes at the top: ClassA on the left, Interface B in the middle, and Interface C on the right.\n\nClassA has a method called methodA. Interface B has a method called methodB. Interface C has a method called methodC.\n\nAn arrow labeled \"extends\" goes from Class C to ClassA. Two arrows labeled \"implements\" go from Class C to Interface B and Interface C, respectively.\n\nThere are two bullet points below the diagram. The first one says Java does not allow multiple inheritance. The second one says: But it several interfaces can be implemented.\n", "Interfaces\nHow to use them?\n\nWe have three classes: Figure, Circle and Rectangle. Figure is an abstract class. Circle and Rectangle extend Figure. There is also an interface called Drawable. Both Circle and Rectangle implement Drawable. Figure has one method: area. Drawable has one method: draw. Both Circle and Rectangle inherit area from Figure and implement draw from Drawable. \n", "Interfaces\nExample\n\nThis code defines a public interface called \"LowEmission\".\n\n**Attributes:**\n\n* It first declares a public character variable named \"tag\" and initializes it with the character 'B'.\n* Then, it declares another character variable \"tag2\" and sets it to 'B'.\n* Next, it defines a public static double variable \"emission\" and assigns it the value 12.4.\n* It also declares a static double variable \"emission2\" with the same value, 12.4.\n* Further, it declares a public static final double variable \"maxEmission\" and initializes it with the value 12.\n* Another static final double variable \"maxEmission2\" is declared and set to 12.\n\nThe comments in the code indicate that:\n* Initializing variables within the interface declaration is not allowed for non-static and non-final variables.\n* Private attributes are not allowed in interfaces.\n\n**Methods:**\n\n* The interface includes a public method called \"getTag\" that returns a character.\n* It also has a public static method named \"getEmission\" which returns a double value of 0.\n* Additionally, there's a static method \"getEmission2\" that also returns a double value of 0.\n\nSimilar to attributes, the comments highlight that:\n* Private methods are not allowed in interfaces.\n* It's not allowed to have only the declaration of a method without a body in an interface.\n", "Exercise 9\n\nImplement the interface **Printable**, which contains the method **print()**, which does not return any value.\nClass **Bicycle** implements the interface **Printable**, so that it prints on screen the values of current speed, cadence and gear. \n", "Interfaces. Interface inheritance. Polymorphism\n\n- Interfaces can also have an inheritance hierarchy.\n- Classes implementing the interfaces in the hierarchy must include all the methods defined in the interfaces.\n- Interfaces also support dynamic resolution of methods during runtime (dynamic binding).\n", "Exercise 10\n\nImplement the interface \"Definable\", which contains the method \"getAttributes()\". This method returns the value of the attributes of the object. The interface \"Printable\" inherits from \"Definable\". Which changes are needed in the interface \"Printable\"? And in the class \"Bicycle\"? \n", "Object Orientation Summary\n\nWe are going to talk about classes, abstract classes and interfaces.\n\nA class, in its actual form, has all its methods implemented.\n\nAn abstract class can include methods which are not implemented but just declared. Abstract classes use the abstract modifier.\n\nFinally, an interface has no implementation at all. The reserved word for interface is, as you can imagine, \"interface\". \n", "Object Orientation Summary\n\nA class, which can be actual or abstract, can extend only one base class, which is called simple inheritance. It can implement one or more interfaces, which is called multiple inheritance.\n\nAn Interface can extend one or more interfaces. \n", "The table describes Java modifiers. \n\nThe table lists 6 access modifiers: public, friendly (package), protected, private, abstract and final, and one modifier that changes the behavior of members of a class: static.\n\nFor each modifier, the table describes how it affects classes, methods and attributes.\n\n**public** elements are accessible from any other class.\n\n**(friendly)** elements are only accessible to classes in the same package.\n\n**protected** elements are accessible to the class, its subclasses and classes in the same package.\n\n**private** elements are only accessible inside the class.\n\n**abstract** classes cannot be instantiated but are designed to be inherited from. They have no code, and it is implemented in the subclasses. They must have at least one abstract method.\n\n**final** classes cannot be extended and are a leaf in the inheritance tree. Final methods cannot be overridden. Final attributes are constants and their value cannot be changed.\n\n**static** elements are the same for all the class objects. To use a static method, use ClassName.method(); To use a static attribute, use ClassName.attribute;\n"]}, {"filename": "4. Recursion.pdf", "text": "Systems Programming\n\nRecursion\n\nDepartamento de Ingenier\u00eda \nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nCarlos Delgado Kloos, Carmen Fern\u00e1ndez Panadero, \nCarlos Alario Hoyos, Julio Villena Rom\u00e1n\n\n\fContents\n\nv Recursion\nv Types of recursion\nv Recursion vs. iteration\n\n2\n\n\fRecursive Methods\n\n\u2022 A method is called recursive, if it calls itself\n\n(directly or indirectly)\n\n\u2022 (For a recursive method to define a \n\nterminating computation)\nthe recursive call(s) have to be simpler\n(according to some metric)\n\n3\n\n\fThe call stack and the JVM\n\nThe stack is used to store the \nexecution order of methods and \nlocal variables.\n\nThe heap \nstores the \nobjects\n\nJava Virtual Machine (JVM)\n\n4\n\n\fExample 1\n\n\u2022 Summation from 1 to n (with n > 0)\n\npublic static long s (int n) {\n\n    if (n==1){\n\n     return 1;\n\n    }\n\n  else{\n     return s(n-1)+n;\n\n    }\n}\n\nBase \ncase\n\nRecursive \ncase\n\n5\n\n\fExample 1\n\n\u2022 Summation from 1 to n (with n > 0)\n\n\u275a s(3) =\n\n\u275a s(2)+3 =\n\n\u275a  s(1)+2)+3 =\n\n\u275a  (1+2)+3 =\n\n\u275a  (3+3)=\n\n\u275a  6\n\npublic static long s (int n){     \n   if (n==1){\n      return 1;\n   }\n   else{\n\n      return s(n-1)+n;\n\n   }\n}\n\n\u2022\n\u2022\n\nThe recursive case happens twice => s(3) and s(2)\nThe base case happens once => s(1)\n\n6\n\n\fExample 2\n\n\u2022 Badly designed recursion*\n\npublic static long s (int n){     \n   if (n==1){\n      return 1;\n   }\n   else{\n\nBase \ncase\n\n      return s(n+1)+n;\n\n   }\n}\n\n*(if n > 1)\n\nRecursive \ncase\n\n7\n\n\fExample 2\n\n\u2022 Badly designed recursion*\n\n\u275a  s(3) =\n\n\u275a  s(4)+3 =\n\n\u275a  (s(5)+4)+3 =\n\npublic static long s (int n){     \n   if (n==1){\n      return 1;\n   }\n   else{\n\n\u275a  ((s(6)+5)+4)+3 =\n\n      return s(n+1)+n;\n\n\u275a  (((s(7)+6)+5)+4)+3 =\n\n\u275a  ...\n\n\u275a    It does not terminate\n\n   }\n}\n\n\u2022\n\u2022\n\u2022\n\nThe recursive case happens \u201cinfinite\u201d number of times\nThe base case never happens\nStackOverflowError (too much memory used in the call stack)\n\n*(if n > 1)\n\n8\n\n\fExample 3\n\n\u2022 Summation from n to 1000\n\npublic static long s (int n){     \n   if (n==1000){\n      return 1000;\n   }\n   else if (n>1000){\n\nBase cases\n\n      return 0;\n\n   }\n\n   else{\n\n      return s(n+1)+n;\n\nRecursive case\n\n   }\n}\n\n9\n\n\fExample 4\n\n\u2022 Countdown (with counter > 0)\n\npublic static void countdown(int counter){\n   if(counter == 0){\n      return;\n   }\n   else{\n      System.out.println(counter+\" \");\n      countdown(--counter);\n      return;\n   }\n}\n\nBase case\n\nRecursive case\n\n10\n\n\fExercise 1\n\n\u2022\n\nImplement the recursive method \nsquare(int n), which calculates the \nsquare of n (when n > 1). We shall \nconsider the following formula in your \nimplementation:\n\n(N-1)2 = N2 - 2N + 1\n\n11\n\n\fExercise 2\n\n\u2022\n\nImplement the recursive method  riddle(int \np, int q)with p and q > 0. Each time this \nmethod is called, the value of q increases in one \nunit, while the value of p decreases in one unit. \nWhen p is zero, the method returns the value of q.\n\n\u2022 How many time are the recursive and base cases \nexecuted when calling riddle(3,5) and what \nvalue is returned?\n\n12\n\n\fTypes of recursion\n\n\u2022 Linear recursion\n\n\u2013 One recursive call per recursive case at most\n\u2013 Non-tail recursion\n\n\u2022 We need to reach the base case to get the first result. \n\nThen we go back calculating the final result\n\n\u2022 It is computationally expensive \n\n\u2013 Tail recursion\n\n\u2022 The final result is computed when reaching the base \n\ncase (using an accumulator)\n\n\u2022 Lower computational cost\n\n13\n\n\fNon-tail recursion\n\n\u2022 Computing the factorial\n\nfac(n) = n! = n*(n-1)*(n-2)\u20262*1 (with n >= 0)\n\npublic static long fac(int n){\n   if (n<=1){\n      return 1;\n   }\n   else{\n      return n*fac(n-1);\n   }\n}\n\nfac (4) = \n4*fac(3) =\n4*3*fac(2) =\n4*3*2*fac(1) =\n4*3*(2*1) =\n4*(3*2) =\n4*6 =\n24\n\npublic static void main (String[] args){\n   System.out.println(fac(4));\n}\n\n14\n\n\fTail recursion\n\n\u2022 Computing the factorial\n\nfac(n) = n! = n*(n-1)*(n-2)\u20262*1 (with n >= 0)\n\npublic static long fact(int n, int m){\n   if (n<=1){\n      return m;\n   } \n   else{\n      return fact(n-1, n*m);\n   }\n} \n\npublic static void main (String[] args){\n   System.out.println(fact(4,1));\n}\n\nfac (4) = \nfact(4,1) =\nfact(3,4) =\nfact(2,12) =\nfact(1,24) =\n24\n\n15\n\n\fTypes of recursion\n\n\u2022 Non-Linear recursion\n\n\u2013 Several recursive calls per recursive case\n\u2013 Cascade recursion\n\n\u2022 E.g., return method(n) + method(n-1);\n\n\u2013 Nested recursion\n\n\u2022 E.g., return method(n, method(n-1));\n\n16\n\n\fCascade recursion: Fibonacci\n\n17\n\n\fCascade recursion: Fibonacci\n\n\u2022 Fibonacci series (with n > 0)\n\npublic static long fib(int n){\n   if (n<=1){\n      return 1;\n   }\n   else{\n      return fib(n-1)+fib(n-2);\n   }\n}\n\n18\n\n\fCascade recursion: Fibonacci\n\n\u2022 Fibonacci series: from cascade recursion \n\nto linear recursion \n\n19\n\n\fCascade recursion: Fibonacci\n\n\u2022 Fibonacci series: from cascade recursion \n\nto linear recursion \n\npublic static long fibo(int n, int x, int y){\n   if (n<=1){\n      return x+y;\n   }\n   else {\n      return fibo(n-1, y, x+y);\n   }\n}\n\npublic static long fib (int n){\n   return fibo(n,0,1);\n}\n\n20\n\n    \n\fNon-recursive \n\n21\n\n\fNested recursion: Morris\n\npublic static int mor(int n, int m){\n   if (n==m){\n      return (m+1);\n   }\n   else{\n      return(mor(n, mor(n-1, m+1)));\n   }\n}\n\n\u275a mor(4,0) =\n\n\u275a mor(4, mor(3,1)) =\n\n\u275a mor(4, mor(3, mor(2,2)) =\n\n\u275a mor(4, mor(3,3)) =\n\n\u275a mor(4,4) =\n\n\u275a 5\n\n22\n\n\fExercise 3\n\n\u2022\n\nImplement the recursive method a(int m, \nint n), which allows computing the \nAckermann-P\u00e9ter function, defined as follows:\n\n\u2022 What is the result of a(3,3)? \n\u2022 What happens with a(4,3)?\n\n23\n\n\fTypes of recursion\n\n\u2022 Mutual\n\npublic static boolean even(int n){\n   if (n==0){\n      return true;\n   }\n   else{\n      return odd(n-1);\n   }\n}\n\npublic static boolean odd(int n){\n   if (n==0){\n      return false;\n   }\n   else{\n      return even(n-1);\n   }\n}\n\nodd\n\neven\n\n24\n\n    \n\fRecursion vs. Iteration\n\n\u2022 Tail recursion can be immediately \n\nconverted into iteration (loop)\n\u2022 Other forms of recursion require \n\nprogram transformation techniques and \npossibly more complex data structures\n\n\u201cThe transformation from recursion to iteration is one of the most \nfundamental concepts of computer science.\u201d  D. Knuth, 1974\n\n25\n\n\fRecursion vs. Iteration\n\n\u2022 Computing the factorial\n\nfac(n) = n! = n*(n-1)*(n-2)\u20262*1 (with n > 0 and m = 1)\n\npublic static long fac(int n, int m){\n   if (n<=1){\n      return m;\n   } \n   else{\n      return fac(n-1, n*m);\n   }\n}\n\npublic static long fac(int n, int m){\n\nwhile (! (n <= 1)){\nm = n * m;\nn = n - 1;\n\n}\nreturn m;\n\n}\n\nRecursion\n\nIteration\n\n26\n\n\fExercise 4\n\n\u2022\n\nImplement the recursive method gcd(int a, \nint b), which allows computing the greatest \ncommon divisor of two integer numbers.\n\n27\n\n\fExercise 5\n\n\u2022\n\nImplement the recursive method decToBin(int \ndecimal, String binary), which receives a \ndecimal number and returns a String with the \nequivalent binary number. \n\n28\n\n\fTo remember\n\n\u2022 Range of values for termination\n\u2022 Base case(s) and decreasing recursive \n\ncase(s)\n\n\u2022 Linear recursion (\u22641 recursive call/branch)\n\u2013 Tail-recursion (call: last operation, easily \nconvertible to loop) or non-tail recursion\n\n\u2022 Non-linear recursion \n\n(>1 recursive calls on some branch)\n\u2013 Cascading or nested recursion\n\n29\n\n\f", "pages_description": ["Recursive Methods\n\n- A method is called recursive if it calls itself directly or indirectly.\n- For a recursive method to define a terminating computation, the recursive call(s) have to be simpler according to some metric. \n", "The call stack and the JVM\n\nThe stack is used to store the execution order of methods and local variables. The heap stores the objects.\n\nThere are three boxes: \"Call Stack\", \"Stack Memory\", and \"Heap Space\".\n\nThe \"Call Stack\" box contains three boxes: \"main (String [])\", \"buildStudent (int,string)\", and \"Student(int,string)\".\n\nThe \"Stack Memory\" box is divided by a dashed line. The upper part contains: \"Integer value\" with value \"rollno = 05\", \"String Reference\" with value \"name\", and \"Student Reference\" with value \"this\". The lower part contains: \"Integer value\" with value \"rollno = 05\", \"String Reference\" with value \"Tom\", and \"Student Reference\" with value \"student\".\n\nThe \"Heap Space\" box contains a box labeled \"String Pool\" which contains a box labeled \"Tom\". There is also a box labeled \"05|\"name\"\\nreference\" pointing to a box labeled \"Student Object\".\n\nThere are arrows pointing from the \"Student Reference\" in the upper part of the \"Stack Memory\" box to the \"Tom\" box in the \"String Pool\" box, from the \"Student Reference\" in the lower part of the \"Stack Memory\" box to the \"05|\"name\"\\nreference\" box, and from the \"05|\"name\"\\nreference\" box to the \"Student Object\" box.\n", "Example 1\n\nThis code sample shows how to calculate the summation from 1 to n, with n greater than 0, using a recursive function in Java. The function is named \"s\" and takes an integer \"n\" as input. Inside the function, there is a base case and a recursive case. The base case is when n equals 1, in which case the function returns 1. The recursive case is when n is not 1, in which case the function returns the sum of s(n-1) and n. This means that the function will recursively call itself with n-1 until it reaches the base case, at which point it will start returning the sum of all the previous calls. \n", "Example 1\n\nThis slide describes how to calculate the sum of numbers from 1 to n, where n is greater than 0, using a recursive function in programming.\n\nThe code is written in a C-like language and defines a function called \"s\" that takes an integer \"n\" as input and returns a long integer.\n\n- The base case of the recursion is when n is equal to 1. In this case, the function returns 1.\n- The recursive case is when n is greater than 1. In this case, the function returns the sum of s(n-1) and n.\n\nThe slide provides an example of how the function works when n is equal to 3.\n\n- The function first calculates s(2) which in turn calculates s(1).\n- s(1) returns 1 (base case).\n- s(2) then returns 3 (1 + 2).\n- Finally, s(3) returns 6 (3 + 3).\n\nThe slide concludes by stating that the recursive case happens twice (for s(3) and s(2)) and the base case happens once (for s(1)).\n", "Example 2\n\nThis slide shows an example of a badly designed recursive function in Java. The function is called \"s\" and takes an integer \"n\" as input. The function has a base case where if \"n\" is equal to 1, it returns 1. Otherwise, it recursively calls itself with \"n+1\" and adds \"n\" to the result. This is a bad design because it will result in an infinite loop if \"n\" is greater than 1. The comment at the bottom of the slide indicates that the recursive case is only executed if \"n\" is greater than 1.\n", "Example 2\n\nThe slide describes a badly designed recursive function in programming. \n\nThe code snippet shows a function named \"s\" that takes an integer \"n\" as input. If \"n\" is equal to 1, it returns 1. Otherwise, it returns the result of calling the function \"s\" with \"n+1\" as input, plus the value of \"n\".\n\nThe slide then provides examples of calling the function with different input values. For instance, s(3) would lead to s(4)+3, which in turn would lead to s(5)+4)+3, and so on.\n\nThe slide highlights that this recursion is badly designed because it does not terminate. The recursive case, where \"n\" is not equal to 1, will always lead to another recursive call with a larger value of \"n\". This results in an infinite loop.\n\nThe slide further explains that the base case, where \"n\" is equal to 1, is never reached because the recursive calls continue indefinitely.\n\nAs a consequence, the code would result in a StackOverflowError. This error occurs when too much memory is used in the call stack, which happens when a recursive function keeps calling itself without reaching a base case.\n", "Example 3\n\nThis code sample shows a recursive function in Java that calculates the summation from n to 1000. The function takes an integer n as input. If n is equal to 1000, it returns 1000. This is the base case. If n is greater than 1000, it returns 0. This is another base case. Otherwise, it recursively calls itself with n+1 and adds n to the result. This is the recursive case. The base cases are highlighted on the right side of the code. The first base case is labeled \"Base cases\" and the second base case is labeled \"Recursive case\". \n", "Example 4\n\nCountdown (with counter greater than 0)\n\nWe see a code snippet showing a recursive function called countdown. The function takes an integer called counter as input. If the counter equals 0, the function returns. Otherwise, it prints the counter value followed by a space and recursively calls itself with a decremented counter value. The base case is highlighted with a red bracket and labeled \"Base case\". The recursive case is highlighted with a red bracket and labeled \"Recursive case\". \n", "Exercise 1\n\nImplement the recursive method square, which takes an integer n as input and calculates the square of n when n is greater than 1. The formula (N-1)^2 = N^2 - 2N + 1 should be considered in the implementation. \n", "Exercise 2\n\nWe are asked to implement a recursive method called \"riddle\" that takes two integer arguments, p and q, both greater than 0. Each time the method is called, the value of q is incremented by one, and the value of p is decremented by one. When p reaches zero, the method returns the value of q.\n\nThe second question asks how many times the recursive and base cases are executed when calling the riddle method with the arguments (3, 5), and what value is returned. \n", "Types of recursion\n\nWe are going to see the different types of recursion. \n\nLinear recursion: one recursive call per recursive case at most.\n\nNon-tail recursion: we need to reach the base case to get the first result. Then we go back calculating the final result. It is computationally expensive.\n\nTail recursion: the final result is computed when reaching the base case using an accumulator. Lower computational cost. \n", "Non-tail recursion\n\nThe image shows an example of non-tail recursion. \n\nThe factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 4! = 4 * 3 * 2 * 1 = 24.\n\nThe code defines a function called \"fac\" that takes an integer n as input and returns the factorial of n. The function is defined recursively, meaning that it calls itself with a smaller value of n until it reaches the base case, which is when n is less than or equal to 1. In this case, the function returns 1.\n\nThe code also includes a main function that calls the fac function with the value 4 and prints the result to the console.\n\nThe code on the right side of the image shows the step-by-step calculation of fac(4). \n\nFirst, fac(4) is called. Since 4 is not less than or equal to 1, the function enters the else block and returns 4 * fac(3).\n\nNext, fac(3) is called. Since 3 is not less than or equal to 1, the function enters the else block and returns 3 * fac(2).\n\nNext, fac(2) is called. Since 2 is not less than or equal to 1, the function enters the else block and returns 2 * fac(1).\n\nNext, fac(1) is called. Since 1 is less than or equal to 1, the function enters the if block and returns 1.\n\nNow that fac(1) has returned 1, the calculation of fac(2) can be completed: 2 * 1 = 2.\n\nNext, the calculation of fac(3) can be completed: 3 * 2 = 6.\n\nFinally, the calculation of fac(4) can be completed: 4 * 6 = 24.\n\nTherefore, the output of the program is 24.\n", "Tail recursion\n\n- Computing the factorial.\n- Mathematical formula for calculating the factorial of n: fac(n) = n! = n*(n-1)*(n-2)...2*1 (with n >= 0)\n- Java code snippet showing a tail-recursive function to calculate the factorial of a number.\n- The code defines a function called \"fact\" that takes two integer arguments, n and m.\n- The function checks if n is less than or equal to 1. If it is, it returns the value of m.\n- Otherwise, it recursively calls itself with n-1 and n*m as arguments.\n- The code also includes a main method that calls the fact function with arguments 4 and 1 and prints the result to the console.\n- On the right-hand side, there is a breakdown of how the factorial of 4 is calculated using the defined function.\n- It shows the values of the arguments passed to the function in each recursive call and the final result of 24.\n", "Types of recursion\n\nNon-linear recursion. Several recursive calls per recursive case. Cascade recursion. For example, return method of n plus method of n minus 1. Nested recursion. For example, return method of n, method of n minus 1. \n", "Cascade recursion: Fibonacci\n\nThe image shows a table with two columns: n and fib(n). The first column contains the numbers 0, 1, 2, 3, 4, 5 and the second column contains the numbers 1, 1, 2, 3, 5, 8. The table shows the Fibonacci sequence, which is a sequence of numbers where each number is the sum of the two preceding ones. The image also shows a diagram of a tree with rabbits. The tree shows how the Fibonacci sequence can be calculated recursively. The root of the tree is a pair of rabbits. Each node in the tree represents a pair of rabbits, and the children of a node represent the offspring of that pair of rabbits. The number of pairs of rabbits in each generation of the tree corresponds to a number in the Fibonacci sequence. The image also shows the equation fib(5) = fib(4) + fib(3) = 5 + 3, which shows how the fifth Fibonacci number can be calculated recursively. \n", "Cascade recursion: Fibonacci\n\nThe image shows a code snippet of a function called \"fib\" that takes an integer \"n\" as input and returns a long integer. The function calculates the Fibonacci series for a given input \"n\" where n is greater than zero. The function uses a recursive approach where it calls itself twice with n-1 and n-2 as input parameters. The base case for the recursion is when n is less than or equal to 1, in which case the function returns 1. \n", "Cascade recursion: Fibonacci\n\nWe are looking at a diagram representing the Fibonacci series from cascade recursion to linear recursion. On the left, we have a box labeled fib(4) with the value 5. An arrow points to the right to a box labeled fibo(4,0,1) also with the value 5. This box points downwards to another box labeled fibo(3,1,1) with the value 5, which points downwards to a box labeled fibo(2,1,2) with the value 5. Finally, this box points downwards to a box labeled fibo(1,2,3) with the value 5. \n", "Cascade recursion: Fibonacci\n\nThe image shows an example of cascade recursion with the Fibonacci series. Cascade recursion is a type of recursion where the recursive call is made with a modified version of the original arguments. In this case, the fibo function takes three arguments: n, x, and y. If n is less than or equal to 1, the function returns x+y. Otherwise, it returns the result of calling fibo with n-1, y, and x+y. This process is repeated until n is equal to 1. The image also shows a diagram of the recursive calls made when calculating the fourth Fibonacci number. The diagram shows that the fibo function is called four times, with the arguments (4,0,1), (3,1,1), (2,1,2), and (1,2,3). The final result of the calculation is 5, which is the fourth Fibonacci number.\n", "Non-recursive\n\nThe image presents a mathematical formula for calculating the Fibonacci sequence non-recursively. The formula is fib(n) equals open parenthesis one plus the square root of five close parenthesis to the power of n plus 1 minus open parenthesis 1 minus the square root of 5 close parenthesis to the power of n plus 1 all divided by open parenthesis 2 to the power of n plus 1 times the square root of 5 close parenthesis. \n", "Nested recursion: Morris\n\nWe see a piece of code that defines a function called \"mor\" that takes two integer arguments, n and m. The function returns an integer value. \n\n- If n is equal to m, the function returns m+1. \n- Otherwise, the function recursively calls itself twice. \n\nBelow the code, we see several lines of text that illustrate how the \"mor\" function is evaluated for the input values n=4 and m=0. The final result of the evaluation is 5. \n", "Exercise 3\n\nWe are asked to implement a recursive method called \"a\", which takes two integer parameters, m and n, and computes the Ackermann-P\u00e9ter function.\n\nThe Ackermann-P\u00e9ter function is defined by a mathematical formula. This formula has three cases:\n\n* If m equals zero, the function returns n plus 1.\n* If m is greater than zero and n equals zero, the function returns A(m - 1, 1), which is a recursive call to the function with m decremented by 1 and n set to 1.\n* If m is greater than zero and n is greater than zero, the function returns A(m - 1, A(m, n - 1)), which is a nested recursive call to the function.\n\nFinally, we are asked two questions:\n* What is the result of a(3,3)?\n* What happens with a(4,3)? \n", "Types of recursion\n\n- Mutual\n\nWe see two blocks of code and a diagram.\n\nThe first block of code defines a function called \"even\" that takes an integer \"n\" as input and returns a boolean value. \nIf \"n\" is equal to 0, the function returns \"true\". Otherwise, it returns the result of calling another function called \"odd\" with \"n-1\" as input.\n\nThe second block of code defines a function called \"odd\" that takes an integer \"n\" as input and returns a boolean value. \nIf \"n\" is equal to 0, the function returns \"false\". Otherwise, it returns the result of calling the \"even\" function with \"n-1\" as input.\n\nThe diagram on the right shows two ovals, one labeled \"odd\" and the other labeled \"even\", with arrows pointing from each oval to the other. This illustrates the concept of mutual recursion, where two or more functions call each other in a circular fashion. In this case, the \"even\" function calls the \"odd\" function, which in turn calls the \"even\" function again, and so on. This process continues until one of the functions returns a value without making another recursive call.\n", "Recursion vs. Iteration\n\n- Tail recursion can be immediately converted into iteration (loop).\n- Other forms of recursion require program transformation techniques and possibly more complex data structures.\n\n\"The transformation from recursion to iteration is one of the most fundamental concepts of computer science.\" D. Knuth, 1974 \n", "**Recursion vs. Iteration**\n\n*Computing the factorial*\n\nThe factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120.\n\nThe slide shows two ways to compute the factorial of a number: recursively and iteratively.\n\nThe recursive approach defines a function `fac(n, m)` that takes two integer arguments, n and m. If n is less than or equal to 1, the function returns m. Otherwise, it returns the result of calling `fac()` with n-1 and n*m as arguments.\n\nThe iterative approach defines a function `fac(n, m)` that takes two integer arguments, n and m. The function uses a while loop to iterate over the numbers from n down to 2, multiplying m by each number in turn. When the loop finishes, the function returns m.\n\nBoth approaches achieve the same result, but they do so in different ways. The recursive approach is more concise and elegant, but it can be less efficient than the iterative approach for large values of n. This is because each recursive call adds a new frame to the call stack, which can lead to a stack overflow error if the recursion is too deep. The iterative approach, on the other hand, does not use recursion, so it is not susceptible to stack overflow errors.\n", "Exercise 4\n\nImplement the recursive method gcd (int a, int b), which allows computing the greatest common divisor of two integer numbers.\n\nThe method is defined as follows: gcd(x, y) = x if y = 0, gcd(x, y) = gcd(y, remainder(x, y)) if y > 0. \n", "Exercise 5\n\nImplement the recursive method \"decToBin\" which takes an integer \"decimal\" and a String \"binary\" as input, and returns a String with the equivalent binary number. \n", "To remember\n\n- Range of values for termination\n- Base case(s) and decreasing recursive case(s)\n- Linear recursion: less than or equal to 1 recursive call per branch. It can be tail-recursion, where the recursive call is the last operation and easily convertible to a loop, or non-tail recursion.\n- Non-linear recursion: more than 1 recursive call on some branch. It can be cascading or nested recursion. \n"]}, {"filename": "6. StackAndQueues.pdf", "text": "Systems Programming\n\nStacks and Queues\n\nDepartamento de Ingenier\u00eda\nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nCarlos Alario Hoyos, Jes\u00fas Arias Fisteus, Carlos Delgado Kloos, \nM\u00aa Carmen Fern\u00e1ndez Panadero, Julio Villena Rom\u00e1n\n\n\fContents\n\nv Stacks\nv Queues\nv Deques \u2013 double-ended queues\n\n2\n\n\fStacks\n\n\u2022 Linear data structure\n\n\u2022\n\nInsertion and extraction into/from the (same) end (side)\n\u00fc LIFO (Last-In-First-Out)\n\n3\n\n\fStacks\n\n\u2022\n\nInsert into an end: push(x)\n\n\u2022 Extract from the same end: pop()\n\n4\n\n\fInterface for stacks\n\npublic interface Stack<E> {\nboolean isEmpty();\nint size();\nE top();\nvoid push(E info);\nE pop();\n\n}\n\n5\n\n\fInterface for stacks (with exceptions)\n\npublic interface Stack<E> {\nboolean isEmpty();\nint size();\nE top() throws \n\nEmptyStackException;\nvoid push(E info) throws\n\nStackOverflowException;\n\nE pop() throws\n\nEmptyStackException;\n\n}\n\n6\n\n\fInterface for stacks (without generics)\n\npublic interface Stack {\n\nboolean isEmpty();\nint size();\nObject top();\nvoid push(Object info);\nObject pop();\n\n}\n\n7\n\n\fOne interface, two implementations\n\n\u2022 Array-based implementation: \n\n\u00fc ArrayStack\n\n\u2022 Linked-list-based implementation:\n\n\u00fc LinkedStack\n\n8\n\n\fArrayStack\n\ntop\n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6 \u2026 \u2026 N-1\n\nEmpty stack\n\ntop\n\n1\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6 \u2026 \u2026 N-1\n\nStack with 1 element\n\ntop\n\n1\n0\n\n2 3\n2\n1\n\n4\n3\n\n4\n\n5\n\n6 \u2026 \u2026 N-1\n\nEnd for \ninsertion and \nextraction\n\nStack with 4 \nelements\n\n9\n\n\fExercise 1\n\n\u2022 Create the ArrayStack<E> class, which implements Stack<E>, \nand has three attributes: int capacity, the array of generics data\narray and int top with -1 as initial value.\n\n\u2022 Create the class constructor, which takes just one argument, and uses \nit to initialize the capacity attribute, creating also an array of data \nwith such capacity. IMPORTANT: We cannot create an array of \ngenerics, so we need to create an array Object and do a casting.\nImplement the following methods:\no boolean isEmpty()\no int size()\no void push(E info)\n\n\u2022\n\n\u2022 Homework: implement these methods:\n\no E pop()\no E top()\n\n10\n\n\fLinkedStack\n\nEnd for \ninsertion \nand \nextraction\n\nEmpty stack\n\nStack with 1 element\n\nStack with 4 \nelements\n\n11\n\n\fRemembering the Node class\n\npublic class Node<E> {\n\nprivate E info; \nprivate Node<E> next;\n\npublic Node()\n{\u2026}\npublic Node(E info)\npublic Node(E info, Node<E> next)\n\n{\u2026}\n\n{\u2026}\n\npublic Node<E> getNext() {\u2026}\npublic void setNext(Node<E> next) {\u2026}\npublic E getInfo() {\u2026}\npublic void setInfo(E info) {\u2026}\n\n}\n\n12\n\n\fLinkedStack (I)\n\npublic class LinkedStack<E> implements Stack<E> {\n\nprivate Node<E> top;\nprivate int size;\npublic LinkedStack() { }    \n\npublic boolean isEmpty() {\nreturn (size == 0);\n// return (top == null);\n\n}\npublic int size() { \nreturn size;\n\n}   \npublic E top() {\n\nE info = null;\nif (!isEmpty()) {\n\ninfo = top.getInfo();\n\n}\nreturn info;\n\nAttributes\n\nConstructor\n\nStack interface methods to \nimplement (I)\n\n}\n\n\u2026\n\n13\n\n\fInsertion (push)\n\n14\n\n\fExtraction (pop)\n\n15\n\n\fLinkedStack (II)\n\n\u2026 \n\npublic void push(E info){\n\nNode<E> n = new Node<E>(info, top);\ntop = n;\nsize++;\n\n}\n\npublic E pop() {\n\nE info = null;\nif (!isEmpty()) {\n\ninfo = top.getInfo();\ntop = top.getNext();\nsize--;\n\n}\nreturn info;\n\n}\n\n}\n\nStack interface methods \nto implement (II)\n\n16\n\n\fQueues\n\n\u2022 Linear data structure\n\n\u2022\n\nInsertion into one end and extraction from the \nopposite end\n\u00fc FIFO (First-In-First-Out)\n\n17\n\n\fQueues\n\n\u2022\n\nInsert into one end: enqueue(x)\n\n\u2022 Extract from the opposite end: dequeue()\n\n18\n\n\fInterface for queues\n\npublic interface Queue<E> {\nboolean isEmpty();\nint size();\nE front();\nvoid enqueue (E info);\nE dequeue();\n\n}\n\n19\n\n\fInterface for queues (with exceptions)\n\npublic interface Queue<E> {\nboolean isEmpty();\nint size();\nE front() throws\n\nEmptyQueueException;\nvoid enqueue (E info) throws\n\nQueueOverflowException;\n\nE dequeue() throws\n\nEmptyQueueException;\n\n}\n\n20\n\n\fInterface for queues (without generics)\n\npublic interface Queue {\n\nboolean isEmpty();\nint size();\nObject front();\nvoid enqueue (Object info);\nObject dequeue();\n\n}\n\n21\n\n\fOne interface, two implementations\n\n\u2022 Array-based implementation:\n\n\u00fc ArrayQueue\n\n\u2022 Linked-list-based implementation:\n\n\u00fc LinkedQueue\n\n22\n\n\fArrayQueue\n\nExtraction \nend\n\nhead\n\ntail\n\n1\n0\ntail\n\nhead\n\n2\n\n3\n\n4\n\n5\n\n6 \u2026 \u2026 N-1\n\nEmpty queue\n\n1\n0\n\nhead\n\n1\n\n2\n\n3\n\n4\n\n6 \u2026 \u2026 N-1\n\n5\ntail\n\n1\n0\n\n2 5\n2\n1\n\n9 3\n4\n3\n\n4\n5\n\nhead\n\ntail\n\n6 \u2026 \u2026 N-1\n\nInsertion of 1 element\n\nInsertion \nend\n\nInsertion of 5 \nextra elements\n\n5\n2\n\n9\n3\n\n3\n4\n\n4\n5\n\n0\n\n1\n\n6 \u2026 \u2026 N-1\n\nExtraction of \n2 elements\n\n23\n\n\fLinkedQueue\n\nhead tail\n\nhead\n\ntail\n\nExtraction \nend\n\nhead\n\nEmpty queue\n\nQueue with \n1element\n\ntail\n\nInsertion end\n\nQueue with 4 \nelements\n\n24\n\n\fLinkedQueue (I)\n\npublic class LinkedQueue<E> implements Queue<E> {\n\nprivate Node<E> head;\nprivate Node<E> tail;\nprivate int size;\npublic LinkedQueue(){}\n\npublic boolean isEmpty() {\nreturn (size == 0);\n// return (head == null);\n\n}\npublic int size() {\nreturn size;\n\n}\npublic E front() {\nE info = null;\nif (!isEmpty()) {\n\ninfo = head.getInfo();\n\n}\nreturn info;\n\nAttributes\n\nConstructor\n\nQueue interface methods \nto implement(I)\n\n}\n\n\u2026\n\n25\n\n\fInsertion (enqueue)\n\nhead\n\n26\n\n\fLinkedQueue (II)\n\n\u2026\n\npublic void enqueue (E info){\n\nNode<E> n = new Node<E>(info, null);\nif (isEmpty()){\n\nhead = n;\n\n} else {\n\ntail.setNext(n);\n\nQueue interface methods \nto implement (II)\n\n} \ntail = n;\nsize++;\n\nhead\n\n}\n\n\u2026\n\n27\n\n\fExtraction (dequeue)\n\nhead\n\n28\n\n\fLinkedQueue (III)\n\n\u2026\n\npublic E dequeue(){\n\nE info = null;\nif (!isEmpty()) {\n\ninfo = head.getInfo();\nhead = head.getNext();\nsize--;\nif (isEmpty()) {\ntail = null;\n\n}\n\n}\n\n}\n\n}\nreturn info;\n\nhead\n\nQueue interface methods \nto implement(III)\n\n29\n\n\fDouble-ended queues (deques)\n\n\u2022 Linear data structures\n\no Deque (double-ended queue)\n\n\u2022\n\nInsertion and extraction from any end\n\n30\n\n\fInterface for deques\n\npublic interface Deque<E> {\n\npublic boolean isEmpty();\npublic int size();\npublic E first();\npublic E last();\npublic void insertFirst(E info);\npublic void insertLast(E info);\npublic E removeFirst();\npublic E removeLast();\n\n}\n\n31\n\n\fInterface for deques\n\nStack\n\nDeque\n\nQueue\n\nDeque\n\nsize()\n\nsize()\n\nsize()\n\nsize()\n\nisEmpty() isEmpty()\n\nisEmpty()\n\nisEmpty()\n\ntop()\n\nlast()\n\nfront()\n\nfirst()\n\npush(x)\n\ninsertFirst(x)\n\nenqueue(x) insertLast(x)\n\npop()\n\nremoveFirst()\n\ndequeue()\n\nremoveFirst()\n\n32\n\n\fImplementation of deques\n\n\u2022\n\n(regular) linked lists are not the best idea \nbecause removeLast needs to traverse \nthe whole list to get the reference to the \nnext-to-last element\n\n\u2022 Solution: doubly-linked lists\n\n33\n\n\fDoubly-linked lists\n\n\u2022 Linked lists where each node, in addition to the \n\ninformation and the reference to the next node in \nthe list, also stores a reference to the previous node\no The list can be traversed in both ways\no The cost to extract the last node is reduced\n\nhead\n\nnull\n\ninfo\n\nprev\nnext\n\ninfo\n\nprev\nnext\n\ninfo\n\nprev\nnext\n\ntail\n\nnull\n\n34\n\n\fClass DLNode\n\npublic class DLNode<E> {\nprivate E info;\nprivate DLNode<E> prev;\nprivate DLNode<E> next;\n\npublic DLNode() {\u2026}\npublic DLNode(E info) {\u2026}\npublic DLNode(E info, DLNode<E> prev, DLNode<E> next){\u2026}\n\npublic DLNode<E> getNext(){\u2026}\npublic void setNext(DLNode<E> next){\u2026}\npublic DLNode<E> getPrev(){\u2026}\npublic void setPrev(DLNode<E> prev){\u2026}\npublic E getInfo(){\u2026}\npublic void setInfo(E info){\u2026}\n\n}\n\n35\n\n\fExercise 2\n\n\u2022 Complete the code for the class DLNode<E>. \n\nAdd three constructors: one with no parameters, a \nsecond one that allows initializing the info\nattribute, and third one that allows initializing all \nattributes.\n\n36\n\n\fDoubly-linked lists\n\n\u2022\n\n\u2022\n\nThe implementation of deques based on linked lists needs to check \nin each operation that both the previous and the next node exist\nSimplification: Create two special nodes (dummy nodes), with no \ndata, one at the beginning and another at the end of the list: \no An empty list only contains these two nodes.\no In each insertion or extraction operation, both the previous and the next \n\nnode always exist, without needing to check.\n\no head and tail references never change.\n\nhead\n\n37\n\n\fDouble queue class (DLDeque) with \ndoubly-linked lists\n\npublic class DLDeque<E> implements Deque<E>{\n\nprivate DLNode<E> head;\nprivate DLNode<E> tail;\nprivate int size;\n\npublic DLDeque(){\n\nhead = new DLNode<E>();\ntail = new DLNode<E>();\ntail.setPrev(head);\nhead.setNext(tail);\nsize = 0;\n\n}\n\n\u2026\n\nAttributes\n\nConstructor\n\n38\n\n\fExercise 3\n\n\u2022\n\nImplement the following methods in the \nDLDeque<E> class:  \no boolean isEmpty()\no int size()\no E first()\no E last()\n\n39\n\n\fDouble queue class (DLDeque) with doubly-\nlinked lists: Insertion at the beginning\n\npublic void insertFirst(E info) {\n\nDLNode<E> second = head.getNext();\nDLNode<E> first = new DLNode<E>(info, head, second);\nsecond.setPrev(first);\nhead.setNext(first);\nsize++;\n\n}\n\nhead\n\n40\n\n\fDouble queue class (DLDeque) with doubly-\nlinked lists: Extraction from the beginning\n\npublic E removeFirst() {\n\nE info = null;\nif (!(head.getNext() == tail)) {\n\nDLNode<E> first = head.getNext();\ninfo = first.getInfo();\nDLNode<E> second = first.getNext();\nhead.setNext(second);\nsecond.setPrev(head);\nsize--;\n\n}\nreturn info;\n\n}\n\nhead\n\nfirst\n\nsecond\n\ntail\n\nMosc\u00fa\n\nMadrid\n\nMiami\n\nM\u00fanich\n\n41\n\n\fExercise 4\n\n\u2022\n\nImplement the following methods in the\nDLDeque<E> class: \no void insertLast (E info)\n\n\u2022 Homework:\n\no E removeLast()\n\n42\n\n\fInsertion (without dummy nodes)\n\nhead\n\nDLNode<E> node = new DLNode<E>(data);\n\n\fInsertion (without dummy nodes)\n\nhead\n\nnode.setPrev(prev);\nif (prev != null) {\n\nnode.setNext(prev.getNext());\nprev.setNext(node);\n\n}\n\n\fInsertion (without dummy nodes)\n\nhead\n\nif (prev == null) { // Insert at the beginning\n\nnode.setNext(head);\nhead = node;\n\n}\nif (node.getNext() != null) {\n\nnode.getNext().setPrev(node);\n\n} else {\n\ntail = node;\n\n}\n\n\f", "pages_description": ["Stacks\n\n- Linear data structure\n- Insertion and extraction into/from the same end (side)\n- LIFO (Last-In-First-Out)\n\nThe image shows a stack of books. The books are stacked on top of each other, with the last book placed on top being the first one that can be removed. This illustrates the concept of a LIFO (Last-In-First-Out) data structure, where the last element added to the stack is the first one to be removed. \n", "Stacks\n\n- Insert into an end: push (x)\n- Extract from the same end: pop ()\n\nA diagram shows a stack with 5 elements. The top element of the stack is the darkest shade of blue, and each element below it is a lighter shade of blue. An arrow labeled \"Push\" points to the top of the stack, and an arrow labeled \"Pop\" points away from the top of the stack. There is a blue rectangle above the \"Push\" arrow and to the right of the \"Pop\" arrow. \n", "Interface for stacks\n\nThis code defines a public interface in Java called Stack that takes a generic type parameter E. The interface includes methods to check if the stack is empty, get the size of the stack, get the top element of the stack, push an element onto the stack, and pop an element from the stack. \n", "Interface for stacks (with exceptions)\n\nThis code defines a public interface named Stack for a generic type E. The interface includes methods to check if the stack is empty, get the size of the stack, get the top element of the stack, push an element onto the stack, and pop an element from the stack. The top and pop methods throw an EmptyStackException if the stack is empty, and the push method throws a StackOverflowException if the stack is full. \n", "Interface for stacks (without generics)\n\nThis code defines a public interface in Java called \"Stack\". The interface includes the following methods:  is Empty, size, top, push, and pop. The is Empty method returns a boolean value. The size method returns an integer. The top method returns an Object. The push method takes an Object as an argument and returns void. The pop method takes no arguments and returns an Object. \n", "One interface, two implementations\n\nWe have one interface called \"Stack\" and two implementations: \"ArrayStack\" and \"LinkedStack\".\n", "ArrayStack\n\nThe image illustrates the concept of an array-based stack data structure. \n\nWe see four horizontal arrays of equal size, representing the stack at different states of occupancy. Each array element is depicted as a rectangle. The arrays are labeled with indices from 0 to N-1. \n\nThe term \"top,\" accompanied by a downward arrow, indicates the top element of the stack at each state.\n\n- The first array, labeled \"Empty stack,\" has an upward arrow pointing to the last element (N-1).\n- The second array, \"Stack with 1 element,\" has the first element (index 0) filled with the value \"1,\" and the \"top\" arrow points to this element. The upward arrow again points to the last element.\n- The third array is not labeled but represents the stack with four elements. The first four elements are filled with values \"1,\" \"2,\" \"3,\" and \"4,\" and the \"top\" arrow points to the fourth element.\n- The final state, labeled \"Stack with 4 elements,\" is identical to the previous one, with the upward arrow pointing to the last element (N-1).\n\nA red arrow connects the last element of the empty stack to the last element of the stack with one element, and another red arrow connects that point to the last element of the stack with four elements. This line is labeled \"End for insertion and extraction,\" indicating that elements are added and removed from the stack at this end. \n", "Exercise 1\n\nThe first exercise requires creating an \"ArrayStack\" class of type E. This class implements the \"Stack\" of type E and has three attributes: an integer called \"capacity\", an array of generics called \"data\", and an integer called \"top\" with an initial value of -1. The class constructor takes one argument and uses it to initialize the \"capacity\" attribute. It also creates an array of data with the given capacity. It is important to note that an array of generics cannot be created directly, so an array of Objects needs to be created and then cast to the desired type. The exercise also requires implementing the following methods: \"isEmpty\" which returns a boolean, \"size\" which returns an integer, and \"push\" which takes an argument of type E called \"info\" and returns void. As homework, the exercise requires implementing the \"pop\" and \"top\" methods, both of which return type E. \n", "LinkedStack\n\nThe image shows three different states of a linked stack. The first state is an empty stack, represented by a single dot labeled \"top\". The second state is a stack with one element, represented by two boxes stacked on top of each other. The top box contains a black dot and is labeled \"top\", while the bottom box contains the word \"M\u00fanich\". The third state is a stack with four elements, represented by four boxes stacked on top of each other. Each box contains a black dot and is connected to the box below it by an arrow. The top box is labeled \"top\", and the boxes below it are labeled \"Mosc\u00fa\", \"Madrid\", \"Miami\", and \"M\u00fanich\" from top to bottom. An arrow labeled \"End for insertion and extraction\" points to the top of each stack. \n", "Remembering the Node class\n\nWe have a generic class Node that takes a type parameter E. It has two private members: info of type E and next of type Node with the same type parameter E.\n\nThe class has three constructors: one without parameters, one taking an argument of type E to initialize info, and another one taking an argument of type E for info and another one of type Node with type parameter E for next.\n\nThe class also has public methods to get and set the next node and to get and set the info. \n", "LinkedStack (I)\n\nWe have a class definition for LinkedStack, which implements the Stack interface. The class has two private attributes: top of type Node and size of type int. There is also a constructor defined for the class. The class implements the isEmpty method, which checks if the size is zero. It also implements the size method, which returns the size. Finally, the class implements the top method, which returns the info of the top node if the stack is not empty. The comment on the right side of the code states that these are the Stack interface methods to implement. \n", "Insertion (push)\n\nThe diagram shows the insertion operation, also known as push, in a stack data structure. The stack is represented as a linked list, with each element containing a value and a pointer to the next element. The \"top\" of the stack is indicated by a black dot, which initially points to the last element of the list. A new element containing the value \"Mosc\u00fa\" is being inserted into the stack. This element is highlighted in red. An orange arrow indicates that the \"top\" pointer will be updated to point to the new element after insertion. The existing elements, \"Madrid\", \"Miami\", and \"M\u00fanich\", remain in the stack, with their order preserved. \n", "Extraction (pop)\n\nWe see a diagram representing a data structure. The structure is composed of four elements containing a black dot each. The elements are linked to each other. The second element from the left is highlighted in red. An arrow points to the highlighted element and is labeled \"top\". The arrow originates from a black dot. There are four more arrows, each one pointing down, from each one of the elements to rounded rectangles containing the following labels: \"Mosc\u00fa\", \"Madrid\", \"Miami\", and \"M\u00fanich\". \n", "LinkedStack (II)\n\nThe image shows code snippets for the push and pop methods of a LinkedStack data structure, along with diagrams illustrating their effects.\n\nThe push method takes an element \"info\" as input and creates a new node containing that element. This new node is then linked to the top of the stack, effectively pushing the new element onto the stack. The \"top\" reference is updated to point to the new node, and the size of the stack is incremented.\n\nThe pop method, on the other hand, first checks if the stack is empty. If not, it retrieves the element stored in the top node, updates the \"top\" reference to point to the next node in the stack, decrements the stack size, and finally returns the retrieved element.\n\nThe diagrams visually represent the state of the stack before and after the push and pop operations. Each node in the stack is represented by a rectangle, with the top node indicated by an arrow labeled \"top\". The elements stored in the stack are shown inside the rectangles. The arrows connecting the nodes represent the links between them.\n", "Queues\n\n- Queues are a linear data structure.\n- Insertion happens at one end of the queue and extraction happens at the opposite end.\n- Queues follow the FIFO principle: First-In-First-Out.\n- The image shows a queue of people waiting to board a bus, illustrating the concept of a queue. \n", "Queues\n\nThis slide explains the concept of a queue data structure. It defines two main operations: enqueue, which inserts an element at the back of the queue, and dequeue, which extracts an element from the front.\n\nThe slide includes a diagram to illustrate how these operations work. The diagram shows a queue with five elements, labeled \"Back\" and \"Front\" to indicate the ends of the queue. An arrow labeled \"Enqueue\" points to the back of the queue, indicating where new elements are added. Another arrow labeled \"Dequeue\" points away from the front of the queue, indicating where elements are removed.\n", "Interface for queues\n\nThis code defines a public interface called Queue for a generic type E. The interface includes the following methods: isEmpty, size, front, enqueue, and dequeue. \n- isEmpty: returns true if the queue is empty, false otherwise. \n- size: returns the number of elements in the queue. \n- front: returns the element at the front of the queue without removing it. \n- enqueue: adds an element to the back of the queue. \n- dequeue: removes and returns the element at the front of the queue. \n", "Interface for queues (with exceptions)\n\nThis code defines a public interface in Java called \"Queue\" that takes a generic type parameter \"E\". The interface includes methods to check if the queue is empty, get its size, get the element at the front of the queue, add an element to the back of the queue, and remove and return the element at the front of the queue. The \"front\" and \"dequeue\" methods can throw an \"EmptyQueueException\" if the queue is empty, while the \"enqueue\" method can throw a \"QueueOverflowException\" if the queue is full. \n", "Interface for queues (without generics)\n\nThis code defines a public interface in Java called \"Queue\". The interface outlines the methods that any class implementing it must provide. These methods include: \"isEmpty\" which returns a boolean indicating whether the queue is empty, \"size\" which returns an integer representing the number of elements in the queue, \"front\" which returns the Object at the front of the queue, \"enqueue\" which takes an Object as input and adds it to the end of the queue, and \"dequeue\" which removes and returns the Object at the front of the queue. \n", "One interface, two implementations\n\nThis slide illustrates the concept of having one interface and two implementations. There is a single interface called \"Queue\" which is implemented by two classes: \"ArrayQueue\" and \"LinkedListQueue\". The diagram shows two arrows pointing from the \"Queue\" interface to the two implementation classes. \n", "ArrayQueue\n\nThe image describes the ArrayQueue data structure. \n\nIt shows an array with N-1 positions. The first diagram shows an empty queue, where both the head and tail pointers point to the first position of the array. \n\nThe second diagram shows the insertion of one element. The tail pointer now points to the second position of the array, while the head remains in the first position. \n\nThe third diagram shows the insertion of five more elements. The tail pointer now points to the sixth position of the array, as we have inserted six elements in total. The head remains in the first position. \n\nThe fourth diagram shows the extraction of two elements. The head pointer now points to the third position of the array, while the tail pointer remains in the sixth position. \n", "LinkedQueue\n\nThe image shows four different states of a linked queue data structure. \n\nThe first state, labeled \"Empty queue,\" shows a single dot representing both the head and tail of the queue. \n\nThe second state, labeled \"Queue with 1 element,\" shows a single node containing the value \"M\u00fanich.\" This node is both the head and tail of the queue. \n\nThe third state, labeled \"Queue with 4 elements,\" shows four nodes linked together. The first node contains the value \"M\u00fanich,\" the second node contains the value \"Miami,\" the third node contains the value \"Madrid,\" and the fourth node contains the value \"Mosc\u00fa.\" The head of the queue is the first node, and the tail of the queue is the fourth node. \n\nRed arrows are used to indicate the \"Extraction end\" and the \"Insertion end\" of the queue. The extraction end is at the head of the queue, and the insertion end is at the tail of the queue. \n", "LinkedQueue (I)\n\nWe're looking at the code for a LinkedQueue class, which implements the Queue interface. The class has three private attributes: head and tail, which are both Node objects of type E, and size, which is an integer. The class also has a constructor, which takes no arguments. There are three public methods: isEmpty, size, and front. The isEmpty method returns true if the size is equal to 0, and false otherwise. The size method returns the size of the queue. The front method returns the info of the head node if the queue is not empty, and null otherwise. On the right side of the slide, we see that the code snippet shows the attributes and constructor of the class, and the methods from the Queue interface that need to be implemented. \n", "Insertion (enqueue)\n\nThe diagram shows a queue data structure. The queue contains three elements: Madrid, Miami, and Munich. The head of the queue is pointing to Madrid, and the tail of the queue is pointing to Munich. A new element, Mosc\u00fa, is being added to the queue. The tail of the queue will now point to Mosc\u00fa. The letter 'n' is indicating the new element being added.\n", "LinkedQueue (II)\n\nWe see a code snippet of a method called enqueue, which takes an argument info of type E. Inside the method, a new node is created with the given info and a null next pointer. If the queue is empty, the head is set to the new node. Otherwise, the next pointer of the current tail is set to the new node. Finally, the tail is updated to the new node and the size is incremented.\n\nThere is also a note indicating that this is part of the implementation of the Queue interface methods.\n\nThe diagram illustrates the process of enqueuing a new element into a linked queue. The queue contains four nodes with values Madrid, Miami, Munich, and Mosc\u00fa. The head of the queue points to the node with the value Madrid, while the tail points to the node with the value Mosc\u00fa. A new node with the value 'n' is being added to the end of the queue. The tail will now point to this new node. \n", "Extraction (dequeue)\n\nWe see a diagram representing a queue data structure. The queue contains four elements: Madrid, Miami, Munich, and Mosc\u00fa. The head of the queue is pointing to the element \"Madrid\", while the tail is pointing to the element \"Mosc\u00fa\". An arrow is coming out from the element \"Madrid\" and is going to the left, outside of the queue. This represents the extraction or dequeue operation, where the element at the head of the queue is removed. \n", "LinkedQueue (III)\n\nWe see a code snippet of a dequeue method and a diagram illustrating a linked queue. The dequeue method first checks if the queue is empty. If it is not empty, it retrieves the information from the head node, updates the head to the next node, and decrements the size. If the queue becomes empty after removing the element, it sets the tail to null. Finally, it returns the retrieved information.\n\nThe diagram depicts a linked queue with four nodes representing cities: Madrid, Miami, Munich, and Moscow. Each node contains data and a pointer to the next node in the queue. The head points to the first node (Madrid), and the tail points to the last node (Moscow). The arrows indicate the direction of the queue, with elements being added at the tail and removed from the head. \n", "Double-ended queues (deques)\n\nDouble-ended queues are linear data structures. A deque is a double-ended queue. Insertion and extraction are possible from any end. The diagram shows a deque with 5 elements. The first element is labeled \"first\" and the last element is labeled \"last\". The operations that can be performed on a deque are: insertFirst, removeFirst, insertLast, and removeLast. \n", "Interface for deques\n\nThis code defines an interface for a double-ended queue, or \"deque\", in Java. A deque is a data structure that allows elements to be added or removed from both the front and back of the queue. \n\nThe interface includes methods for checking if the deque is empty, getting the size of the deque, getting the first and last elements of the deque, inserting elements at the front and back of the deque, and removing elements from the front and back of the deque. \n", "Interface for deques\n\nThe image shows four tables that represent the interface for stacks, queues, and deques. \n\nThe first table, labeled \"Stack,\" lists the following methods: size, isEmpty, top, push, and pop. \n\nThe second table, labeled \"Deque,\" lists the following methods: size, isEmpty, last, insertFirst, and removeFirst. \n\nThe third table, labeled \"Queue,\" lists the following methods: size, isEmpty, front, enqueue, and dequeue. \n\nThe fourth table, labeled \"Deque,\" lists the following methods: size, isEmpty, first, insertLast, and removeFirst. \n", "Implementation of deques\n\nRegular linked lists are not the best idea because removeLast needs to traverse the whole list to get the reference to the next-to-last element.\n\nThe solution is to use doubly-linked lists. \n", "Doubly-linked lists\n\nDoubly-linked lists are linked lists where each node, in addition to the information and the reference to the next node in the list, also stores a reference to the previous node. This means the list can be traversed in both ways and the cost to extract the last node is reduced.\n\nThe diagram shows three nodes, each with three fields: info, prev, and next. The info field contains the data stored in the node. The prev field contains a pointer to the previous node in the list. The next field contains a pointer to the next node in the list. The first node in the list is called the head. The last node in the list is called the tail. The prev field of the head points to null. The next field of the tail points to null.\n", "Class DLNode\n\nThe image shows a code snippet for a generic doubly linked list node class named \"DLNode\". The class uses the generic type parameter \"E\" to represent the type of data stored in each node. The class has three private member variables: \"info\" of type E to store the data, \"prev\" of type DLNode<E> to store the reference to the previous node in the list, and \"next\" of type DLNode<E> to store the reference to the next node in the list. The class has three constructors: a default constructor that does nothing, a constructor that takes an argument of type E to initialize the \"info\" member variable, and a constructor that takes three arguments of type E, DLNode<E>, and DLNode<E> to initialize the \"info\", \"prev\", and \"next\" member variables, respectively. The class also has public getter and setter methods for each of the member variables, as well as a \"getNext()\" method that returns the \"next\" member variable and a \"getPrev()\" method that returns the \"prev\" member variable. \n", "Exercise 2\n\nComplete the code for the class DLNode of type E. Add three constructors: one with no parameters, a second one that allows initializing the info attribute, and a third one that allows initializing all attributes. \n", "Doubly-linked lists\n\nThe implementation of deques based on linked lists needs to check in each operation that both the previous and the next node exist. A simplification to this is to create two special nodes, called dummy nodes, with no data. One of these nodes is at the beginning and the other at the end of the list. An empty list only contains these two nodes. In each insertion or extraction operation, both the previous and the next node always exist, without needing to check. The head and tail references never change.\n\nThere is a diagram showing three nodes. The leftmost and rightmost nodes are dummy nodes. The leftmost node is pointed to by the text \"head\" and the rightmost node is pointed to by the text \"tail\". The leftmost node points to null on the left and the middle node on the right. The middle node points to the leftmost node on the left and the rightmost node on the right. The rightmost node points to the middle node on the left and null on the right.\n", "Double queue class (DLDeque) with doubly-linked lists\n\nWe are looking at the code for a double-ended queue class called DLDeque. The class implements the Deque interface and uses a doubly-linked list to store the elements.\n\nThe class has three attributes: head, tail, and size. Head is a reference to the first node in the list, tail is a reference to the last node in the list, and size is the number of elements in the list.\n\nThe class has a constructor that initializes the head and tail nodes and sets the size to 0. The head and tail nodes are initially connected to each other to form an empty list.\n", "Exercise 3\n\nImplement the following methods in the DLDeque<E> class:\n- boolean isEmpty()\n- int size()\n- E first()\n- E last() \n", "Double queue class (DLDeque) with doubly-linked lists: Insertion at the beginning\n\nThe image shows the Java code and a diagram illustrating the insertion of a new element at the beginning of a double ended queue implemented with a doubly-linked list.\n\nThe code defines a method called insertFirst that takes a generic type E info as input. \n\nThe diagram shows a doubly-linked list with 3 nodes: head, second and tail. Each node has two pointers: one to the previous node and one to the next node. The head node points to the first element of the list, while the tail node points to the last element of the list.\n\nThe insertFirst method inserts a new node, labeled as \"first\", before the head node. The new node contains the value \"Mosc\u00fa\". The next pointer of the new node points to the previous head node, and the previous pointer of the new node points to null. The next pointer of the head node is updated to point to the new node, and the previous pointer of the second node is updated to point to the new node. The size of the list is incremented by 1.\n", "**Double queue class (DLDeque) with doubly-linked lists: Extraction from the beginning**\n\nThe image shows the code and a diagram illustrating the process of removing the first element from a double-ended queue implemented using a doubly-linked list. \n\nThe code is a Java method called `removeFirst()` that returns an element of generic type `E`. \n\n1. **Initialization:** The method starts by initializing a variable `info` of type `E` to `null`. This variable will store the information of the element being removed.\n\n2. **Checking for an empty queue:** It then checks if the queue is empty by comparing the `next` pointer of the `head` node to the `tail` node. If they are the same, the queue is empty, and the method returns the initial `null` value of `info`.\n\n3. **Extracting the first element:** If the queue is not empty, the method retrieves the first node after the `head` and stores it in the `first` variable. The information of this node is then extracted and stored in the `info` variable.\n\n4. **Updating pointers:** Next, the method gets the second node in the queue and stores it in the `second` variable. The `next` pointer of the `head` node is updated to point to the `second` node, effectively removing the `first` node from the queue. The `prev` pointer of the `second` node is then updated to point to the `head` node, maintaining the doubly-linked list structure.\n\n5. **Decreasing the size:** The size of the queue is decremented by one to reflect the removal of an element.\n\n6. **Returning the removed element:** Finally, the method returns the `info` variable, which contains the information of the element that was removed from the beginning of the queue.\n\nThe diagram visually represents the doubly-linked list before and after the removal of the first element. The orange boxes represent the nodes of the list, with arrows indicating the `next` and `prev` pointers. The first node, labeled \"first\", is removed from the list, and the `head` pointer is updated to point to the second node. The `Mosc\u00fa` element is removed from the queue.\n", "Exercise 4\n\nWe will implement the following methods in the DLDeque of E class: insertLast which takes an argument of type E called info, and for homework, we will implement removeLast which takes no arguments and returns an object of type E. \n", "**Insertion (without dummy nodes)**\n\nThe image shows three existing nodes in a doubly linked list, labeled \"head\", \"prev\", and \"tail\". Each node has two pointers: one to the previous node (\"prev\") and one to the next node. The \"head\" node's \"prev\" pointer points to \"null\", indicating that it is the first node in the list. Similarly, the \"tail\" node's next pointer points to \"null\", indicating it is the last node.\n\nA new node, colored red, is being inserted into the list. The code snippet below the diagram shows the creation of this new node:\n\n```\nDLNode<E> node = new DLNode<E>(data);\n```\n\nThis line of code creates a new `DLNode` object with the given data and assigns it to the variable `node`. The `<E>` syntax indicates that this is a generic type, meaning it can hold any type of data.\n", "Insertion (without dummy nodes)\n\nThe diagram shows the insertion of a node into a doubly linked list. The new node is red. It is inserted between the node labeled \"prev\" and the next node. The code shows how to insert the new node. First, the new node's previous pointer is set to \"prev\". Then, if \"prev\" is not null, the new node's next pointer is set to the next node after \"prev\" and the next pointer of \"prev\" is set to the new node.\n", "Insertion (without dummy nodes)\n\nThe diagram shows the insertion of a new node into a doubly linked list, without using dummy nodes. The new node is shown in red.\n\nThe code checks if the previous node is null. If it is, it means that the new node should be inserted at the beginning of the list. In this case, the new node's next pointer is set to the current head of the list, and the head is updated to point to the new node.\n\nIf the previous node is not null, the code checks if the new node's next pointer is not null. If it is not, it means that the new node is not being inserted at the end of the list. In this case, the next node's previous pointer is set to the new node. Otherwise, the new node is being inserted at the end of the list, so the tail is updated to point to the new node. \n"]}, {"filename": "7. Trees.pdf", "text": "Systems Programming\n\nTrees\n\nDepartamento de Ingenier\u00eda \nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nCarlos Alario Hoyos, Raquel M. Crespo Garc\u00eda, Carlos Delgado Kloos, \nM\u00aa Carmen Fern\u00e1ndez Panadero, Julio Villena Rom\u00e1n\n\n\fContents\n\nv Concept of tree\nv Terminology\nv Implementation\nv Particular cases\n\n\u00d8 Binary search trees\n\u00d8 (Binary) heaps\n\n2\n\n\fConcept of tree\n\nA tree is a non-linear \ndata structure that \nstores the elements \nhierarchically\n\n(Generalization of lists)\n\n3\n\n\fExamples\n\n1. Classification of information in an \n\nencyclopedia\n\n4\n\n\fExamples\n\n2. File system\n\n5\n\n\fExamples\n\n3. Management structure of a company\n\n4. Rank system in the army\n\n5. Structure of a book or document\n\n\u2026\n\n6\n\n\fNon-recursive definition\n\n\u2022 A tree consists of a set of nodes and a \n\nset of edges, such that:\n\u2013 There is a special node called root\n\u2013 For each node c (child), except for the root, \nthere is one edge from another node p (p is \nparent of c, and can have several children)\n\n\u2013 For each node there is a single path\n(sequence of edges) from the root\n\n\u2013 Nodes without children are called leaves\n\n7\n\n\fNon-recursive definition\n\nRoot (no parent)\n\np\n\nsibling \nof c\n\nThe parent of c\n\nA child of p\n\nc\n\nHojas\nLeaves (no\n(sin hijos)\nchildren)\n\nLeaves (no\nHojas\nchildren)\n(sin h\n\n8\n\n\fRecursive definition\n\n\u2022 A tree is\n\u2013 empty \n\u2013 or a node (root) and zero or more trees \n(subtrees) connected to the node by \nmeans of an edge to its root\n\n* Trees connected to the root are called subtrees\n\n9\n\n\fRecursive definition\n\na\n\nb\n\nc\n\nf\n\ng\n\nd\n\nh\n\ne\n\ni\n\nj\n\nk\n\n10\n\n\fRecursive definition\n\na\n\nb\n\nc\n\nf\n\ng\n\nd\n\nh\n\ne\n\ni\n\nj\n\nk\n\n11\n\n\fRecursive definition\n\na\n\nb\n\nc\n\nf\n\ng\n\nd\n\nh\n\ne\n\ni\n\nj\n\nk\n\n12\n\n\fRecursive definition\n\na\n\nb\n\nc\n\nf\n\ng\n\nd\n\nh\n\ne\n\ni\n\nj\n\nk\n\n13\n\n\fRecursive definition\n\na\n\nb\n\nc\n\nf\n\ng\n\nd\n\nh\n\ne\n\ni\n\nj\n\nk\n\n14\n\n\fTerminology\n\n\u2022 A node is external, if it has no children (it is a leaf)\n\n\u2013 According to the recursive definition: if all the subtrees\n\nconnected to that node are empty\n\n\u2022 A node is internal, if it has one or more children\n\u2013 According to the recursive definition: if any of the subtrees\n\nconnected to that node is not empty\n\n\u2022 A node is ancestor of another one, if the former is \na parent of the latter or an ancestor of its parent\n\n\u2022 A node is descendent of another one, if the latter \n\nis ancestor of the former\n\u2013 The descendants of a node determine a subtree where this \n\nnode acts as the root\n\n15\n\n\fTerminology\n\n\u2022 A path from one node to another one is a \n\nsequence of consecutive edges between the \nnodes. \n\n\u2013 The length is the number of edges in the path.\n\n\u2022 The depth of a node is the length of the path from \n\nthe root to this node.\n\n\u2022 The height of a tree is the depth of the deepest \n\nnode.\n\n\u2022 The size of a tree is the number of nodes.\n\n16\n\n\fExamples\n\nSize of the tree: 7\nHeight of the tree: 2\n\nNode Height\n\na\n\nb\n\nc\n\nd\n\ne\n\nf\n\ng\n\n2\n\n1\n\n0\n\n0\n\n0\n\n0\n\n0\n\nDepth\n0\n\nSize\n7\n\n1\n\n1\n\n1\n\n1\n\n2\n\n2\n\n3\n\n1\n\n1\n\n1\n\n1\n\n1\n\nInt./Ext.\nInternal\n\nInternal\n\nExternal\n\nExternal\n\nExternal\n\nExternal\n\nExternal\n\n\fExercise 1\n\n\u2022 Complete the table for the following tree\n\nNode Height\n\na\n\nb\n\nc\n\nd\n\ne\n\nf\n\ng\n\nh\n\ni\n\nj\n\nk\n\n3\n\n1\n\n0\n\n1\n\n2\n\n0\n\n0\n\n0\n\n0\n\n1\n\n0\n\nDepth\n0\n\nSize\n11\n\n1\n\n1\n\n1\n\n1\n\n2\n\n2\n\n2\n\n2\n\n2\n\n3\n\n3\n\n1\n\n2\n\n4\n\n1\n\n1\n\n1\n\n1\n\n2\n\n1\n\nInt./Ext.\nInternal\n\nInternal\n\nExternal\n\nInterno\n\nInterno\n\nExternal\n\nExternal\n\nExterno\n\nExterno\n\nInterno\n\nExterno\n\nSize of the tree: \nHeight of the tree: \n\n\fTerminology: ordered tree\n\na\n\na\n\nb\n\nc\n\nc\n\nb\n\n\u2022 A tree is ordered, if for each node there exists a \n\nlinear ordering for its children.\n\n20\n\n\fTerminology: binary tree\n\n\u2022 A binary tree is an ordered tree, where \n\neach node has 2 subtrees (left and right).\n\u2013 According to the recursive definition of tree\n\u2013 Left and/or right subtrees can be empty\n\n21\n\n\fInterface Btree<E>\n\npublic interface BTree<E> {\n\nstatic final int LEFT = 0;\nstatic final int RIGHT = 1;\n\nboolean isEmpty();\nE getInfo();\nBTree<E> getLeft();\n\nBTree<E> getRight();\n\nvoid insert(BTree<E> tree, int side);\nBTree<E> extract(int side);\n\nString toStringPreOrder();\nString toStringInOrder();\n\nString toStringPostOrder();\nString toString(); // preorder\n\nint size();\n\nint height();\n\nboolean equals(BTree<E> tree);\nboolean find(BTree<E> tree);\n\n}\n\n22\n\n\fInterface Btree<E> \n(with exceptions)\n\npublic interface BTree<E> {\n\nstatic final int LEFT = 0;\nstatic final int RIGHT = 1;\n\nboolean isEmpty();\nE getInfo() throws BTreeException;\nBTree<E> getLeft() throws BTreeException;\n\nBTree<E> getRight() throws BTreeException;\n\nvoid insert(BTree<E> tree, int side) throws BTreeException;\nBTree<E> extract(int side) throws BTreeException;\n\nString toStringPreOrder();\nString toStringInOrder();\n\nString toStringPostOrder();\nString toString(); // preorder\n\nint size();\n\nint height();\n\nboolean equals(BTree<E> tree);\nboolean find(BTree<E> tree);\n\n}\n\n23\n\n\fOne interface several implementations\n\n\u2022 Array-based implementation\n\nv Left subtree\n\n\u00fc Position of root * 2 +1\n\nv Right subtree\n\n\u00fc Position of root * 2 +2\n\np(root)=0\np(x.left)=2*p(x)+1\np(x.right)=2*p(x)+2\n\nor\n\np(root)=1\np(x.left)=2*p(x)\np(x.right)=2*p(x)+1\n\n\fImplementation based on a linked structure\n\n\u2022 Linked-based implementation\n\n\u00a7 Linked Binary Node (LBNode<E>)\n\u00a7 Linked Binary Tree (LBTree<E>)\n\u00fc Each tree (LBTree<E>) has a root (attribute LBNode<E>)\n\u00fc Each root (LBNode<E>) has two subtrees (attributes \nLBTree<E>), which can be empty (root is null)\n\n\f*Binary node... (non-recursive)\n\npublic class LBNode<E> {\nprivate E info;\nprivate LBNode<E> left;\nprivate LBNode<E> right;\n\npublic LBNode() {\n\nthis(null);\n\n}\npublic LBNode(E info) {\n\nthis(info, null, null);\n\n}\npublic LBNode(E info, LBNode<E> l, LBNode<E> r) {\n\nthis.info = info; \nleft = l; \nright = r;\n\n}\n\n}\n\n26\n\n\fLBNode<E> (recursive tree)\n\npublic class LBNode<E> {\n\nprivate E info;\nprivate BTree<E> left;\nprivate BTree<E> right;\n\npublic LBNode(E info, BTree<E> left, BTree<E> right) {\u2026}\n\npublic E getInfo() {\u2026}\npublic void setInfo(E info) {\u2026}\n\npublic BTree<E> getLeft() {\u2026}\npublic void setLeft(BTree<E> left) {\u2026}\n\npublic BTree<E> getRight() {\u2026}\npublic void setRight(BTree<E> right){\u2026}\n\n}\n\n27\n\n\fExercise 2\n\n\u2022 Complete the implementation of \n\nthe class LBNode<E>. \n\n\fLBTree<E> (I) (recursive tree)\n\npublic class LBTree<E> implements BTree<E> {\n\nprivate LBNode<E> root;\n\npublic LBTree() {\n\nroot = null;\n\n}\n\npublic LBTree(E info) {\n\nroot = new LBNode<E>(info, new LBTree<E>(), new LBTree<E>());\n\n}\n\npublic boolean isEmpty() {\n\nreturn (root==null);\n\n}\n\n\u2026\n\n29\n\n\fLBTree<E> (II) (recursive tree)\n\n\u2026\npublic E getInfo() throws BTreeException {\n\nif (isEmpty()) {\n\nthrow new BTreeException(\"empty trees do not have info\");\n\n}\nreturn root.getInfo();\n\n}\npublic BTree<E> getLeft() throws BTreeException {\n\nif (isEmpty()) {\n\nthrow new BTreeException(\"empty trees do not have a left child\");\n\n}\nreturn root.getLeft();\n\n}\npublic BTree<E> getRight() throws BTreeException {\n\nif (isEmpty()) {\n\nthrow new BTreeException(\"empty trees do not have a right child\");\n\n}\nreturn root.getRight();\n\n}\n\u2026 \n\n30\n\n\fBasic algorithms\n\n\u2022 Size (number of nodes)\n\u2022 Height\n\u2022 Traversals\n\u2013 Euler\n\u2013 Pre-, in- and post-order\n\n(To simplify, we assume binary trees)\n\n31\n\n\fLBTree<E>: size()\n\npublic int size() {\nif (isEmpty()) {\nreturn 0;\n\n} else {\n\nreturn 1 + root.getLeft().size()\n+ root.getRight().size();\n\n}\n\n}\n\n\fLBTree<E>: size() non-recursive\n\n1. Create empty queue\n2. enqueue(root)\n3. Loop until empty queue\n1. Dequeue() an element\n2.\n3. Enqueue() its children\n\nsize++\n\n\fLBTree<E>: height()\n\npublic int height() {\n\nif (isEmpty()) {\n\nreturn -1;\n\n} else {\n\nint leftHeight = root.getLeft().height();\nint rightHeight = root.getRight().height();\nif (leftHeight > rightHeight) {\nreturn 1 + leftHeight;\n\n1+Math.max(leftHeight, \nrightHeight);\n\n} else {\n\nreturn 1 + rightHeight;\n\n}\n\n}\n\n}\n\n34\n\n\fLBTree<E>: height() non-recursive\n\n1. Create empty queue\n2. enqueue(root)\n3. Loop until empty queue\n1. Dequeue() all element\n2. Enqueue() their children\n3.\n\nif (queue is not empty) => height++\n\n\fEuler traversal\n\n36\n\n\fPreorder traversal\n\n1\n\n\u2022 First the node (root)\n\u2022 Then its children \n\n(recursively)\n\n2\n\n3\n\n4\n\n6\n\n5\n\n7\n\n37\n\n\fLBTree<E>: toStringPreOrder()\n\npublic String toStringPreOrder() {\n\nif (isEmpty()) {\n\nreturn \"\";\n\n} else {\n\nreturn root.getInfo().toString() + \" \" +\n\nroot.getLeft().toStringPreOrder() +\nroot.getRight().toStringPreOrder();\n\n}\n\n}\n\n\fLBTree<E>: toStringPreorder() non-recursive\n\n1. Create empty stack\n2. push(root)\n3. Loop until empty stack\n\n1.\n2.\n3.\n4.\n\npop()\nprint value\npush(rightChild)\npush(leftChild)\n\n\fPostorder traversal\n\n\u2022 First the children trees \n\n7\n\n(recursively)\n\n\u2022 Then the node (root)\n\n1\n\n6\n\n3\n\n5\n\n2\n\n4\n\n40\n\n\fLBTree<E>: toStringPostOrder()\n\npublic String toStringPostOrder() {\n\nif (isEmpty()) {\n\nreturn \"\";\n\n} else {\n\nreturn root.getLeft().toStringPostOrder() +\n\nroot.getRight().toStringPostOrder() +\nroot.getInfo().toString() + \" \";\n\n}\n\n}\n\n\fInorder (symmetric) traversal\n\n2\n\n1\n\n5\n\n\u2022 First the left tree \n\n(recursively)\n\u2022 Then the node\n\u2022 Finally, the right tree \n\n(recursively)\n\n3\n\n7\n\n4\n\n6\n\n42\n\n\fLBTree<E>: toStringInOrder()\n\npublic String toStringInOrder() {\n\nif (isEmpty()) {\n\nreturn \"\";\n\n} else {\n\nreturn root.getLeft().toStringInOrder() +\nroot.getInfo().toString() + \" \" +\nroot.getRight().toStringInOrder();\n\n}\n\n}\n\n\fExercise 3\n\n\u2022 Considering the following binary tree, \n\nindicate which traversal type produces the \nresult (A+B)*(C-D)\n\n\fDifferent mathematical notation\n\nInfix\n\nA+B\n\nPrefix\n\n+AB\n\nPostfix\n\nAB+\n\nA+B\u2013C\n\n\u2013+ABC\n\nAB+C\u2013\n\n(A+B)*(C\u2013D)\n\n*+AB\u2013CD\n\nAB+CD\u2013*\n\n45\n\n\fSystems Programming\n\nTrees (II)\n\nDepartamento de Ingenier\u00eda\nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY:\nCarlos Alario Hoyos, Raquel M. Crespo Garc\u00eda, Carlos Delgado Kloos, \nM\u00aa Carmen Fern\u00e1ndez Panadero, Julio Villena Rom\u00e1n\n\n\fContents\n\nv Concept of tree\nv Terminology\nv Implementation\nv Particular cases\n\n\u00d8 Binary search trees\n\u00d8 (Binary) heaps\n\n47\n\n\fNotation\n\n\u2022 So far:\n\no One node, three attributes: information, left subtree and \n\nright subtree\n\no One tree, one attribute: node (root)\n\n\u2022 When drawing a tree we represent the information as \n\nthe content in each node\n\n\fNotation\n\n\u2022 From now on:\n\no We add an additional attribute: the key\n\n\u2022\n\u2022\n\nIt facilitates using the tree for searching, inserting and extracting\nDepending on the implementation, the key can be an attribute of the \nnode or an attribute of the key. \n\n*\n\n4\n\nWhen drawing the tree\nv Dark color: Key\nv Light color: Information\n\n+\n\n2\n\n-\n\n8\n\nA\n\n1\n\nB\n\n3\n\nC\n\n6\n\nD\n\n9\n\n\fExample of using keys\n\n\u2022 Priority queues\n\no Linear data structure that returns the elements according to \nthe value of a key, instead of the order in which they were \ninserted into the queue. The key indicates the priority. \n\nPriority queue\nCOLA CON PRIORIDAD\n\n*1 => Max. priority\n\n\fExample of using keys\n\n\u2022 Priority queues\n\no Implementation 1: Comparing at insertion\n\n\u00fc Facilitates extraction\n\no Implementation 2: Comparing at extraction\n\n\u00fc Facilitates insertion\n\n\fBinary search trees\n\n\u2022 Concept of binary search tree\n\u2022 Operations\n\u2013 Searching\n\u2013 Insertion\n\u2013 Extraction\n\n\fBinary search trees: concept\n\n\u2022 A binary search tree is a binary tree \n\nwhere for each node n, \n\u2013 all the keys in the left subtree are\n\nlower than the key of n\n\n\u2013 and all those of the right subtree are  \n\ngreater than the key of n\n\n\u2013 Some implementations allow keys that are equal to that of n on the left or right\n\u2013 Others just override the info in case of two identical keys\n\n53\n\n\fExample (I)\n\n4\n\n\u2264\n\n2\n\n\u2264\n\n1\n\n\u2265\n\n3\n\n\u2265\n\n\u2264\n\n6\n\n8\n\n\u2265\n\n9\n\n\u2265\n\n7\n\n\u2264\n\n5\n\n1\n\n2\n\n3\n\n- We only represent keys (the stored information is not included) \n- Wrong implementation (left subtree of \u201c2\u201d includes a key that is greater than \u201c2\u201d) \n\n54\n\n\fExample (I)\n\n2\n\n\u2265\n\n\u2264\n\n3\n\n\u2264\n\n1\n\n4\n\n\u2264\n\n5\n\n\u2265\n\n\u2264\n\n6\n\n8\n\n\u2265\n\n9\n\n\u2265\n\n7\n\n1\n\n2\n\n3\n\n- We only represent keys (the stored information is not included) \n- Correct implementation\n\n55\n\n\fExample (II)\n\n8\n\n\u2265\n\n9\n\n\u2265\n\n7\n\n\u2264\n\n6\n\n\u2265\n\n5\n\n\u2264\n\n4\n\n\u2264\n\n2\n\n\u2265\n\n3\n\n\u2264\n\n1\n\n1\n\n2\n\n3\n\n4\n\nv Correct implementation of a binary search tree\n\n56\n\n\fOperation: Searching\n\nSearching \u201c3\u201d:\n\n\u2022 3<4: go to left subtree\n\u2022 3>2: go to right subtree\n\u2022 3=3: element found\n\n2\n2\n\n\u2265\n\n\u2264\n\n3\n3\n\n\u2264\n\n1\n\n4\n4\n\n\u2264\n\n5\n\n\u2265\n\n\u2264\n\n6\n\n8\n\n\u2265\n\n9\n\n\u2265\n\n7\n\n57\n\n\fOperation: Insertion\n\nInserting \u201c6\u201d:\n\n\u2022 6<7: go to left subtree\n\u2022 6>2: go to right subtree\n\u2022 when gap: insert\n\n7\n7\n\n\u2265\n\n9\n\n\u2264\n\n2\n2\n\n\u2265\n\n\u2264\n\n1\n\n5\n5\n\n\u2265\n\n6\n\n\u2264\n\n3\n\n58\n\n\fExercise 4\n\n\u2022 Given the following binary search tree, insert three \n\nnodes with keys 4, 8, 10\n\n7\n7\n\n\u2265\n\n9\n\n\u2264\n\n2\n2\n\n\u2265\n\n5\n5\n\n\u2265\n\n6\n\n\u2264\n\n3\n\n\u2264\n\n1\n\n59\n\n\fOperation: Extraction (II)\n\nIf left and right subtrees\nare empty (\u201cleaf\u201d)\n\u2022 Remove node\n\u2022 e.g. remove \u201c3\u201d\n\n\u2264\n\n1\n\n7\n7\n\n\u2265\n\n9\n\n\u2264\n\n2\n2\n\n\u2265\n\n5\n5\n\n\u2265\n\n6\n\n\u2264\n\n3\n\n60\n\n\fOperation: Extraction (II)\n\nIf one of the subtrees in \nempty\n\u2022 Replace by the root of \nthe non-empty subtree\n\u2022 e.g. extract \u201c5\u201d\n\n\u2264\n\n1\n\n2\n\n\u2265\n\n\u2264\n\n3\n\n7\n\n\u2265\n\n9\n\n\u2264\n\n3\n5\n\n61\n\n\fOperation: Extraction (III)\n\nIf none of the subtrees\nin empty\n\u2022 Replace by the greatest \nkey in the left subtree or \nby the lowest key in the \nright subtree\n\u2022 e.g. extract \u201c2\u201d \n(replacing by \u201c1\u201d or \u201c3\u201d)\n\n\u2264\n\n1\n\n\u2264\n\n5\n\n23\n\n\u2265\n\n\u2264\n\n3\n\n7\n\n\u2265\n\n9\n\n62\n\n\fExercise 5\n\n\u2022 Given the following binary search tree, extract the \nnode with key 7. Propose two ways of doing this \noperation\n\n7\n7\n\n\u2265\n\n9\n\n\u2264\n\n1\n\n\u2264\n\n5\n5\n\n2\n2\n\n\u2265\n\n\u2264\n\n3\n\n63\n\n\f(Binary) Heaps\n\n\u2022 A binary heap is a complete binary tree \nwhere every node has a key greater(*) \nthan the key of its parent (min-heap).\n\u2013 Usually, heaps refer to binary heaps\n* It could also be defined as less than (max-heap)\n* Some implementations allow equal keys, others override the information\n\n\u2022 Utility\n\n\u2013 Priority queues\n\u2013 Sorting algorithms (Heap Sort)\n\n64\n\n\f(Binary) Heaps: properties\n\n\u2022 A (binary) heap fulfils two properties:\n1. For each node n (except for the root), \nits key is greater than or equal to the \none of its parent.\n\n2. Completeness\n\nComplete\n\nNot complete\n\n65\n\n\fExample 1\n\n1\n\n2\n\n4\n\n3\n\n5\n\n6\n\n9\n\n8\n\n7\n\nNot a heap: it is not complete\n\n66\n\n\fExample 2\n\n1\n\n3\n\n4\n\n2\n\n5\n\n6\n\n9\n\n8\n\n7\n\nNot a heap: keys in some children \nare lower than those of the parent\n\n67\n\n\fExample 3\n\n1\n\n2\n\n4\n\n3\n\n5\n\n6\n\n9\n\n8\n\n7\n\nHeap\n\n68\n\n\fSequence-based implementation\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n1 2 3 4 5 6 7\n\np(root)=0\np(x.left)=2*p(x)+1\np(x.right)=2*p(x)+2\n\nor\n\np(root)=1\np(x.left)=2*p(x)\np(x.right)=2*p(x)+1\n\n0    1    2    3    4    5    6  \n\n69\n\n\fInsert\n\nInsert element \nwith key=\u201c2\u201d\n\n4\n\n5\n\n6\n\n15\n\n9\n\n7\n\n20\n\n16\n\n25\n\n14\n\n12\n\n11\n\n8\n\n70\n\n\fInsert\n\nInsert element \nwith key=\u201c2\u201d\n\n4\n\n5\n\n6\n\n15\n\n9\n\n7\n\n20\n\n16\n\n25\n\n14\n\n12\n\n11\n\n8\n\n2\n\n71\n\n\fInsert\n\nInsert element \nwith key=\u201c2\u201d\n\n4\n\n5\n\n6\n\n15\n\n9\n\n7\n\n2\n\n16\n\n25\n\n14\n\n12\n\n11\n\n8\n\n20\n\n72\n\n\fInsert\n\nInsert element \nwith key=\u201c2\u201d\n\n4\n\n5\n\n2\n\n15\n\n9\n\n7\n\n6\n\n16\n\n25\n\n14\n\n12\n\n11\n\n8\n\n20\n\n73\n\n\fInsert\n\nInsert element \nwith key=\u201c2\u201d\n\n2\n\n5\n\n4\n\n15\n\n9\n\n7\n\n6\n\n16\n\n25\n\n14\n\n12\n\n11\n\n8\n\n20\n\n74\n\n\fExercise 6\n\n\u2022 Given the following binary heap, insert 3, 10, 1\n\n2\n\n5\n\n4\n\n15\n\n9\n\n7\n\n6\n\n16\n\n25\n\n14\n\n12\n\n11\n\n8\n\n20\n\n75\n\n\fExtract\n\nExtract element \nwith key=\u201c4\u201d\n\n4\n\n5\n\n6\n\n15\n\n9\n\n7\n\n20\n\n16\n\n25\n\n14\n\n12\n\n11\n\n8\n\n76\n\n\fExtract\n\nExtract element \nwith key=\u201c4\u201d\n\n8\n\n4\n\n5\n\n6\n\n15\n\n9\n\n7\n\n20\n\n16\n\n25\n\n14\n\n12\n\n11\n\n77\n\n\fExtract\n\nExtract element \nwith key=\u201c4\u201d\n\n5\n\n8\n\n6\n\n15\n\n9\n\n7\n\n20\n\n16\n\n25\n\n14\n\n12\n\n11\n\n78\n\n\fExercise 7\n\n\u2022 Given the following binary heap, extract 15, 5, 7\n\n5\n\n8\n\n6\n\n15\n\n9\n\n7\n\n20\n\n16\n\n25\n\n14\n\n12\n\n11\n\n79\n\n\f", "pages_description": ["Concept of tree\n\nA tree is a non-linear data structure that stores the elements hierarchically. This is a generalization of lists. \n", "Examples\n\nWe see a tree diagram with the root node labeled \"Encyclopaedia\". The root node has two children: \"Science\" on the left and \"Culture\" on the right. The \"Culture\" node has two children: \"Art\" on the left and \"Craft\" on the right. \n", "Examples\n\nA diagram shows a file system. The root directory is at the top, and it branches down to several other directories, including home, tmp, usr, and var. The home directory branches down to its and scs. The its directory branches down to ug1 and pg1. The ug1 directory branches down to ee51vn and ma51ik. The ee51vn directory branches down to docs, pics, and report.doc. The scs directory branches down to staff. \n", "Examples\n\nThis slide lists three examples: Management structure of a company, Rank system in the army, Structure of a book or document. There are three dots below the list, indicating that there are more examples. On the right side of the slide, there is a cartoon drawing of a book with an \"at\" symbol on the cover. The book has three bookmarks in green, yellow, and red. \n", "Non-recursive definition\n\nA tree consists of a set of nodes and a set of edges, such that:\n- There is a special node called root\n- For each node c (child), except for the root, there is one edge from another node p (p is parent of c, and can have several children)\n- For each node there is a single path (sequence of edges) from the root\n- Nodes without children are called leaves \n", "Non-recursive definition\n\nThe image shows a tree data structure with nodes represented as orange circles. The top node is labeled as \"Root (no parent)\". An arrow points from the root node to a node labeled \"p\". Another arrow points from \"p\" to a node labeled \"c\". A text box next to \"p\" reads \"The parent of c\". A text box next to \"c\" reads \"A child of p\". A text box pointing to a group of nodes that are children of the root node reads \"sibling of c\". A text box pointing to a group of nodes that have no children reads \"Leaves (no children)\". \n", "Recursive definition\n\nA tree is either empty or it is a node called root and zero or more trees called subtrees connected to the root by means of an edge.\n\nThe slide contains a diagram of a tree: the root is represented as an orange circle and it is connected to three subtrees represented as orange triangles.\n", "Recursive definition\n\nWe see a diagram with a series of triangles and rectangles. The top rectangle, labeled \"a,\" has arrows pointing to five other triangles, each containing a rectangle. These rectangles are labeled \"b,\" \"c,\" \"d,\" \"e,\" and \"h.\" Rectangles \"b\" and \"e\" each have arrows pointing to two more rectangles within their respective triangles, labeled \"f\" and \"g\" for \"b,\" and \"i\" and \"j\" for \"e.\" Finally, rectangle \"j\" has an arrow pointing to a final rectangle labeled \"k.\" \n", "Recursive definition\n\nWe see a diagram with several triangles connected by lines. One triangle is highlighted in orange. The diagram illustrates a recursive definition. The top element \"a\" is connected to four other elements \"b\", \"c\", \"d\", and \"e\". Element \"e\" is part of the orange triangle and is further connected to \"i\", \"j\", and \"k\". Element \"j\" is connected to element \"k\". Elements \"b\", \"f\", \"g\", and \"h\" are placed within separate triangles. \n", "Recursive definition\n\nWe see a diagram with several triangles connected by arrows. The triangles represent data structures and the arrows represent relationships between them. The topmost triangle contains the letter 'a'. It has arrows pointing to four other triangles containing the letters 'b', 'c', 'd', and 'e' respectively. Triangle 'b' has arrows pointing to two triangles containing 'f' and 'g'. Triangle 'e' is highlighted in orange and has arrows pointing to two other triangles, also highlighted in orange, containing nothing and 'j'. Triangle 'j' has an arrow pointing to a final orange triangle containing 'k'. \n", "Recursive definition\n\nWe see a diagram with a tree data structure. The nodes of the tree are labeled with letters from 'a' to 'k'. The node 'a' is the root of the tree and has five children: 'b', 'c', 'd', 'e', and an unlabeled node. The node 'b' has two children: 'f' and 'g'. The node 'e' has two children: an unlabeled node and 'j'. The node 'j' has one child: 'k'. The node 'k' is highlighted in orange. \n", "Recursive definition\n\nWe see a diagram with several triangles connected by arrows. The triangles represent data structures, and the arrows represent relationships between them. The top triangle, labeled \"a\", points to four other triangles, labeled \"b\", \"c\", \"d\", and \"e\". Triangle \"b\" points to triangles \"f\" and \"g\". Triangle \"d\" points to triangle \"h\". Triangle \"e\" points to triangles \"i\" and \"j\". Triangle \"j\" is highlighted in orange and points to triangle \"l\". This diagram illustrates a recursive definition, where a data structure is defined in terms of itself. \n", "Terminology\n\n- A node is external, if it has no children (it is a leaf)\n  - According to the recursive definition: if all the subtrees connected to that node are empty\n- A node is internal, if it has one or more children\n  - According to the recursive definition: if any of the subtrees connected to that node is not empty\n- A node is ancestor of another one, if the former is a parent of the latter or an ancestor of its parent\n- A node is descendent of another one, if the latter is ancestor of the former\n  - The descendants of a node determine a subtree where this node acts as the root \n", "Terminology\n\n- A path from one node to another one is a sequence of consecutive edges between the nodes. The length is the number of edges in the path.\n- The depth of a node is the length of the path from the root to this node.\n- The height of a tree is the depth of the deepest node.\n- The size of a tree is the number of nodes. \n", "Examples\n\nWe see a tree data structure with nodes a, b, c, d, e, f, g. Node a is the root and has children b, c, d and e. Node b has children f and g. The size of the tree is 7 and the height of the tree is 2.\n\nOn the right side, we see a table with five columns: Node, Height, Depth, Size, Int./Ext. The table lists the properties of each node in the tree. For example, node a has height 2, depth 0, size 7 and is an internal node. Node b has height 1, depth 1, size 3 and is an internal node. Node c has height 0, depth 1, size 1 and is an external node. Node d has height 0, depth 1, size 1 and is an external node. Node e has height 0, depth 1, size 1 and is an external node. Node f has height 0, depth 2, size 1 and is an external node. Node g has height 0, depth 2, size 1 and is an external node. \n", "Exercise 1\n\nWe have a diagram representing a tree data structure and a table to be filled with information about the nodes of the tree.\n\nThe tree has the following structure:\n- The root node is \"a\".\n- Node \"a\" has 5 children: \"b\", \"c\", \"d\", and \"e\".\n- Node \"b\" has 2 children: \"f\" and \"g\".\n- Node \"e\" has 2 children: \"h\" and \"i\".\n- Node \"j\" is a child of \"i\".\n- Node \"k\" is a child of \"j\".\n\nThe table has the following columns: \"Node\", \"Height\", \"Depth\", \"Size\", \"Int./Ext.\".\n\nThe table is partially filled. The following information is already present:\n- Node \"a\" is an internal node.\n- Node \"b\" has height 1, depth 1, size 3 and is internal.\n- Node \"c\" has height 0, depth 1, size 1 and is external.\n- Node \"f\" has height 0, depth 2, size 1 and is external.\n- Node \"g\" has height 0, depth 2, size 1 and is external.\n\nThe following questions are asked about the tree:\n- What is the size of the tree?\n- What is the height of the tree?\n", "Terminology: ordered tree\n\nWe see two tree data structures. The nodes in both trees contain the letters a, b, and c. In the tree on the left, b is to the left of c, while in the tree on the right, c is to the left of b. The question is whether these two trees are the same.\n\nThe text below states that a tree is ordered if, for each node, there exists a linear ordering for its children. \n", "Terminology: binary tree\n\nA binary tree is an ordered tree, where each node has two subtrees: a left subtree and a right subtree. According to the recursive definition of a tree, the left and/or right subtrees can be empty. \n", "Interface Btree<E>\n\nThe image shows an interface definition, for a Binary Tree, written in a language similar to Java. The name of the interface is \"BTree\" and it has a generic type \"E\".\n\nThe interface defines the following methods:\n\n* isEmpty: returns true if the tree is empty, false otherwise.\n* getInfo: returns the element stored in the root of the tree.\n* getLeft: returns the left subtree.\n* getRight: returns the right subtree.\n* insert: inserts a new element in the tree.\n* extract: extracts an element from the tree.\n* toStringPreOrder: returns a string representation of the tree in preorder.\n* toStringInOrder: returns a string representation of the tree in inorder.\n* toStringPostOrder: returns a string representation of the tree in postorder.\n* toString: returns a string representation of the tree, by default in preorder.\n* size: returns the number of elements in the tree.\n* height: returns the height of the tree.\n* equals: checks if two trees are equal.\n* find: checks if an element is in the tree.\n\nThe interface also defines two constants:\n\n* LEFT: represents the left side of a node.\n* RIGHT: represents the right side of a node.\n", "Interface Btree<E> (with exceptions)\n\nThe image shows code for a Java interface called BTree which takes a generic type E. It has two static final integer variables called LEFT and RIGHT that are initialized to 0 and 1 respectively. It also has the following methods:\n\n- isEmpty: returns a boolean\n- getInfo: returns a generic type E and throws a BTreeException\n- getLeft: returns a BTree of generic type E and throws a BTreeException\n- getRight: returns a BTree of generic type E and throws a BTreeException\n- insert: takes a BTree of generic type E and an integer and throws a BTreeException\n- extract: takes an integer and throws a BTreeException\n- toStringPreOrder: returns a String\n- toStringInOrder: returns a String\n- toStringPostOrder: returns a String\n- toString: returns a String, this is the preorder traversal of the tree\n- size: returns an integer\n- height: returns an integer\n- equals: takes a BTree of generic type E and returns a boolean\n- find: takes a BTree of generic type E and returns a boolean\n", "One interface several implementations\n\nThis slide describes an array-based implementation of a binary tree. \n\nThe diagram shows a binary tree with 7 nodes. The nodes are numbered from 1 to 7. The root node is 1, and it has two children: 2 and 3. Node 2 has two children: 4 and 5. Node 3 has two children: 6 and 7.\n\nThe nodes of the tree are stored in an array. The root node is stored at index 0 of the array. The left child of a node at index i is stored at index 2*i+1, and the right child is stored at index 2*i+2.\n\nThere are two possible ways to store the root node: at index 0 or at index 1. The slide shows the formulas for calculating the indexes of the left and right children for both cases. \n", "Implementation based on a linked structure\n\nWe have a linked-based implementation.\n- Linked Binary Node (LBNode<E>)\n- Linked Binary Tree (LBTree<E>)\n\nEach tree (LBTree<E>) has a root (attribute LBNode<E>).\nEach root (LBNode<E>) has two subtrees (attributes LBTree<E>), which can be empty (root is null).\n\nThere is a diagram of a binary tree with 7 nodes. The nodes are numbered 1 through 7. Node 1 is the root node. Node 2 is the left child of node 1 and node 3 is the right child of node 1. Node 4 is the left child of node 2 and node 5 is the right child of node 2. Node 6 is the left child of node 3 and node 7 is the right child of node 3. \n\nThe nodes are colored in red and green. The nodes 1, 2, 4 and 6 are colored in red and the nodes 3, 5 and 7 are colored in green. The nodes are connected by lines. The lines connecting the red nodes are also red and the lines connecting the green nodes are also green. The line connecting node 1 and node 2 is red and the line connecting node 1 and node 3 is green.\n", "*Binary node... (non-recursive)*\n\nWe see a code snippet showing the implementation of a binary node in Java. The class LBNode has three private attributes: info of generic type E, left of type LBNode, and right of type LBNode. \n\nThe class has three constructors: \n- LBNode() -  a no-argument constructor that calls the constructor with one parameter E, passing null as argument.\n- LBNode(E info) - a constructor that takes an argument of type E and calls the constructor with three arguments, passing the received argument, null and null.\n- LBNode(E info, LBNode<E> l, LBNode<E> r) - a constructor that takes three arguments: info of type E, l of type LBNode, and r of type LBNode. It sets the info attribute to the value of the info argument, the left attribute to the value of the l argument, and the right attribute to the value of the r argument. \n", "LBNode<E> (recursive tree)\n\nWe see a code snippet showing the definition of a class named LBNode, parameterized with a generic type E. This class represents a node in a binary tree, where each node stores an element of type E and references to its left and right children, which are also of type BTree<E>. The class provides a constructor to initialize the node with its info, left child, and right child. It also includes methods to get and set the info, left child, and right child of the node. \n", "Exercise 2\n\nComplete the implementation of the class LBNode of type E. \n", "LBTree<E> (I) (recursive tree)\n\nWe see code for a class named \"LBTree\" which implements the \"BTree\" interface. This class represents a binary tree data structure. It has a private member variable \"root\" of type \"LBNode\", representing the root node of the tree.\n\nThe class has two constructors: a no-argument constructor that initializes the root to null, and a constructor that takes an argument of type \"E\" representing the information to be stored in the root node. This constructor creates a new \"LBNode\" with the given information and two empty subtrees, represented by new instances of \"LBTree\".\n\nFinally, the class has an \"isEmpty\" method that returns true if the tree is empty (i.e., the root is null) and false otherwise. \n", "LBTree<E> (II) (recursive tree)\n\nThe image shows three code snippets of a data structure called LBTree. The first snippet shows the method \"getInfo\" which returns the information stored in the root of the tree. The second snippet shows the method \"getLeft\" which returns the left subtree of the root. The third snippet shows the method \"getRight\" which returns the right subtree of the root. All three methods throw a BTreeException if the tree is empty. \n", "Basic algorithms\n\n- Size: number of nodes\n- Height\n- Traversals: Euler, Pre-order, In-order, and Post-order \n\nTo simplify, we assume binary trees. \n", "LBTree<E>: size()\n\nWe see a code snippet showing the implementation of a method called size. The method first checks if the tree is empty. If it is, it returns zero. Otherwise, it recursively calls the size method on the left and right subtrees, adds one to the result, and returns the sum. \n", "LBTree<E>: size() non-recursive\n\nThe image describes an algorithm to calculate the size of an LBTre of generic type E. The algorithm is non-recursive and uses a queue. \n\nOn the left side of the image, we see a tree. The root of the tree is node 1. Node 1 has two children: node 2 and node 3. Node 2 has two children: node 4 and node 5. Node 3 has two children: node 6 and node 7.\n\nOn the right side of the image, we see a schematic representation of a queue. The queue is initially empty. The algorithm works as follows:\n\n1. Create an empty queue.\n2. Enqueue the root of the tree (node 1 in this case).\n3. Loop until the queue is empty.\n   1. Dequeue an element from the queue.\n   2. Increment the size of the tree by one.\n   3. Enqueue all the children of the dequeued element.\n\nThe algorithm iterates through the tree level by level. It starts by adding the root node to the queue. Then, for each node dequeued from the queue, the algorithm increments the size count and adds all the node's children to the queue. This process continues until the queue is empty, ensuring that all nodes in the tree are visited and counted.\n", "LBTree<E>: height()\n\nWe have a code snippet showing the implementation of the method \"height\" for a generic type \"LBTree\". The method begins by checking if the tree is empty. If it is, it returns -1. Otherwise, it recursively calculates the height of the left and right subtrees. The height of the tree is then determined by taking the maximum height of the left and right subtrees and adding 1. This is represented by the expression \"1 + Math.max(leftHeight, rightHeight)\". \n", "LBTree<E>: height() non-recursive\n\nThe image describes an algorithm to calculate the height of a binary tree in a non-recursive way. \n\nOn the left side, we see a binary tree with 7 nodes. The nodes are numbered from 1 to 7. The root node is 1, and it has two children: 2 and 3. Node 2 has two children: 4 and 5. Node 3 has two children: 6 and 7.\n\nOn the right side, there is a visual representation of a queue data structure. The queue is represented as a horizontal array with \"Front\" and \"Back\" labels. The \"Enqueue\" arrow points to the back of the queue, indicating where elements are added. The \"Dequeue\" arrow points from the front of the queue, indicating where elements are removed.\n\nBelow the tree and the queue, there is a numbered list describing the steps of the algorithm:\n\n1. Create empty queue\n2. enqueue(root) - Add the root node to the queue.\n3. Loop until empty queue\n   1. Dequeue() all element - Remove all elements from the queue.\n   2. Enqueue() their children - Add all children of the removed elements to the queue.\n   3. if (queue is not empty) => height++ - If the queue is not empty after adding the children, increment the height. \n", "Euler traversal\n\nWe see a tree with seven nodes. An arrow indicates that the traversal starts at the topmost node. The text \"Also applicable to non-binary trees!\" highlights that Euler traversal is not limited to binary trees. \n", "Preorder traversal\n\nWe see a diagram representing a tree data structure with nodes numbered from 1 to 7. Node 1 is the root node. An arrow originates from the root node and follows the path of a preorder traversal. The preorder traversal visits the root node first, then recursively visits its children. In this case, the traversal order is 1, 2, 3, 4, 5, 6, 7. \n", "LBTree<E>: toStringPreOrder()\n\nWe see a code snippet for a function called `toStringPreOrder`. It's a recursive function that takes no arguments and returns a `String`. If the tree is empty, it returns an empty string. Otherwise, it returns a string containing the root node's information, followed by the string representation of the left subtree in pre-order, and then the string representation of the right subtree in pre-order.\n\nThere is also a tree diagram with nodes containing the numbers 1 through 7. The node containing 1 is the root node. The node containing 2 is the left child of the root node, and the node containing 3 is the right child of the root node. The node containing 4 is the left child of the node containing 3, and the node containing 6 is the right child of the node containing 3. The node containing 5 is the left child of the node containing 4, and the node containing 7 is the right child of the node containing 4. \n", "LBTree<E>: toStringPreorder() non-recursive\n\nWe have an example of a non-recursive implementation of the toStringPreorder method for a binary tree.\nThe algorithm is as follows:\nFirst, create an empty stack.\nThen, push the root of the tree onto the stack.\nIterate while the stack is not empty:\n- pop the top node from the stack.\n- print the value of the node.\n- push the right child of the node onto the stack.\n- push the left child of the node onto the stack.\nThis will print the values of the nodes in the tree in preorder.\n\nThere is a diagram representing a binary tree with 7 nodes. The nodes are numbered from 1 to 7. The root node is node 1. The left child of node 1 is node 2. The right child of node 1 is node 3. The left child of node 2 is node 4. The right child of node 2 is node 5. The left child of node 3 is node 6. The right child of node 3 is node 7.\n\nThere is a diagram representing a stack. The stack is initially empty. The algorithm pushes and pops nodes from the stack in the order that they are visited during the preorder traversal.\n", "Postorder traversal\n\nWe see a diagram representing a tree data structure. The nodes in the tree are numbered 1 through 7. The postorder traversal algorithm is described as follows: first, the children trees are traversed recursively, then the node itself is visited. \n", "LBTree<E>: toStringPostOrder()\n\nWe see a code snippet of a recursive function called toStringPostOrder. The function returns a string. If the tree is empty, it returns an empty string. Otherwise, it recursively calls itself on the left and right subtrees, concatenates the results with the string representation of the root node's information, and returns the resulting string.\n\nThere is a diagram of a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, and 7. The root node is 7, and the left and right subtrees are rooted at 1 and 6, respectively.\n", "Inorder (symmetric) traversal\n\nThe image shows a binary tree with 7 nodes, numbered from 1 to 7. The nodes are connected by lines. The lines are colored in black, except for the lines that connect the nodes in the order of an inorder traversal, which are colored in green. The inorder traversal is a way to visit all the nodes in a tree. It starts by recursively visiting the left subtree, then it visits the current node, and finally it recursively visits the right subtree. The inorder traversal of the tree in the image is: 1, 3, 4, 5, 6, 7. \n", "LBTree<E>: toStringInOrder()\n\nWe have some source code for a function called toStringInOrder. The function returns a string. If the tree is empty, it returns an empty string. Otherwise, it recursively calls the function on the left and right subtrees, concatenating the results with the value of the root node in the middle, separated by spaces. There is also a diagram showing a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, and 7. The tree is structured such that the in-order traversal would visit the nodes in the following order: 1, 3, 4, 5, 6, 7, 2. \n", "Exercise 3\n\nWe are presented with a binary tree and asked to determine which traversal type produces the result: open parenthesis A plus B close parenthesis asterisk open parenthesis C minus D close parenthesis. The tree has a root node with an asterisk symbol. The root node branches to the left to a node with a plus symbol and to the right to a node with a minus symbol. The plus node branches to the left to a leaf node with the letter A and to the right to a leaf node with the letter B. The minus node branches to the left to a leaf node with the letter C and to the right to a leaf node with the letter D.\n", "Different mathematical notation\n\nThe table shows different mathematical notations: infix, prefix and postfix. The first column shows the infix notation, the second column shows the prefix notation and the third column shows the postfix notation. The first row shows the addition of A and B, the second row shows the addition of A and B minus C, and the third row shows the multiplication of the sum of A and B and the subtraction of C from D. \n", "Systems Programming\n\nTrees (II)\n\nThe presentation is about Trees, part 2, for a Systems Programming course. It was created by the Telematics Engineering Department. The content is based on the work of Carlos Alario Hoyos, Raquel M. Crespo Garc\u00eda, Carlos Delgado Kloos, M\u00aa Carmen Fern\u00e1ndez Panadero, and Julio Villena Rom\u00e1n. The presentation is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike license. \n", "Contents\n\nThe contents of this presentation are: Concept of tree, Terminology, Implementation, and Particular cases. The particular cases are: Binary search trees and (Binary) heaps. \n", "Notation\n\nWe have a tree data structure. Each node has three attributes: information, left subtree and right subtree. When drawing a tree we represent the information as the content in each node. The tree has a root node containing an asterisk. The root node branches into a plus sign on the left and a minus sign on the right. The plus sign branches into A on the left and B on the right. The minus sign branches into C on the left and D on the right. \n", "Notation\n\nFrom now on, we will add an additional attribute: the key. It facilitates using the tree for searching, inserting, and extracting. Depending on the implementation, the key can be an attribute of the node or an attribute of the key. When drawing the tree, the dark color will represent the key and the light color will represent information. We see an example of a tree. The root node has a key of 4 and the rest of the nodes have keys 2, 8, 1, 3, 6, and 9. \n", "Example of using keys\n\nWe have an example of a priority queue. A priority queue is a linear data structure that returns the elements according to the value of a key, instead of the order in which they were inserted into the queue. The key indicates the priority. In this example, 1 is the maximum priority. We have the elements \"E\", \"U\", \"U\", \"Q\" and \"E\" with the keys 3, 2, 4, 1 and 5 respectively. After processing the elements through the priority queue, the order of the elements is \"Q\", \"U\", \"E\", \"U\" and \"E\". \n", "Example of using keys\n\nThe image describes two implementations of priority queues. \n\nThe first implementation compares elements at insertion time. This approach facilitates extraction, as the element with the highest priority is always at the front of the queue. The diagram shows a queue with five elements, labeled Q, U, E, U, and E. The elements are ordered by priority, with E having the highest priority and Q having the lowest. When a new element is inserted into the queue, it is compared to the existing elements and placed in the appropriate position based on its priority.\n\nThe second implementation compares elements at extraction time. This approach facilitates insertion, as new elements can be added to the end of the queue without comparison. However, extracting the element with the highest priority requires comparing all elements in the queue. The diagram shows the same queue as in the first implementation, but this time the elements are not ordered by priority. When an element needs to be extracted from the queue, all elements are compared to find the one with the highest priority.\n", "Binary search trees\n\n- Concept of binary search tree\n- Operations\n  - Searching\n  - Insertion\n  - Extraction \n", "Binary search trees: concept\n\nA binary search tree is a binary tree where for each node n, all the keys in the left subtree are lower than the key of n and all those of the right subtree are greater than the key of n.\n\nSome implementations allow keys that are equal to that of n on the left or right. Others just override the info in case of two identical keys.\n", "Example (I)\n\nWe have a binary search tree with nodes containing the numbers 1, 2, 4, 5, 6, 7, 8 and 9. The root node is 4. The left subtree of the root node contains the nodes 1 and 2. The right subtree of the root node contains the nodes 6 and 8. The left subtree of the node 2 contains the node 3, which is marked as an error. The left subtree of the node 6 contains the node 5. The right subtree of the node 6 contains the node 7. The right subtree of the node 8 contains the node 9.\n\nOn the right side of the image, there are three arrows pointing down. The first arrow points to the number 1, the second arrow points to the number 2 and the third arrow points to the number 3.\n\nThe text below the diagram states that only keys are represented in the tree, and that the stored information is not included. It also states that the implementation of the tree is wrong because the left subtree of the node \"2\" includes a key that is greater than \"2\".\n", "Example (I)\n\nWe have a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, 7, 8 and 9. The root node is 4. The left child of 4 is 2 and the right child is 8. The children of 2 are 1 and 3. The children of 8 are 6 and 9. Finally, the children of 6 are 5 and 7. \n\nOn the right side of the image, there are three green arrows pointing down at the numbers 1, 2 and 3.\n\nBelow the tree, there are two sentences. The first sentence says: \"We only represent keys (the stored information is not included)\". The second sentence says: \"Correct implementation\".\n", "Example (II)\n\nWe see a binary search tree with the number 8 at the root. The left subtree of the root contains the values 1, 2, 3, 4, 6. The right subtree of the root contains the values 9 and 7. The values in the tree are in green, and the comparison operators are in blue. To the right of the tree, we see a green down arrow with the numbers 1, 2, 3, and 4. Below the tree, we see the text \"Correct implementation of a binary search tree\". \n", "Operation: Searching\n\nThe image shows how to search for the element \"3\" in a binary search tree. \n\nThe search starts at the root node, which has a value of 4. Since 3 is less than 4, the search continues to the left subtree. The left subtree has a root node with a value of 2. Since 3 is greater than 2, the search continues to the right subtree. The right subtree has a root node with a value of 3. Since 3 is equal to 3, the element has been found. \n\nThe search path is indicated by arrows. The arrows are labeled with the comparison that was made at each step. For example, the arrow from the node with value 4 to the node with value 2 is labeled \"3<4\" because the search went to the left subtree because 3 is less than 4.\n", "Operation: Insertion\n\nThe image shows how to insert the number six into a binary search tree. The tree has the following existing nodes: seven at the root, two as the left child of seven, nine as the right child of seven, one as the left child of two, five as the right child of two, and three as the left child of five. The insertion process starts by comparing the new value, six, with the value of the root node, seven. Since six is less than seven, we move to the left subtree. Next, we compare six with the value of the current node, two. Since six is greater than two, we move to the right subtree. There is no right child of two, so we insert six as the right child of five. The final tree has the following nodes: seven at the root, two as the left child of seven, nine as the right child of seven, one as the left child of two, five as the right child of two, three as the left child of five, and six as the right child of five. \n", "Exercise 4\n\nGiven the following binary search tree, insert three nodes with keys 4, 8, 10.\n\nThe image shows a binary search tree. The root node is 7. The left child of 7 is 2 and the right child of 7 is 9. The left child of 2 is 1 and the right child of 2 is 5. The left child of 5 is 3 and the right child of 5 is 6. \n", "Operation: Extraction (II)\n\nThe image shows an example of node extraction from a binary tree. The text explains that if the left and right subtrees of a node are empty, the node should be removed. The example shows a binary tree with a root node of 7. The node to be removed is 3, which has both left and right subtrees empty. \n", "Operation: Extraction (II)\n\nIf one of the subtrees in empty\n- Replace by the root of the non-empty subtree\n- e.g. extract \"5\"\n\nWe see a tree data structure. The root node is 7. The left subtree has root node 2. Node 2 has two children: 1 and 3. Node 3 has one child: 3. The right subtree of node 7 has a single node: 9. The node with value 3, child of the node with value 2, is colored blue. \n", "Operation: Extraction (III)\n\nThe diagram illustrates the extraction operation on a binary tree. \n\nIf none of the subtrees are empty, the node to be extracted is replaced by the greatest key in the left subtree or by the lowest key in the right subtree. \n\nFor example, to extract \"2\", it can be replaced by \"1\" or \"3\". The diagram shows a binary tree with nodes containing the numbers 1, 3, 5, 7, and 9. The node with the value 7 is at the root of the tree. The node with the value 3 is the left child of the root node. The node with the value 9 is the right child of the root node. The node with the value 1 is the left child of the left child of the root node. The node with the value 5 is the right child of the left child of the root node. The node with the value 3 is the left child of the right child of the left child of the root node.\n", "Exercise 5\n\nGiven the following binary search tree, extract the node with key 7. Propose two ways of doing this operation.\n\nThe binary search tree has the root node with value 7. The left child of the root has value 2 and the right child has value 9. The left child of node 2 has value 1 and the right child has value 5. The left child of node 5 has value 3. \n", "(Binary) Heaps\n\nA binary heap is a complete binary tree where every node has a key greater than the key of its parent. This is called a min-heap. Usually, heaps refer to binary heaps. It could also be defined as less than, which is called a max-heap. Some implementations allow equal keys, others override the information. \n\nSome of the utilities of binary heaps are priority queues and sorting algorithms, such as Heap Sort. \n", "(Binary) Heaps: properties\n\nA binary heap fulfills two properties. The first property is that for each node n, except for the root, its key is greater than or equal to the one of its parent. The second property is completeness. \n\nThere are two diagrams. The first diagram is an example of a complete binary tree. The second diagram shows two examples of binary trees that are not complete. \n", "Example 1\n\nWe see a binary tree with nodes containing the numbers 1, 2, 3, 4, 5, 6, 7, 8 and 9. The tree is not a heap because it is not complete: node 6 is missing a left child. \n", "Example 2\n\nWe see a tree with nodes containing numbers. The root node is a one. Its children are a three and a four. The three has children two and five. The four has children six and nine. The two has children eight and seven. This is not a heap because some children have keys lower than those of the parent. For example, node two has a lower value than its parent, node three. \n", "Example 3\n\nA diagram shows a binary tree labeled heap. The nodes of the tree contain the following values: 1 at the root, 2 and 4 on the second level, 3, 5, 6, and 9 on the third level, and 8 and 7 on the fourth level. \n", "Sequence-based implementation\n\nWe see a binary tree with 7 nodes. The nodes are numbered from 1 to 7. Node 1 is the root node, nodes 2 and 3 are its children, nodes 4 and 5 are children of node 2, and nodes 6 and 7 are children of node 3.\n\nBelow the tree, we see a sequence-based representation of the tree. The sequence contains the numbers from 1 to 7.\n\nThe mapping between the tree and the sequence is defined by the following formulas:\n\n- p(root) = 0\n- p(x.left) = 2 * p(x) + 1\n- p(x.right) = 2 * p(x) + 2\n\nwhere:\n\n- p(x) is the position of node x in the sequence\n- x.left is the left child of node x\n- x.right is the right child of node x\n\nAlternatively, the mapping can be defined by the following formulas:\n\n- p(root) = 1\n- p(x.left) = 2 * p(x)\n- p(x.right) = 2 * p(x) + 1\n", "Insert\n\nWe are given instructions to insert an element with a key of two into a data structure. The data structure is a binary search tree. The tree has a root node with a value of four. The left child of the root node has a value of five. The right child of the root node has a value of six. The left child of the node with value five has a value of fifteen. The right child of the node with value five has a value of nine. The left child of the node with value six has a value of seven. The right child of the node with value six has a value of twenty. The left child of the node with value fifteen has a value of sixteen. The right child of the node with value fifteen has a value of twenty five. The left child of the node with value nine has a value of fourteen. The right child of the node with value nine has a value of twelve. The left child of the node with value seven has a value of eleven. The right child of the node with value seven has a value of eight. \n", "Insert\n\nThe image shows a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5 and the right child has the value 6. The left child of 5 has the value 15 and the right child has the value 9. The left child of 15 has the value 16 and the right child has the value 25. The left child of 9 has the value 14 and the right child has the value 12. The left child of 6 has the value 7 and the right child has the value 20. The left child of 7 has the value 11 and the right child has the value 8. The left child of 20 has the value 2. The node with the value 2 is highlighted in blue. The text \"Insert element with key=\"2\"\" is displayed above the tree. \n", "Insert\n\nThe image contains a red-black tree. The tree is composed of nodes connected by lines. Each node contains a number, called a key. The root node, at the top of the tree, has key=4. Its left and right children have keys 5 and 6, respectively. \n\nThe instruction \"Insert element with key='2'\" is shown above the tree. The key '2' has been inserted into the tree. The node containing the key '2' is colored blue, to indicate that it is the node that has just been inserted. \n", "Insert element with key=\"2\"\n\nThis slide depicts a binary search tree. The tree has a root node with the value 4. The left child of the root node has the value 5, and the right child has the value 2. The left child of the node with value 5 has the value 15, and the right child has the value 9. The left child of the node with value 15 has the value 16, and the right child has the value 25. The left child of the node with value 9 has the value 14, and the right child has the value 12. The left child of the node with value 2 has the value 7, and the right child has the value 6. The left child of the node with value 7 has the value 11, and the right child has the value 8. The left child of the node with value 6 has the value 20. The nodes with values 2, 6, and 20 are highlighted in blue. \n", "Insert\n\nWe see a tree. The text \"Insert element with key=2\" suggests we are about to insert an element with key \"2\" into this tree. The tree has a light blue node with the value \"2\" as its root. The root has two children: a left child, which is a red node with the value \"5\", and a right child, which is a light blue node with the value \"4\". The node with value \"5\" has a left child with value \"15\" and a right child with value \"9\". The node with value \"15\" has a left child with value \"16\" and a right child with value \"25\". The node with value \"9\" has a left child with value \"14\" and a right child with value \"12\". The node with value \"4\" has a left child with value \"7\" and a right child with value \"6\". The node with value \"7\" has a left child with value \"11\" and a right child with value \"8\". The node with value \"6\" has a left child with value \"20\". \n", "Exercise 6\n\nGiven the following binary heap, insert 3, 10, 1: The heap is represented as a tree with nodes containing the numbers 2, 5, 4, 15, 9, 7, 6, 16, 25, 14, 12, 11, 8 and 20. Node 2 is at the root, its children are nodes 5 and 4. Node 5's children are 15 and 9, node 4's children are 7 and 6. Node 15's children are 16 and 25, node 9's children are 14 and 12, node 7's children are 11 and 8 and node 6's child is 20. \n", "Extract element with key=\"4\u201d\n\nWe have a tree data structure. The root node has key equals 4. The left child of the root node has key equals 5, and the right child of the root node has key equals 6. The left child of node 5 has key equals 15, and the right child of node 5 has key equals 9. The left child of node 6 has key equals 7, and the right child of node 6 has key equals 20. The left child of node 15 has key equals 16, and the right child of node 15 has key equals 25. The left child of node 9 has key equals 14, and the right child of node 9 has key equals 12. The left child of node 7 has key equals 11, and the right child of node 7 has key equals 8. \n", "Extract\n\nThe image shows a tree data structure. We are trying to extract the element with key equal to 4. The tree has root 8 and the following children: 5 on the left and 6 on the right. The right subtree, starting at node 6, has a left child 7 and a right child 20. The node with key 4 is not present in the tree, so it's highlighted with a red arrow pointing to an empty space on the right of node 8. \n", "Extract\n\nWe see a binary search tree. The root node has the value five. Its left child has the value eight and its right child has the value six. The objective is to extract the element with key four. \n", "Exercise 7\n\nGiven the following binary heap, extract 15, 5, 7. The heap is structured as follows: at the root, we have a node with value 5, its left child has value 8 and its right child has value 6. The node with value 8 has a left child with value 15 and a right child with value 9. The node with value 15 has a left child with value 16 and a right child with value 25. The node with value 9 has a left child with value 14 and a right child with value 12. The node with value 6 has a left child with value 7 and a right child with value 20. The node with value 7 has a right child with value 11. \n"]}, {"filename": "3. Testing.pdf", "text": "Systems Programming\n\nTesting\n\nDepartamento de Ingenier\u00eda \nTelem\u00e1tica\n\nCONTENTS ARE MOSTLY BASED ON THE WORK BY: \nCarlos Alario Hoyos, Carlos Delgado Kloos, \nM\u00aa Carmen Fern\u00e1ndez Panadero, Julio Villena Rom\u00e1n\n\n1\n\n\fContents\n\n\u2022 Introduction \n\u2022 Types of testing \n\u23bb Unit testing\n\no White-box testing\no Black-box testing\n\u23bb Integration testing\n\u23bb Other types of testing\n\n\u2022 Test plan\n\n2\n\n\fIntroduction\nWhat is testing?\n\n\u2022 Finding the largest number of errors in a \n\nprogram\n\n\u2022 Watch out! It is not convincing oneself that \n\nthe program is correct...\n\n\u2022 Testing is searching for errors on purpose\n\u2022 The aim is to detect errors\n\n3\n\n\fIntroduction\nDebugging\n\n\u2022 Identifying and removing \u201cbugs\u201d on software\n\n\u201cBug\u201d found in a Mark II in Harvard in 1947 and taped to the \u201clog file\u201d\n\n4\n\n\fIntroduction\nThe perfect test in impossible\n\n\u2022 Ideally, we should test the program in all \n\npossible situations\n\n\u2022 Impossible from any point of view:\n\n\u23bb Human\n\u23bb Economic\n\u23bb Mathematic: infinite loops\n\n\u2022 Huge number of combinations\n\u2022 We should test all the possible variations in \n\ninput data \n\n\u2022 We cannot reach perfection but\u2026 we can do \n\nit well enough\n\n5\n\n\fIntroduction\nCriteria for good tests\n\n\u2022 Complete: Covering most of the code.\n\n\u2022 Automated (as far as possible): minimum manual \n\nintervention. Useful for continuous integration.\n\n\u2022 Repeatable or Reusable: Test should be able to \n\nrun more than once. Useful for continuous \nintegration.\n\n\u2022 Independent: Running a test should not affect the \n\nexecution of another test.\n\n\u2022 Professionals: Testing has the same \n\nconsideration as coding, documentation, etc. \n\n6\n\n\fTypes of testing\n\n\u2022 Unit testing\n\n\u2022 White-box testing (structural)\n\n\u23bb Method coverage\n\u23bb Line/Instruction coverage\n\u23bb Branch/Condition/Loop coverage\n\u2022 Black-box testing (functional)\n\n\u23bb Requirement coverage\n\n\u2022 Integration testing\n\u2022 Other types of testing\n\n7\n\n\fUnit Testing\n\n\u2022 Testing isolated modules (methods, classes\u2026)\n\u2022 Informal phase first\n\n\u23bb Running simple examples \n\u23bb Tools that automatically analyze program syntax (and \n\neven \u201csuggest\u201d potential sources of error). \n\n\u2022 Systematic testing phase\n\n\u23bb White-box testing: The structure of the code is tested \n\nthoroughly\n\n\u23bb Black-box testing: The functionality of the module is \n\ntested without looking at the code\n\n\u2022 JUnit 5 (Jupiter) (integrated in Eclipse)\n\n\u23bb Requires Java 8 (1.8) or above\n\no \u201cEclipse\u201d => \u201cPreferences\u201d => \u201cJava\u201d => \u201cCompiler\u201d\no Or \u201cProject\u201d => \u201cProperties\u201d => \u201cJava Compiler\u201d\n\n8\n\n\fUnit Testing. Example with JUnit5\n\nExample Java code to be tested\n\nDifferences in types \n(parameters, return \nvalues, and exception \nhandling\n\n9\n\n\fUnit Testing. Example with JUnit5\n\nCreation of a JUnit Test Case\n\nFile that can run as Java \nApplication without a \nmain method\n\nIt is used to test other \nJava classes / methods\n\n10\n\n\fUnit Testing. Example with JUnit5 (I)\n\nJUnit Test Case\n\nMethod to be tested\n\nResult of the test\n\n11\n\n\fUnit Testing. Example with JUnit5 (II)\n\nMethod to be tested\n\nJUnit Test Case\n\nResult of the test\n\n12\n\n\fUnit Testing. Example with JUnit5 (III)\n\nMethod to be tested\n\nJUnit Test Case\n\nResult of the test\n\n13\n\n\fUnit Testing. Example with JUnit5 (IV)\n\nMethod to be tested\n\nJUnit Test Case\n\nResult of the test\n\n14\n\n\fUnit Testing\nWhite-box testing\n\n\u2022 White-box, glass-box, transparent-box, structural \n\ntesting\u2026\n\n\u2022 Aim: Testing thoroughly the code structure\n\n\u2022 Coverage: measure of the percentage of code that \n\nhas been tested or \u201dcovered\u201d with the tests.\n\n\u23bb Method coverage\n\u23bb Line/Instruction coverage\n\u23bb Branch/Condition/Loop coverage\n\u2022 EclEmma (integrated in Eclipse) \n\n\u23bb Code coverage\n\n15\n\n\fUnit Testing\nWhite-box testing example\n\nProgram\n\nTest class using JUnit 5 (Jupiter)\n\nResult of the test\n- Green: Covered\n- Yellow: Partially covered\n- Red: Not covered\n\n16\n\n\fUnit Testing\nWhite-box testing example\n\n\u2022 Method coverage\n\n\u23bb Testing that all the methods meet their role \n\nand return the expected result\n\n\u23bb Example: Three methods tested plus implicit \n\nconstructor\n\n17\n\n\fUnit Testing\nWhite-box testing example\n\n\u2022 Line/Instruction coverage\n\n\u23bb A line of code can include several instructions \no E.g., f = f*i; (multiplication and assignment) \n\n\u23bb We do not normally pass through all the lines/instructions, \n\nonly through most of them, but choosing wisely. \n\n\u23bb Example: Lines covered (green and yellow) vs. lines not \n\ncovered (red)\n\n18\n\n\fUnit Testing\nWhite-box testing example\n\n\u2022 Branch/condition/loop coverage\n\u23bb Testing all possible paths in branches\n\no Testing every condition (when it is true and false)\no Testing every loop (entering and not entering the loop) \n\n\u2022\n\nfor loop is safer than while and do-while\n\no Testing all possible program exist and decision points \n\n(including exceptions)\n\n\u23bb Example:\n\no max: the else of the first if, and the second if/else are not tested\no fac: the if, and entering / not entering the loop are tested \n\n19\n\n\fUnit Testing\nWhite-box testing example\n\nTest class using JUnit 5 (Jupiter) \n**Calculator.fac(-1); fails as it is expected\n\nResult of the test\nAll covered (100% coverage)\n\n20\n\n\fUnit Testing\nWhite-box testing\n\n\u2022 What to do in real life?\n\n\u23bb Testing 100% of the methods\n\u23bb Approaching 100% of line/instruction coverage \n\u23bb Reaching a good branch/condition/loop coverage\n\u23bb The coverage depends on the type of program:\no Games: enough with 60-80% code coverage\no Critical software (health, nuclear power plants, military, etc.) \n\n>90%\n\no The code coverage required grows with the distribution degree \n\nof the program\n\n\u23bb White-box testing is usually supported by specific tools \n\n(e.g., EclEmma + JUnit)\n\n21\n\n\fUnit Testing\nWhite-box testing\n\n\u2022 Limitations\n\n\u23bb White-box testing checks the structure, but \n\nnot the functionality of the program\n\n\u23bb A program can be correctly structured, but not \nworking according to the functionality that was \nexpected (it does correctly what it does, but it \ndoes not what we wanted) \n\n\u23bb We need to test the functionality with black-box \n\ntesting\n\n22\n\n\fExercise 1A\n\n\u2022 Design a class that conducts a white-box testing over the \nfollowing code, maximizing the code coverage. Use \nassertTrue and assertFalse of class Assert of JUnit \n(instead of assertEquals) to test if a condition is true or \nfalse, respectively\n\npublic class M {\n\npublic static boolean checkPrime(int a){       \n\nif (a<=0){return false;}\nelse {\n\nint tmp = 0;\nfor(int i=2; i<=a/2; i++){\n\ntmp = a%i;\nif(tmp==0){return false;}\n\n}\nreturn true;\n\n}\n}    \n\n}\n\n23\n\n\fExercise 1B\n\n\u2022 Starting from the class Bicycle which has three attributes, \n\nspeed, cadence and gear, of type integer and four \nmethods speedUp(), brake(), setCadence(int \nnewCadence), and setGear(int newGear), plus \nthree \u201cget\u201d methods, implement a test class with JUnit \nBicycleTest, which reaches a code coverage of 100%. \n\u2022 Use @BeforeEach to create the object of the bicycle which \n\nwill be used for testing purposes.\n\n    @BeforeEach\n\n   public void setUp() {\n\n    \u2026\n    }\n\n24\n\n     \n\fUnit Testing\nBlack-box testing\n\n\u2022 Also called:\n\n\u23bb Functional testing\n\u23bb Behavioral testing\n\u23bb Input/output\n\u23bb Data-driven testing\n\n\u2022 Aim: testing the functionality of the code\n\u2022 They try to find cases in which the module \n\ndoes not fulfil its specification\n\n\u2022 Particularly important in modules that will \n\nbe the interface with the end-user\n\n25\n\n\fUnit Testing\nBlack-box testing\n\n\u2022 Requirement coverage: number of requirements \n\nthat were tested\n\n\u2022 The problem: the set of data tends to be very large\n\n\u2022 Solution: \u201cEquivalence classes\u201d\n\n\u23bb Disjoint sets of possible data\n\u23bb Not to be confused with Java \u201cClasses\u201d!!\n\n\u2022 Tricks to identify them:\n\n\u23bb Below, in, and above the range\n\u23bb Below, in, and above a specific value\n\u23bb In and out the set\n\u23bb True or false\n\u23bb The same criteria for output data\n\n26\n\n\fUnit Testing\nBlack-box testing\n\n\u2022 Example: Integer to identify the day of the month\n\n\u23bb Possible values: [1..31]\n\u23bb Three equivalence classes:\n\no Numbers below 1\no Numbers between 1 and 31\no Numbers above 31\n\n\u2022 Pay attention to singular values\n\n\u2022 We choose one value of each class (but not in the \n\nboundaries)\n\n\u2022 And then we test boundary values (1 and 31)\n\n27\n\n\fUnit Testing\nBlack-box testing\n\n\u2022 Limitations:\n\n\u23bb Black-box testing tests the functionality (the \n\nprogram does what we want) but...\n\n\u23bb They do not check if the program does other \nthings as well\u2026 (e.g., a virus, malware\u2026)\n\n\u23bb Black-box testing is not enough\n\n28\n\n\fExercise 2\n\n\u2022 We program a method that calculates the quadrant to which \nan object of class Point, received as argument, belongs. \nThe object of class Point has two attributes of type \ndouble, which indicate the x and y coordinates. Think of \nthe pairs of coordinates (x,y) that the objects of class Point \nshould have in the black-box testing. How many pairs of \ncoordinates must be used at least to test that the functionality \nis correct? \n\n29\n\n\fIntegration testing\n\n\u2022 Several modules (methods, classes) are \n\ninvolved\n\n\u2022 They can be structural or functional\n\n\u23bb Structural: like white-box tests, but analyzing calls \n\nbetween modules \n\n\u23bb Functional: like black-box tests, but checking joint \n\nfunctionalities\n\n\u23bb Equivalence classes and boundary values are \n\nused in the analysis\n\n\u2022 Final tests consider the whole system, fully \n\ncovering the whole specification with the user \nrequirements\n\n30\n\n\fIntegration Testing\nSome design approaches\n\n\u2022 Top-down: the most general modules are tested first \n\n\u23bb Advantage: Think of the whole functionality \n\u23bb Disadvantage: Specific modules are not ready yet \n\u2022 Bottom-up: base modules are tested first\n\u23bb Advantage: No need for building artificial modules\n\u23bb Disadvantage: More focused on the development than in the client\u2019s \n\nexpectations\n\n\u2022 Incremental coding: only the parts of the program \n\nneeded for each functionality are coded; once tested, \nmore functionalities are added\n\n\u23bb Advantage: If there is much interaction with the user\n\u23bb Disadvantage: Complete modules are not ready until the end of the process\n\n31\n\n\fOther types of testing\nSystem testing\n\n\u2022 Functional tests of the whole system, \n\nincluding the software developed and the \nrest of the components interacting with it. \n\n\u2022 Equivalent to black-box testing as no \nknowledge on the code is required. \n\n32\n\n\fOther types of testing\nAcceptance testing\n\n\u2022 Functional tests done by the client before the \n\napplication goes into the production phase\n\n\u2022 There are errors that only the client can detect\u2026 \n\nAnd \u201cthe client is always right\u201d\n\n\u2022 Some techniques:\n\n\u23bb Alpha tests: The client comes to the development \nenvironment, and does the test on a controlled \nenvironment\n\n\u23bb Beta tests: They are done in the client\u2019s environment. \n\nThe client is left alone with the product in an \nuncontrolled environment\n\n\u23bb Both tests are very common when the program is \n\ndelivered to many clients\n\n33\n\n\fOther types of testing\n\n\u2022 Walkthroughs\n\n\u23bb Developers and critics are met in the same room: \n\ncritics read the code line by line and ask for \nexplanations to the developers\n\u23bb Effective for errors of local nature \n\u23bb Terrible to identify errors in interactions between \n\nremote parts\n\u2022 Random testing\n\n\u23bb Because the probability of discovering errors with \nrandom tests is like that of using coverage criteria \n\n\u23bb Reasonable to start testing the program\n\u23bb But insufficient in critical programs\n\n34\n\n\fOther types of testing\n\n\u2022 Robustness testing\n\n\u23bb How does the program react with incorrect input data? \n\u23bb If the data are commands, we should check that:\n\no All the commands are correct\no Commands with syntax errors\no Commands correct but out of place\no The command null\no Commands with more data than expected \no Forcing an interruption after a command\no Commands with inappropriate opening and closing \n\nsymbols\n\no Commands with incoherent opening and closing \n\nsymbols ( ]\n\n35\n\n\fOther types of testing\n\n\u2022 Stress testing\n\n\u23bb Testing  beyond normal capacity for internal reasons\n\u23bb Examples:\n\no Can the program work with the disk at the 90%?\no Does the program work with thousands of concurrent users? \no Can the program work with files larger than 1GB?\n\n36\n\n\fOther types of testing\n\n\u2022 Performance testing\n\n\u23bb Performance of the system (responsiveness and stability) \n\nunder a particular workload, disk or memory load\n\n\u2022 Conformance testing\n\n\u23bb Rules and standards that the program must fulfil \n\u23bb Black-box tests to check that the program follow the \n\nstandards \n\n\u2022 Interoperability testing\n\n\u23bb Look for communication problems between out product \n\nand others it must work with\n\n37\n\n\fOther types of testing\n\n\u2022 Regression testing\n\n\u23bb A new version requires a test round (all the tests!)\n\u23bb In order to reuse tests, they must be very well \n\ndocuments \n\n\u2022 Mutation testing\n\n\u23bb Adding errors to the software on purposes \n\n(creating a \u201cmutant\u201d) to verify the quality of the \ntests\n\n38\n\n\fOther types of testing\n\n\u2022 Smoke testing (or build verification \n\ntesting)\n\n\u23bb Testing the system constantly until it \u201cbreaks\u201d, trying \n\nto catch fire (or \u201csmoke\u201d).\n\n\u23bb \u201cSimple\u201d tests (non-exhaustive), but at all levels, to \nsee the stability of the program and move forward \nwith the development \n\n39\n\n\fAnd more\u2026\n\n\u2022 Grey-box testing\n\u2022 Database testing\n\u2022 Security testing\n\u2022 Documentation testing\n\u2022 Usability testing\n\u2022 Installation testing\n\n\u2022 Fault tolerance testing\n\u2022 Recovery testing\n\n40\n\n\fTest Plan\n\n\u2022 Set of tests to be done\n\u2022 Each test must specify:\n\n\u23bb The properties that are being tested\n\u23bb How to measure the result\n\u23bb What is the test about\n\u23bb What is the expected result\n\n\u2022 \u201cSoft\u201d tests are useless\n\n41\n\n\fTest Plan\n\n\u2022 A case test includes:\n\n\u23bb  The purpose of the test\n\u23bb  The steps to run the test\n\u23bb  The expected result\n\n\u2022 They need to be perfectly documented\n\u2022 This is laborious, tedious, boring and \n\nunpleasant\n\n42\n\n\fTest Plan\n\n\u2022 Order of tests:\n\n\u23bb Black-box tests with boundary values\n\u23bb Identifying equivalence classes for input data \n\nand adding more black-box tests\n\n\u23bb Adding more tests based on presumption of error \n\n\u201cI suspected it!\u201d\n\n\u23bb Measuring the code coverage of white-box \ntesting that was achieved with the previous \nphases and adding more white-box tests\n\n43\n\n\fPsychological and organizational \naspects of testing\u2026\n\n\u2022 Testing is exercising the program to find errors, not to \n\ndemonstrate that it works\n\n\u2022 A test is successful when it finds a bug\n\n\u2022 Tests should be designed and run by a different team that of \n\nwhich wrote the code\n\n\u2022 We shall not wait until the whole code is written to start the tests\n\n\u2022 If tests reveal several errors in a module, we must insist on it\n\n\u2022 If tests reveal many error in a module, we should discard it, and \n\nredesign and program it from scratch\n\n\u2022 Test can find errors, but can never prove that there are not\n\n\u2022 Test can also contain errors\n\n44\n\n\fConclusions\n\n\u2022 Testing is finding errors/bugs in a program\n\u2022 Testing entails an important part of software \n\ndevelopment costs\n\n\u2022 There are tools for testing, but in the end, we \n\nneed people\n\n\u201cTesting shows the presence, not the absence of bugs\u201d, Edsger W. Dijkstra\n\n45\n\n\fPractical case\n\n\u2022 Develop a test plan for the following \n\nmethod:\n\npublic boolean search (char what, char where[])\n\n\u2022 The method returns true if what is in where, \n\nand false otherwise\n\n46\n\n \n\fPractical case\n\n\u2022 Identify equivalence classes:\n\n\u23bb what: poorly specified\n\u23bb where: no information on the dimensions of \n\nthe array or in the ordering criteria\n\n\u23bb What the method returns is clear\n\n\u2022 First of all, we need to clarify these \n\npoints in the specification of the problem\n\n47\n\n\fPractical case\n\n\u2022 New version of the specification:\n\npublic boolean search (char what, char where[])\n\n\u201cThis Java method receives a character \n(char) what and an array of char, where. Any \n8-bit character that can be represented in a \nJava program is valid. The array can have \nbetween 0 and 10,000 characters and must \nbe sorted alphabetically in ascending order. \nAny string of characters is admissible. The \nmethod returns true if what is in where, and \nfalse otherwise.\u201d\n\n48\n\n \n\fPractical case\n\n\u2022 Now we can identify the equivalence classes:\n\n\u23bb what\n\no Any character\n\n\u23bb where\n\no An empty array\no An array between 1 and 10.000 elements, sorted\no An array between 1 and 10.000 elements, unsorted\n\n\u23bb Result\no true\no false\n\n\u2022 We might consider singular combinations of \ninput data (e.g., that the character to look for is \nthe first or the last in the array)\n\n49\n\n\fPractical case\nBlack-box testing\n\n\u2022 Black-box testing: boundary values\n\n1. Look for the character \u2018k\u2019 in the array {} \u00e0 must return false\n\n2. Look for the character \u2018k\u2019 in the array {\u2018k\u2019} \u00e0 must return true\n\n3. Look for the character \u2018k\u2019 in the array {\u2018c\u2019} \u00e0 must return false\n\n4. Look for the character \u2018k\u2019 in the array {\u2018k\u2019,\u2019l\u2019} \u00e0 must return true\n\n5. Look for the character \u2018k\u2019 in the array {\u2018j\u2019,\u2019k\u2019} \u00e0 must return true\n\n6. Look for the character \u2018k\u2019 in the array of 10,000  \u2018a\u2019 \u00e0 must \n\nreturn false\n\n(we do not consider tests related to the order of the array so far)\n\n50\n\n\fPractical case\nBlack-box testing\n\n\u2022 Black-box testing: Regular values\n\n1. Look for the character \u2018k\u2019 in the array {\u2018a\u2019,\u2019b\u2019,\u2019c\u2019} \u00e0 must return false\n\n2. Look for the character \u2018k\u2019 in the array {\u2018j\u2019,\u2019k\u2019,\u2019l\u2019} \u00e0 must return true\n\n51\n\n\fPractical case\nWhite-box testing\n\npublic class Search{ \n  public static boolean search ( char what, char where[] ) {     \n    int a, z, m;\n    a = 0;\n    z = where.length \u2013 1;\n    while ( a <= z ) {\n      m = ( a + z ) / 2;\n      if (where[m] == what )\n        return true;\n      else {\n        if (where[m] < what )\n          a = m + 1;\n        else\n          z = m \u2013 1;\n      }\n    }\n    return false;\n  }\n}\n\nFor white-box \ntesting we need \nto look at the code\n\n52\n\n\fPractical case\nWhite-box testing\n\n\u2022 If we run the aforementioned tests, and we mark the \nlines and branches that we traverse, we will see that \nonly branch \u201celse z = m \u2013 1;\u201d has not been \ntested\n\n\u2022 We need an additional case for white-box testing:\n1. Look for the character \u2018k\u2019 in the array {\u2018l\u2019} \u00e0 must return false\n\n\u2022 Code coverage 100% of lines/instructions and \n\nbranches\n\n53\n\n\fPractical case\n\n\u2022 Formalization of test set (9 tests)\n\nq if (search(\u2018k\u2019, {})) System.out.println(\u201cfails 1.1\u201d);\n\nq if (!search(\u2018k\u2019, {\u2018k\u2019})) System.out.println(\u201cfails 1.2\u201d);\n\nq if (search(\u2018k\u2019, {\u2018c\u2019})) System.out.println(\u201cfails 1.3\u201d);\n\nq if (!search(\u2018k\u2019, {\u2018k\u2019,\u2018l\u2019})) System.out.println(\u201cfails 1.4\u201d);\n\nq if (!search(\u2018k\u2019, {\u2018j\u2019,\u2018k\u2019})) System.out.println(\u201cfails 1.5\u201d);\n\nq if (search(\u2018k\u2019, {\u2018a\u2019,\u2018a\u2019,\u2018a\u2019,\u2018a\u2019})) System.out.println(\u201cfails 1.6\u201d);\n\nq if (search(\u2018k\u2019, {\u2018a\u2019,\u2018b\u2019,\u2018c\u2019})) System.out.println(\u201cfails 2.1\u201d);\n\nq if (!search(\u2018k\u2019, {\u2018j\u2019,\u2018k\u2019,\u2018l\u2019})) System.out.println(\u201cfails 2.2\u201d);\n\nq if (search(\u2018k\u2019, {\u2018l\u2019})) System.out.println(\u201cfails 3.1\u201d);\n\n54\n\n\fPractical case\nJUnit Test Cases\n\n55\n\n\fPractical case\nJUnit Test Cases\n\nAll test pass\n100% coverage\n\n56\n\n\fPractical case\nRobustness testing\n\n\u2022 We could also have robustness tests:\n\n\u23bb What if we go over the 10,000 limit in the array?\n\u23bb What if the array was disordered? \n\n57\n\n\f", "pages_description": ["Introduction\nWhat is testing?\n\n- Finding the largest number of errors in a program\n- Watch out! It is not convincing oneself that the program is correct...\n- Testing is searching for errors **on purpose**\n- The aim is to detect errors \n", "Introduction\nDebugging\n\n- Identifying and removing \"bugs\" on software\n\n\"Bug\" found in a Mark II in Harvard in 1947 and taped to the \"log file\"\nThere is a piece of paper with text and handwritten notes on it. The notes describe chronologically the steps taken to identify a bug in a Mark II computer in Harvard in 1947. The bug was found in relay number 70, panel F. A moth was found trapped in the relay. \n", "Introduction\nThe perfect test in impossible\n\nIdeally, we should test the program in all possible situations.\n\nIt is impossible from any point of view: human, economic, and mathematical, due to infinite loops.\n\nThere is a huge number of combinations.\n\nWe should test all the possible variations in input data.\n\nWe cannot reach perfection, but we can do it well enough.\n", "Introduction\nCriteria for good tests\n\nHere are some criteria for good tests:\n\n- Complete: Covering most of the code.\n- Automated (as far as possible): minimum manual intervention. Useful for continuous integration.\n- Repeatable or Reusable: Test should be able to run more than once. Useful for continuous integration.\n- Independent: Running a test should not affect the execution of another test.\n- Professionals: Testing has the same consideration as coding, documentation, etc.\n", "Types of testing\n\nThis slide presents a list of software testing types.\n\nIt is divided into four main categories: unit testing, integration testing, other types of testing, and a subcategory of unit testing.\n\nThe first category, unit testing, is further divided into two subcategories: white-box testing, also called structural testing, and black-box testing, also called functional testing.\n\nWhite-box testing includes method coverage, line or instruction coverage, and branch, condition, and loop coverage.\n\nBlack-box testing includes requirement coverage. \n", "Unit Testing\n\n- Testing isolated modules, such as methods and classes.\n- It can be done in two phases: informal and systematic.\n- The informal phase involves running simple examples and using tools to analyze program syntax and identify potential errors.\n- The systematic testing phase includes white-box testing, where the structure of the code is thoroughly tested, and black-box testing, where the functionality of the module is tested without looking at the code.\n- JUnit 5 (Jupiter), integrated in Eclipse, can be used for testing and requires Java 8 or above.\n- To configure JUnit 5 in Eclipse, go to \"Preferences\" -> \"Java\" -> \"Compiler\" or \"Project\" -> \"Properties\" -> \"Java Compiler\".\n", "Unit Testing. Example with JUnit5\n\nThe image shows an example of Java code to be tested. The code contains four methods for division: division, division2, division3, and division4. The methods differ in the types of parameters, return values, and exception handling. \n\n- The `division` method takes two integers as input and returns an integer, which is the result of the division. \n\n- The `division2` method takes two integers as input and returns an integer, which is the result of the division. If the divisor is zero, it throws an exception with the message \"Cannot divide by 0\".\n\n- The `division3` method takes two integers as input and returns a double, which is the result of the division. If the divisor is zero, it throws an exception with the message \"Cannot divide by 0\".\n\n- The `division4` method takes two doubles as input and returns a double, which is the result of the division. \n", "Unit Testing. Example with JUnit5\n\nCreation of a JUnit Test Case\n\nThe image shows a screenshot of a computer screen displaying the process of creating a new JUnit test case in a Java IDE. The user has navigated to the \"New\" menu and is selecting the \"JUnit Test Case\" option. The text on the right provides additional information about JUnit test cases, stating that they are files that can run as Java applications without a main method and that they are used to test other Java classes and methods. \n", "Unit Testing. Example with JUnit5 (I)\n\nThe image shows an example of unit testing using JUnit5. \n\nOn the left-hand side, we see the code of a JUnit test case. The test case includes three test methods: `testDivision1_1`, `testDivision1_2`, and `testDivision1_3`. Each test method is annotated with `@Test` and calls a `division` method with different input values. The `assertEquals` method is used to assert that the expected result matches the actual result of the `division` method.\n\nThe `division` method is defined in a separate class and is shown on the right-hand side of the image. The method takes two integer arguments, `x` and `y`, and returns the result of dividing `x` by `y`.\n\nThe test results are shown in a separate window on the right-hand side of the image. The results show that the first test method passed, the second test method failed, and the third test method threw an `ArithmeticException`.\n\nThe second test method failed because the expected result (2.5) did not match the actual result (2). The third test method threw an exception because the `division` method was called with `y` equal to 0, which resulted in a division by zero error.\n", "Unit Testing. Example with JUnit5 (II)\n\nThe image shows an example of unit testing with JUnit5. The code snippet on the right side, enclosed in a box with the title \"Method to be tested,\" presents a Java method named `division2` that takes two integers, `x` and `y`, as input and returns the result of their division. The method includes a condition to handle division by zero by throwing an exception with the message \"Cannot divide by 0\".\n\nOn the left side, there are two JUnit test cases designed to test the `division2` method. The first test case, `testDivision2_1`, aims to verify the normal division functionality. It calls the `division2` method with arguments 4 and 2, expecting the result to be 2. The `assertEquals` assertion is used to compare the expected result with the actual result returned by the method.\n\nThe second test case, `testDivision2_2`, focuses on testing the exception handling mechanism of the `division2` method. It utilizes the `assertThrows` assertion to verify that the method throws an exception of type `Exception` when attempting to divide by zero. The test case then asserts that the exception message is \"Cannot divide by 0\" using the `assertEquals` assertion.\n\nFinally, at the bottom of the image, a box labeled \"Result of the test\" displays the outcomes of running the two test cases. Both tests are marked with green checkmarks, indicating that they passed successfully. The execution time for each test is also provided, with `testDivision2_1` taking 0.002 seconds and `testDivision2_2` taking 0.003 seconds.\n", "Unit Testing. Example with JUnit5 (III)\n\nThe image shows an example of unit testing with JUnit5. The example shows a method called \"division3\" that takes two integers as input and returns a double. The method throws an exception if the second integer is zero. The example also shows two JUnit test cases. The first test case tests the method with valid input and the second test case tests the method with invalid input. The first test case passes and the second test case fails. The result of the test is shown in the bottom right corner of the image. The first test case took 0.001 seconds to run and the second test case took 0.003 seconds to run. The second test case failed because the expected result was 2.0 but the actual result was 2.5. \n", "Unit Testing. Example with JUnit5 (IV)\n\nThe image shows an example of unit testing with JUnit5. The method to be tested is \"division4\", which takes two doubles as input and returns their quotient as a double. Two test cases are shown: \"testDivision4_1\" and \"testDivision4_2\". The first test case asserts that the result of calling \"division4\" with arguments 4.0 and 2.0 is equal to 2.0. The second test case asserts that the result of calling \"division4\" with arguments 5.0 and 2.0 is equal to 2.5. The result of the test shows that both test cases passed with a running time of 0.000 seconds. \n", "Unit Testing\nWhite-box testing\n\nThis slide is about Unit Testing and more specifically about White-box testing.\n\nWhite-box testing is also called glass-box testing, transparent-box testing, or structural testing.\n\nThe aim of White-box testing is to thoroughly test the code structure.\n\nCoverage is a measure of the percentage of code that has been tested or \"covered\" with the tests.\nThere are different types of coverage: Method coverage, Line/Instruction coverage, and Branch/Condition/Loop coverage.\n\nFinally, the slide mentions EclEmma, a tool integrated in Eclipse, that provides Code coverage. \n", "Unit Testing\nWhite-box testing example\n\nWe see an example of unit testing using a white-box testing approach.\n\nOn the left side, we have a code snippet showing a class named \"Calculator\" written in Java. This class contains three static methods:\n- \"add\" which takes two integers as input and returns their sum.\n- \"max\" which takes two integers and returns the larger of the two.\n- \"fac\" which calculates the factorial of an integer. It includes a check for non-negative input and throws an exception if the input is invalid.\n\nOn the right side, we have another code snippet, this time showing a \"CalculatorTest\" class, also written in Java. This class is designed to test the functionality of the \"Calculator\" class using the JUnit 5 framework. \n\nThe \"CalculatorTest\" class includes three test methods:\n- \"testAdd\" which tests the \"add\" method of the Calculator class.\n- \"testMax\" which tests the \"max\" method of the Calculator class.\n- \"testFac\" which tests the \"fac\" method of the Calculator class.\n\nEach test method uses assertions from the JUnit framework to verify that the output of the tested method matches the expected result.\n\nBelow the code snippets, there is a window displaying the test results. It shows that three tests were run, and all of them passed successfully. \n\nFinally, at the bottom of the image, there is a caption that reads: \"Test class using JUnit 5 (Jupiter)\" confirming the testing framework used.\n\nThe image also highlights different parts of the code in green, yellow, and red. This color-coding represents the code coverage achieved by the tests:\n- Green: indicates lines of code that were fully covered and executed during the tests.\n- Yellow: indicates lines of code that were partially covered, meaning some branches or conditions within those lines were not tested.\n- Red: indicates lines of code that were not covered at all by the tests.\n\nIn the context of this example, the color-coding helps visualize how effectively the test cases are exercising the code in the \"Calculator\" class. \n", "Unit Testing\nWhite-box testing example\n\nMethod coverage\n- Testing that all the methods meet their role and return the expected result\n- Example: Three methods tested plus implicit constructor\n\nThe table shows the code coverage achieved for the Calculator.java file. 100% code coverage was achieved as all 4 methods were covered by the tests. The methods are: add, fac, max, and the implicit constructor. \n", "Unit Testing\nWhite-box testing example\n\nLine/Instruction coverage\n\nA line of code can include several instructions for example: f equals f multiply i, in parenthesis multiplication and assignment. We do not normally pass through all the lines or instructions, only through most of them, but choosing wisely. Example: Lines covered, green and yellow, versus lines not covered, red.\n\nThere are two tables. The first table shows line coverage for a Java class named Calculator. The overall coverage is 69.2%. The class has four methods: max, fac, add, and an unnamed constructor. The constructor has 100% coverage, add has 100%, fac has 83.3%, max has 40%, and the unnamed constructor has 69.2%.\n\nThe second table shows instruction coverage for the same Calculator class. The overall instruction coverage is 71.4%. The constructor has 100% coverage, add has 100%, fac has 78.3%, max has 41.7%, and the unnamed constructor has 71.4%.\n", "Unit Testing\nWhite-box testing example\n\nThe slide is about branch, condition, and loop coverage in white-box testing. It lists the following points:\n- Testing all possible paths in branches\n- Testing every condition (when it is true and false)\n- Testing every loop (entering and not entering the loop)\n  - for loop is safer than while and do-while\n- Testing all possible program exit and decision points (including exceptions)\n\nAn example is given with two functions: max and fac.\n- For max: the else of the first if, and the second if/else are not tested\n- For fac: the if, and entering / not entering the loop are tested\n\nA table shows the coverage, covered branches, missed branches, and total branches for each function.\n- Calculator.java has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.\n- Calculator has 50% coverage, 4 covered branches, 4 missed branches, and 8 total branches.\n- max(int, int) has 25% coverage, 1 covered branch, 3 missed branches, and 4 total branches.\n- fac(int) has 75% coverage, 3 covered branches, 1 missed branch, and 4 total branches.\n- add(int, int) has 0% coverage, 0 covered branches, 0 missed branches, and 0 total branches.\n", "Unit Testing\nWhite-box testing example\n\nThe image shows an example of unit testing using JUnit 5 in Java. \n\nOn the left side, there is a code snippet of a test class named \"CalculatorTest2\". This class contains three test methods: \"testAdd\", \"testMax\", and \"testFac\". Each test method is annotated with \"@Test\" and uses assertions from the \"org.junit.Assert\" class to verify the expected behavior of the corresponding methods in the \"Calculator\" class.\n\nThe \"testAdd\" method tests the \"add\" method of the \"Calculator\" class by asserting that the sum of 3 and 2 is equal to 5.\n\nThe \"testMax\" method tests the \"max\" method of the \"Calculator\" class with three different sets of input values (3, 2), (2, 3), and (3, 3), asserting that the returned value is the maximum of the two input values.\n\nThe \"testFac\" method tests the \"fac\" method of the \"Calculator\" class. It first asserts that calling \"fac\" with an input value of 3 returns the expected factorial value of 6. Then, it uses the \"assertThrows\" method to assert that calling \"fac\" with an invalid input value of -1 throws a \"NumberFormatException\". It further verifies that the exception message is \"invalid number\".\n\nOn the right side, there is a code snippet of the \"Calculator\" class being tested. The class contains three static methods: \"add\", \"max\", and \"fac\". \n\nThe \"add\" method takes two integer arguments and returns their sum.\n\nThe \"max\" method takes two integer arguments and returns the maximum value among them.\n\nThe \"fac\" method takes an integer argument and calculates its factorial. It includes a condition to handle invalid input values less than or equal to 0 by throwing a \"NumberFormatException\" with the message \"invalid number\".\n\nAt the bottom of the image, there is a caption that reads: \"Test class using JUnit 5 (Jupiter) **Calculator.fac(-1); fails as it is expected\". This indicates that the test case for the \"fac\" method with an input of -1 is designed to fail, as it is expected to throw an exception.\n\nFinally, there is a statement: \"Result of the test All covered (100% coverage)\". This indicates that all the code in the \"Calculator\" class has been tested, resulting in 100% code coverage.\n", "Unit Testing\nWhite-box testing\n\nWhat to do in real life?\n- Testing 100% of the methods\n- Approaching 100% of line/instruction coverage\n- Reaching a good branch/condition/loop coverage\n- The coverage depends on the type of program:\n  - Games: enough with 60-80% code coverage\n  - Critical software (health, nuclear power plants, military, etc.) >90%\n  - The code coverage required grows with the distribution degree of the program\n- White-box testing is usually supported by specific tools (e.g., EclEmma + JUnit)\n", "Unit Testing\nWhite-box testing\n\nLimitations\n\n- White-box testing checks the **structure**, but not the functionality of the program\n- A program can be correctly structured, but not working according to the functionality that was expected (it does correctly what it does, but it does not what we wanted)\n- We need to test the functionality with black-box testing \n", "Exercise 1A\n\nThe slide presents an exercise about white-box testing. The task is to design a class that conducts a white-box testing over the given code, maximizing the code coverage. The code snippet represents a function called \"checkPrime\" that takes an integer \"a\" as input and returns a boolean value. The function checks if the input integer is a prime number. The instructions specify to use \"assertTrue\" and \"assertFalse\" methods of the \"Assert\" class from JUnit to test if a condition is true or false, respectively, instead of using \"assertEquals\". \n", "Exercise 1B\n\nStarting from the class \"Bicycle\" which has 3 attributes: speed, cadence and gear of type integer, and 4 methods: \"speedUp\", \"brake\", \"setCadence\" which takes an integer \"newCadence\" as input, and \"setGear\" which takes an integer \"newGear\" as input, plus 3 \"get\" methods, implement a test class with JUnit \"BicycleTest\", which reaches a code coverage of 100%. Use \"@BeforeEach\" to create the object of the bicycle which will be used for testing purposes.\n\nThe code snippet shows the \"@BeforeEach\" annotation preceding the definition of the \"setup\" method which is public, void and takes no arguments. \n", "Unit Testing\nBlack-box testing\n\nThis slide is about black-box testing, also known as functional testing, behavioral testing, input/output testing, or data-driven testing. \n\nThe aim of black-box testing is to test the functionality of the code. Testers try to find cases in which the module does not fulfill its specification. Black-box testing is particularly important in modules that will be the interface with the end-user. \n", "Unit Testing\nBlack-box testing\n\nRequirement coverage: number of requirements that were tested. The problem: the set of data tends to be very large. Solution: \"Equivalence classes\". Equivalence classes are disjoint sets of possible data. Note: they are not to be confused with Java \"Classes\". Some tricks to identify them are: below, in, and above the range, below, in, and above a specific value, in and out the set, true or false, and the same criteria for output data. \n", "Unit Testing\nBlack-box testing\n\nThis slide explains the concept of equivalence classes and boundary values in the context of black-box testing.\n\nWe have an example of an integer used to identify the day of the month, with possible values ranging from 1 to 31.\nFrom this, we can define three equivalence classes: numbers below 1, numbers between 1 and 31, and numbers above 31.\n\nThe slide highlights the importance of paying attention to singular values and choosing one value from each equivalence class for testing, avoiding boundary values. \n\nFinally, it emphasizes the need to test boundary values, which are 1 and 31 in this case. \n", "Unit Testing\nBlack-box testing\n\nThis slide is about the limitations of black-box testing.\nBlack-box testing tests the functionality of a program, meaning it checks if the program does what is expected. However, it does not check if the program does other things as well, such as containing a virus or malware. Therefore, black-box testing is not enough to ensure the quality of a program. \n", "Exercise 2\n\nWe are programming a method that, given a point as an argument, calculates the quadrant to which the point belongs. The point is defined by its x and y coordinates, which are double-precision floating-point numbers. The question is: how many pairs of coordinates must be used at least to test that the functionality is correct?\n\nThe image shows a coordinate system with four quadrants. The first quadrant is the upper right quadrant, the second quadrant is the upper left quadrant, the third quadrant is the lower left quadrant, and the fourth quadrant is the lower right quadrant.\n\nTo test the functionality of the method, we need to provide at least one point in each quadrant. This means that we need at least four pairs of coordinates. \n", "Integration testing\n\nSeveral modules, like methods or classes, are involved in integration testing. Integration testing can be structural or functional. Structural testing is like white-box testing, but it analyzes calls between modules. Functional testing is like black-box testing, but it checks joint functionalities. Equivalence classes and boundary values are used in the analysis. Final tests consider the whole system, fully covering the whole specification with the user requirements. \n", "Integration Testing\nSome design approaches\n\nThere are three approaches to integration testing: top-down, bottom-up, and incremental coding.\n\nTop-down testing starts by testing the most general modules first. The advantage of this approach is that it allows you to think of the whole functionality of the system from the beginning. The disadvantage is that specific modules may not be ready yet, which can delay testing.\n\nBottom-up testing starts by testing the base modules first. The advantage of this approach is that there is no need for building artificial modules. The disadvantage is that it can be more focused on the development than in the client's expectations.\n\nIncremental coding is a technique where only the parts of the program needed for each functionality are coded. Once those parts are tested, more functionalities are added. The advantage of this approach is that it allows for a lot of interaction with the user. The disadvantage is that complete modules are not ready until the end of the process.\n", "Other types of testing\nSystem testing\n\n- Functional tests of the whole system, including the software developed and the rest of the components interacting with it.\n- Equivalent to black-box testing as no knowledge on the code is required. \n", "Other types of testing\nAcceptance testing\n\nFunctional tests are done by the client before the application goes into the production phase. There are errors that only the client can detect and the client is always right. Some techniques are: Alpha tests, where the client comes to the development environment and does the test on a controlled environment. Beta tests are done in the client's environment. The client is left alone with the product in an uncontrolled environment. Both tests are very common when the program is delivered to many clients. \n", "Other types of testing\n\n- Walkthroughs: Developers and critics are met in the same room. Critics read the code line by line and ask for explanations to the developers. This method is effective for errors of local nature. However, it is terrible to identify errors in interactions between remote parts.\n- Random testing: Because the probability of discovering errors with random tests is like that of using coverage criteria, it is reasonable to start testing the program. However, it is insufficient in critical programs. \n", "Other types of testing\n\n- Robustness testing\nHow does the program react with incorrect input data? If the data are commands, we should check that: all the commands are correct, commands with syntax errors, commands correct but out of place, the command null, commands with more data than expected, forcing an interruption after a command, commands with inappropriate opening and closing symbols, commands with incoherent opening and closing symbols. \n", "Other types of testing\n\nThis slide lists other types of testing.\n\nStress testing: testing beyond normal capacity for internal reasons. Examples: \n- Can the program work with the disk at the 90%?\n- Does the program work with thousands of concurrent users?\n- Can the program work with files larger than 1GB?\n", "Other types of testing\n\n- Performance testing: measures the performance of the system in terms of responsiveness and stability under a particular workload, disk or memory load.\n- Conformance testing: verifies that the program fulfills the rules and standards using black-box tests.\n- Interoperability testing: looks for communication problems between the product and other systems it must work with. \n", "Other types of testing\n\n- Regression testing\n  - A new version requires a test round (all the tests!)\n  - In order to reuse tests, they must be very well documents\n- Mutation testing\n  - Adding errors to the software on purposes (creating a \"mutant\") to verify the quality of the tests \n", "Other types of testing\n\n- Smoke testing (or build verification testing)\nTesting the system constantly until it \"breaks\", trying to catch fire (or \"smoke\u201d).\n- \"Simple\" tests (non-exhaustive), but at all levels, to see the stability of the program and move forward with the development \n", "And more...\n\n- Grey-box testing\n- Database testing\n- Security testing\n- Documentation testing\n- Usability testing\n- Installation testing\n- Fault tolerance testing\n- Recovery testing \n", "Test Plan\n\n- A test plan is a set of tests to be done.\n- Each test must specify the properties that are being tested, how to measure the result, what the test is about, and what the expected result is.\n- \"Soft\" tests are useless. \n", "Test Plan\n\n- A case test includes the purpose of the test, the steps to run the test and the expected result\n- They need to be perfectly documented\n- This is laborious, tedious, boring and unpleasant \n", "Test Plan\n\nThe order of tests is as follows: First, we perform black-box tests with boundary values. Then, we identify equivalence classes for input data and add more black-box tests. Next, we add more tests based on presumption of error. Finally, we measure the code coverage of white-box testing that was achieved with the previous phases and add more white-box tests. \n", "Psychological and organizational aspects of testing...\n\n- Testing is meant to find errors in a program, not to demonstrate that it works.\n- A test is considered successful when it finds a bug.\n- Tests should be designed and run by a team different from the one that wrote the code.\n- Testing should not wait until all the code is written.\n- If several errors are found in a module, it's crucial to insist on fixing them.\n- If many errors are found in a module, it's best to discard it and start over with the design and programming.\n- While tests can find errors, they can never definitively prove that there are no errors.\n- It's important to remember that tests themselves can also contain errors. \n", "Conclusions\n\n- Testing is finding errors or bugs in a program\n- Testing entails an important part of software development costs\n- There are tools for testing, but in the end, we need people\n\nThere is a quote from Edsger W. Dijkstra that says: \"Testing shows the presence, not the absence of bugs\". \n", "Practical case\n\nWe have to develop a test plan for the following method: public boolean search, that receives as input char what and char array where. The method returns true if what is in where, and false otherwise. \n", "Practical case\n\nWe need to identify equivalence classes. The what is poorly specified. For the where, there is no information on the dimensions of the array or in the ordering criteria. What the method returns is clear. First of all, we need to clarify these points in the specification of the problem. \n", "Practical case\n\nWe are looking at a new version of a specification for a Java method called \"search\". The method takes two arguments: a character called \"what\" and an array of characters called \"where\". The specification states that any 8-bit character that can be represented in a Java program is valid for the \"what\" argument. The \"where\" array can have between 0 and 10,000 characters and must be sorted alphabetically in ascending order. Any string of characters is admissible for the \"where\" argument. The method returns true if the \"what\" character is present in the \"where\" array, and false otherwise. \n", "Practical case\n\nWe can identify the following equivalence classes: \n- What: any character\n- Where: an empty array, an array between 1 and 10,000 elements sorted, an array between 1 and 10,000 elements unsorted\n- Result: true or false\n\nWe might consider singular combinations of input data, for example that the character to look for is the first or the last in the array. \n", "Practical case Black-box testing\n\nThe image shows a slide titled \"Practical case Black-box testing\". The slide focuses on black-box testing with boundary values. It lists six test cases for finding the character 'k' in different arrays.\n\n- The first test case suggests looking for 'k' in an empty array, which should return false.\n- The second test case suggests looking for 'k' in an array containing only 'k', which should return true.\n- The third test case suggests looking for 'k' in an array containing only 'c', which should return false.\n- The fourth test case suggests looking for 'k' in an array containing 'k' and 'l', which should return true.\n- The fifth test case suggests looking for 'k' in an array containing 'j' and 'k', which should return true.\n- The sixth test case suggests looking for 'k' in an array of 10,000 'a's, which should return false.\n\nThe slide concludes by stating that the order of the array is not considered in these test cases. \n", "Practical case\nBlack-box testing\n\nBlack-box testing: Regular values\n\nWe have two test cases. The first one is: look for the character 'k' in the array 'a', 'b', 'c'. This test must return false. \nThe second test case is: look for the character 'k' in the array 'j', 'k', 'l'. This test must return true. \n", "**Practical case White-box testing**\n\nThe image shows a code snippet of a search function in Java. The code is used to illustrate the concept of white-box testing, which requires looking at the code to design test cases. The code implements a binary search algorithm. \nThe function takes two arguments: a character to search for (what) and a character array to search in (where). The function returns true if the character is found in the array, and false otherwise.\nThe code starts by initializing three integer variables: a, z, and m. The variable a is initialized to 0, z is initialized to the length of the array minus 1, and m is initialized to the middle index of the array.\nThe code then enters a while loop that continues as long as the value of a is less than or equal to the value of z. Inside the loop, the code calculates the middle index of the array and stores it in the variable m. The code then checks if the character at the middle index of the array is equal to the character being searched for. If it is, the function returns true.\nIf the character at the middle index of the array is not equal to the character being searched for, the code checks if the character at the middle index is less than the character being searched for. If it is, the value of a is set to the middle index plus 1. Otherwise, the value of z is set to the middle index minus 1.\nThe loop continues until the value of a is greater than the value of z. At this point, the function returns false.\nThe comment on the right side of the image emphasizes that white-box testing requires understanding the internal workings of the code to design effective test cases. \n", "Practical case\nWhite-box testing\n\nWe need an additional case for white-box testing to achieve 100% code coverage of lines, instructions, and branches.\n\nIf we run the aforementioned tests and mark the lines and branches that we traverse, we will see that only the branch \"else z = m - 1;\" has not been tested.\n\nTo address this, we need an additional test case: Look for the character 'k' in the array {'l'}. This test case must return false. \n", "**Formalization of test set (9 tests)**\n\nWe have a list of nine tests for the function \"search\". Each test consists of a call to the function with different inputs and a message that will be printed to the standard output depending on the result of the function.\n\nThe first test checks if the function returns false when the second argument is an empty set. The second test checks if the function returns true when the second argument contains the element we are looking for. The third test checks if the function returns false when the second argument does not contain the element we are looking for. The fourth test checks if the function returns true when the second argument contains the element we are looking for and another element. The fifth test checks if the function returns true when the second argument contains the element we are looking for and two other elements. The sixth test checks if the function returns true when the second argument contains the element we are looking for repeated four times. The seventh test checks if the function returns false when the second argument contains three different elements but not the one we are looking for. The eighth test checks if the function returns true when the second argument contains the element we are looking for and two other elements. The ninth test checks if the function returns true when the second argument contains only the element we are looking for. \n", "**Practical case JUnit Test Cases**\n\nWe see a code snippet showing a JUnit test class named \"SearchTest\". \n\nThe class starts by declaring a variable \"s\" of type \"Search\" and initializing it with a new \"Search\" object.\n\nThe code then defines nine test methods: \"test1\" through \"test9\". Each test method is annotated with \"@Test\" and calls the \"search\" method of the \"Search\" class with different input parameters. The \"search\" method seems to take a character and an array of characters as input.\n\nThe test methods use assertions to verify the expected outcome of the \"search\" method. For example, \"test1\" asserts that the \"search\" method should return false when searching for the character 'k' in an empty array. Similarly, \"test2\" asserts that the \"search\" method should return true when searching for the character 'k' in an array containing only the character 'k'.\n\nThe \"test6\" method creates a large array of characters filled with the character 'a' and asserts that the \"search\" method should return false when searching for the character 'k' in this array.\n\nThe remaining test methods (\"test7\" to \"test9\") continue to test the \"search\" method with different input parameters and assertions to ensure its correctness. \n", "Practical case JUnit Test Cases\n\nThe image shows the code and the result of running some JUnit test cases for that code. The code is a simple search algorithm that takes two arguments: a character to search for and an array of characters to search in. The algorithm returns true if the character is found in the array, and false otherwise.\n\nThe test results show that all nine test cases passed and that the code coverage is 100%. This means that all lines of code in the search algorithm were executed by at least one test case. \n", "**Practical case Robustness testing**\n\nWe could also have robustness tests:\n- What if we go over the 10,000 limit in the array?\n- What if the array was disordered? \n"]}]
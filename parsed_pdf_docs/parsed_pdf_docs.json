[{"filename": "10 en calario-ObjectOrientedProgramming.pdf", "text": "Object-Oriented \nProgramming\n\nCarlos Alario Hoyos & Carlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n\f2\n\nOverview\n\n1. Objects and Classes\n\n2. Object encapsulation\n\n3. Message passing\n\n4. Overloading\n\n5. Constructors\n\n6. Modifiers and access\n\n\f3\n\n1. Objects and Classes\n\n\f4\n\nObjects\n\n\u00b4 Computational representations of(simple/complex) \n\n(real/imagined) things: \n\n\u00b4 Car\n\n\u00b4 Clock \n\n\u00b4 Airplane\n\n\u00b4 Bird\n\n\u00b4 \u2026\n\n\u00b4 Some things are simply characteristics of the objects\n\n\u00b4 Car => color, speed, number of wheels\n\n\u00b4 Objects have concrete values for their characteristics\n\n\u00b4 Car => color (red), speed (90), number of wheels (4)\n\n\f5\n\nObjects and classes\n\n\u00b4 Objects are sets of related data (state) and functionality (behavior)\n\n\u00b4 Classes are blocks of code which include \n\n\u00b4 Attributes (variables used to stored the state of objects of the same type)\n\n\u00b4 Methods (functions used to carry out the behavior of objects of the same type)\n\n\f6\n\nObjects and classes\n\n\u00b4 Creating a new class means creating a new data type:\n\n\u00b4 Primitive data type (not classes): int, boolean, char, double\u2026\n\n\u00b4 Non-primitive data types (classes): String, Integer, Double, Boolean, Car\u2026\n\n\u00b4 Creating a new object from a class is called instantiation\n\n\u00b4 Objects are instances of classes\n\n\u00b4 Classes are the pattern to create objects\n\n\u00b4 Where can I find objects and classes?\n\n\u00b4 Classes are stored in files \u201d.java\u201d (with the same name of the class)\n\n\u00b4 Objects are stored in the memory of our program and only exist in runtime\n\n\f7\n\nObjects: functional and data abstractions\n\nA. Functional abstraction: \n\nB. Data abstraction: \n\n\u00b4 Things the object does (behavior)\n\n\u00b4 Properties of the object (state)\n\n\u00d8 Move forward\n\n\u00d8 Move backwards\n\n\u00d8 Turn left\n\n\u00d8 Turn right\n\n\u00d8 Speed up\n\n\u00d8 Brake\n\n\u00d8 Refuel\n\n\u00d8 \u2026\n\n\u00d8 Color\n\n\u00d8 Brand\n\n\u00d8 Maximum speed\n\n\u00d8 Number of wheels\n\n\u00d8 Number of doors\n\n\u00d8 Fuel\n\n\u00d8 \u2026\n\n\f8\n\nExample\n\nClass\n\nObjects\n\n3 attributes\n\nState\n\n5 methods\n\nConstructor\n\nBehavior\n\n\u2022 new operator to create instances from a class\n\u2022 this reference the the current object\n\u2022 public/private access modifiers\n\n\f9\n\nExercise 1\n\n\u2022\n\nImplement the class Bicycle, which has three attributes,\nspeed, cadence and gear, of type integer and four methods\nspeedUp(), brake(), setCadence(int newCadence), and\nsetGear(int newGear), where the first method doubles the\ncurrent speed, the second method halves the current speed,\nand the third and fourth methods set the cadence and gear\naccording to the arguments received. The class must have a\nconstructor which initializes all the attributes.\n\n\u2022 Create two objects of\n\nthis class: myBicycle and\n\nyourBicycle.\n\n\f10\n\n2. Object encapsulation\n\n1. Objects bundle data and methods together\n\nA. Methods are used to operate on that data\n\n2. Direct access to some parts of the object are restricted\n\nA.\n\nB.\n\nPrivate attributes and methods cannot be accessed directly (information hiding)\n\nPublic methods (public interface) allow accessing private data and methods\n\n\u00b4 We don't need to know the internal implementation of the private part\n\n\u00b4 The private part can change as long as the public interface remains\n\n\f11\n\n2. Object encapsulation\n\n\u00b4 Methods are typically public\n\n\u00b4 Methods for internal use only can be private\n\n\u00b4 Attributes are typically private\n\n\u00b4 It is dangerous to have public attributes\n\n\f12\n\n3. Message passing\n\n\u00b4 An objects sends a message to another object\n\n\u00b4 By calling a method (method call/invocation) of the public interface of the \n\nreceiving object\n\n\u00b4 The receiving object will:\n\n\u00b4 Change its state (modifying its directly attributes)\n\n\u00b4 Call public/private methods of the same object\n\n\u00b4 Send a message to another object\n\n\f13\n\nExample\n\nClass Car\n\nClass Engine\n\nClass Wheel\n\n\f14\n\n4. Overloading\n\n\u00b4 Two methods with the same name can be defined in the same class \n\nif they have different parameters\n\n\u00b4 It is widely used for constructors\n\n\u00b4 The method actually executed depends on the parameters passed \n\nwhen it is called\n\n\f15\n\nExample\n\nClass\n\nObjects\n\nOverload\n\nAlthough they have equal\nthey are different\nnames,\nmethods,\nthey\nreceive different parameters\n\nbecause\n\n\f16\n\nExercise 2\n\n\u2022\n\nIn the class Bicycle,\nthe overloaded\nmethods setCadence(), and setGear(), which do not\nreceive arguments and change the values of cadence\nand gear to one value by default: 1.\n\nimplement\n\n\f17\n\n5. Constructors\n\n\u00b4 When an object is created, its members are initialized using a \n\nconstructor method\n\n\u00b4 Constructors:\n\n\u00b4Have the same name as the class\n\n\u00b4They have no return type (not even void)\n\n\u00b4 At least one constructor should be defined per class\n\n\f18\n\nExample\n\nClass\n\nConstructor\n\n\f19\n\n5. Constructors\n\n\u00b4 Several constructors can exist (overloading)\n\n\u00b4 They are distinguished by their parameters \n\n\u00b4 If no explicit constructor is defined, then there is a default \n\nconstructor without parameters\n\n\u00b4 It initializes the attributes to their default values\n\n\u00b4 If a constructor is defined, the default constructor no longer exits \n\n\f20\n\nExample\n\nOverloaded\nConstructors\n\n\f21\n\nExercise 3\n\n\u2022\n\nIn the class Bicycle,\nimplement an additional\nconstructor, which does not receive arguments, and\nthat initializes the speed to 0, and the cadence and gear\nto 1.\n\n\f22\n\n6. Modifiers and Access: static\n\n\u00b4 Static members exist only once per class\n\n\u00b4 Independently of the number of instances of the class that have been created \n\n\u00b4 Even if no instances have been created yet.\n\n\u00b4 The value of static attributes is shared by all objects\n\n\u00b4 Changing it for one object affects all the others\n\n\u00b4 Static methods do not depend on attributes\n\n\u00b4 Although might depend on input parameters\n\n\u00b4 Static elements can be accessed using the class name\n\n\u00b4 A static method cannot access non-static members directly (an object must be \n\ncreated first)\n\n\f23\n\n6. Modifiers and Access: static\n\nStatic attributes\n\n\u2026\n\nstatic attribute\n\nOther examples\n\n\f24\n\n6. Modifiers and Access: static\n\nStatic method: has access to static attributes.\nWe do not need to create instances\n\nOther examples\n\nhttp://docs.oracle.com/javase/9/docs/api/java/lang/Math.html\n\n\f25\n\n6. Modifiers and Access: static\n\n\u00b4 Static members are invoked with:\n\nClassName.staticMethod();\nClassName.staticAttribute;\n\n\u00b4 Non static members require an instance (object) in order to be accessed.\n\nClassName objectName = new ClassName();\n\n\u00b4 Non static members are invoked with:\nobjectName.normalMethod();\nobjectName.normalAttribute;\n\n\u00b4 When a static member is invoked within the same class, the class name \n\ncan be deleted.\n\nstaticMethod();\nstaticAttribute;\n\ninstead of:\n\nClassName.staticMethod();\nClassName.staticAttribute;\n\n\f26\n\n6. Modifiers and Access: public/private\n\n\u00b4 public\n\n\u00b4 Attributes/Methods/Classes => Visible from any other class\n\n\u00b4 Each public classes needs to be a separate file with the same name of the class\n\n\u00b4 private\n\n\u00b4 Attributes/Methods/Classes => Visible only within the class\n\n\u00b4 Private classes are rarely as inner classes inside a file with another public class\n\n\f27\n\n6. Modifiers and Access: methods get/set\n\n\u00b4 Public methods to control \naccess to private attributes\n\n\u00b4 Can include control mechanisms to \n\navoid undesired modifications\n\nget/set methods\n\n\f28\n\nExercise 4\n\n\u2022\n\nIn the class Bicycle, implement the necessary get()\nand set() methods which allow accessing and\nmodifying all the attributes.\n\n\f", "pages_description": ["Overview\n\nThe slide presents an overview of key concepts, listing six topics: Objects and Classes, Object encapsulation, Message passing, Overloading, Constructors, and Modifiers and access. \n", "1. Objects and Classes\n\nWe have two boxes, the first one is titled \"class\" and contains the drawing of a car with a dotted line and the label \"Car\".\nThe second box is titled \"objects\" and contains three drawings of cars: the first one is green and labeled \"Mercedes\", the second one is blue and labeled \"Bmw\", the third one is orange and labeled \"Audi\". \n", "Objects\n\nComputational representations of simple or complex, real or imagined things. Some examples are: car, clock, airplane, bird, and so on. Some things are simply characteristics of the objects, for example a car has a color, a speed, and a number of wheels. Objects have concrete values for their characteristics. For example, a car might have the color red, a speed of 90, and 4 wheels. \n", "Objects and classes\n\nObjects are sets of related data, called state, and functionality, called behavior. Classes are blocks of code which include attributes and methods. Attributes are variables used to store the state of objects of the same type. Methods are functions used to carry out the behavior of objects of the same type.\n\nThere are two boxes, one labeled \"class\" and the other labeled \"objects.\" The \"class\" box contains the outline of a car with the label \"Car\" inside. The \"objects\" box contains three filled-in cars, one green, one blue, and one orange. The green car is labeled \"Mercedes,\" the blue car is labeled \"Bmw,\" and the orange car is labeled \"Audi.\"\n", "Objects and classes\n\nCreating a new class means creating a new data type. There are two types of data types: primitive data types and non-primitive data types. Primitive data types are not classes and include: int, boolean, char, and double. Non-primitive data types are classes and include: String, Integer, Double, Boolean, and Car. \n\nCreating a new object from a class is called instantiation. Objects are instances of classes. Classes are the pattern to create objects. \n\nClasses are stored in \".java\" files with the same name as the class. Objects are stored in the memory of our program and only exist in runtime. \n", "Objects: functional and data abstractions\n\nWe have two types of abstractions: functional and data abstraction.\nFunctional abstraction refers to the things the object does, its behavior. Examples of behavior are: move forward, move backwards, turn left, turn right, speed up, brake, refuel, and so on.\nData abstraction refers to the properties of the object, its state. Examples of properties are: color, brand, maximum speed, number of wheels, number of doors, fuel, and so on.\nThere is an image of a red sports car at the bottom of the slide. \n", "Example\n\nThe image shows an example of a class and objects in programming.\n\nOn the left side, we have the definition of a class named \"Car\". The class has three private attributes: \"color\" of type String, \"speed\" of type int, and \"size\" of type float. It also has a constructor that takes the color, speed, and size as arguments and initializes the corresponding attributes. Additionally, the class has five public methods: \"advance\", \"stop\", \"turnLeft\", \"turnRight\", which are all empty, indicating they don't have any implementation yet.\n\nOn the right side, we have the \"Objects\" section, which shows how to create instances of the \"Car\" class. Three car objects are created: \"myCar\" with green color, 80 speed, and 3.2 size, \"yourCar\" with red color, 120 speed, and 4.1 size, and \"hisCar\" with yellow color, 100 speed, and 3.4 size.\n\nThe example also highlights three key concepts: the \"new\" operator used to create instances of a class, the \"this\" reference which refers to the current object, and the \"public/private\" access modifiers that control the visibility and accessibility of class members.\n", "Exercise 1\n\nWe need to implement a class named Bicycle. This class will have 3 attributes: speed, cadence, and gear, all of them of type integer.\nThe class will also have 4 methods: speedUp, brake, setCadence, and setGear.\nThe speedUp method doubles the current speed.\nThe brake method halves the current speed.\nThe setCadence method takes an integer called newCadence as an argument and sets the cadence accordingly.\nThe setGear method takes an integer called newGear as an argument and sets the gear accordingly.\nFinally, the class must have a constructor to initialize all the attributes.\n\nThe second part of the exercise asks to create two objects of this class: myBicycle and yourBicycle. \n", "2. Object encapsulation\n\nObjects bundle data and methods together. Methods are used to operate on that data. Direct access to some parts of the object are restricted. Private attributes and methods cannot be accessed directly, this is called information hiding. Public methods, also called public interface, allow accessing private data and methods. We don't need to know the internal implementation of the private part. The private part can change as long as the public interface remains.\n\nA diagram shows an object with public methods, private data and private methods. The public methods interact with an interaction interface. \n", "2. Object encapsulation\n\nMethods are typically public. Methods for internal use only can be private. Attributes are typically private. It is dangerous to have public attributes.\n\nThere is a diagram showing an object and an interaction interface. The object has public methods, private data, and private methods. The public methods interact with the interaction interface. \n", "3. Message passing\n\nAn object sends a message to another object by calling a method of the public interface of the receiving object. The receiving object will: change its state by modifying its attributes directly, call public or private methods of the same object, or send a message to another object.\n\nA diagram shows message passing between two objects. Object A is labeled \"Sending Object\" and Object B is labeled \"Receiving Object\". A curved arrow labeled \"Message\" points from Object A to Object B.\n", "Example Class Car\n\nWe have three classes: Car, Engine and Wheel. The Car class has private String color, int speed, float size, an array of Wheels and Engine as attributes. The Car constructor takes as input all the attributes and sets the object's attributes to the values received as parameters. The Car class has an advance method that calls the injectFuel method on the engine object and then iterates through the wheels array and calls the turn method on each wheel. The main method instantiates an array of wheels and a Car object. The Engine class has private String type and int hp as attributes. The constructor takes the type and hp as parameters and sets the object's attributes. The Engine class also has an injectFuel method. The Wheel class has private double diameter and public String manufacturer as attributes. The Wheel constructor takes the diameter and manufacturer as parameters and sets the object's attributes. The Wheel class also has a turn method. \n", "4. Overloading\n\nTwo methods with the same name can be defined in the same class if they have different parameters. It is widely used for constructors. The method actually executed depends on the parameters passed when it is called.\n\nWe see an example with three methods named \"add\". The first method takes two integers as parameters and returns their sum. The second method takes three integers as parameters and returns their sum. The third method takes four integers as parameters and returns their sum as a float. \n", "Example\n\nWe have a class named Car. The class has private attributes: String color, int speed, float size. The class has a constructor that takes a String, an int and a float as parameters and sets the color, speed and size attributes, respectively. The class also has several public methods: advance, brake, turnLeft, turnRight. The advance method is overloaded. One version takes no parameters, another takes an int representing meters and the last one takes an int representing meters and an int representing speed. \n\nWe also have an example of how to instantiate objects of the class Car. We instantiate three objects: myCar, yourCar and hisCar. Each object is instantiated with a different color, speed and size. We then call the advance method on each object. For myCar, we call the version of advance that takes no parameters. For yourCar, we call the version of advance that takes an int representing meters. For hisCar, we call the version of advance that takes an int representing meters and an int representing speed.\n\nAlthough the methods have the same name, they are different methods, because they receive different parameters.\n", "Exercise 2\n\nIn the class Bicycle, implement the overloaded methods setCadence() and setGear(), which do not receive arguments and change the values of cadence and gear to one value by default: 1. \n", "5. Constructors\n\nWhen an object is created, its members are initialized using a constructor method.\n- Constructors have the same name as the class\n- They have no return type (not even void)\n- At least one constructor should be defined per class\n", "Example\n\nThis code defines a class named \"Car\". The class has three private attributes: \"color\" of type String, \"speed\" of type int, and \"size\" of type float. \n\nThe class has a constructor that takes three arguments: a String for the color, an int for the speed, and a float for the size. The constructor initializes the attributes of the class with the values of the arguments.\n\nThe class also has a main method. The main method creates three instances of the \"Car\" class: \"myCar\" with values \"green\", 80, and 3.2f, \"yourCar\" with values \"red\", 120, and 4.1f, and \"hisCar\" with values \"yellow\", 100, and 3.4f. The part of the code defining the constructor is labeled \"Constructor\".\n", "5. Constructors\n\nSeveral constructors can exist, this is called overloading. They are distinguished by their parameters. If no explicit constructor is defined, then there is a default constructor without parameters. It initializes the attributes to their default values. If a constructor is defined, the default constructor no longer exists. \n", "Example: Overloaded Constructors\n\nWe see an example of a Java class named \"Car\" with overloaded constructors. The class has three private member variables: \"color\" of type String, \"speed\" of type int, and \"size\" of type float. \n\nThe class defines four constructors: \n- a no-argument constructor, \n- a constructor that takes a String argument and initializes the \"color\" member variable, \n- a constructor that takes a String and an int argument and initializes the \"color\" and \"speed\" member variables, and \n- a constructor that takes a String, an int, and a float argument and initializes the \"color\", \"speed\", and \"size\" member variables. \n\nThe class also defines four public methods: \"advance\", \"brake\", \"turnLeft\", and \"turnRight\", all of which take no arguments and have a void return type. \n", "Exercise 3\n\nIn the class \"Bicycle\", implement an additional constructor, which does not receive arguments, and that initializes the speed to 0, and the cadence and gear to 1. \n", "6. Modifiers and Access: static\n\nStatic members exist only once per class, independently of the number of instances of the class that have been created, even if no instances have been created yet. The value of static attributes is shared by all objects, changing it for one object affects all the others. Static methods do not depend on attributes, although they might depend on input parameters. Static elements can be accessed using the class name. A static method cannot access non-static members directly, an object must be created first. \n", "6. Modifiers and Access: static\n\nStatic attributes\n\nThis slide introduces the concept of static attributes in object-oriented programming.\n\nA code snippet shows the declaration of a static attribute within a class named \"Car\". The static attribute is named \"numberOfWheels\" and is assigned a value of 4. The code also includes a main method that prints the value of the static attribute.\n\nThe slide also provides other examples of static attributes, including:\n\n- \"radium\" with a value of 3\n- \"areaCircle\" calculated using the value of \"radium\" and the mathematical constant PI\n- \"minValue\" assigned with the minimum value of the Integer type\n- \"maxValue\" assigned with the maximum value of the Integer type\n", "Modifiers and Access: static\n\nThis slide is about static methods in programming. A static method has access to static attributes and does not require the creation of an instance.\n\nWe see an example of a static method declaration:\n\n```java\npublic static void main(String args[]) {\n  int x1 = Integer.parseInt(args[0]);\n  double y1 = Double.parseDouble(args[1]);\n}\n```\n\nThis code defines the main method, which takes an array of strings as input. Inside the method, two variables, x1 and y1, are declared and initialized by parsing the input arguments as an integer and a double, respectively.\n\nThe slide also provides additional examples of static methods:\n\n- `Math.sqrt(100);`\n- `Math.cos(76);`\n\nThese examples demonstrate how to call static methods from the `Math` class to calculate the square root of 100 and the cosine of 76, respectively.\n\nFinally, a URL is provided, which points to the documentation of the `Math` class in Java 9.\n", "Modifiers and Access: static\n\nStatic members are invoked with: ClassName.staticMethod(); and ClassName.staticAttribute;\n\nNon-static members require an instance (object) in order to be accessed. ClassName objectName = new ClassName();\n\nNon-static members are invoked with: objectName.normalMethod(); and objectName.normalAttribute;\n\nWhen a static member is invoked within the same class, the class name can be deleted. So instead of ClassName.staticMethod(); and ClassName.staticAttribute; we can use: staticMethod(); and staticAttribute;\n", "6. Modifiers and Access: public/private\n\nThis slide explains the concepts of public and private modifiers in programming.\n\n- Public attributes, methods, and classes are visible from any other class. Each public class needs to be in a separate file with the same name as the class.\n\n- Private attributes, methods, and classes are visible only within the class. Private classes are rarely used as inner classes inside a file with another public class.\n\nThe image shows two street signs. The sign pointing to the right says \"Private\" and the sign pointing slightly to the left says \"Public.\" \n", "Modifiers and Access: methods get/set\n\nThis slide explains the concept of getter and setter methods in object-oriented programming.\n\nIt mentions that public methods can be used to control access to private attributes of a class. These methods can include control mechanisms to avoid undesired modifications.\n\nThe slide then introduces the concept of \"get/set methods\" and provides an example of a \"Car\" class with private attributes for \"color\" and \"speed\". The class includes public methods \"getColor\", \"setColor\", \"getSpeed\", and \"setSpeed\" which allow controlled access to the private attributes. \n", "Exercise 4\n\nIn the class bicycle, implement the necessary get() and set() methods which allow accessing and modifying all the attributes. \n"]}, {"filename": "9 en calario-Errors.pdf", "text": "Errors\n\nCarlos Alario Hoyos & Carlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n\f2\n\nOverview\n\n1. Syntax errors\n2. Error correction\nA. Hand tracing\nB. Extra code\nC. Assertions\nD. Eclipse Debugger\n\n\f3\n\n1. Syntax errors\n\n\f4\n\nExamples of basic syntax errors (I)\n\n1. Assignment vs boolean expression\n\nif(x=0){ // if(x==0)\n\nstatement;\n\n}\n\n2. Missing curly brackets {}\n\nif(x==0) //statement 2 is always executed\n\nstatement1;\nstatement2;\n\n3. Missing operators \n\nSystem.out.println(\u201cValue:\u201d x); //+ missing\n\n\f5\n\nThe compiler (sometimes) warns us (I)\n\n1. Line nn: \u201cType mismatch cannot convert from int to boolean\u201d\n\nif(x=0){ // if(x==0)\n\nstatement;\n\n}\n\n2. The compiler does not detect any errors \n\nif(x==0) //statement 2 is always executed\n\nstatement1;\nstatement2;\n\n3. Line nn: \u201cSyntax error on token \u201cx\u201d, delete this token\u201d\n\nSystem.out.println(\u201cValue:\u201d x); //+ missing\n\n\f6\n\nExamples of basic syntax errors (II)\n\n1. Java is a case-sensitive language\n\nint Var=0;\nif(var==0){\n\nstatement;\n\n}\nstring s = \u201cHello\u201d;\n\nBy agreement, variables and methods start with \nlowercase, and classes with capital letters.\n\nPrimitive data types must be written with lowercase\n\n\f7\n\nThe compiler (sometimes) warns us (II)\n\n1. Line nn: \u201cvar cannot be resolved to a variable\u201d\n\nint Var=0;\nif(var==0){\n\nstatement;\n\n}\n\n2. Line nn: \u201cstring cannot be resolved to a type\u201d\n\nstring s = \u201cHello\u201d;\n\n\f8\n\nExamples of syntax errors in methods\n\n1.\n\nLine nn: \u201cThis method must return a result of type boolean\u201d\n\npublic boolean method(){\n\n}\n\n2.\n\nLine nn: \u201cThis method must return a result of type boolean\u201d\n\npublic boolean method(int a){\n\nif (a == 0){\n\nreturn true;\n\n}\n\n}\n\n*A return value must be provided if the condition is not met\n\n\f9\n\nThe compiler in Eclipse\n\n\u00b4 Eclipse compiles automatically as we write (and when we save)\n\n\u00b4 Eclipse provides quick fixes\n\nUse quick fixes\ncarefully!!\n\n\f10\n\nErrors affecting multiple lines\n\n\u00b4 Sometimes we do not get quick fixes \n\n\u00b4 If we are sure a line is correct, an error in another line \n\nmight be affecting the overall structure of the program\n\n\f11\n\nErrors closing curly brackets\n\n\u00b4 A proper code indentation helps\n\n\u00b4 PC:\n\n\u00b4 Mac\n\nClosing curly \nbracket for the \nclass missing\n\n\f12\n\nExercise 1\n\n\u00b4 The following code should calculate the average value of the numbers \n\nentered by the end-user, but it has several syntax errors, fix them!\n\npublic class Exercise1 {\n\npublic static void main(String args) {\n\nScanner sc = new Scanner(System.in);\nSystem.out.print(\"Enter number of element: \");\nint n = sc.nextInt();\ndouble sum = 0;\nfor (i = 0; i < n; i++)\n\nSystem.out.print(\"Enter element \" + (i + 1) + \": \");\nint a = sc.nextInt();\nsum += a;\n\ndouble Average = sum / n;\nSystem.out.println(\"Average value of elements is : \" average);\n\n}\n\n}\n\n\f13\n\nExecution errors (I)\n\n1. The code compiles, but the result is not as expected\n\npublic static void main (String args[]) { \n\nString a = new String(\"Hello\"); \nString b = new String(\"Hello\"); \nif (a == b){ \n\nSystem.out.println(a + \" \" + b + \" are equal\"); \n\n}else{ \n\nSystem.out.println(a + \" \" + b + \" are different\"); \n\n} \n\n}\n\nStrings are compared with equals => a.equals(b)\n\n\f14\n\nExecution errors (II)\n\n2. The code compiles, but the program crashes\n\npublic class Example {\n\npublic static int divide (int a, int b){\n\nreturn a/b;\n\n}\npublic static void main(String[] args){\n\nint result = divide(3,0);\nSystem.out.println(result);\n\n}\n\n}\n\n\f15\n\nExecution errors (III)\n\n2. Use of try-catch block to handle Exceptions\n\npublic class Example {\n\npublic static int divide (int a, int b){\n\nreturn a/b;\n\n}\npublic static void main(String[] args){\n\ntry{\n\nint result = divide(3,0);\nSystem.out.println(result);\n\n} catch (ArithmeticException e){\n\nSystem.err.println(\"You cannot divide a number by zero\");\n\n}\n\n}\n\n}\n\n\f16\n\n2. Error correction\n\n\f17\n\n2.A. Hand tracing (I)\n\n\u00b4 Calculate the values variables take in the program by hand\n\nm \n\n12\n\nn\n\n3\n\nx\n\n12\n\n9\n\n6\n\n3\n\ny\n\n0\n\n1\n\n2\n\n3\n\ny*n + x == m\n\n\f18\n\n2.A. Hand tracing (II)\n\nm \n\n12\n\nn\n\n3\n\nx\n\n12\n\n9\n\n6\n\n3\n\n0\n\ny\n\n0\n\n1\n\n2\n\n3\n\n4\n\ny*n + x == m\n\n\f19\n\nExercise 2\n\n\u00b4 The following \ncode should \ncalculate the \nfactorial of a \nnumber. Try to \ndetect the \nerrors by hand.\n\n\f20\n\n2.B. Extra code\n\n\u00b4 Add extra lines of code to see the values of variables\n\n\f21\n\nExercise 3\n\n\u00b4 The following \ncode should \ncalculate if a \nnumber a is a \nprime number. \nTry to detect \nthe errors \nadding extra \ncode. \n\n\f22\n\n2.C. Assertions\n\n\u00b4 Statements to test assumptions (assert)\n\n1. assert booleanExpression;\n\n2. assert booleanExpression:value;\n\n\u00b4 If the boolean expression is false, an AssertionError is \n\nthrown with the value\n\n\u00b4 Errors, unlike Exceptions, should not be caught\n\n\f23\n\n2.C. Assertions\n\ny*n + x == m\n\n\f24\n\n2.C. Assertions\n\n\u00b4 Assertions are normally \nignored while running \nthe program\n\n\u00b4 We need to configure \nthe JVM with \u201c-ea\u201d \nbefore running the \nprogram\n\n\u00b4 Run configurations => \nArguments => VM \narguments\n\n\f25\n\n2.D. Eclipse Debugger\n\n\u00b4 Running the program step by step tracking \n\nthe values of variables\n1. Set a breakpoint in the line you want the \n\nprogram to stop (double click on the number \nof the line)\n\n2. Run the program with the option \u201cDebug as\u201d \n\n=> \u201cJava application\u201d\n\n3. The new \u201cDebug\u201d view opens\n\n\f26\n\n2.D. Eclipse Debugger\n\nMethods called\n\nVariables\n\nCode\n\nMethods\n\nBreakpoint\n\nConsole\n\n\f27\n\n2.D. Eclipse Debugger\n\n\u00b4 Resume: continues running the program until the \n\nnext breakpoint or the end of the program\n\n\u00b4 Terminate: forces the termination of the program\n\n\u00b4 Step into: executes the next line. If it is a method \n\ncall, goes into the first line of the method\n\n\u00b4 Step over: executes the following line. If it is a \n\nmethod call, executes it completely\n\n\u00b4 Step return: executes the rest of the current \nmethod returning the control to the calling \nmethod\n\n\f28\n\nExercise 4\n\n\u00b4 The following code calculates the greatest divisor of a \n\nrandom number (between 1 and 100). Run it several times \nand try to detect the error using the Eclipse debugger. \n\npublic class Example4 {\n\npublic static void main(String[] args) {\n\nint t = (int) (Math.random() * 100) + 1;\nSystem.out.println(\"The number is: \"+t);\nint result = 1;\nfor(int i =t/2; i>1; i--){\n\nif(t%i==0)\n\nresult = i;\ni = 1;\n\n}\nSystem.out.println(\"The greatest divisor is: \"+result);\n\n}\n\n}\n\n\f29\n\nSummary\n\n\u00b4 Errors will always happen, but we need to try to detect \n\nand correct them\n\n\u00b4 The compiler helps us to detect some syntax errors\n\n\u00b4 Execution errors are critical as they end the program\n\n\u00b4 Hand tracing and adding extra code are not \n\nelegant/efficient solutions\n\n\u00b4 If you have errors use the Eclipse debugger\n\n\f", "pages_description": ["Overview\n\n- Syntax errors\n- Error correction\n    - Hand tracing\n    - Extra code\n    - Assertions\n    - Eclipse Debugger \n", "1. Syntax errors\n\nThe image shows a computer error message that reads \"Syntax error....I think\". There is an \"OK\" button below the message. \n", "Examples of basic syntax errors (1)\n\nThe image shows three examples of basic syntax errors. The first one is an assignment vs. boolean expression error. The code shows an if statement where the condition is (x=0). This is an assignment, not a boolean expression, so it will always evaluate to true. The correct boolean expression should be (x==0). The second example is a missing curly brackets error. The code shows an if statement without curly brackets. This means that only the first statement after the if condition will be executed if the condition is true. The second statement will always be executed. The third example is a missing operators error. The code shows a System.out.println statement that is missing the plus operator (+) between the string \"Value: \" and the variable x. \n", "The compiler (sometimes) warns us (1)\n\nWe have three code snippets, each with a different type of error.\n\nThe first snippet shows an if statement with an assignment instead of a comparison in the condition. The error message indicates a type mismatch, as an integer cannot be converted to a boolean.\n\nThe second snippet shows an if statement with a comment indicating that the second statement is always executed. This implies that the condition in the if statement is always true, making the conditional logic redundant.\n\nThe third snippet shows a print statement with a syntax error. The error message points to the token \"x\" and suggests deleting it. This indicates a missing operator, likely a plus sign, between the string literal and the variable x. \n", "Examples of basic syntax errors (II)\n\nThe first example of a basic syntax error is that Java is a case-sensitive language. For example, we have a code snippet where the variable var is defined with a lowercase v. Then, in the if statement, the same variable is used with an uppercase V. This will cause a syntax error. Another example is that the string data type is written with a lowercase s, while it should be String with an uppercase S. By convention, variables and methods start with lowercase, and classes with capital letters. Also, primitive data types must be written with lowercase. \n", "The compiler (sometimes) warns us (II)\n\nThere are two common compiler warnings listed on this slide. The first is \"Line nn: 'var' cannot be resolved to a variable\". This warning occurs when the variable 'var' is used in the code, but the compiler cannot find a declaration for it. This could be because the variable name was misspelled, or because the variable was not declared in the correct scope. An example of this warning is shown in the code snippet, where the variable 'var' is used in the if statement, but it is declared as 'Var'.\n\nThe second common compiler warning is \"Line nn: 'string' cannot be resolved to a type\". This warning occurs when the 'string' type is used in the code, but the compiler cannot find a definition for it. This could be because the required library was not included in the file, or because the code is being compiled in an environment where the 'string' type is not defined. An example of this warning is shown in the code snippet, where the 'string' type is used to declare the variable 's', but the 'string' type is not defined.\n", "Examples of syntax errors in methods\n\nThere are two code snippets, both showing syntax errors in methods.\n\nThe first snippet shows a method called \"method\" that is declared to return a boolean value. However, the method body is empty, so it does not return any value.\n\nThe second snippet shows a method called \"method\" that takes an integer argument and is declared to return a boolean value. The method body contains an if statement that checks if the argument is equal to 0. If it is, the method returns true. However, if the argument is not equal to 0, the method does not return any value.\n\nThe note at the bottom of the slide explains that a return value must be provided for all possible execution paths of a method that is declared to return a value. \n", "The compiler in Eclipse\n\nEclipse compiles automatically as we write and when we save. Eclipse provides quick fixes. We can see an example of this in the given code. The code contains an error because the variable \"result\" is not declared. When we hover the mouse over the error, Eclipse shows a light bulb icon with several quick fix options. We can choose to create a local variable, a field, or a parameter named \"result\". We can also choose to remove the assignment, change the variable name to \"val1\" or \"val2\", or rename the variable in the file. We should use quick fixes carefully because they may not always produce the desired result. For example, if we choose to create a local variable named \"result\", the code will compile, but it may not work as expected if we intended to use a field or a parameter with the same name. \n", "Errors affecting multiple lines\n\nThis slide shows an example of code with errors on lines 3, 4 and 7. The errors are marked with a red X. The first point states that sometimes we do not get quick fixes for errors. The second point states that if we are sure a line is correct, an error in another line might be affecting the overall structure of the program. \n", "Errors closing curly brackets\n\nThe slide shows two code snippets, both containing syntax errors. The slide explains that proper code indentation helps identify these errors. The first code snippet is missing a closing curly bracket for the class definition. The second code snippet has been corrected by adding the missing curly bracket. The slide also provides keyboard shortcuts for indenting code on both PC and Mac. On a PC, the shortcut is Ctrl+Shift+F, while on a Mac, it is Cmd+Shift+F. \n", "Exercise 1\n\nThe image shows an exercise about fixing syntax errors in a Java code snippet. The code is intended to calculate the average of numbers entered by the user. The code first declares a class named \"Exercise1\" and a main method. Inside the main method, it initializes a Scanner object to read user input. It then prompts the user to enter the number of elements and stores it in the variable \"n\". A for loop is used to iterate \"n\" times, prompting the user to enter each element and calculating the sum of all entered elements. Finally, the average is calculated by dividing the sum by \"n\" and the result is printed to the console. However, the provided code snippet contains syntax errors that need to be fixed. \n", "Execution errors (1)\n\nThe code compiles, but the result is not as expected. We have a snippet of Java code that declares two strings, a and b, both initialized with the value \"Hello\". Inside an if-else block, it checks if a is equal to b using the \"==\" operator. If true, it prints \"a and b are equal\", otherwise it prints \"a and b are different\". The code highlights that strings are compared with the \"equals\" method, implying that using \"==\" might lead to unexpected results. \n", "Execution errors (II)\n\nThe code compiles, but the program crashes.\nThe code defines a class named \"Example\" with two methods: \"divide\" and \"main\".\nThe \"divide\" method takes two integers as input, divides the first by the second and returns the result.\nThe \"main\" method calls the \"divide\" method with 3 and 0 as arguments, stores the result in a variable named \"result\" and prints it to the console.\nThe program throws an ArithmeticException because it is trying to divide by zero.\nThe exception message indicates that the error occurred in the \"divide\" method at line 3 and in the \"main\" method at line 6. \n", "Execution errors (III)\n\nThe slide shows a code snippet with a try-catch block to handle exceptions. The code defines a class named \"Example\" with two methods: \"divide\" and \"main\". The \"divide\" method takes two integers as input and returns their quotient. The \"main\" method calls the \"divide\" method with arguments 3 and 0. Since dividing by zero is not allowed, an ArithmeticException is thrown. The try block encloses the code that might throw an exception. The catch block catches the ArithmeticException and prints an error message to the console. The output of the code is \"You cannot divide a number by zero\". \n", "2. Error correction\n\nThe image shows the word \"Error\" written on lined paper. A red eraser at the end of a red pencil is erasing part of the word. \n", "2.A. Hand tracing (1)\n\nThe slide describes how to hand-trace a Java program that calculates integer division.\n\nThe program defines a class named \"Example\" with two methods: \"intDiv\" and \"main\".\n\nThe \"intDiv\" method takes two integers, \"m\" and \"n\", as input and returns the integer quotient of \"m\" divided by \"n\". It first checks if \"n\" is not equal to 0. If it is, it throws an exception. Otherwise, it initializes two integer variables, \"x\" to \"m\" and \"y\" to 0. It then enters a while loop that continues as long as \"x\" is greater than \"n\". Inside the loop, it subtracts \"n\" from \"x\" and increments \"y\" by 1. Once the loop terminates, it returns the value of \"y\".\n\nThe \"main\" method is the entry point of the program. It first declares an integer variable \"i\" and initializes it by calling the \"intDiv\" method with arguments 12 and 3. It then prints the value of \"i\" to the console. If an exception is thrown by the \"intDiv\" method, it catches the exception and prints an error message to the console.\n\nThe slide also includes a table that shows the values of the variables \"m\", \"n\", \"x\", and \"y\" at each iteration of the while loop in the \"intDiv\" method when called with arguments 12 and 3. The table shows that the loop iterates 4 times, and at the end of the loop, the value of \"y\" is 3, which is the correct quotient of 12 divided by 3. The value of \"x\" is 3, which is the remainder of the division.\n\nThe equation \"y*n + x == m\" at the bottom of the slide represents the relationship between the dividend (\"m\"), the divisor (\"n\"), the quotient (\"y\"), and the remainder (\"x\") in integer division.\n", "2.A. Hand tracing (II)\n\nWe have a java program that calculates the integer division of two numbers. The program first checks if the divisor is not zero. If it is, it throws an exception. Otherwise, it initializes two variables, x and y, to the dividend and zero, respectively. Then, it enters a while loop that continues as long as x is greater than or equal to the divisor. Inside the loop, it subtracts the divisor from x and increments y by one. Finally, it returns the value of y.\n\nOn the right side of the image, we have a table that shows the values of the variables m, n, x, and y at each iteration of the loop. The first row of the table shows the initial values of the variables. The second row shows the values of the variables after the first iteration of the loop. The third row shows the values of the variables after the second iteration of the loop, and so on. The last row of the table shows the values of the variables after the loop has finished executing.\n\nThe equation at the bottom of the image shows the relationship between the variables m, n, x, and y. The equation states that the product of y and n plus x is equal to m. This equation is true because y represents the quotient of the division of m by n, and x represents the remainder of the division. \n", "Exercise 2\n\nWe have a Java program that calculates the factorial of a number. The 'fac' function takes an integer 'a' as input. If 'a' is greater than 0, it calculates the factorial using a for loop and returns the result. If 'a' is not greater than 0, it throws an exception. In the 'main' function, the program calls the 'fac' function with the argument 12, prints the result to the console, and catches any exceptions that may occur. If an exception is caught, it prints an error message to the standard error stream. \n", "Extra code\n\nThe code snippet shows a Java program with a class named \"Example\". The program defines a method called \"intDiv\" that takes two integers, \"m\" and \"n\", as input and returns an integer. The method calculates the integer division of \"m\" by \"n\".\n\nInside the \"intDiv\" method:\n- It first checks if \"n\" is not equal to zero. \n- If \"n\" is not zero, it initializes two integer variables, \"x\" with the value of \"m\" and \"v\" with the value of 0.\n- It then enters a while loop that continues as long as \"x\" is greater than \"n\".\n- Inside the loop, it calculates the difference between \"x\" and \"n\" and assigns the result back to \"x\". It also increments the value of \"v\" by 1.\n- After the loop completes, it returns the value of \"v\".\n\nThe code also includes a \"main\" method that demonstrates the usage of the \"intDiv\" method. \n- It calls the \"intDiv\" method with the arguments 12 and 3. \n- It then prints the returned value.\n\nAdditionally, the code includes a try-catch block to handle the exception that would occur if \"n\" is zero. If an exception is caught, it prints an error message \"You cannot divide by zero\".\n", "Exercise 3\n\nThe code defines a function called \"checkPrime\" that takes an integer as input and returns a boolean value. The function is designed to determine if the input integer is a prime number. The main function then calls the \"checkPrime\" function with the numbers 0, 1, 4, 6, and 11 as input and prints the results to the console. The output of the code shows that the \"checkPrime\" function incorrectly identifies the number 4 as a prime number. \n", "2.C. Assertions\n\n- Statements to test assumptions, using the keyword \"assert\".\n- There are two ways to use it:\n 1. \"assert\" followed by a boolean expression\n 2. \"assert\" followed by a boolean expression, then \":\" and a value\n- If the boolean expression is false, an AssertionError is thrown with the value.\n- Errors, unlike Exceptions, should not be caught.\n", "2.C. Assertions\n\nWe have a java code with a class named \"Example underscore\". This class has two methods: \"intDiv\" and \"main\".\n\nThe \"intDiv\" method takes two integers, m and n, as input and returns an integer. \n- It first checks if n is not equal to zero. \n- If n is not zero, it initializes two integer variables, x and y, with m and zero respectively. \n- Then, it enters a while loop that continues as long as x is greater than n. \n- Inside the loop, it subtracts n from x and increments y by one. \n- After the loop, it asserts that y multiplied by n plus x is equal to m. \n- Then, it asserts that x is less than n. \n- Finally, it returns the value of y. \n- If n is zero, the method throws an exception.\n\nThe \"main\" method is the entry point of the program. \n- It first tries to call the \"intDiv\" method with the arguments 12 and 3 and prints the returned value. \n- If an exception is caught, it prints an error message to the console.\n\nWhen we run this code, an error occurs: an AssertionError exception is thrown. The error message indicates that the assertion \"y * n + x == m\" failed at line 11 of the Example_.java file and that the assertion at line 19 of the same file also failed. \n", "2.C. Assertions\n\nAssertions are normally ignored while running the program. We need to configure the JVM with \"-ea\" before running the program. Run configurations, arguments, then VM arguments. In the VM arguments field, we have \"-ea\". \n", "2.D. Eclipse Debugger\n\nThis slide explains how to use the Eclipse debugger. The debugger allows you to run a program step by step and track the values of variables. To use the debugger, you first need to set a breakpoint in the line of code where you want the program to stop. You can do this by double-clicking on the number of the line in the editor. Once you have set a breakpoint, you can run the program in debug mode by selecting \"Debug As\" > \"Java Application\" from the Run menu. When the program reaches the breakpoint, it will stop and you will be able to step through the code line by line. The new \"Debug\" view will open, showing the current state of the program. \n", "2.D. Eclipse Debugger\n\nWe are looking at a screen capture of the Eclipse IDE. The code is paused at a breakpoint at line 6, inside the \"intDiv\" method of the \"Example\" class. The method takes two integers, m and n, as input and is supposed to return the result of the integer division of m by n.\n\nThe \"Variables\" pane shows the current values of the local variables: m is 12, n is 3, x is 12, and y is 0.\n\nThe \"Methods\" pane shows the call stack: the \"intDiv\" method was called from the \"main\" method.\n\nThe \"Code\" pane shows the source code of the \"Example\" class. The breakpoint is set on the line \"while (x > n)\".\n\nThe \"Console\" pane is at the bottom of the screen.\n", "2.D. Eclipse Debugger\n\nThis slide describes the debugger functions in Eclipse. The functions are Resume, Terminate, Step into, Step over, and Step return. Resume continues running the program until the next breakpoint or the end of the program. Terminate forces the termination of the program. Step into executes the next line. If it is a method call, it goes into the first line of the method. Step over executes the following line. If it is a method call, it executes it completely. Step return executes the rest of the current method returning the control to the calling method. Each function is shown with an icon representing its action. \n", "Exercise 4\n\nThe following code calculates the greatest divisor of a random number between 1 and 100. Run it several times and try to detect the error using the Eclipse debugger. \n\nThe code is as follows: \n\n```java\npublic class Example4 {\n  public static void main(String[] args) {\n    int t = (int) (Math.random() * 100) + 1;\n    System.out.println(\"The number is: \" + t);\n    int result = 1;\n    for (int i = t / 2; i > 1; i--) {\n      if (t % i == 0) {\n        result = i;\n        i = 1;\n      }\n    }\n    System.out.println(\"The greatest divisor is: \" + result);\n  }\n}\n```\n", "Summary\n\nErrors will always happen, but we need to try to detect and correct them. The compiler helps us to detect some syntax errors. Execution errors are critical as they end the program. Hand tracing and adding extra code are not elegant/efficient solutions. If you have errors use the Eclipse debugger. \n"]}, {"filename": "5 en.pdf", "text": "5. Functional Abstraction\n\nCarlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n\fMethods, Scope\n\nCarlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n\f3\n\nFrom the Calculator to the Computer\n\nValues\n\nExpressions\n\nStatements\n\nx=x\u00d712;\n\n3\n\nx\n\nset\n\nget\n\n\f4\n\nd =    0;\n\nC ;\n\n9\n8\n7\n6\n5\n4\n1 2 3\n\n\u2044\n*\n\u2212\n. +\n\n0\n\nf\n\n\f5\n\nMethod Definition\n\nsquare: int gint\nsquare(x) = x*x\n\nint\n\nx\nsquare\nsquare\nx*x\n\nint\n\nint square (int x)\n\n{\n\n}\n\nreturn x*x;\n\n\f6\n\nMethod Definition\n\nResult type\n\nParameter type\n\nMethod name\n\nParameter\n\nint square (int x)\n\nreturn x*x;\n\nMethod\nheader\n\n{\n\n}\n\nMethod body\n\nint\n\nx\nsquare\nx*x\n\nint\n\n\f7\n\nMethod Name\n\n\u00b4Recommendations\n\n\u00b4Initial small letter\n\u00b4Verb: move\n\u00b4Phrase: isEmpty\n\n\u00b4For understanding purposes,\nit should have a meaning\n\n\f8\n\nParameter Names\n\nThis method gets an integer, which we will call x,\nand will return an integer by multiplying x*x\nLet's call this method square.\n\nint\n\nint square (int x)\n\n{\n\n}\n\nreturn x*x;\n\nx\nsquare\nx*x\n\nint\n\n\f9\n\nConsistent Substitution\n\nThis method gets an integer, which we will call y,\nand will return an integer by multiplying y*y\nLet's call this method square.\n\nint\n\nint square (int y)\n\n{\n\n}\n\nreturn y*y;\n\ny\nsquare\ny*y\n\nint\n\n\f10\n\nParameter: Placeholder\n\nThis method gets an integer and\nwill return an integer by multiplying it by itself.\nLet's call this method square.\n\nint\n\nint square (int c)\n\n{\n\n}\n\nreturn c*c;\n\nc\nsquare\nc*c\n\nint\n\n\f11\n\nOne Parameter\n\nsquare: int gint\nsquare(x) = x*x\n\nint\n\nx\nsquare\nsquare\nx*x\n\nint\n\nint square (int x)\n\n{\n\n}\n\nreturn x*x;\n\n\f12\n\nExercise 1\n\n\u00b4 Create a new Java class that\n\n\u00b4 Contains the method int square (int x), which \n\nreturns the square of the parameter received.  \n\n\u00b4 Contains a main method that calls the method square\n\n(in order to call the method square add public \nstatic in its signature) and prints the result on screen\n\n\u00b4 The value for which the square is calculated will be an \ninput argument to the program. Collect this argument \nin the main method in args and transform it to an int\nwith Integer.parseInt() \n\n\f13\n\nMore Parameters\n\nint\n\nint\n\naverage\n\nint\n\nint mult(int x, int y)\n{\n\nreturn x*y;\n\n}\n\n\f14\n\nExercise 2\n\n\u00b4 Create a new Java class that\n\n\u00b4 Contains the method double average(double x, \n\ndouble y), which returns the average of the two \nparameters received.  \n\n\u00b4 Contains a main method that calls the method average\n\nand prints the result on screen\n\n\u00b4 The values for which the average is calculated will be \n\ninput arguments to the program. Collect these \narguments in the main method in args and transform \nthem to double with Double.parseDouble() \n\n\f15\n\nNo Parameters\n\nsayHello\n\nString\n\nString sayHello()\n{\n\nreturn \"Hello!\";\n\n}\n\n\f16\n\nNo Result\n\ndouble\n\nprintInverse\n\nvoid printOpposite(double x)\n{\n\nSystem.out.println(-x);\n\n}\n\n\f17\n\nNo Parameters, No Result\n\nprintHello\n\nvoid printHello()\n{\n\nSystem.out.println(\"Hello!\");\n\n}\n\n\f18\n\nMethod Definition\n\nsquare: int gint\nsquare(x) = x*x\n\nint\n\nx\nsquare\nsquare\nx*x\n\nint\n\nint square (int x)\n\n{\n\n}\n\nreturn x*x;\n\n\f19\n\nOutside / Inside\n\nOutside\n\nInside\n\nint square (int )\nint square (int x)\n\n{\n\n}\n\nreturn x*x;\n\nint\n\nx\nsquare\nsquare\nx*x\n\nint\n\n\f20\n\nOutside / Inside\n\nOutside\n\nInside\n\nint square (int )\nint square (int x)\n\n{\n\n}\n\nreturn 1+(x+1)*(x-1);\n\nint\n\nx\nsquare\nsquare\nx*x\n\nint\n\n\f21\n\nMethod Call\n\n9\n\n16\n\ny=square(3)+square(4);\n\nUse\n\nDefinition\n\n4\n3\n\nint square (int x)\n\n{\n\n}\n\nreturn x*x;\n\n16\n9\n\nint\n\n3\n4\n\nx\nsquare\nsquare\nx*x\n\nint\n\n16\n9\n\n\f22\n\nScope\n\n\u00b4 What happens if I use an identifier used in a method body,\n\nalso outside of the method?\n\nx\n\nMethod\n\nx\n\n\f23\n\nExample 1\n\nint x=1;\n\nint f(int x)\n\n{\n\n}\n\nreturn x+x;\n\nint z=f(x+1);\n\nx\n1\nx\n2\n\nz\n4\n\n\f24\n\nExample 1\n\nint x=1;\nint f(int c)\n\n{\n\n}\n\nreturn c+c;\n\nint z=f(x+1);\n\n\f25\n\nExample 2\n\nint x=1;\n\nint f(int x)\n\n{\n\n}\n\nreturn x+x;\n\nint z=f(f(x+1));\n\nx\n1\nx\nx\n2\n4\n\nz\n8\n\n\f26\n\nExample 3\n\nint x=1;\n\nint f(int y)\n\n{\n\n}\n\nreturn x+y;\n\nint z=f(x+1);\n\nx\n1\n\ny\n2\n\nz\n3\n\n\f27\n\nExample 4\n\nint x=1;\n\nint f()\n\n{\n\n}\n\nint y=2;\n\nreturn x+y;\n\nint z=f();\n\nx\n1\n\ny\n2\n\nz\n3\n\n\f28\n\nExample 5\n\nint x=1;\n\nint f()\n\n{\n\n}\n\nint x=2;\n\nreturn x+x;\n\nint z=f();\n\nx\n1\n\nx\n2\n\nz\n4\n\n\f29\n\nExample 6\n\nx only exists in for loop\n\nint y=0;\n\nfor (int x=1; x<3; x++)\n\n{\n\n}\n\ny=y+x;\n\nint z=y;\n\ny\n0\n\n1\n3\n\nx\n1\n2\n\nz\n3\n\n\f30\n\nExample 7\n\nint x=1;\n\nint y=0;\n\nname conflict with x\n\nfor (int x=1; x<3; x++)\n\n{\n\n}\n\ny=y+x;\n\nint z=y;\n\n\f31\n\nExample 8\n\nint x=1;\n\nint y=0;\n\nx also exists\nout of for loop\n\nfor (x=1; x<3; x++)\n\n{\n\n}\n\ny=y+x;\n\nint z=y+x;\n\nx\n1\n\n1\n2\n3\n\ny\n0\n\n1\n3\n\nz\n6\n\n\f32\n\nExample 9\n\nint x=1;\n\nint f()\n\n{\n\n}\n\nreturn x;\n\nint z=f();\n\nx\n1\n\nz\n1\n\n\f33\n\nExample 10\n\nint x=1;\n\nint f()\n\n{\n\n}\n\nreturn x;\n\nint g()\n\n{\n\n}\n\nint x=0;\n\nreturn f();\n\nint z=g();\n\nx\n1\n\nx\n0\n\nz\n1\n\n\f34\n\nExample 11\n\nint f()\n\n{\n\n}\n\nreturn x;\n\nint g()\n\n{\n\n}\n\nint x=0;\n\nreturn f();\n\nint z=g();\n\n\f35\n\nEnvironment\n\nx\n1\nx\n2\n\nf\n(x)->x+x\n\nint x=1;\n\nint f(int x)\n\n{\n\n}\n\nreturn x+x;\n\nint z=f(x+1);\n\n\f36\n\nTo Remember\n\n\u00b4 A variable is valid in a scope\n\n(from its declaration to the end of the block)\nbut can be temporarily hidden\nby another variable with the same name\n\n\u00b4 However, arrays are passed by reference\n\n\u00b4 If there are free variables in a method definition,\nthey are bound at its definition, not at its call\n\n\f37\n\nExercise 3\n\n\u00b4 Program a method that receives three int and \nreturns the squares of each of these three int \n\n\u00b4 Think of different implementations, with and without the \nuse of arrays and take into account the scope for each \nof these cases\n\n\f38\n\nExercise 4\n\n\u00b4 Program the method power, which calculates the \npower of a number given the base and a non-\nnegative exponent as parameters.\n\n\u00b4 Program a method that calculates the area of a \nsphere given its radius and another method that \ncalculates the volume of a sphere given its radius. \nThese methods use the method power.\n\n\u00b4 Program a main method to test your program\n\nV = (4/3)\u03c0r3\n\nA = 4\u03c0r2\n\n\f39\n\n\f", "pages_description": ["Methods, Scope\n\nWe see two sets X and Y. Set X contains the elements 1, 2, and 3. Set Y contains the elements a, b, c, and d. There are arrows pointing from element 1 in set X to element d in set Y, from element 2 in set X to element d in set Y, and from element 3 in set X to element c in set Y. The name Carlos Delgado Kloos is displayed below the diagram, followed by the name Universidad Carlos III de Madrid on the next line. \n", "From the Calculator to the Computer\n\nThe image shows the evolution from a calculator to a computer. It presents three devices: a calculator displaying the value \"36\", a calculator displaying the expression \"3 x 12\", and a calculator displaying the statement \"x = x x 12;\". Each device has buttons labeled \"C\" and \";\". The third device also has buttons labeled \"3\", \"x\", \"set\", and \"get\". \n", "The image shows a calculator with a display at the top and a keypad at the bottom. The display shows \"d = 0\" on the first line and \"C :\" on the second line. The keypad has keys for digits 0 to 9, arithmetic operators such as plus, minus, multiplication, division, and a special key labeled \"f\". \n", "Method Definition\n\nWe see the definition of a method named \"square\". The method takes an integer as input and returns an integer as output. The method calculates the square of the input integer and returns the result. There is a diagram showing the input and output of the method. The input is an integer and it goes into a box labeled \"square\". The output of the box is also an integer. To the right of the box, we see the code implementation of the method in c-like language. \n", "Method Definition\n\nThe image describes the definition of a method. \n\nThe method header is composed of the result type, the method name, and the parameter type. In this example, the result type is \"int\", the method name is \"square\", and the parameter type is \"int x\".\n\nThe method body is composed of the code that will be executed when the method is called. In this example, the method body contains a single line of code that returns the square of the parameter \"x\".\n\nThe diagram shows how the different parts of the method definition are related. The result type is shown at the top, followed by the method name and the parameter type. The method body is shown at the bottom.\n\nThe arrows in the diagram show how the different parts of the method definition are related. The arrow from the result type to the method name indicates that the result type specifies the type of value that will be returned by the method. The arrow from the parameter type to the method name indicates that the parameter type specifies the type of value that will be passed to the method when it is called. The arrow from the method name to the method body indicates that the method body contains the code that will be executed when the method is called.\n", "Method Name\n\n- Recommendations for method names:\n    - Initial small letter\n    - Verb: move\n    - Phrase: isEmpty\n    - For understanding purposes, it should have a meaning \n", "Parameter Names\n\nThis slide explains how to name parameters in a method. It uses the example of a method called \"square\" that takes an integer as input and returns its square. The input integer is named \"x\" within the method. The slide shows a diagram with two boxes, one representing the method call and the other representing the method definition. The diagram illustrates how the value of \"x\" is passed from the method call to the method definition, and how the result of \"x*x\" is returned back. \n", "Consistent Substitution\n\nThis method gets an integer, which we will call Y, and will return an integer by multiplying Y*Y. Let's call this method square. There is a blue arrow pointing from the word \"square\" to the word \"int\" above a blue box. Inside the box are a red arrow pointing to the letter \"Y,\" the word \"square,\" and another red arrow pointing to \"Y*Y.\" There is also a red arrow pointing from \"Y*Y\" to the word \"int\" below the box.  There is a blue arrow pointing from \"(int Y)\" to the word \"int\" above the box. \n", "Parameter: Placeholder\n\nThis slide explains the concept of a parameter as a placeholder in programming. It describes a method called \"square\" that takes an integer as input and returns its square. The input integer is represented by a placeholder within the method definition. The slide visually illustrates how the placeholder is replaced with the actual integer value when the method is called. It emphasizes that the parameter acts as a container for the value passed to the method. \n", "One Parameter\n\nThe image describes a function named \"square\" that takes an integer as input and returns an integer as output. The function is defined as `square(x) = x*x`.\n\nThere is a diagram illustrating the function. The diagram shows an input arrow labeled \"int\" pointing to a blue rectangle labeled \"square\".  Another arrow labeled \"int\" is pointing out from the rectangle. On the right side of the rectangle, there is a code snippet showing the implementation of the function:\n```c++\nint square (int x)\n{\n  return x*x;\n}\n``` \nThe code snippet shows that the function takes an integer \"x\" as input and returns the square of \"x\" as output.\n", "Exercise 1\n\nCreate a new Java class that contains the method \"int square (int x)\", which returns the square of the parameter received.\n\nIt also contains a main method that calls the method square. In order to call the method square, add \"public static\" in its signature. This method prints the result on the screen.\n\nThe value for which the square is calculated will be an input argument to the program. Collect this argument in the main method in \"args\" and transform it to an integer with \"Integer.parseInt()\". \n", "More Parameters\n\nWe see a diagram depicting a function called \"average\" that takes two integer parameters as input and returns an integer value. The function calculates the product of the two input integers, x and y, and returns the result. \n", "Exercise 2\n\nCreate a new Java class that contains the method \"double average (double x, double y)\", which returns the average of the two parameters received.\n\nThe class should also contain a main method that calls the method \"average\" and prints the result on the screen.\n\nThe values for which the average is calculated will be input arguments to the program. Collect these arguments in the main method in \"args\" and transform them to \"double\" with \"Double.parseDouble()\". \n", "No Parameters\n\nWe have a function named \"sayHello\". It's return type is String. It doesn't take any parameters and it returns the string \"Hello!\". \n", "No Result\n\nWe have a function definition for printOpposite which takes a double as an argument. The function prints the negative of the double. There is an arrow pointing from the word double to a blue rectangle with the text printInverse. \n", "No Parameters, No Result\n\nWe have a function definition for a function called print hello. This function takes no parameters and returns void. The body of the function simply prints the string hello with a new line to the console. \n", "Method Definition\n\nThe image describes how to define a method called \"square\". The method takes an integer as input and returns an integer as output. The method calculates the square of the input integer by multiplying it by itself. The image shows a diagram of the method, with an arrow pointing to a box labeled \"square\". The box has two arrows pointing to it, one labeled \"int\" and the other labeled \"int\". The arrow labeled \"int\" represents the input integer, and the arrow labeled \"int\" represents the output integer. The box also contains the code for the method, which is \"return x*x;\". \n", "Outside / Inside\n\nWe have a function definition for a function named square that takes an integer x as input and returns an integer. The body of the function computes x times x and returns the result. There is a blue box labeled \"square\". There is an arrow labeled \"int\" pointing down to the box. There is another arrow labeled \"int\" pointing down from the box. \n", "Outside / Inside\n\nWe have a function called \"square\" that takes an integer \"x\" as input and returns an integer. Inside the function, it calculates 1 plus (x+1) times (x-1) and returns the result. \n", "Method Call\n\nThe image describes how a method call works, in this case the method is named \"square\".  There are two calls to the method \"square\", one with the argument 3 and the other with the argument 4. The first call returns a value of 9 and the second returns a value of 16. The sum of these two values is assigned to the variable y. The definition of the method \"square\" is shown below the calls. It takes an integer argument x and returns an integer value that is the square of x. The value of x is first multiplied by itself and then returned. \n", "Scope\n\nWhat happens if I use an identifier used in a method body also outside of the method?\n\nThere are two Xs, one outside of a circle and one inside of a circle. The circle is labeled \"Method\". \n", "Example 1\n\nWe have a piece of code. The first line declares an integer variable x and assigns it the value 1. The second line defines a function f that takes an integer x as input and returns the sum of x and x. The third line declares an integer variable z and assigns it the value returned by the function f when called with the argument x+1. \nThere is a diagram on the right side. The diagram shows the values of the variables x and z at different points in the code. The variable x is initialized to 1 and then passed to the function f. The function f returns the value 2, which is then assigned to the variable z.", "Example 1\n\nWe have a piece of code. First, an integer x is initialized with value 1. Then, we define a function f that takes an integer as input and returns the sum of an empty square and an empty square. Finally, we define an integer z equal to the output of the function f when applied to x+1. \n", "Example 2\n\nWe have a function f that takes an integer x and returns x+x. In the main function, we have an integer x initialized to 1. Then, we call the function f twice: first with x+1 as input, and then with the result of the first call as input. The final result is stored in an integer z. \n", "Example 3\n\nWe have a piece of code. The first line declares an integer variable x and assigns it the value 1. The second line defines a function f that takes an integer y as input and returns the sum of x and y. The third line declares an integer variable z and assigns it the value returned by calling the function f with the argument x+1. On the right side of the image we have three boxes, one below the other. The top box is labeled X and contains the number 1. The middle box is labeled Y and contains the number 2. The bottom box is labeled Z. \n", "Example 4\n\nWe have a piece of code that defines an integer variable x and assigns it the value 1. Then, an integer function f is defined. Inside the function f, an integer variable y is defined and assigned the value 2. The function returns the sum of x and y. Finally, an integer variable z is defined and assigned the value returned by the function f. \n\nThere are three boxes, one below the other. The top box is labeled X and contains the value 1. The middle box is labeled Y and contains the value 2. The bottom box is labeled Z. The middle box is colored red. \n", "Example 5\n\nWe have a piece of code that defines an integer variable x and assigns it the value of 1. Then, we define a function called f that takes no arguments and returns an integer. Inside the function f, we define another integer variable x and assign it the value of 2. The function then returns the sum of x and x, which is 4. Finally, we define an integer variable z and assign it the value returned by the function f. \nThere is a diagram on the right side. The diagram shows the values of the variables x and z at different points in the code. The top box represents the global scope, the middle box represents the scope of the function f, and the bottom box represents the value of z. In the global scope, the value of x is 1. In the scope of the function f, the value of x is 2. The value of z is 4, which is the value returned by the function f. \n", "Example 6\n\nWe have a code snippet with a comment \"x only exists in for loop\". The code is:\nint y = 0;\nfor (int x = 1; x less than 3; x plus plus)\n{\ny = y + x;\n}\nint z = y;\n\nThere is a table with three columns: X, Y and Z.\nThe column X has two rows with the values 1 and 2.\nThe column Y has one row with the value 0.\nThe column Z has one row with the value z.\n", "Example 7\n\nWe have a code snippet showing a name conflict. The first two lines of code declare an integer variable x and assign it the value 1 and an integer variable y and assign it the value 0. The next line is a for loop that declares an integer variable x and assigns it the value 1, the condition is x less than 3, and the increment is x plus plus. There is a red x over the variable declaration in the for loop and a call out that says \"name conflict with x\". Inside the for loop, y is assigned the value of y plus x. After the for loop, an integer variable z is declared and assigned the value of y. \n", "Example 8\n\nWe have a code snippet that initializes two integer variables, x and y, with values 1 and 0, respectively. A for loop iterates twice, incrementing x by 1 in each iteration. Inside the loop, y is updated by adding the current value of x to it. After the loop completes, another integer variable z is declared and initialized with the sum of y and x.\n\nA table with three columns, x, y, and z, illustrates the values of the variables during the code execution. The x column shows the values 1, 2, and 3. The y column shows the value 0 initially and remains unchanged. The z column is represented by a black rectangle. A text box highlights that the variable x also exists outside the for loop.\n", "Example 9\n\nWe have a code snippet that defines an integer variable 'x' initialized to 1. Then, we have a function 'f' that returns an integer. Inside the function 'f', we have a return statement that returns the value of 'x'. Finally, we have another integer variable 'z' that is assigned the value returned by the function 'f'. On the right-hand side, we have a memory representation with 'x' at the top and 'z' at the bottom. Both 'x' and 'z' have a value of 1. \n", "Example 10\n\nWe have a code snippet with three functions: f, g, and the main function. The main function first declares an integer variable x and initializes it to 1. Then, it defines a function named f that takes no arguments and returns an integer. Inside the function f, it returns the value of x. After that, it defines another function named g that also takes no arguments and returns an integer. Inside the function g, it declares an integer variable x and initializes it to 0. Then, it returns the value returned by calling the function f. Finally, in the main function, it declares an integer variable z and assigns it the value returned by calling the function g.\n\nThere is a diagram on the right side. It shows a stack frame with three variables: x, x, and z. The first x is at the top of the stack frame and has a value of 1. The second x is below the first x and has a value of 0. The variable z is at the bottom of the stack frame. \n", "Example 11\n\nWe have two functions f and g. Function f returns the value of x. Function g declares x equal to zero and returns the output of function f. Finally, we have a variable z that is assigned the output of function g. \n", "Environment\n\nWe have a piece of code that defines an integer variable x and assigns it the value of 1. Then, it defines a function called f that takes an integer as input and returns an integer. The function f returns the sum of the input integer with itself. Finally, the code defines an integer variable z and assigns it the value of the function f called with the argument x+1. The diagram illustrates the environment of the code with two boxes. The left box represents the global environment with variable x assigned to value 1. The right box represents the function f with the input variable x assigned to value 2 and the function definition (x)->x+x. \n", "To Remember\n\n- A variable is valid in a scope from its declaration to the end of the block, but can be temporarily hidden by another variable with the same name\n- However, arrays are passed by reference\n- If there are free variables in a method definition, they are bound at its definition, not at its call \n", "Exercise 3\n\nThe exercise is to program a method that receives three integers and returns the squares of each of these three integers.\nWe should think of different implementations, with and without the use of arrays, and take into account the scope for each of these cases. \n", "Exercise 4\n\nWe need to program a method called \"power\" that calculates the power of a number. The method takes two parameters: the base and a non-negative exponent.\n\nThen, we need to program two more methods: one that calculates the area of a sphere given its radius and another one that calculates the volume of a sphere given its radius. These methods should use the \"power\" method. The formula for the volume of a sphere is V = (4/3)\u03c0r\u00b3 and the formula for the area of a sphere is A = 4\u03c0r\u00b2.\n\nFinally, we need to program a main method to test the program. \n", "The word \"wooclap\" in blue letters. \n"]}, {"filename": "3 en calario-StateTransformation_I.pdf", "text": "State Transformation (I)\n\nCarlos Alario Hoyos & Carlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n2018-02-06\n\n\f2\n\nOverview\n\n1. Repetition\nA. While\nB. For \nC. Do-While\n\n2. Arrays\n\nA. Declaration\nInitialization\nB.\nC. Access\n\n\f3\n\n1. Repetition\n\n\f4\n\n1. Repetition\n\n1. While\n\nwhile(condition){\n\nstatements;\n\n}\n\n2. For\n\nfor(initialization;condition;update){\n\nstatements;\n\n3. Do-While\n\n}\n\ndo{\n\nstatements;\n}while(condition);\n\n\f5\n\n1.A. While\n\nint i = 5;\nwhile (i>0){\n\nSystem.out.println(i);\ni--;\n\n}\n\ni\n5\n\n4\n\n3\n\n2\n\n1\n\n0\n\nCondition Print New i\n\ntrue\n\ntrue\n\ntrue\n\ntrue\n\ntrue\n\nfalse\n\n5\n\n4\n\n3\n\n2\n\n1\n\n4\n\n3\n\n2\n\n1\n\n0\n\n\f6\n\n1.B. For\n\ni Condition Print New i\n0\n\ntrue\n\n0\n\n1\n\nfor (int i=0; i<5; i++) {\nSystem.out.println(i);\n\n}\n\n1\n\n2\n\n3\n\n4\n\n5\n\ntrue\n\ntrue\n\ntrue\n\ntrue\n\nfalse\n\n1\n\n2\n\n3\n\n4\n\n2\n\n3\n\n4\n\n5\n\n\f7\n\n1.B. For\n\n\u00b4 When the loop has several statements (in initialization, condition or \n\nupdate), they will be separated by commas\n\nfor(int i=0, int sum=0;\n\ni<=5;\n\ni++, sum+=5){\n\nstatements;\n\n}\n\n\f8\n\n1.B. For\n\n\u00b4 More examples\n\nint i=0;\nfor (i=0;i<10;){      \n\nint i=0;\nfor (i=13;i<10; i++){ \n\ni=i+2;\n\ni=i+2;\n\n}\n\n}\n\nint i=4;\nfor (;i<10;){ \ni=i+2;\n\n}\n\nint i=0;\nfor ( ; ; ){ \ni=i+2;\n\u00b4\n\n}\n\nint i, sum;\nfor (i=0, sum=5;i<10;sum+=i){\n\ni=i+8;\n\n}\n\n\u00b4 How many times are these loops executed?\n\n\u00b4 What is the value of \u201ci\u201d in each example at the end of the loop?\n\n\f9\n\nWhile vs. For\n\n\u00b4 When to use while or for\n\nThe number of iterations is known (e.g., array)\n\nThe number of iterations is unknown\n\nIncrease of variables in each cycle\n\n\u00b4 E.g.: reading a file with while\n\n\u00b4 E.g.: cover an array with for\n\nfor\n\nwhile\n\nX\n\nX\n\nX\n\n\f10\n\n1.C. Do-While\n\nint i = 5;\ndo{\n\nSystem.out.println(i);\ni--;\n\n}while (i>0){\n\ni\n5\n\n4\n\n3\n\n2\n\n1\n\nPrint New i Condition\n\n5\n\n4\n\n3\n\n2\n\n1\n\n4\n\n3\n\n2\n\n1\n\n0\n\ntrue\n\ntrue\n\ntrue\n\ntrue\n\nfalse\n\n\f11\n\nSummary\n\n\u00b4 for vs. while vs. do-while\n\nInitialize \nvariables\n\nUpdate \nvariables\n\nMinimum \nnumber of \nExecutions\n\nFrequency of use\n\nfor\n\nwhile\n\ndo-while\n\nYes\n\nNo\n\nNo\n\nYes\n\nNo\n\nNo\n\n0\n\n0\n\n1\n\nHigh\n\nHigh\n\nLow\n\n\f12\n\nAdditional remarks\n\n\u00b4 Nested loops: Program slows down\n\n\u00b4 The statements in a while or for\nmight never run; in a do-while\nstatements are executed at least \nonce\n\n\u00b4 Avoid infinite loops (always check \n\ntermination condition)\n\n\u00b4 A for loop always can be converted \ninto a  while loop, and vice versa\n\n\f13\n\nExercise 1\n\n\u00b4 Write a method that prints numbers from 1 to 100 in steps of seven. \n\nThe output should be:\n\n1 8 15 22 29 36 43 50 57 64 71 78 85 92 99 \n\nThink of an efficient solution!\n\n\f14\n\nExercise 2\n\n\u00b4 Write a methods that calculates whether an input number n is prime. \n\nThe output should be\n\n13 is a prime number\n\n16 is not a primer number\n\n*** Remember that a prime number is a positive integer number that has no positive divisors other than 1 and itself.\n\n\f15\n\nExercise 2: \nStep 1: Think about the algorithm\n\n\u00b4 Split the problem into simpler steps:\n\n\u00b4 Starting by 2, check for each number if it is an integer divisor of n\n\n\u00b4 We only needs to repeat it until n/2\n\n\u00b4 Or until we find an integer divisor\n\n\u00b4 We will use a boolean variable as \u201csentinel\u201d\n\n\f16\n\nExercise 2: \nStep 2: Represent the algorithm\n\n\u00b4 Flowchart\n\ndivisor = 2 \nisPrime = true\n\nfalse\n\ndivisor < n / 2\n&&\nisPrime\n\ntrue\n\nn % divisor == 0\n\ntrue \n\nisPrime = false\n\nfalse\n\ndivisor++\n\n\f17\n\nExercise 2: \nStep 3: Write the code\n\npublic static void main(String[] args){\n\nif (args.length != 0){\n\nboolean b = isPrime(Integer.parseInt(args[0]));\nif (b) {System.out.println (args[0] + \" is a prime number\");}\nelse {System.out.println (args[0] + \" is not a prime number\");}\n\n}\n\n}\n\nprivate static boolean isPrime (int n){\n\nint divisor = 2;\nboolean isPrime = true;\nwhile ((divisor < n/2) && isPrime){\n\nif (n%divisor == 0){\nisPrime = false;\n\n}\ndivisor++;\n\n}\nreturn isPrime;\n\n}\n\ndivisor = 2 \nisPrime = true\n\nfalse\n\ndivisor < n / 2\n&&\nisPrime\n\ntrue\n\nn % divisor == 0\n\ntrue \n\nisPrime = false\n\nfalse\n\ndivisor++\n\n\f18\n\n2. Arrays\n\n\f19\n\n2. Arrays\n\n\u00b4 Set of elements belonging to the same data type\n\n\u00b4 The index [ ] operator is used to set or retrieve \n\nindividual elements from the array\n\n\u00b4 The length (attribute) returns the number of \n\nelements in the array. \n\n\u00b4 Range of index\n\n\u00b4 From 0 to length \u2013 1\n\n\u00b4 Don\u2019t exceed the maximum length!\n\n\u00b4 Exception: IndexOutOfBoundsException\n\n\f20\n\n2. Arrays\n\nIndex 1st element = 0\n\nIndex last element \n= length - 1\n\nc[0]\n\nc[1]\n\nc[2]\n\nc[3]\n\nc[4]\n\nc[5]\n\nc[6]\n\nc[7]\n\nc[8]\n\nc[9]\n\n-7\n\n0\n\n3\n\n8\n\n5\n\n-4\n\n6\n\n6\n\n1\n\n2\n\nArray length= 10\n\nIndex nth element = n - 1\n\nIndex : integer expression: 0 <= index <= length - 1\n\n\f21\n\n2.A. Declaration\n\n\u00b4 Assigning an identifier to the array and specify the data type of the \n\nelements that will be stored\n\ntype arrayName[];\ntype[] arrayName;\n\nint arrayName[];\nboolean[] arrayName;\n\n\u00b4 No memory to store the array is allocated in the declaration. \n\n\u00b4 The contents cannot be accessed yet.\n\n\f22\n\n2.B. Creation\n\n\u00b4 Allocating memory for the array\n\n\u00b4 Use the reserved word new and specify the array size\n\n\u00b4 Once created, the elements have default values until the array is initialized\n\narrayName[] = new type[arraySize];\n\narrayName[] = new int[10];\n\narrayName[] = new boolean[5];\n\nDefault values:\nint, short, long  = 0\nfloat, double = 0.0\nboolean = false\nString = null\nObject = null\n\n\f23\n\n2.C. Initialization\n\n\u00b4 To assign values to each of the elements of the array. \n\n\u00b4 Element by element\n\narrayName[0] = element0;\narrayName[1] = element1;\n...\n\n\u00b4 Using a loop\n\nfor(int i = 0; i < arrayName.length; i++){\n\narrayName[i] = element-i;\n\n}\n\n\u00b4 Direct assignment \n\narrayName = {elem1, elem2, elem3, ...};\n\n\f24\n\nExamples\n\n// declaration\n\nint a[]; \na = new int[3]  // creation\na[0]=1;\na[1]=2;\na[2]=3;\n\n// initialization\n\nint a[] = new int[3] // declaration, creation\na[0]=1;              // initialization\na[1]=2;\na[2]=3;\n\nint a[] = new int[3]          // declaration, creation\nfor(int i=0; i<a.length;i++){ // initialization\n\na[i]=i+1;\n\n}\n\nint a[] = {1, 2, 3};   // declaration, creation, initialization\n\n\f25\n\nCommon errors\n\npublic class ArrayExamples{\n\npublic static void main(String args[]){\n\ndouble myArray[];\nSystem.out.println(myArray[0]);\n\n}\n\n}\n\nWRONG\n\ncompile\n\nCompilation \nfailure\n\nvariable myArray may not \nhave been initialized\n\nWhen an array has been declared but not created or initialized, \nelements cannot be accessed. \nThe program does not compile and prints an error message\n\n\f26\n\nCommon errors\n\npublic class ArrayExamples2{\n\npublic static void main(String args[]){\n\nint myArrayOfIntegers[] = new int[10];\nfloat myArrayOfFloats[]= new float[10];\nboolean myArrayOfBooleans[] = new boolean[10];\nchar myArrayOfCharacters[] = new char[10];\nString myArrayOfStrings[] = new String[10];\nSystem.out.println(\u201cInteger by default: \" + myArrayOfIntegers[0]);\nSystem.out.println(\u201dFloat by default : \" + myArrayOfFloats[0]);\nSystem.out.println(\"Boolean by default : \" + myArrayOfBooleans[0]);\nSystem.out.println(\u201cCharacter by default : \" + myArrayOfCharacters[0]);\nSystem.out.println(\"String by default : \" + myArrayOfStrings[0]);\n\ncompile\n\nRun\n\n}    \n\n}\n\nWhen the array has been declared and \ncreated but not initialized we can retrieve its \nelements but they have their default value\n\ninteger by default: 0\nfloat by default: 0.0\nboolean by default: false\nchar by default:\nString by default: null\n\n\f27\n\nExercise 3\n\n\u00b4 Write a method that receives a set of integer values as input, and \nprints the sum on screen. For example, if the method receives as \ninput  {1, 2, 3, 4}, then it will print:\n\n10\n\n\u00b4 Assume that the values received as input will be always integer \n\nvalues. In case that no input is received, the program will print 0. \n\n\f28\n\nExercise 4\n\n\u00b4 Write a method that receives a set of integer values as input, and \nprints the maximum value on screen. For example, if the method \nreceives as input {1, -2, 3, -4}, then it will print:\n\n3\n\n\u00b4 Assume that the values received as input will be always integer \n\nvalues. In case that no input is received, the program will print the \nsmallest integer value in Java, which is contained in \nInteger.MIN_VALUE. \n\n\f29\n\nN-dimensional Arrays\n\n\u00b4 When we need more than one index to set and retrieve the elements of an array\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n1\n\n4\n\n7\n\n2\n\n5\n\n8\n\n3\n\n6\n\n9\n\n// Array 3x3 initialized to 0\nint [][] a = new int[3][3];\n\nint [][] b = {{1, 2, 3},\n\n{4, 5, 6}\n{7, 8, 9}};\n\n\f30\n\nN-dimensional Arrays\n\n0\n\n1\n\n2\n\n2\n1\n0\nA B C\nD E F\nG H I\na[0][2]=\u2018C\u2019\n\n0\n\n1\n\n2\n\n1\n\na\n\nd\n\ng\n\nb\n\ne\n\nh\n\nc\n\nf\n\ni\n\n0\n\n0\n\n1\n\n2\n\n2\n\nt\n\nl\n\nc\n\nw\n\nz\n\n\u00f1\n\nq\n\nf\n\ni\n\na[0][2][1]=\u2018l\u2019\n\nchar a[][];\na = new char[3][3]; // creation\na[0][0]=\u2018A\u2019;\n...\n\n// initialization\n\n// declaration\n\nchar a[][][];\na = new char[3][3][3]; // creation\na[0][0][0]=\u2018a\u2019;\n...\n\n// initialization\n\n// declaration\n\n\f31\n\nExercise 5\n\n\u00b4 Write a method public static int max(int[][] a) which \n\nreceives a bidimensional array of integer values as input, and prints \nthe maximum value on screen. For example, if the method receives \na where int a[][] = {{1, -2, 8, -4},{3, -1, 7, -2}};\nthen it will print:\n\n8\n\n\u00b4 Assume that the bidimensional array contains always integer values. \nIn case that no input is received, the program will print the smallest \ninteger value in Java, which is contained in Integer.MIN_VALUE. \n\n\f32\n\nExercise 6\n\n\u00b4 Write a method public static int rowSum(int[][] a, int r) \n\nwhich receives a bidimensional array of integer values as input, and \nprints the sum of the elements in row r (starting in 0). For example, if \nthe program receives a, 1 where                                                            \nint a[][] = {{1, -2, 3, -4},{3, -1, 7, -2}};\nthen it will print:\n\n7\n\n\u00b4 Assume that the bidimensional array and r contain always integer \n\nvalues. In case that no input is received, the program will print an error \nmessage. \n\n\f", "pages_description": ["Overview\n\nThe slide presents an overview of two programming concepts: repetition and arrays.\n\n- Repetition is further divided into three sub-concepts: while loops, for loops, and do-while loops.\n- Arrays are divided into three sub-concepts: declaration, initialization, and access. \n", "1. Repetition\n\nThe image shows a 3D figure running in a hamster wheel. \n", "1. Repetition\n\nThis slide lists and describes three types of repetition statements. The first is \"while,\" which has a condition in parentheses followed by statements in curly brackets. The second is \"for,\" which has an initialization, condition, and update in parentheses followed by statements in curly brackets. The third is \"do-while,\" which has the keyword \"do\" followed by statements in curly brackets, and then \"while\" with a condition in parentheses. \n", "1.A. While\n\nWe have a code snippet and a table. The code snippet shows a while loop in Java. It initializes an integer variable 'i' to 5. The while loop continues as long as 'i' is greater than 0. Inside the loop, the value of 'i' is printed to the console, and then 'i' is decremented by 1. \n\nThe table illustrates the execution of the while loop. Each row in the table represents an iteration of the loop. The columns show the value of 'i', the condition (i > 0), the value printed to the console, and the new value of 'i' after each iteration. \n\nThe loop iterates 5 times, printing the values 5, 4, 3, 2, and 1 to the console. In each iteration, the condition (i > 0) is evaluated. If it's true, the loop continues. Once 'i' becomes 0, the condition becomes false, and the loop terminates. \n", "1.B. For\n\nWe have a for loop with the following structure: for (int i=0; i<5; i++). Inside the loop, we print the value of i using System.out.println(i).\n\nA table shows the values of i, the condition (i<5), the printed value, and the new value of i after each iteration.\n\n- Initially, i is 0, the condition is true, 0 is printed, and i is incremented to 1.\n- In the next iteration, i is 1, the condition is true, 1 is printed, and i becomes 2.\n- This process continues until i reaches 4. 4 is printed, and i is incremented to 5.\n- Now, the condition (i<5) becomes false, and the loop terminates. \n", "1.B. For\n\nWhen the loop has several statements in initialization, condition or update, they will be separated by commas. For example, we have a for loop with int i equals 0 comma int sum equals 0, and then i less than or equal to 5 semicolon i plus plus comma sum plus equals 5. Inside the curly braces, we have statements and then the closing curly brace. \n", "1.B. For\n\nThe slide shows four examples of for loops in a C-like programming language.\n\nThe first loop initializes an integer variable i to 0. The loop continues as long as i is less than 10. In each iteration of the loop, the value of i is incremented by 2.\n\nThe second loop also initializes an integer variable i to 0. However, the loop condition checks if i is less than 10 after setting i to 13. Since 13 is not less than 10, the loop will not execute. In each iteration of the loop, the value of i is incremented by 2.\n\nThe third loop initializes an integer variable i to 4. The loop continues as long as i is less than 10. In each iteration of the loop, the value of i is incremented by 2.\n\nThe fourth loop initializes two integer variables, i and sum, to 0 and 5, respectively. The loop continues as long as i is less than 10. In each iteration of the loop, the value of sum is incremented by i, and the value of i is incremented by 8.\n\nThe slide asks two questions:\n\n* How many times are these loops executed?\n* What is the value of \"i\" in each example at the end of the loop?\n", "**While vs. For**\n\nThis table describes when to use a \"for\" loop and when to use a \"while\" loop. Use a \"for\" loop when the number of iterations is known, for example when iterating over an array. Use a \"while\" loop when the number of iterations is unknown, or when the variables are incremented in each cycle.\n\nExamples of when to use a \"while\" loop include reading a file. Examples of when to use a \"for\" loop include covering an array. \n", "1.C. Do-While\n\nThe code snippet shows a do-while loop in Java. The loop starts by initializing an integer variable 'i' to 5. Inside the loop, the value of 'i' is printed to the console using System.out.println(i). Then, 'i' is decremented by 1 using the decrement operator. The loop continues to execute as long as the condition 'i > 0' is true.\n\nThe table shows the values of 'i', the printed output, the new value of 'i' after each iteration, and the condition evaluation result. The loop iterates 5 times, printing the values 5, 4, 3, 2, and 1. After the fifth iteration, 'i' becomes 0, and the condition 'i > 0' evaluates to false, terminating the loop. \n", "Summary\n\nfor VS. while VS. do-while\n\nThe table compares the for, while, and do-while loops in terms of initialization of variables, updating variables, minimum number of executions, and frequency of use.\n\n- The for loop initializes and updates variables, has a minimum of 0 executions, and is frequently used.\n- The while loop does not initialize or update variables, has a minimum of 0 executions, and is frequently used.\n- The do-while loop does not initialize or update variables, has a minimum of 1 execution, and is not used as frequently as the for and while loops. \n", "Additional remarks\n\n- Nested loops: Program slows down\n- The statements in a *while* or *for* might never run; in a *do-while* statements are executed at least once\n- Avoid infinite loops (always check termination condition)\n- A *for* loop always can be converted into a *while* loop, and vice versa \n", "Exercise 1\n\nWe are asked to write a method that prints numbers from 1 to 100 in steps of seven. The expected output is 1 8 15 22 29 36 43 50 57 64 71 78 85 92 99. We should think of an efficient solution. \n", "Exercise 2\n\nThe slide describes an exercise to write a method that calculates whether an input number n is prime. The expected output should state if the number is prime or not. For example, for the number 13, the output should be \"13 is a prime number\". For the number 16, the output should be \"16 is not a prime number\".\n\nThere is also a reminder at the bottom of the slide that says \"Remember that a prime number is a positive integer number that has no positive divisors other than 1 and itself.\" \n", "Exercise 2:\nStep 1: Think about the algorithm\n\nSplit the problem into simpler steps:\n- Starting by 2, check for each number if it is an integer divisor of n\n- We only needs to repeat it until n/2\n- Or until we find an integer divisor\n- We will use a boolean variable as \"sentinel\"\n", "Exercise 2:\nStep 2: Represent the algorithm\n\nThe image shows a flowchart with a title \"Flowchart\" and a series of steps to check if a number is prime.\n- It starts by setting a variable named \"divisor\" to 2 and a variable named \"isPrime\" to true.\n- Then it checks if the divisor is less than half of n and if isPrime is true.\n- If both conditions are true, it checks if the remainder of the division of n by the divisor is equal to 0.\n- If the remainder is 0, it sets isPrime to false.\n- If any of the conditions are false, it increments the divisor by 1.\n- The flowchart ends with a return to the previous step. \n", "Exercise 2: Step 3: Write the code\n\nWe have a piece of code written in Java. This code determines if a given number is a prime number.\n\nThe main function takes an array of strings as an argument. If the array is not empty, it parses the first element as an integer and calls the isPrime function. Depending on the boolean value returned by the isPrime function, it prints a message indicating whether the number is prime or not.\n\nThe isPrime function takes an integer as an argument and returns a boolean value. It initializes two variables: divisor to 2 and isPrime to true. It then enters a while loop that continues as long as the divisor is less than half of the input number and isPrime is true. Inside the loop, it checks if the input number is divisible by the current divisor. If it is, it sets isPrime to false. The divisor is incremented by one in each iteration of the loop. Finally, the function returns the value of isPrime.\n\nOn the right-hand side, we have a flowchart illustrating the logic of the isPrime function. The flowchart starts by initializing the divisor to 2 and isPrime to true. It then enters a loop that continues as long as the divisor is less than half of the input number and isPrime is true. Inside the loop, it checks if the input number is divisible by the current divisor. If it is, it sets isPrime to false. The divisor is incremented by one in each iteration of the loop. Finally, the flowchart ends with the isPrime value. \n", "2. Arrays\n\nThe image shows rows of empty chairs. \n", "2. Arrays\n\nArrays are sets of elements belonging to the same data type. The index operator, represented by square brackets, is used to set or retrieve individual elements from the array. The length attribute returns the number of elements in the array. The range of the index is from 0 to length minus 1. It's important not to exceed the maximum length of the array, otherwise an IndexOutOfBoundsException will be thrown.\n\nThe image shows a set of colorful lockers, representing an array. Each locker is labeled with an index from 0 to 3. \n", "Arrays\n\nThe index of the first element in an array is zero. The index of the last element in an array is equal to the length of the array minus one. The index of the nth element in an array is equal to n minus 1. The index of an array is an integer expression that must be greater than or equal to zero and less than or equal to the length of the array minus one. \n\nThe image shows an array named c with 10 elements. The first element is -7 and the last element is 2. \n", "2.A. Declaration\n\nAssigning an identifier to the array and specify the data type of the elements that will be stored. There are two code snippets: \"type arrayName[];\" and \"type[] arrayName;\" in the first box and \"int arrayName[];\" and \"boolean[] arrayName;\" in the second box. No memory to store the array is allocated in the declaration. The contents cannot be accessed yet. \n", "2.B. Creation\n\nTo create an array, you need to allocate memory for it. This is done using the reserved word \"new\" and specifying the array size. Once created, the elements have default values until the array is initialized.\n\nThe syntax for creating an array is:\n\n- arrayName[] = new type[arraySize];\n\nFor example, to create an array of integers named \"arrayName\" with a size of 10, you would use the following code:\n\n- arrayName[] = new int[10];\n\nThe default values for the different data types are:\n\n- int, short, long = 0\n- float, double = 0.0\n- boolean = false\n- String = null\n- Object = null \n", "2.C. Initialization\n\nWe are going to see how to assign values to each of the elements of the array. \n\nThe first method is to assign values element by element. For example, we can assign element0 to arrayName at index 0 and element1 to arrayName at index 1.\n\nThe second method is to use a loop. We can iterate from i equals 0 until i is less than the length of the array, incrementing i at each step. For each index i, we assign element-i to arrayName at index i.\n\nThe third method is direct assignment. We can assign the list of elements to arrayName. For example, we can assign the list containing eleml, elem2, elem3, etc. to arrayName. \n", "Examples\n\nWe have three different ways to declare and initialize an integer array in Java.\n\nThe first example shows how to declare an array variable, create an array object, and then initialize the array elements. First, we declare an integer array variable named \"a\" using square brackets. Then, we create a new integer array object of size 3 and assign it to the variable \"a\". Finally, we initialize the array elements individually.\n\nThe second example shows how to declare an array variable, create an array object, and initialize the array elements in a single statement. We declare an integer array variable named \"a\" using square brackets and assign it to a new integer array object of size 3. We then initialize the array elements individually.\n\nThe third example shows how to declare an array variable, create an array object, and initialize the array elements using a for loop. We declare an integer array variable named \"a\" using square brackets and assign it to a new integer array object of size 3. We then use a for loop to iterate over the array elements and initialize each element to its index plus 1.\n\nThe fourth example shows how to declare, create, and initialize an array in a single statement. We declare an integer array variable named \"a\" using square brackets and assign it to an array literal containing the values 1, 2, and 3. \n", "Common errors\n\nThis slide explains a common error when working with arrays in programming. \n\nThe code declares a double array variable named \"myArray\" but doesn't initialize it. Then, the code attempts to print the value of the first element of the array. \n\nThis will result in a compilation error because the array has been declared but not created or initialized, so its elements cannot be accessed. The program will not compile and will display an error message indicating that the variable \"myArray\" may not have been initialized. \n", "**Common errors**\n\nWe see here a code snippet, written in Java, that shows how to declare and initialize arrays of different data types. \n\nThe code first declares and creates five arrays: \n- `myArrayOfIntegers` of type integer\n- `myArrayOfFloats` of type float\n- `myArrayOfBooleans` of type boolean\n- `myArrayOfCharacters` of type char\n- `myArrayOfStrings` of type String\n\nEach array has a size of 10.\n\nThen the code prints the value of the first element of each array. \n\nThe output of the code will be the default values for each data type:\n- 0 for integer\n- 0.0 for float\n- false for boolean\n- a space character for char\n- null for String\n\nThe code highlights a common error in Java: when an array is declared and created but not initialized, we can still retrieve its elements, but they will have their default values. \n\nA diagram shows the compilation and execution flow of the code. The code is first compiled, and then it is run. The output of the code is shown in the \"Run\" box.\n", "Exercise 3\n\nWe're tasked with writing a method that takes a set of integers as input and prints their sum. For instance, if the input is the set containing 1, 2, 3, and 4, the method should output 10.  We can assume the input will always consist of integers. If no input is provided, the method should output 0. \n", "Exercise 4\n\nWe're tasked with writing a method that takes a set of integers as input and prints the maximum value. For example, if the input is the set containing 1, 2, 3, and -4, the method should print 3.\n\nWe should assume that the input will always be integer values. If no input is received, the program should print the smallest integer value in Java, which is `Integer.MIN_VALUE`. \n", "N-dimensional Arrays\n\nWhen we need more than one index to set and retrieve the elements of an array, we can use N-dimensional arrays.\n\nThe slide shows two examples of how to declare and initialize a 3x3 array in Java.\n\nThe first example shows how to create a 3x3 array initialized to 0.\n\nThe second example shows how to create a 3x3 array and initialize it with the values 1, 2, 3, 4, 5, 6, 7, 8, and 9. \n", "N-dimensional Arrays\n\nThe image shows two diagrams representing two-dimensional and three-dimensional arrays, and code snippets for declaring, creating, and initializing them.\n\nThe first diagram represents a two-dimensional array with three rows and three columns. Each cell in the array contains a letter. The element in the first row and third column is 'C'.\n\nThe second diagram represents a three-dimensional array with three rows, three columns, and three layers. Each cell in the array contains a letter. The element in the first row, third column, and second layer is 'l'.\n\nThe code snippets show how to declare, create, and initialize two-dimensional and three-dimensional arrays in a programming language. The first snippet declares a two-dimensional array 'a' of characters, creates a 3x3 array, and initializes the element at index [0][0] to 'A'. The second snippet declares a three-dimensional array 'a' of characters, creates a 3x3x3 array, and initializes the element at index [0][0][0] to 'a'. \n", "Exercise 5\n\nWe're tasked with writing a Java method with the signature `public static int max(int[][] a)`. This method takes a two-dimensional array of integers as input and prints the maximum value found within the array. For instance, if the input array is `{{1, -2, 8, -4},{3, -1, 7, -2}}`, the method should output `8`.\n\nAdditionally, we need to handle the case where the input array is empty. In this scenario, the method should print the smallest possible integer value in Java, which is represented by the constant `Integer.MIN_VALUE`. \n", "Exercise 6\n\nWe are asked to write a Java method with the signature `public static int rowSum(int[][] a, int r)`. This method takes a two-dimensional integer array `a` and an integer `r` as input. It calculates and prints the sum of the elements in row `r` of the array, assuming zero-based indexing.\n\nFor instance, if the input array `a` is `{{1, -2, 3, -4},{3, -1, 7, -2}}` and `r` is `1`, the method will print `7`, which is the sum of the elements in the second row (3 + (-1) + 7 + (-2)).\n\nThe input is assumed to always consist of a two-dimensional integer array and an integer. If no input is provided, the program should display an error message. \n"]}, {"filename": "8 en calario-Sorting (II).pdf", "text": "Sorting (II)\n\nCarlos Alario Hoyos & Carlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n\f2\n\nOverview\n\n1. Sorting (advanced algorithms)\n\nA. Heap Sort\nB. Merge Sort\nC. Quick Sort\n\n\f3\n\n1. Sorting (Advanced)\n\n\f4\n\n1.1 Heap\n\nv Hierarchical data structure in the form of a tree\n\n\u2022 With the root on top\n\n\u2022 And the leaves at the bottom\n\nv Every parent node (ascendant) can have 0, 1 or 2 children \n\n(descendant)\n\nv All the levels are complete except maybe for the last one\n\nwhere nodes are arranged from left to right\n\nv Types:\n\n\u2022 Max-heap: parents contain larger values than children\n\n\u2022 Min-heap: parents contain smaller values than children\n\n\f5\n\n1.1 Heap: Example\n\nRoot (no parent)\n\nThe parent of 4 and 5\n\nA child of 2\n\nLeaves \nHojas\n(no children)\n(sin hijos)\n\nMin-heap\n\nLeaves \nHojas\n(no children)\n(sin h\n\n\f6\n\n1.1 Heap: Example (completeness)\n\n1\n\n2\n\n4\n\n3\n\n5\n\n6\n\n9\n\n8\n\n7\n\nComplete\n\nNot a heap: it is not complete\n\nNot complete\n\n\f7\n\n1.1 Heap: Example (values in the nodes)\n\n1\n\n3\n\n4\n\n2\n\n5\n\n6\n\n9\n\n8\n\n7\n\nNot a heap: values in some children \nare lower than those of the parent\n\n\f8\n\n1.1 Heap: Example\n\n1\n\n2\n\n4\n\n3\n\n5\n\n6\n\n9\n\n8\n\n7\n\nMin-Heap\n\n\f9\n\n1.1 Heap: From the array to the heap\n\n1\n\n2\n\n3\n\np(root)=0\np(x.left)=2*p(x)+1\np(x.right)=2*p(x)+2\n\n4\n\n5\n\n6\n\n7\n\n1 2 3 4 5 6 7\n\n0    1    2    3    4    5    6  \n\n\f10\n\n1.1 Heap Sort\n\n1.\n\nImproved version of Selection Sort\n\n2. Two steps:\n\n\u00b4 (In ascending order from low to high)\n\n\u00b4 Build a heap \n\n\u00b4 Binary tree, complete, values in parents are higher than in children\n\n\u00b4 Parent with index i\n\n\u00b4 Left child with index 2*i +1\n\n\u00b4 Right child with index 2*i+2\n\n\u00b4 The highest element of the heap is swapped with the last unsorted \nelement. The heap must be updated after the removal of the root. \n\nhttps://www.cs.usfca.edu/~galles/visualization/HeapSort.html\nhttp://www.algostructure.com/sorting/heapsort.php\nhttp://www.cs.armstrong.edu/liang/animation/web/Heap.html\n\n\f11\n\n1.1 Heap Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nq Build the heap from the array\nq Root in position i (starting from 0)\nq Left (child) node: 2*i + 1\nq Right (child) node: 2*i + 2\n\nLet\u2019s build a Max-heap\n\n\f12\n\n1.1 Heap Sort. Example (II)\n\n\u2022\n\nStep 1: Ordering the heap (root is higher than children)\n\u2022\n\nStarting from the penultimate row to the right, check if the children is higher \nthan the parent\nNodes go down to their corresponding position\nSwapping 66 and 14\nSwapping 98 and 95\nSwapping 98 and 80\nSwapping 95 and 80\n\n\u2022\n1.\n2.\n3.\n4.\n\n98 95 66 80 29 49 14\n\n\f13\n\n1.1 Heap Sort. Example (III)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\n1.\n2.\n\nTaking 98 and placing it at the end (sorted). The root becomes 14.\nReplacing 14 by the highest element of the array (95) and reordering the heap\n\n1\n\n2\n\n\f14\n\n1.1 Heap Sort. Example (IV)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\n1.\n2.\n\nTaking 95 and placing it at the end (sorted). The root becomes 49.\nReplacing 49 by the highest element of the array (80) and reordering the heap\n\n1\n\n2\n\n\f15\n\n1.1 Heap Sort. Example (V)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\n1.\n2.\n\nTaking 80 and placing it at the end (sorted). The root becomes 29.\nReplacing 29 by the highest element of the array (66) and reordering the heap\n\n1\n\n2\n\n\f16\n\n1.1 Heap Sort. Example (VI)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\n1.\n2.\n\nTaking 66 and placing it at the end (sorted). The root becomes 14.\nReplacing 14 by the highest element of the array (49) and reordering the heap\n\n1\n\n2\n\n\f17\n\n1.1 Heap Sort. Example (VI)\n\n\u2022\n\nStep 2: Extracting the root and reordering the heap\n1.\n2.\n3.\n\nTaking 49 and placing it at the end (sorted). The root becomes 29.\nTaking 29 and placing it at the end (sorted). The root becomes 14.\nTaking 14. The heap is empty\n\n14 29 49 66 80 95 98\n\n\f18\n\n1.1 Heap Sort. Two external loops\n\n1. External loop 1 (Step 1): Building the heap\n\no\n\no\n\nFor each node, checking that the children are smaller\n\nNumber of iterations: half the length of the array\n\n\u2022\n\n\u2022\n\nTraversing all the nodes except for the leaves (they do not have children)\n\nRange of the index of external loop 1 [0, length of array - 2)/2]\n\n2.\n\nInternal loop 2 (Step 2): Extracting the root and reordering\n\no\n\no\n\nThe root is extracted, placed at the end of the data structure, and the \nheap is reordered\n\nNumber of iterations: length of array\n\n\u2022\n\nRange of the index of external loop 2 [0, length of array - 1]\n\n3. After m-th iteration (i=m-1) of the external loop 2:\n\no\n\no\n\nElements from 0 to length of array - 2 - i are unsorted\n\nElements from length of array - 1 - i to length of array - 1 are sorted \n\n\f19\n\n1.1 Heap Sort. Code (I)\n\npublic static void heapSort(int[] a) {\n\nfor (int i=(a.length-2)/2; i>=0; i--)\n\nheapify(a,i,a.length-1);\n\nfor (int i=a.length-1; i>=0; i--) {\n\nswap(a,0,i);\nheapify(a,0,i-1);\n\n}\n\n}\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n\f20\n\n1.1 Heap Sort. Code (II)\n\nprivate static void heapify(int[] a, int i, int m) {\n\nint j;\nwhile(2*i+1<=m) {\nj=2*i+1;\nif(j<m) {\n\nif(a[j]<a[j+1])\n\nj++;\n\n}\nif(a[i]<a[j]) {\n\nswap(a,i,j);\ni=j;\n\n} else\n\ni=m;\n\n}\n\n}\n\n\f21\n\nExercise 1\n\n\u00b4 Using the sorting algorithm Heap Sort, how many \n\nswaps are needed to sort the following array from the \nlowest element to the highest element (ascending \norder)?\n\n{7,3,13,1,11,5}\n\n\f22\n\n1.1 Heap Sort: Conclusions\n\nv Advantages:\n\n\u00b4 Efficient for arrays with many elements, even in the worse case\n\nv O(n log n) \n\n\u00b4 Little additional memory is needed\n\nv Drawbacks:\n\n\u00b4 Complex code\n\n\f23\n\n1.2 Merge Sort\n\n1. Divide the array in two subarrays \n\nof approximately the same \nlength (half the original array)\n\n2. Divide each subarray recursively \nuntil we have subarrays of length \n1, in which case that array is \nreturned\n\n3. Merge the two subarrays in a \n\nnew sorted subarray recursively\n\nhttp://www.algostructure.com/sorting/mergesort.php\nhttp://www.cs.armstrong.edu/liang/animation/web/MergeList.html\n\n\f24\n\n1.2 Merge Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n80 95 14 98\n\n29 49 66\n\n80 95\n\n14 98\n\n29 49\n\n80\n\n95\n\n14\n\n98\n\n29\n\n49\n\n66\n\n66\n\n\f25\n\n1.2 Merge Sort. Example (II)\n\n80\n\n95\n\n14\n\n98\n\n29\n\n49\n\n80 95\n\n14 98\n\n29 49\n\n66\n\n66\n\n14 80 95 98\n\n29 49 66\n\n14 29 49 66 80 95 98\n\n\f26\n\n1.2 Merge Sort. Recursive division and \nmerging with auxiliary array\n\n1. Recursive division (Step 1) \n\no Given an array (or part of it) with l the first position, r the last \n\nposition and m the half position ((l+r)/2)\n\no Divide the array recursively in two until l and r are equal\n\n\u2022\n\n\u2022\n\nFrom l to m\n\nFrom m+1 to r\n\n2. Sorting by merging subarrays (Step 2)\n\no Create an auxiliary array containing the two subarrays to sort\n\no Compare the elements to sort of each subarray\n\n\u2022\n\nElements are not in their final correct position until we \nfinish merging subarray\n\n\f27\n\n1.2 Merge Sort. Code (I)\n\npublic static void mergeSort (int[] a) {\n\nmSort(a, 0, a.length-1);\n\n}\n\npublic static void mSort (int[] a, int l, int r) {\n\nif (l>=r){\n\nreturn;\n\n}\nint m = (l+r)/2;\nmSort(a, l, m);\nmSort(a, m+1, r);\nmerge(a, l, m, r);\n\n}\n\n\f28\n\n1.2 Merge Sort. Code (II)\n\npublic static void merge (int[] a, int l, int m, int r){\n\nif (m+1>r){ return; }\nint[] b = new int[a.length];\nfor (int i=l; i<m+1; i++) { \n\n\u2022 The left subarray is copied as it is in the auxiliary \n\nb[i] = a[i]; \n\narray\n\n}\nfor (int i=m+1; i<r+1; i++){\nb[i] = a[r+m+1-i]; \n\n}\nint k=l;\nint j=r;\nfor (int i=l; i<r+1; i++) {\nif (b[k] <= b[j]){\n\na[i] = b[k];\nk++;\n} else {\n\na[i] = b[j];\nj--; \n\n}\n\n}\n\n}\n\n\u2022 The right subarray is copied in the auxiliary array \n\nin reverse order\n\n\u2022 The merging starts from the two ends of the \n\nauxiliary array, which contain the elements with \nthe lowest values of each subarray\n\n\f29\n\nExercise 2\n\n\u00b4 Using the sorting algorithm Merge Sort, describe the \n\nprocess needed to sort the following array in ascending \norder. \n\n\u00b4 Unlike in other cases, with Merge Sort there are no \n\nswapping in the arrays, as we are using an auxiliary array\n\n{7,3,13,1,11,5}\n\n\f30\n\n1.2 Merge Sort: Conclusions\n\nv Advantages:\n\n\u00b4 Efficient for arrays with many elements, even in the worse case\n\nv O(n log n) \n\n\u00b4 Highly parallelizable\n\nv Drawbacks:\n\n\u00b4 Complex code\n\n\u00b4 Requires more memory space to store more auxiliary variables \n\n(e.g., auxiliary array)\n\n\f31\n\n1.3 Quick Sort\n\n1. Choose an element: the pivot\n\n2. Reorder the data structure so that\n\n\u00b4 elements lower than the pivot are on its left \n\n\u00b4 elements higher than the pivot are on its right \n\n3. Sort recursively\n\n\u00b4 the part whose elements are lower than the pivot\n\n\u00b4 the part whose elements are higher than the pivot\n\nhttp://www.algostructure.com/sorting/quicksort.php\nhttp://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html\n\n\f32\n\n1.3 Quick Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nq 80 is the pivot\nq Move forward from the left until a \n\nvalue is higher than 80\n\nq Move forward from the right until a \n\nvalue is lower than 80\n\nq Swap the two values\nq Repeat until converging\n\n\f33\n\n1.3 Quick Sort. Example (II)\n\n\f34\n\n1.3 Quick Sort. Example (III)\n\nq Repeat recursively for the \nleft and right partitions\n\n\f35\n\n1.3 Quick Sort. Recursive partition and \nsorting by swapping\n\n1. Recursive partition (Step 1):\n\no Given an array (or part of it) with l the first position, and r the \n\nlast position\n\no\n\no\n\nWe have to run an algorithm that tell us where to do the partition (elements on the \nleft lower than the pivot, and elements on the right higher than the pivot)\n\nThe next partition is computed recursively\n\n2. Sorting by swapping (Step 2):\n\no Moving forward from the left, and from the right, comparting \n\nwith the pivot and swapping as needed\n\no\n\nPlacing the pivot in its correct location\n\n3. Pivots are always placed in their final sorted position\n\n\f36\n\n1.3 Quick Sort. Code (I)\n\npublic static void quickSort (int[] a) {\n\nqSort(a, 0, a.length-1);\n\n}\n\npublic static void qSort (int[] a, int l, int r) {\n\nif (l>=r){ \n\nreturn; \n\n}\nint m = partition(a, l, r);\nqSort(a,l,m-1);\nqSort(a,m+1,r);\n\n}\n\n\f37\n\n1.3 Quick Sort. Code (II)\n\npublic static int partition (int[] a, int l, int r) {\n\nint i=l+1; // left\nint j=r; // right\nint p=a[l]; // pivot\nwhile (i<=j) {\n\nif (a[i]<=p){\ni++;\n\n} else if (a[j]>p){\n\nj--;\n} else{ \n\nswap(a,i,j); \n\n\u2022 Comparing with a[i]. When we find an \nelement higher than a[i] on the left, and \nan element lower than a[i] on the right: \nswap(a,i,j)\n\n\u2022 Before finishing the pivot must be placed \n\nits the correct location: swap(a,l,j)\n\n}\n\n} \nswap(a,l,j);\nreturn j; \n\n}\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n\f38\n\nExercise 3\n\n\u00b4 Using the sorting algorithm Quick Sort, how many swaps \nare needed to sort the following array from the lowest \nelement to the highest element (ascending order)?\n\n{7,3,13,1,11,5}\n\n\f39\n\n1.3 Quick Sort: Conclusions\n\nv Advantages:\n\no Very efficient for arrays with many elements\n\nv O(n log n)\n\nv But the worse case is O(n2)!\n\no Little additional memory\n\no Highly parallelizable\n\nv Drawbacks:\n\n\u00b4 Complex code\n\n\f40\n\nComparison\n\n\f41\n\nComparison\n\nv Basic algorithms (Bubble, Insertion, Selection)\n\no\n\no\n\no\n\nAverage complexity O(n2)\n\nv Inefficient with many elements \n\nSimple code\n\nLittle use of memory \n\nv Advanced algorithms (Heap, Merge, Quick)\n\no\n\no\n\no\n\nAverage complexity O(n log n)\n\nv Efficient with many elements\n\nComplex code\n\nLittle use of memory (except Merge Sort) \n\nhttps://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html\nhttps://www.cs.usfca.edu/~galles/visualization/HeapSort.html\n\n\f", "pages_description": ["Overview\n\nThe slide titled \"Overview\" outlines advanced sorting algorithms, specifically Heap Sort, Merge Sort, and Quick Sort. \n", "1. Sorting (Advanced)\n\nThe image shows a long narrow room with wooden shelves on both sides. The shelves are empty and the room is dimly lit. The floor is made of concrete and there is a window at the far end of the room. \n", "1.1 Heap\n\nA heap is a hierarchical data structure in the form of a tree, with the root on top and the leaves at the bottom. Every parent node, also known as an ascendant, can have 0, 1, or 2 children, which are also known as descendants. All the levels of the tree are complete, except maybe for the last one, where nodes are arranged from left to right. \n\nThere are two types of heaps: max-heap and min-heap. In a max-heap, parent nodes contain larger values than their children, while in a min-heap, parent nodes contain smaller values than their children. \n", "1.1 Heap: Example\n\nWe see a diagram representing a min-heap data structure. The nodes in the heap are numbered from 1 to 7. Node 1 is the root of the heap and has no parent. Node 2 is the parent of nodes 4 and 5. Node 4 is a child of node 2. Nodes 4, 5, 6 and 7 are leaves and have no children. \n", "1.1 Heap: Example (completeness)\n\nWe see an example of a heap, which is not a heap because it's not complete. The heap is a binary tree with nodes 1, 2, 4 at the first level, 3, 5, 6, 9 at the second level, and 8, 7 at the third level. \n\nOn the right side, we see two examples of trees that are not complete. The first tree is not complete because it's missing a node on the last level. The second tree is not complete because it's missing a node on the second to last level. \n", "1.1 Heap: Example (values in the nodes)\n\nWe have a tree with nodes containing numerical values. The root node contains the value 1. The children of the root node are 3 and 4. The children of 3 are 2 and 5. The children of 4 are 6 and 9. The children of 2 are 8 and 7.\n\nThis is not a heap because the values in some children are lower than those of the parent. \n", "1.1 Heap: Example\n\nThis slide describes a min-heap data structure with an example.\n\nThe example is a tree with 7 nodes. The nodes, from top to bottom and left to right, contain the following values: 1, 2, 4, 3, 5, 6, 9, 8, 7.\n\nThe text \"Min-Heap\" is found below the tree. \n", "1.1 Heap: From the array to the heap\n\nWe have a binary tree with nodes numbered 1 at the root, 2 and 3 on the next level, and 4, 5, 6, and 7 on the bottom level. The tree is also represented as an array with the same numbers in the same order. The array indices are 0 through 6. The relationship between a node's position in the tree, p, and its children is given by the following equations:\n\n- p(root) = 0\n- p(x.left) = 2 * p(x) + 1\n- p(x.right) = 2 * p(x) + 2\n\nwhere x.left is the left child and x.right is the right child.\n", "1.1 Heap Sort\n\nThis slide explains the Heap Sort algorithm, which is an improved version of Selection Sort. \n\nIt has two steps:\n1. Build a heap\n - A heap is a binary tree that is complete, meaning all levels are full except for the last level, which is filled from left to right.\n - Values in parent nodes are higher than the values in their children.\n - The index of the parent node is i, the left child is 2*i+1, and the right child is 2*i+2.\n2. Swap the highest element of the heap, which is the root, with the last unsorted element. Update the heap after removing the root.\n\nThe slide also provides three links to external resources. \n", "Heap Sort. Example (I)\n\nThe image describes the process of building a Max-heap from an array of numbers, as part of the Heap Sort algorithm. The goal is to sort the numbers in ascending order, from the lowest to the highest.\n\nThe initial array contains the following numbers: 80, 95, 14, 98, 29, 49, and 66.\n\nThe first step is to build a Max-heap from this array. The heap is represented as a binary tree, where each node corresponds to an element of the array.\n\nThe root of the heap is at position 0, which contains the number 80. The left child of a node at position 'i' is located at position '2*i + 1', and the right child is at position '2*i + 2'.\n\nThe image shows the initial state of the heap, with the number 80 at the root. The arrows indicate the parent-child relationships between the nodes. The green arrows point to the left children, and the black arrows point to the right children.\n\nThe next step is to \"heapify\" the tree, which involves rearranging the nodes to satisfy the Max-heap property: the value of each node should be greater than or equal to the values of its children.\n\nThe image does not show the heapify process itself, but it indicates that the next step is to build the Max-heap. \n", "1.1 Heap Sort. Example (II)\n\nThe image describes the first step of the heap sort algorithm, which is ordering the heap. The main rule is that the root is higher than the children.\n\nThe first step is to start from the penultimate row to the right, check if the children are higher than the parent, and if so, swap them.\n\nThe slide shows a binary tree with some nodes. The nodes contain the following values: 80, 95, 14, 98, 29, 49, 66.\n\nThe algorithm performs the following swaps:\n- Swap 66 and 14\n- Swap 98 and 95\n- Swap 98 and 80\n- Swap 95 and 80\n\nThe final result of the heap ordering is shown in a table containing the following values: 98 95 66 80 29 49 14.\n", "1.1 Heap Sort. Example (III)\n\nThe slide describes step 2 of extracting the root and reordering the heap in a heap sort example. The first point says that 98 is taken and placed at the end, which is considered sorted. The root then becomes 14. The second point says that 14 is replaced by the highest element of the array, which is 95, and then the heap is reordered. There are two diagrams with eight nodes each that illustrate these two points. The first diagram has, from left to right, the following values for its nodes: 14, 95, 66, 80, 29, 49, and 98. There is a black arrow pointing from node 14 to node 95 and a green arrow pointing from node 95 to node 29. There is also a black arrow pointing from node 14 to node 66 and a black arrow pointing from node 66 to node 49. The second diagram has, from left to right, the following values for its nodes: 95, 80, 66, 14, 29, and 49. There is a black arrow pointing from node 95 to node 80 and a green arrow pointing from node 80 to node 29. There is also a black arrow pointing from node 95 to node 66 and a black arrow pointing from node 66 to node 49. \n", "1.1 Heap Sort. Example (IV)\n\nThe image illustrates step 2 in the heap sort algorithm, which involves extracting the root and reordering the heap.\n\nWe have two diagrams, each representing an array of numbers organized in a binary tree structure. The first diagram shows the initial state of the heap, while the second diagram shows the heap after the root has been extracted and reordered.\n\nIn the first diagram, the root node contains the value 49, and its children are 80 and 66. The left child of 80 is 14, and the right child of 80 is 29. The left child of 66 is not shown, and the right child of 66 is not shown.\n\nIn the second diagram, the root node contains the value 80, and its children are 49 and 66. The left child of 49 is 14, and the right child of 49 is 29. The left child of 66 is not shown, and the right child of 66 is not shown.\n\nThe process of extracting the root and reordering the heap involves the following steps:\n\n1. The root node (95) is swapped with the last element in the heap (49).\n2. The root node (49) is removed from the heap, and the heap is reordered to maintain the heap property.\n3. The highest element in the array (80) is moved to the root node.\n4. The heap is reordered to maintain the heap property.\n\nThe red vertical line in the array representation separates the sorted part of the array from the unsorted part. The sorted part of the array is located to the right of the red line.\n", "1.1 Heap Sort. Example (V)\n\nWe are looking at step 2 of a heap sort example. Step 2 is extracting the root and reordering the heap. This step has two sub-steps: first, taking 80 and placing it at the end, which is now sorted. The root becomes 29. Second, replacing 29 by the highest element of the array, which is 66, and reordering the heap.\n\nOn the left side, we see a diagram of the heap before the operation. The root is 80, its children are 49 and 66, and so on. On the right side, we see the heap after the operation. The root is now 66, its children are 49 and 29, and so on. The element 80 is not shown in the heap anymore. \n", "1.1 Heap Sort. Example (VI)\n\nThe image illustrates step two of a heap sort algorithm example. Step two is extracting the root and reordering the heap. This step has two sub-steps. The first sub-step is taking 66 and placing it at the end, which is sorted. The root then becomes 14. The second sub-step is replacing 14 by the highest element of the array, which is 49, and reordering the heap.\n\nThere are two diagrams, one for each sub-step. Both diagrams are essentially the same, with the only difference being the numbers in the nodes. Each diagram consists of seven nodes. The top node has the value 14 in the first diagram and 49 in the second diagram. The top node has two child nodes, the left child node has the value 49 in the first diagram and 14 in the second diagram, and the right child node has the value 29 in both diagrams. The left child node has two child nodes, with the values 14 and 29 in the first diagram, but in the second diagram, the values are not visible. The right child node does not have any child nodes. The nodes with values 66, 80, 95, and 98 are not part of the tree structure. The first diagram has the number one below it, and the second diagram has the number two below it. There is a red vertical line between the values 29 and 66 in the list of numbers above the diagrams. In the first diagram, there is a black arrow pointing from the node with the value 14 to the node with the value 49, and there is a green arrow pointing from the node with the value 14 to the node with the value 29. In the second diagram, there is a black arrow pointing from the node with the value 49 to the node with the value 14, and there is a green arrow pointing from the node with the value 49 to the node with the value 29. \n", "1.1 Heap Sort. Example (VI)\n\nThe slide describes step 2 of extracting the root and reordering the heap in a heap sort example. The first step is to take the root node with value 49 and place it at the end of the heap, which is now considered sorted. The root node then becomes 29. Next, take the new root node 29 and place it at the end of the heap before the previously placed 49. The root node is now 14. Finally, take the last root node 14 and place it at the end of the heap. The heap is now empty. The sorted array is 14, 29, 49, 66, 80, 95, and 98. \n", "1.1 Heap Sort. Two external loops\n\nWe are going to talk about the two external loops of the heap sort algorithm.\n\nThe first external loop, which corresponds to step one of the algorithm, is about building the heap. For each node, we check that the children are smaller than the node. The number of iterations is half the length of the array. We are traversing all the nodes except for the leaves, because the leaves do not have children. The range of the index of this external loop one is from zero to length of the array minus two, divided by two.\n\nThe second external loop, step two, is about extracting the root and reordering the data structure. The root is extracted and placed at the end of the data structure, and the heap is reordered. The number of iterations is the length of the array. The range of the index of this external loop two is from zero to the length of the array minus one.\n\nAfter m-th iteration, with index equals m minus one, of the external loop two: the elements from zero to length of array minus two minus i are unsorted, and the elements from length of array minus one minus i to length of array minus one are sorted. \n", "1.1 Heap Sort. Code (I)\n\nThe image shows two code snippets. The first one is a function called \"heapSort\" which takes an array of integers as input. It first iterates over the array from the middle to the beginning, calling the function \"heapify\" for each element. Then it iterates over the array from the end to the beginning, swapping the first element with the current one and calling \"heapify\" again for the first element and the index of the current element minus one. \nThe second snippet is a function called \"swap\" which takes an array of integers and two integers as input. It swaps the elements at the indices given by the two integers. \n", "1.1 Heap Sort. Code (II)\n\nThe image shows a code snippet of a private static method called \"heapify\" which takes as input an integer array \"a\", an integer \"i\" and an integer \"m\". The method first declares an integer variable \"j\". Then, it enters a while loop with the condition \"2*i+1 less than or equal to m\". Inside the loop, \"j\" is assigned the value of \"2*i+1\". Then, there is an if statement with the condition \"j less than m\". Inside this if statement, there is another if statement with the condition \"a[j] less than a[j+1]\". If this condition is true, \"j\" is incremented. After the nested if statement, there is another if statement with the condition \"a[i] less than a[j]\". If this condition is true, the method calls another method called \"swap\" with the parameters \"a\", \"i\" and \"j\", and then assigns \"j\" to \"i\". If the condition \"a[i] less than a[j]\" is false, the else block assigns \"m\" to \"i\". The while loop continues until the condition \"2*i+1 less than or equal to m\" is false. \n", "Exercise 1\n\nWe are asked to calculate how many swaps are needed to sort an array from lowest to highest element using the Heap Sort algorithm. The array is: 7, 3, 13, 1, 11, and 5. \n", "1.1 Heap Sort: Conclusions\n\nHeap sort has the following advantages: it is efficient for arrays with many elements, even in the worst case. Its time complexity is O(n log n). It requires little additional memory. \n\nHeap sort has the following drawback: its code is complex. \n", "Merge Sort\n\nThe image describes the Merge Sort algorithm in 3 steps. The steps are visualized with a diagram representing an array of numbers as it is being sorted.\n\nStep 1: Divide the array in two subarrays of approximately the same length (half the original array).\nStep 2: Divide each subarray recursively until we have subarrays of length 1, in which case that array is returned.\nStep 3: Merge the two subarrays in a new sorted subarray recursively.\n\nThe diagram shows the array being split in half repeatedly until each element is isolated. Then, the algorithm starts merging the elements back together in sorted order. For example, 38 and 27 are merged into 27 and 38. Then, 43 and 3 are merged into 3 and 43. This continues until the array is sorted.\n\nThe final sorted array is: 3 9 10 27 38 43 82.\n", "1.2 Merge Sort. Example (I)\n\nThis slide describes the merge sort algorithm, and shows an example of sorting a list of numbers in ascending order.\n\nThe list of numbers to be sorted is: 80, 95, 14, 98, 29, 49, 66.\n\nThe algorithm works by recursively dividing the list into smaller sub-lists until each sub-list contains only one element. Then, the sub-lists are repeatedly merged together in pairs, sorting the elements in each pair, until the original list is reconstructed in sorted order.\n\nThe diagram shows the steps of the merge sort algorithm applied to the list of numbers. Each level of the diagram represents a step in the algorithm. The top level shows the initial list of numbers. The next level shows the list divided into two sub-lists. The following levels show the sub-lists being merged together in pairs, until the final sorted list is obtained at the bottom level.\n", "1.2 Merge Sort. Example (II)\n\nThis slide illustrates the merge sort algorithm with an example. The input is an unsorted list of numbers: 80, 95, 14, 98, 29, 49, 66. The algorithm recursively divides the list into smaller sub-lists until each sub-list contains only one element. Then, it repeatedly merges the sub-lists in a sorted manner until a single sorted list is obtained. The diagram shows the intermediate steps of the merging process, where the numbers are combined into larger sorted sub-lists until the final sorted list is produced: 14, 29, 49, 66, 80, 95, 98. \n", "1.2 Merge Sort. Recursive division and merging with auxiliary array\n\nThe image describes the Merge Sort algorithm.\n\nThe first step is the recursive division of the array. Given an array, or part of it, defined by the first position \"l\", the last position \"r\" and the half position \"m\" which is equal to (l+r)/2, the array is divided recursively in two until l and r are equal. The two halves are \"from l to m\" and \"from m+1 to r\".\n\nThe second step is the sorting by merging subarrays. First, an auxiliary array is created containing the two subarrays to sort. Then, the elements of each subarray are compared to sort them. It is important to note that the elements are not in their final correct position until the merging of the subarray is finished. \n", "1.2 Merge Sort. Code (I)\n\nThis code snippet shows the implementation of the merge sort algorithm in an unspecified programming language. \n\nThe first function, `mergeSort`, takes an integer array `a` as input and calls the `mSort` function with the array, the index of the first element (0), and the index of the last element (a.length-1).\n\nThe `mSort` function recursively divides the input array into two halves until the base case is reached, which is when the left index `l` is greater than or equal to the right index `r`. In this case, the function returns without doing anything. Otherwise, it calculates the middle index `m`, recursively calls itself for the left and right halves of the array, and finally calls the `merge` function to merge the sorted halves.\n\nThe `merge` function, which is not shown in this code snippet, is responsible for merging the two sorted subarrays back into a single sorted array. \n", "1.2 Merge Sort. Code (II)\n\nThis slide titled \"1.2 Merge Sort. Code (II)\" shows a code snippet of the merge function in a merge sort algorithm. The function takes as input an array \"a\", and three integers: \"l\", \"m\", and \"r\". The code first checks if m+1 is greater than r, if so it returns. Otherwise, it creates a new array \"b\" of the same length as \"a\". The code then enters a for loop that iterates from 1 to m+1, copying the elements of \"a\" from index 1 to m into \"b\". Another for loop iterates from m+1 to r+1, copying the elements of \"a\" from index m+1 to r into \"b\" in reverse order. \n\nThere are three bullet points explaining the code:\n- The first bullet point states that the left subarray is copied as it is in the auxiliary array.\n- The second bullet point states that the right subarray is copied in the auxiliary array in reverse order.\n- The third bullet point states that the merging starts from the two ends of the auxiliary array, which contain the elements with the lowest values of each subarray.\n\nThe code then initializes two integer variables \"k\" and \"j\" to 1 and \"r\" respectively. A for loop then iterates from 1 to r+1, comparing the elements of \"b\" at indices \"k\" and \"j\". If the element at index \"k\" is less than or equal to the element at index \"j\", the element at index \"i\" of \"a\" is set to the element at index \"k\" of \"b\" and \"k\" is incremented. Otherwise, the element at index \"i\" of \"a\" is set to the element at index \"j\" of \"b\" and \"j\" is decremented.\n", "Exercise 2\n\nUsing the sorting algorithm Merge Sort, describe the process needed to sort the following array in ascending order. Unlike in other cases, with Merge Sort there are no swapping in the arrays, as we are using an auxiliary array. The array is: 7, 3, 13, 1, 11, 5. \n", "1.2 Merge Sort: Conclusions\n\nMerge sort has some advantages. It is efficient for arrays with many elements, even in the worst case. It has a time complexity of O(n log n). It is also highly parallelizable.\n\nMerge sort also has some drawbacks. It has complex code. It requires more memory space to store more auxiliary variables, for example, an auxiliary array. \n", "1.3 Quick Sort\n\nA numbered list describes the quick sort algorithm: \n1. Choose an element: the pivot\n2. Reorder the data structure so that:\n- elements lower than the pivot are on its left\n- elements higher than the pivot are on its right\n3. Sort recursively:\n- the part whose elements are lower than the pivot\n- the part whose elements are higher than the pivot\n\nTwo URLs are provided at the bottom of the slide. \n", "1.3 Quick Sort. Example (1)\n\nThe image describes the Quick Sort algorithm with an example.\n\nThe algorithm sorts an array of numbers in ascending order. The first step is to choose a pivot, in this case, the first element of the array, which is 80. Then, the algorithm iterates through the array from both ends, comparing each element with the pivot. If the element on the left is greater than the pivot, and the element on the right is smaller than the pivot, the two elements are swapped. The iteration continues until the two pointers meet. At this point, the pivot is in its final sorted position. The algorithm then recursively sorts the subarrays to the left and right of the pivot.\n\nThe example shows the first iteration of the Quick Sort algorithm on the array [80, 95, 14, 98, 29, 49, 66]. The pivot is 80. The algorithm first compares 95 and 66. Since 95 is greater than 80 and 66 is smaller than 80, they are swapped. The array becomes [80, 66, 14, 98, 29, 49, 95]. The algorithm then continues to iterate and compare the elements until the pointers meet. \n", "1.3 Quick Sort. Example (II)\n\nThe image illustrates an example of the Quick Sort algorithm. We have a list of numbers: 80, 66, 14, 98, 29, 49, and 95. The pivot is 80, which is the first element of the list. We compare each element of the list with the pivot. If the element is greater than the pivot, we move to the next element. If the element is smaller than the pivot, we swap it with the first element that is greater than the pivot. In this case, we swap 48 and 98. We repeat this process until the list is sorted. \n", "1.3 Quick Sort. Example (III)\n\nWe have two arrays of numbers. The first array is: 80, 66, 14, 49, 29, 98, 95. The pivot element is 80. After converging, 29 is less than 80, so we place the pivot in its correct location with a swap. The second array shows the result after the swap: 29, 66, 14, 49, 80, 98, 95. All the elements to the left of 80 are less than 80, and all the elements to the right of 80 are greater than 80. We repeat recursively for the left and right partitions. \n", "1.3 Quick Sort. Recursive partition and sorting by swapping\n\nQuick sort has two steps: recursive partition and sorting by swapping. \n\nThe first step, recursive partition, takes an array, or part of an array, with the first and last positions defined. An algorithm is run on the array to determine the partition, where elements on the left are lower than the pivot, and elements on the right are higher than the pivot. The next partition is then computed recursively.\n\nThe second step, sorting by swapping, involves moving forward from both the left and right of the array, comparing elements with the pivot, and swapping them as needed. Finally, the pivot is placed in its correct location.\n\nFinally, the algorithm notes that pivots are always placed in their final sorted position. \n", "1.3 Quick Sort. Code (I)\n\nThis code snippet presents a Java implementation of the Quick Sort algorithm. The first function `quickSort` takes an integer array `a` as input and calls the `qSort` function with the array, the starting index `0`, and the ending index `a.length-1`.\n\nThe `qSort` function implements the recursive part of the Quick Sort algorithm. It takes the array `a`, the starting index `l`, and the ending index `r` as input. It first checks if `l` is greater than or equal to `r`. If it is, it means the subarray has only one element or is empty, so it returns. Otherwise, it calls the `partition` function with the array, `l`, and `r` to partition the subarray around a pivot element. The `partition` function returns the index `m` of the pivot element. Finally, the `qSort` function recursively calls itself twice with the subarrays to the left and right of the pivot element: `qSort(a, l, m-1)` and `qSort(a, m+1, r)`. \n", "1.3 Quick Sort. Code (II)\n\nThe image shows code for a quicksort algorithm. The first function is called \"partition\" and takes an array of integers \"a\", an integer \"l\" and an integer \"r\" as input. It returns an integer. The function first initializes three integer variables: \"i\" to \"l+1\", \"j\" to \"r\" and \"p\" to \"a[l]\". The variable \"p\" represents the pivot element. The function then enters a while loop that continues as long as \"i\" is less than or equal to \"j\". Inside the loop, the function compares the value of the element at index \"i\" with the pivot element \"p\". If the value of the element at index \"i\" is less than or equal to \"p\", the value of \"i\" is incremented by 1. Otherwise, if the value of the element at index \"j\" is greater than \"p\", the value of \"j\" is decremented by 1. If neither of these conditions is true, the function calls the \"swap\" function with the array \"a\", \"i\" and \"j\" as input. This function swaps the values of the elements at indices \"i\" and \"j\" in the array \"a\". After the while loop, the function calls the \"swap\" function again with the array \"a\", \"l\" and \"j\" as input. This swaps the pivot element with the element at index \"j\". Finally, the function returns the value of \"j\".\n\nThe second function is called \"swap\" and takes an array of integers \"a\", an integer \"i\" and an integer \"j\" as input. It does not return any value. The function first initializes an integer variable \"aux\" to the value of the element at index \"i\" in the array \"a\". Then, the function assigns the value of the element at index \"j\" to the element at index \"i\". Finally, the function assigns the value of \"aux\" to the element at index \"j\". This effectively swaps the values of the elements at indices \"i\" and \"j\" in the array \"a\".\n\nThere are two bullet points describing the code. The first bullet point states that the code compares elements with the pivot element \"a[i]\". When the code finds an element higher than \"a[i]\" on the left side of the pivot and an element lower than \"a[i]\" on the right side of the pivot, it swaps these two elements. The second bullet point states that before finishing, the pivot must be placed in its correct location by swapping the pivot element with the element at index \"j\". \n", "Exercise 3\n\nUsing the sorting algorithm Quick Sort, how many swaps are needed to sort the following array from the lowest element to the highest element (ascending order)?\n\nThe array is: 7, 3, 13, 1, 11, 5. \n", "1.3 Quick Sort: Conclusions\n\nLet's talk about the advantages and drawbacks of using the Quick Sort algorithm.\n\nSome of the advantages are: it is very efficient for arrays with many elements, its time complexity is Big O of n log n, it requires little additional memory, and it is highly parallelizable.\n\nHowever, one of the drawbacks is that the code is complex.\n", "Comparison\n\nThis slide compares the performance of different sorting algorithms: Insertion, Selection, Bubble, Shell, Merge, Heap, Quick, and Quick3. Each algorithm is tested on five different types of input data: Random, Nearly Sorted, Reversed, Few Unique, and a control group. The performance of each algorithm is visualized using bar graphs, with the length of the bar representing the time taken to sort the data. \n", "Comparison\n\nThere are two types of sorting algorithms: basic algorithms and advanced algorithms. Basic algorithms include bubble sort, insertion sort, and selection sort. These algorithms have an average complexity of O(n^2) and are inefficient with many elements. However, they are simple to code and use little memory. Advanced algorithms include heap sort, merge sort, and quick sort. These algorithms have an average complexity of O(n log n) and are efficient with many elements. However, they are more complex to code. With the exception of merge sort, they use little memory. \n"]}, {"filename": "4 en.pptx.pdf", "text": "0\n4\n3\n0\n1\n4\n5\n4\n4\n0\n2\n/\nn\ne\nl\no\nc\nn\na\na\ni\nt\ns\ni\nr\nh\nc\n/\ns\no\nt\no\nh\np\n/\nm\no\nc\n.\nr\nk\nc\ni\nl\nf\n.\nw\nw\nw\n\nRepresentation of\nData and Programs\n\nCarlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n2018-02-08\n\n2\n\nOverview\n\n1. Representation of Data\n\n\u00b4 Binary representation\n\n\u00b4 Weight systems\n\n\u00b4 Data types in Java\n\n2. Representation of Programs\n\n\u00b4 Interpretation and compilation\n\n\u00b4 Java Virtual Machine\n\n\u00b4 Programs and processes\n\n1\n\n\f3\n\n4\n\n1. Representation of Data\n\nFlip Flop\n\ninput\n\nset (to 1)\n\nreset (to 0)\n\noutput (0 or 1)\n\n2\n\n\f5\n\nBinary, Boolean\n\nset (to 1)\n\nreset (to 0)\n\nset (to 1)\n\nreset (to 0)\n\n1\n\n0\n\ntrue\n\nfalse\n\n6\n\nBinary, Boolean\n\n22=4 combinations\n\n0      0     1   1\n\n0      1     0      1\n\nset (to 1)\n\nreset (to 0)\n\nset (to 1)\n\nreset (to 0)\n\n3\n\n\f7\n\nByte\n\n00000000\n\n00000001\n\n00000010\n\n00000011\n\n00000100\n\n\u2026\n\n11111110\n\n11111111\n\n28 = 256\ncombinations\n\n8\n\nNatural Numbers from 0 to 255\n\n00000000\n\n\u2026\n\n00000010\n\n00000011\n\n00000100\n\n\u2026\n\n11111110\n\n11111111\n\n0\n\n65\n\n66\n\n67\n\n254\n\n255\n\n4\n\n\f9\n\nRed Levels\n\n00000000\n\n\u2026\n\n00000010\n\n00000011\n\n00000100\n\n\u2026\n\n11111110\n\n11111111\n\n10\n\nCharacters\n\n00000000\n\n(special symbol)\n\n\u2026\n\n00000010\n\n00000011\n\n00000100\n\n\u2026\n\n11111110\n\n11111111\n\nA\n\nB\n\nC\n\nn\n\n(special symbol)\n\n5\n\n\f11\n\nWeight System (Decimal)\n\nBase 10\n\n972 = 9*102 + 7*101 + 2*100\n\n9\t*\n\n100\n\n+\t7\t*\n\n10\n\n+\t2\t*\n\n1\n\n10 Decimal Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\n12\n\nWeight System (Binary)\n\nBase 2\n\n101 = 1*22 + 0*21 + 1*20\n\n1\t*\n\n+\t0\t*\n\n+\t1\t*\n\n2 Binary Digits (Bits): 0, 1\n\n6\n\n\f13\n\nNatural Numbers from 0 to 255\n\n00000000\n\n00000001\n\n\u2026\n\n01111111\n\n10000000\n\n\u2026\n\n11111110\n\n11111111\n\n0\n\n1\n\n127\n\n128\n\n254\n\n255\n\n28 = 256\ncombinations\n\n14\n\nIntegers from -128 to 127\n\n2's \ncomple-\nment\n\n28 = 256\ncombinations\n\n00000000\n\n00000001\n\n0\n\n1\n\n\u2026\n\n01111111 127\n\n10000000 -128\n\n\u2026\n\n11111110\n\n11111111\n\n-2\n\n-1\n\n7\n\n\f15\n\nJava Data Types for Integers\n\nbyte\n\n8 bits: -128..127\n\nshort\n\n16 bits: -32,768..32,767\n\nint\n\n32 bits: -231..231-1\n\nlong\n\n64 bits: -263..263-1\n\n16\n\nJava Data Types for Reals\n\nfloat\n\nsingle-precision 32-bit\nIEEE 754 floating point\n\ndouble\n\ndouble-precision 64-bit\nIEEE 754 floating point\n\n8\n\n\f17\n\nPrimitive Data Types\n\nboolean\n\nchar\n\nbyte\n\nshort\n\nint\n\nlong\n\nfloat\n\ndouble\n\nintegers\n\nreals\n\n18\n\nPlay with Unsigned & Signed Integers\n\n\u00b4 2.3.3 and 2.3.4\n\n9\n\n\f2. Representation\nof Programs\n\n19\n\n20\n\nEdition and Execution together\n\n10\n\n\f21\n\nEdition and Execution separated\n\nExecution\n\n256\n\nEdition\n\n22\n\nInterpretation\n\ninput\n\nInterpretation\n\noutput\n\nprogram\n\n11\n\n\f23\n\nCompilation\n\ninput\n\nCompi-\nlation\n\nexecutable\n\nExecu-\ntion\n\noutput\n\nPro-\nprogram\ngram\n\n24\n\nCompilation\n\ninput\n\nCompi-\nlation\n\nmachine code\n\nExecu-\ntion\n\noutput\n\nsource\nPro-\ncode\ngram\n\n12\n\n\f25\n\nJava Virtual Machine\n\ninput\n\nCompi-\nlation\n\nbyte code\n\nJVM\n\nmachine code\n\nExecu-\ntion\n\noutput\n\nsource\nPro-\ncode\ngram\n\nclass\nlibrarie\ns\n\nJRE\n\n26\n\nJava Virtual Machine\n\ninput\n\nCompi-\nlation\n\nbyte code\n\nJVM\n\nmachine code\n\nsource\nPro-\ncode\ngram\n\nclass\nlibra-\nries\n\nJRE\n\nWORA\n\nExecu-\ntion\n\noutput\n\nExecu-\ntion\n\noutput\n\nExecu-\ntion\n\noutput\n\n13\n\n\f27\n\nJava Development Kit\n\ninput\n\nCompi-\nlation\n\nbyte code\n\nJVM\n\nmachine code\n\nExecu-\ntion\n\noutput\n\nsource\nPro-\ncode\ngram\n\nclass\nlibra-\nries\n\nJRE\n\nJDK\n\nProgram\n\npublic class HelloWorld {\n\npublic static void main(String[] args) {\nSystem.out.println(\"Hello, World!\");\n\n}\n\n}\n\n14\n\n\fProgram as Data\n\npublic class HelloWorld {\n\npublic static void main(String[] args) {\nSystem.out.println(\"Hello, World!\");\n\n}\n\n}\n\ncompiler\n\n1010001001001001001001001001001010101010101\n0011001010010010010010001001001001000101101\n1010101010111010100010101001000100100100100\n1001001010100101000100001001000100100101001\n\nProgram as Instructions\n\npublic class HelloWorld {\n\npublic static void main(String[] args) {\nSystem.out.println(\"Hello, World!\");\n\n}\n\n}\n\ncomputer\n\nHello, World!\n\n15\n\n\fSecondary storage\n\nPrimary storage\n\n254\nx\n255\ny\n256\nz\n\nrun\n\nget\n\nset\n\nload\n\noutput\n\ninput\n\nI/O devices\n\nProcessing unit\n\n16\n\n\f", "pages_description": ["Slide 3\n\n1. Representation of Data\n\nSlide 4\n\nFlip Flop\n\nThe image shows a diagram of a flip flop, with two inputs and one output. The first input is labeled \"set (to 1)\" and the second input is labeled \"reset (to 0)\". The output is labeled \"output (0 or 1)\". \n", "Binary, Boolean\n\nThe slide shows the concept of binary values and their relation to boolean values.\n\nA binary value can be either 0 or 1. In this example, the value 1 is associated with the boolean value \"true\" and is represented by a lit light bulb. The value 0 is associated with the boolean value \"false\" and is represented by an unlit light bulb.\n\nThe slide also shows that with 2 bits, we can have 2^2=4 combinations, which are: 00, 01, 10, and 11. These combinations are represented in a table with two rows and four columns. Each column represents a different combination of the two bits. \n", "Slide 7: Byte\n\nThis slide explains the concept of a byte. It shows a list of binary numbers, from 00000000 to 11111111, and mentions that a byte, which consists of 8 bits, can have 2\u2078 = 256 different combinations.\n\nSlide 8: Natural Numbers from 0 to 255\n\nThis slide shows how natural numbers from 0 to 255 can be represented in binary format using a byte. It presents a list of binary numbers and their corresponding decimal values. For example, 00000000 corresponds to 0, 00000010 corresponds to 65, and so on, up to 11111111, which corresponds to 255. \n", "Red Levels\n\nThis slide describes how to encode characters using red levels.  The special symbol is encoded with all zeros and the color black.  A is encoded with 00000010 and a dark shade of red. B is encoded with 00000011 and a slightly lighter shade of red. C is encoded with 00000100 and an even lighter shade of red. Another special symbol is encoded with 11111110 and a light shade of red.  The final special symbol is encoded with 11111111 and the lightest shade of red. \n", "**Weight System (Decimal)**\n\nThis slide explains the weight system in the decimal system, or base 10. It shows the equation 972 = 9*10<sup>2</sup> + 7*10<sup>1</sup> + 2*10<sup>0</sup>. There are three bags illustrated below the equation. The first bag on the left has the number 100 on it and has many colorful balls in it, representing the first part of the equation, 9 * 100. The second bag has the number 10 on it and has 7 red balls in it, representing 7 * 10. The third bag has the number 1 on it and has 2 red balls in it, representing 2 * 1. Below the bags is the text \"10 Decimal Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\".\n\n**Weight System (Binary)**\n\nThis slide explains the weight system in the binary system, or base 2. It shows the equation 101 = 1*2<sup>2</sup> + 0*2<sup>1</sup> + 1*2<sup>0</sup>. There are three bags illustrated below the equation. The first bag on the left has 4 balls in it: one blue, one black, one purple, and one red, representing the first part of the equation, 1 * 1. The second bag has 2 yellow balls in it, representing 0 * 1. The third bag has 1 red ball in it, representing 1 * 1. Below the bags is the text \"2 Binary Digits (Bits): 0, 1\". \n", "Natural Numbers from 0 to 255\n\nThis slide describes how natural numbers from 0 to 255 are represented in computer memory. It shows a table with binary numbers and their decimal representation. The first row shows the binary number 00000000 which corresponds to the decimal number 0. The second row shows the binary number 00000001 which corresponds to the decimal number 1. The third row shows the binary number 01111111 which corresponds to the decimal number 127. The fourth row shows the binary number 10000000 which corresponds to the decimal number 128. The fifth row shows the binary number 11111110 which corresponds to the decimal number 254. The sixth row shows the binary number 11111111 which corresponds to the decimal number 255. The slide also shows that 2 to the power of 8 equals 256, which is the number of possible combinations of 8 bits.\n\nIntegers from -128 to 127\n\nThis slide describes how integers from -128 to 127 are represented in computer memory using two's complement. It shows a table with binary numbers and their decimal representation. The first row shows the binary number 00000000 which corresponds to the decimal number 0. The second row shows the binary number 00000001 which corresponds to the decimal number 1. The third row shows the binary number 01111111 which corresponds to the decimal number 127. The fourth row shows the binary number 10000000 which corresponds to the decimal number -128. The fifth row shows the binary number 11111110 which corresponds to the decimal number -2. The sixth row shows the binary number 11111111 which corresponds to the decimal number -1. The slide also shows that 2 to the power of 8 equals 256, which is the number of possible combinations of 8 bits. A callout mentions \"2's complement\".\n", "Java Data Types for Integers\n\nThis slide describes the Java data types for integers. \n\n- byte: 8 bits, ranging from -128 to 127\n- short: 16 bits, ranging from -32,768 to 32,767\n- int: 32 bits, ranging from -2<sup>31</sup> to 2<sup>31</sup>-1\n- long: 64 bits, ranging from -2<sup>63</sup> to 2<sup>63</sup>-1\n\nJava Data Types for Reals\n\nThis slide describes the Java data types for reals.\n\n- float: single-precision 32-bit IEEE 754 floating point\n- double: double-precision 64-bit IEEE 754 floating point\n", "Primitive Data Types\n\nA list of primitive data types is presented, separated in two groups: integers and reals. The integers are: byte, short, int, long. The reals are: float, double.  In addition to those two groups, there are also the char and boolean primitive data types.\n\nPlay with Unsigned & Signed Integers\n\nThis slide explains how to convert between decimal and binary numbers. It shows the place values for each digit in a binary number, which are powers of 2 (2^7, 2^6, 2^5, etc.). It also shows the place values for each digit in a decimal number, which are powers of 10 (10^2, 10^1, 10^0). \n", "Slide 1: 2. Representation of Programs\n\nSlide 2: Edition and Execution together\n\nThe slide shows a calculator with a hand pressing the \"2\" key. Above the calculator, there is a piece of paper with the number \"153\" printed on it, and an arrow pointing down towards the calculator. Below the calculator, there is another piece of paper with the numbers \"153\" and \"2\" printed on it, separated by a horizontal line, and an arrow pointing up from the calculator. \n", "Slide 21: Edition and Execution separated\n\nThis slide explains the concepts of edition and execution.\nThere are two columns, one for edition and one for execution.\nIn the edition column, we see a hand using a calculator to enter the numbers 153 and 2.\nAn upwards arrow indicates that the result of this edition will be used as input for the execution.\nIn the execution column, we see a point-of-sale terminal displaying the number 256, which is the result of 153 to the power of 2.\nAn arrow indicates that the input of the execution is 153 to the power of 2.\n\nSlide 22: Interpretation\n\nThis slide shows a diagram explaining the concept of interpretation.\nThe diagram shows a left-to-right flow going through three boxes, respectively labeled \"input\", \"interpretation\" and \"output\".\nThe \"interpretation\" box has an upwards arrow pointing to a box labeled \"program\". \n", "Compilation\n\nThe first diagram shows the process of compilation. The input is a program, which is fed into the compilation stage. The output of the compilation stage is an executable. The executable is then fed into the execution stage, which produces the output.\n\nThe second diagram shows the same process, but with more detail. The input is now labeled as source code. The compilation stage now produces machine code, which is then fed into the execution stage. \n", "Java Virtual Machine\n\nThe first diagram shows the process of running a Java program. The source code is first compiled into byte code. The byte code is then executed by the Java Virtual Machine (JVM). The JVM uses the class libraries to execute the byte code. The output of the program is then displayed.\n\nThe second diagram shows the same process, but with the addition of the Write Once Run Anywhere (WORA) principle. WORA means that a Java program can be compiled on one platform and then run on any other platform that has a JVM. This is possible because the byte code is platform-independent. The second diagram shows that the same byte code can be executed on multiple platforms, each with its own JVM and machine code.\n", "Java Development Kit\n\nThe diagram shows the process of compiling and executing a Java program. The input source code is compiled into byte code. The byte code is then executed by the Java Virtual Machine (JVM). The JVM uses class libraries to execute the byte code and produces output. The Java Development Kit (JDK) includes the compiler and the JRE. The JRE includes the JVM and class libraries.\n\nThe code snippet is a simple Java program that prints the text \"Hello, World!\" to the console. The program consists of a single class called \"HelloWorld\" with a main method. The main method is the entry point for the program and is executed when the program is run. The System.out.println() method is used to print the text \"Hello, World!\" to the console. \n", "**Program as Data**\n\nWe see a snippet of Java code defining a class called \"HelloWorld\". This class has a main method that prints the text \"Hello, World!\" to the console.\n\nBelow the code, there is a red arrow pointing to a box containing a sequence of 0s and 1s. This represents the compiled form of the Java code, where the program exists as data.\n\n**Program as Instructions**\n\nThe second part shows the same Java code snippet as before. This time, a red arrow labeled \"computer\" points to a box containing the output of the program, which is the text \"Hello, World!\".\n\nThis part illustrates that when the compiled program (the 0s and 1s) is executed by the computer, it acts as a set of instructions, leading to the desired output. \n", "The image shows a diagram representing the interaction between secondary storage, primary storage, the processing unit, and I/O devices.\n\nStarting with secondary storage, represented as a blue square containing a green circle, data is loaded into primary storage, another blue square with a green circle, labeled as \"load\". Primary storage contains three memory locations: 254, 255, and 256. The processing unit, depicted as a blue rectangle, interacts with primary storage through three operations: \"run,\" \"get,\" and \"set.\" The processing unit receives input from and sends output to I/O devices, which include a smartphone, a printer, and a keyboard.\n\nThe image also includes two smartphone screens displaying various applications, including contacts, educational content, and utility apps. \n"]}, {"filename": "2 en.pptx.pdf", "text": "Conditionals\n\nCarlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n2018-02-01\n\nSummary\n\n1. Conditional statement\n\n\u00b4 if\n\n2. Alternative\n\u00b4 else\n\n3. Conditional expression\n\n\u00b4 ? :\n\n4. Expressions and statements for assignment\n\n\u00b4 x++\n\n1\n\n\f1. Conditional Statement\n\nConditional Statement\n\n\u2026\n\u2026\nif (n<0) n=-n;\n\u2026\n\u2026\n\n2\n\n\fConditional Statement\n\n\u2026\n\u2026\nif (n<0) n=-n;\n\u2026\n\u2026\n\nn\n\n-3\n\n3\n\nConditional Statement\n\n\u2026\n\u2026\nif (n<0) n=-n;\n\u2026\n\u2026\n\nn\n\n3\n\n3\n\n3\n\n\fConditional Statement\n\n\u2026\n\u2026\nif (n<0) {\nn=-n;\nx=0;\n\n}\n\u2026\n\u2026\n\nn\n-3\n\n3\n3\n3\n\nx\n1\n\n1\n0\n0\n\nConditional Statement\n\n\u2026\n\u2026\nif (n<0) {\nn=-n;\n\n}\n\u2026\n\u2026\n\n4\n\n\fConditional Statement\n\n\u2026\n\u2026\nif (n<0); {\n\nn=-n;\n\n}\n\u2026\n\u2026\n\nConditional Statement\n\nif (Boolean Expression) {\n\nStatements;\n\n}\n\n5\n\n\f2. Alternative\n\nAlternative\n\n\u2026\nif (n<0) {\nx=-n;\n\nn\n-3\n\nx\n\n3\n\nn\n3\n\n}\nelse {\nx=n;\n\n}\n\u2026\n\n-3\n\n3\n\n3\n\nx\n\n3\n3\n\n6\n\n\fAlternative\n\n\u2026\nif (n<0) {\n\nx=-n; s=\"n<0\"; b=true;\n\n}\nelse {\n\nx=n; s=\"n>=0\"; b=false;\n\n}\n\u2026\n\nNested Conditionals\n\nif (n<0) {\n\nx=-n; s=\"n<0\";\n\n}\nelse {\n\nn<0\n\nif (n==0) {\n\nx=0; s=\"n==0\";\n\n!(n<0)&&(n==0)\n\n}\nelse {\n\nx=n; s=\"n>0\";\n\n}\n\n}\n\n!(n<0)&&!(n==0)\n\n7\n\n\fNested Conditionals\n\nif (n<0) {\n\nx=-n; s=\"n<0\";\n} else if (n==0) {\nx=0; s=\"n==0\";\n\n} else {\n\nx=n; s=\"n>0\";\n\n}\n\nn<0\n\n!(n<0)&&(n==0)\n\n!(n<0)&&!(n==0)\n\nNested Conditionals\n\nif (n<0) {\n\nx=-n; s=\"n<0\";\n} else if (n==0) {\nx=0; s=\"n==0\";\n} else if (n<5) {\nx=n; s=\"0<n<5\"\n\n} else {\n\nx=n; s=\"n>=5\";\n\n}\n\nn<0\n\n!(n<0)&&(n==0)\n\n!(n<0)&&!(n==0) \n&&(n<5)\n\n!(n<0)&&!(n==0) \n&&!(n<5)\n\n8\n\n\fNested Conditionals\n\nif (n<0) {\n\nx=-n; s=\"n<0\";\n} else if (n==0) {\nx=0; s=\"n==0\";\n} else if (n<5) {\nx=n; s=\"0<n<5\"\n\n} else {\n\nx=n; s=\"n>=5\";\n\n}\n\nn<0\n\nn==0\n\n(0<n)&&(n<5)\n\nn>=5\n\nif (n<0) {\nx=-n;\n\n}\nelse {\nx=n;\n\n}\n\nif (n<0) {\nx=-n;\n\n}\nelse if (n==0) {\n\nx=0;\n\n}\nelse {\nx=n;\n\n}\n\n9\n\n\f3. Conditional Expression\n\nExpression with Ternary Operator\n\nBoolean Expression ? Expression : Expression\n\n(n>0) ? 1 : 2\n\nHas to be boolean type\n\nArbitrary but same type\nArbitrary but same type\n\n10\n\n\fExpression with Ternary Operator\n\nBoolean Expression ? Expression : Expression\n\n(n>0) ? 1 : 2\n\n(true) ? 1 : 2     1\n\n(false) ? 1 : 2\n\n4\n4\n\nExample: Absolute Value\n\nint x=\u2026;\n\nint absx = (x>0) ? x : -x;\n\nabsx is always non-negative,\nit is the absolute value of x.\n\n2\n\n11\n\n\fExample: Absolute Value\n\nabsx = (x>0) ? x : -x;\n\nis equivalent to\n\nif (x>0) absx=x; else absx=-x;\n\nConditional Statement and \nConditional Expression\n\nif (b) {x=m;}\nelse {x=n;}\n\nx=\n\n(b) ? m : n\n\n;\n\nConditional Statement\n\nConditional Expression\n\n12\n\n\fNever-ending Computations\n\n(true)  ? 1 : never-end\n(false) ? 1 : never-end\n\n1\nnever-end\n\n(true)  ? never-end : 2   never-end\n(false) ? never-end : 2          2\n\nnever-end ? 1 : 2         never-end\n\n4\n4\n4\n4\n4\n\nif (b==true) {S1;} else {S2;}\n\nif (b)       {S1;} else {S2;}\n\n13\n\n\fif (b==false) {S1;} else {S2;}\n\nif (!b)       {S1;} else {S2;}\n\nif (b) \n\n{S2;} else {S1;}\n\nb\n\nb ? true : false\n\nb\n\n14\n\n\fb\n\nb ? false : true\n\n!b\n\nc\n\nb\n\nb ? c : false\n\nb && c\n\n15\n\n\fc\n\nb\n\nb ? true : c\n\nb || c\n\n4. Expressions and Statements\nfor Assignment\n\n16\n\n\fExpressions and Statements\n\n\u00b4Assume x=3\n\n\u00b4Expression\n\nx+2\n\n\u00b4Statement\n\n5\n\nx\n\nx=x+1;\n\n3\n\n4\n\nExpressions and Statements\n\n\u00b4Assume x=3\n\n\u00b4Expression\n\nx+2\n\n\u00b4Statement\n\n5\n\nx\n\nx=x+1;\n\n3\n\n4\n\nEvaluates\n(has a value)\n\nProduces an effect\n(does something)\n\n17\n\n\fStatement with Value?\n\n4\n\nx=x+1;\n\ny=x=x+1;\n\ny=(x=x+1);\n\n4\n\nx\n\n3\n\n4\n\nx=x+1;\ny=x;\n\nIncrement x\n\nx = x+1;\n\nx += 1;\n\nx += 1;\nx -= 2;\nx *= 3;\nx /= 4;\nx %= 5;\n\n18\n\n\fIncrement x by 1\n\nx = x+1;\n\nx += 1;\n\n++x;\n\nx++;\n\nx\n\n3\n\n4\n\n(prefix)\n\n(postfix)\n\nIncrement x by 1\n\nx = x+1;\n\nx += 1;\n\n4\n\n3\n\n++x;\n\nx++;\n\n4\n\n4\n\n(prefix)\n\n(postfix)\n\nx\n\n3\n\n4\n\n19\n\n\fPre- and Post-fix Increment\n\nx\n3\n4\n5\n\nx=3;\n\ny=++x; \nz=x++; \n\ny\n\n4\n\nz\n\n4\n\nx=3;\n\nx=x+1; y=x;\nz=x; x=x+1;\n\nSummary\n\n\u00b4Expression: has value\n\n\u00b4Statement: does sth (changes state)\n\n++x; value after increment\nx++; value before increment\n\n20\n\n\f", "pages_description": ["1. Conditional Statement\n\nConditional Statement\n- if n is less than 0, then n equals negative n. \n", "Conditional Statement\n\nWe have a table with one column and three rows. The header of the column is \"n\". The first row contains the value \"-3\". The second row is empty. The third row contains the value \"3\".\n\nWe also have a conditional statement: if n is less than 0, then n is equal to -n.\n\nConditional Statement\n\nWe have a table with one column and three rows. The header of the column is \"n\". The first row contains the value \"3\". The second row is empty. The third row contains the value \"3\".\n\nWe also have a conditional statement: if n is less than 0, then n is equal to -n.\n", "Conditional Statement\n\nWe have a conditional statement and a table with two columns: n, x. The conditional statement says: if n is less than 0, then n becomes -n and x becomes 0. \n", "Slide 1: Conditional Statement\n\nWe have a code snippet showing an example of a conditional statement. The condition is \"if n is less than zero\" then we have a statement \"n equals minus n\". There is a warning sign next to the code snippet.\n\nSlide 2: Conditional Statement\n\nWe see a code snippet showing the generic syntax of a conditional statement. The statement is \"if Boolean Expression\" then we have \"statements\" in between curly brackets. \n", "2. Alternative\n\nThis slide explains an alternative way of writing a piece of code. On the left side of the slide, we see the code snippet:\n\n```\n...\nif (n<0) {\n  x=-n;\n}\nelse {\n  x=n;\n}\n...\n```\n\nThis code checks if the variable `n` is less than 0. If it is, then `x` is assigned the value of `-n`. Otherwise, `x` is assigned the value of `n`.\n\nOn the right side of the slide, we see two tables that visualize the execution of this code snippet. The first table shows the case where `n` is -3. In this case, the condition `n<0` is true, so the code inside the `if` block is executed. This means that `x` is assigned the value of `-(-3)`, which is 3.\n\nThe second table shows the case where `n` is 3. In this case, the condition `n<0` is false, so the code inside the `else` block is executed. This means that `x` is assigned the value of 3.\n", "Alternative\n\nThis slide shows two code snippets, both aiming to achieve the same result. \n\nThe first snippet uses an \"if\" statement followed by an \"else\" statement. If \"n\" is less than 0, \"x\" is assigned the negative value of \"n\", \"s\" is assigned the string \"n\\<0\", and \"b\" is assigned the boolean value \"true\". Otherwise, \"x\" is assigned the value of \"n\", \"s\" is assigned the string \"n>=0\", and \"b\" is assigned the boolean value \"false\".\n\nThe second snippet, titled \"Nested Conditionals\", aims to achieve the same outcome but uses nested conditionals. It starts with an \"if\" statement checking if \"n\" is less than 0. If true, it executes the same code as the first snippet's \"if\" block. The \"else\" block is left incomplete, marked by a red rectangle. Two speech bubbles offer potential conditions to complete the \"else\" block. The first bubble suggests \"!(n\\<0) && (n==0)\", while the second bubble proposes \"!(n\\<0) && !(n==0)\". Both options aim to cover the remaining scenarios where \"n\" is not less than 0. \n", "Nested Conditionals\n\nWe have some code snippets visualizing nested conditional statements. The first snippet has three branches. The first branch checks if 'n' is less than zero. If so, 'x' is assigned the negative value of 'n' and 's' is assigned the string \"n<0\". Otherwise, it moves to the next branch and checks if 'n' is equal to zero. If so, 'x' is assigned zero, and 's' is assigned the string \"n==0\". If none of the above conditions are met, the last branch assigns 'n' to 'x' and \"n>0\" to 's'.  The conditions that are not met in each branch are shown on the right side. For example, the condition not met in the second branch is \"not (n<0) and (n==0)\".\n\nThe second snippet has four branches. It has the same first two branches as the first snippet. The third branch checks if 'n' is less than 5. If so, 'x' is assigned 'n' and 's' is assigned the string \"0<n<5\". Otherwise, the final 'else' branch assigns 'n' to 'x' and \"n>=5\" to 's'. Similar to the first snippet, the conditions that are not met in each branch are shown on the right side. For example, the condition not met in the fourth branch is \"not (n<0) and not (n==0) and not (n<5)\". \n", "Nested Conditionals\n\nWe see two code snippets, both implementing the same logic in slightly different ways.\n\nThe first snippet uses a single `if` statement with nested `else if` and `else` blocks to handle different ranges of the variable `n`. \n\n- If `n` is less than 0, `x` is assigned the negative of `n` and `s` is assigned the string \"n<0\". \n- If `n` is equal to 0, `x` is assigned 0 and `s` is assigned the string \"n==0\". \n- If `n` is less than 5, `x` is assigned the value of `n` and `s` is assigned the string \"0<n<5\". \n- Finally, if none of the above conditions are met, meaning `n` is greater than or equal to 5, `x` is assigned the value of `n` and `s` is assigned the string \"n>=5\".\n\nThe second snippet refactors the logic into two separate `if-else` statements. \n\n- The first `if-else` statement checks if `n` is less than 0. If true, `x` is assigned the negative of `n`. Otherwise, `x` is assigned the value of `n`. \n- The second `if-else` statement is nested within the `else` block of the first statement and is only executed if `n` is not less than 0. This statement checks if `n` is equal to 0. If true, `x` is assigned 0. Otherwise, `x` is assigned the value of `n`.\n\nBoth snippets achieve the same result: assigning values to `x` and `s` based on the value of `n`. The first snippet is more compact, while the second snippet might be considered more readable due to its flatter structure.\n", "3. Conditional Expression\n\nThis slide explains conditional expressions with ternary operators. The syntax is: Boolean Expression question mark Expression colon Expression. For example, open parenthesis n greater than 0 close parenthesis question mark 1 colon 2. The first expression, in this case, open parenthesis n greater than 0 close parenthesis, has to be a Boolean type. The other two expressions, in this case, 1 and 2, can be of arbitrary type but must be the same type. \n", "Expression with Ternary Operator\n\nA ternary operator uses a boolean expression followed by a question mark, then an expression followed by a colon, and lastly another expression. If the boolean expression is true, the entire ternary operator evaluates to the first expression. If the boolean expression is false, the entire ternary operator evaluates to the second expression. For example, if n > 0, then the expression (n > 0) ? 1 : 2 evaluates to 1. If n is less than or equal to 0, the expression evaluates to 2.\n\nExample: Absolute Value\n\nWe can use the ternary operator to calculate the absolute value of a variable x. First, x is declared as an integer variable. Then, the variable absx is declared as an integer and assigned to the ternary operator (x > 0) ? x : -x. If x is greater than 0, then absx will take on the value of x. If x is less than or equal to 0, then absx will take on the value of -x. Therefore, absx will always be non-negative, and it will be the absolute value of x. \n", "Example: Absolute Value\n\nThe expression \"absx = (x greater than 0) ? x : -x;\" is equivalent to \"if (x greater than 0) absx=x; else absx=-x;\".\n\nConditional Statement and Conditional Expression\n\nThe conditional statement \"if (b) {x=m;} else {x=n;}\" is equivalent to the conditional expression \"x = (b) ? m : n;\". \n", "Never-ending Computations\n\nWe see a few conditional expressions that evaluate to never-ending computations. For example, \"never-end ? 1 : 2\" will result in a never-ending computation because \"never-end\" will never terminate, so the expression will never be able to evaluate to either 1 or 2.\n\nWe then see two conditional statements. The first statement checks if the variable \"b\" is equal to true. If it is, then the statement {S1} is executed. Otherwise, the statement {S2} is executed. The second statement is similar, but it only checks if the variable \"b\" is true. \n", "There are three different conditional statements that all result in the same logic. The first statement, \"if (b equals false) then {S1} else {S2}\" The second statement, \"if (not b) then {S1} else {S2;}\" The third statement, \"if (b) then {S2} else {S1;}\"  All three statements are logically equivalent and will execute the same code block based on the truth value of the boolean variable 'b'. \n", "There are two truth tables, one with one variable and one with two. The first table shows a single variable, b. The expression \"b?\" evaluates to false, while the expression \"!b\" evaluates to true. The second table shows two variables, b and c. The expression \"b?c\" evaluates to false, while the expression \"b&&c\" also evaluates to false. \n", "There are two code snippets, \"b ? true : c\" and \"b || c\".  The first snippet is a ternary operator that will evaluate to \"true\" if \"b\" is true, and \"c\" if \"b\" is false. The second snippet is a logical OR operator that will evaluate to \"true\" if either \"b\" or \"c\" is true.\n\n4. Expressions and Statements for Assignment \n", "Expressions and Statements\n\nWe are presented with information about expressions and statements.\n\nAn example of an expression is \"x+2\". Assuming that x equals 3, the expression evaluates to 5.\n\nAn example of a statement is \"x=x+1\". Assuming x equals 3, the statement produces an effect: it assigns the value 4 to x.\n\nExpressions and Statements\n\nWe are presented with information about expressions and statements.\n\nAn example of an expression is \"x+2\". Assuming that x equals 3, the expression evaluates to 5.\n\nAn example of a statement is \"x=x+1\". Assuming x equals 3, the statement produces an effect: it assigns the value 4 to x.\n", "Statement with Value?\n\nWe see four different statements, each assigned a number. The first statement is \"x equals x plus 1\". The second statement is \"y equals x equals x plus 1\". The third statement is \"x equals 3\". The fourth statement is a block containing two statements: \"x equals x plus 1\" and \"y equals x\".\n\nIncrement x\n\nWe see six different statements. The first statement is \"x equals x plus 1\". The second statement is \"x plus equals 1\". The third statement is \"x minus equals 2\". The fourth statement is \"x times equals 3\". The fifth statement is \"x divided equals 4\". The sixth statement is \"x modulo equals 5\". \n", "Increment x by 1\n\nThe first slide shows four ways to increment the value of a variable x by 1. The first two use the assignment operator, = and +=, while the last two use the increment operator, ++. The increment operator can be used as a prefix or postfix operator. When used as a prefix operator, the increment happens before the value of the variable is used in the expression. When used as a postfix operator, the increment happens after the value of the variable is used in the expression.\n\nThe second slide shows the values of x after each of the four increment operations is performed. The initial value of x is 3. After the first two increment operations, the value of x is 4. After the third increment operation, the value of x is 4 because the increment operator is used as a prefix operator. After the fourth increment operation, the value of x is 3 because the increment operator is used as a postfix operator.\n", "Pre- and Post-fix Increment\n\nWe have a table that shows the values of x, y, and z after executing different code snippets.\n\nOn the left-hand side, the code snippet is:\n- x is assigned the value 3\n- y is assigned the value of x incremented by 1 using the pre-increment operator\n- z is assigned the value of x incremented by 1 using the post-increment operator\n\nOn the right-hand side, the code snippet is:\n- x is assigned the value 3\n- x is incremented by 1\n- y is assigned the value of x\n- z is assigned the value of x\n- x is incremented by 1\n\nThe table shows the values of x, y, and z after each line of code is executed.\n\nSummary\n\n- An expression has a value.\n- A statement does something, which changes the state.\n\n++x: the value after increment\nx++: the value before increment\n"]}, {"filename": "1.pdf", "text": "public class HelloWorld {\n\npublic static void\n\nmain(String[] args) {\nSystem.out.println\n\n(\"Hello, World!\");\n\n}\n\n}\n\nFrom the Calculator\nto the Computer\n\nCarlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n2018-01-25\n\n2\n\nFrom the Calculator to the Computer\n\nValues\n\nExpressions\n\nStatements\n\nx=x\u00d712;\n\n3\n\nx\n\nset\n\nget\n\n\u2026and more\n\n1\n\n\f3\n\nOverview\n\n1.Values\n\n4.Programs\n\n2.Expressions\n\n5.Data Types\n\n3.Statements\n\n6.Identifiers\n\n4\n\n1. Display for Values\n\n2\n\n\f5\n\nValues\n\n\u00b4 For the moment, we will just consider numeric integer values\n\n\u00b4 They might consist of several digits and possibly a minus sign\n\n\u00b4 Examples:\n0\n-1\n36\n987654321\n\n6\n\n2. Display for Expressions\n\n3\n\n\f7\n\nExpressions\n\noperand\n\noperand\n\n3 * 12\n\noperator\n\n8\n\nExpressions\n\nexpression\n\nexpression\n\n(1 + 2) * 12\n\noperator\n\n4\n\n\f9\n\nExpressions (with Integers)\n\n1\n-1\n2-1\n7%3\n(3*4)+2\n\n32\n\u27139\n\nMath.pow(3,2)\nMath.sqrt(9)\n\nNeeds to be defined\n\n3!\n\nfac(3)\n\nInfix\nInfix\noperator\noperator\n\nPostfix\noperator\n\nPrefix\noperator\n\n10\n\nExpressions evaluate to a Value\n\n(3*4)+2\n3*(4+2)\n3*4+2\nfac(3)\nMath.pow(3,2)\n\n14\n18\n14\n6\n9\n\n5\n\n\f11\n\n3. Display for Statements\n\nx=x\u00d712;\n\n2\n\ny\n\n3\n\nx\n\nset\n\nget\n\nset\n\nget\n\n12\n\nVariables\n\n\u00b4 Now, we are able to buy extensions (memory cells) for our calculator\n\nthat are able to store a value for future usage\n\n\u00b4 Each memory cell comes with a predefined name\n\n\u00b4 We'll call each memory cell, a variable\n\n\u00b4 We can store a value in the variable (set)\n\nor retrieve the stored value (get)\n\n3\n\nx\n\nset\n\nget\n\n6\n\n\f13\n\nExpressions with Variables (get)\n\n\u00b4 To get the value stored you just write the name of the variable\n\n\u00b4 Assuming variable x is set to 3 and y is set to 2, evaluate these expressions\n\n(x*4)+2\n(x*4)+y\n(x*4)+(x-1)\n\n14\n\nVariable Assignment (set)\n\n\u00b4 To set a variable to a value,\n\nwe write the name of the variable followed by =,\nthen the expression the value of which we want to store and a semicolon\n\n\u00b4 This is not to be read as an equation to solve or equality to be computed!\n\n\u00b4 First evaluate the expression on the right,\n\nthen assign the value obtained to the variable on the left\nx=3;\ny=3*2;\n\ny=x*2;\nx=x*y;\n\n6\n\n7\n\n\f15\n\nStatement\n\n\u00b4 An assignment is not an expression, it is a statement\n\n(later on there will be some surprise)\n\n\u00b4 Statements have effects (on the set of values stored, the state)\ny\n\nx\n\nx\n\ny\n\nx\n\ny\n\n1\n\n1\n\nx=3;\n\n3\n\n1\n\n3\n\n1\n\n3\n\n6\n\nold\n\ny=x*2;\n\nx=x*y;\n\n3\n\n6\n\n18\n\n6\n\nnew\n\n16\n\nState Transformation\n\nu\n\n1\n\nv\n\n1\n\nw\n\n1\n\nx\n\n1\n\ny\n\n1\n\nz\n\n1\n\n1\n\n1\n\n2\n\n1\n\n1\n\n1\n\n1\n\n1\n\n2\n\n1\n\n1\n\n5\n\n1\n\n1\n\n2\n\n0\n\n1\n\n5\n\nw=2;\n\nz=u+v+w+x;\n\nx=x-y;\n\n8\n\n\f17\n\nDisplay for Statements\n\nx=x\u00d712;\n\n2\n\ny\n\n3\n\nx\n\nset\n\nget\n\nset\n\nget\n\n18\n\n4. Display\nfor Programs\n\nx=3;    \n\nx=x\u00d712;\n\nC ;\n\n7\n\n4\n\n1\n\n8\n\n5\n\n2\n\n0\n\n9\n\n6\n\n3\n\n.\n\n\u2044\n\n\u00d7\n\n\u2212\n\n+\n\n3\n\nx\n\nset\nget\n\n9\n\n\f19\n\n20\n\nProgram\n\n\u00b4 A program is a recorded computation\n\n\u00b4 It is a record of the computation\n\n\u00b4 It can be\n\n\u00b4 stored for later use,\n\n\u00b4 run several times,\n\n\u00b4 checked for correctness,\n\n\u00b4 modified, \u2026\n\n\u00b4 The program is the software,\nthe device, the hardware\n\n10\n\n\f21\n\nRecipe for\nSpanish Potato Omelet\n\nThe recipe\n(the program)\n\nThe result\n(the omelet)\n\n22\n\nInstructions to Draw a Triangle\n\nThe instructions\n(the program)\n\nThe result\n(the drawing)\n\n11\n\n\f23\n\nValue\n\nExpression\n\n7\n\n3 + 4\n\nStatement\n\nd = 3 + 4;\n\nProgram\n\nd = 2 \u2013 1;\nx = d;\nd = x * d;\nd = 3 + 4;\n\n24\n\n5. Data Types\n\n\u00b4 Arithmetic: Numbers (to be refined later)\n\n1 + 2\n\n\u00b4 Logic: Boolean values\n\n\u00b4 Text: Strings\n\ntrue && false\n\n\"he\" + \"llo\"\n\n12\n\n\f25\n\nArithmetic Calculator\n\n26\n\nLogic Calculator\n\nd =      0;\n\nC ;\n\n7\n\n4\n\n1\n\n8\n\n5\n\n2\n\n0\n\n9\n\n6\n\n3\n\n.\n\n\u2044\n\n*\n\n\u2212\n\n+\n\nd =  false;\n\nC ;\n\nT\n\nF\n\n&&\n\n||\n\n!\n\n13\n\n\f27\n\nBoolean Algebra\n\n\u00b4 Values\n\n\u00b4 true\n\n\u00b4 false\n\n\u00b4 Operations\n\n\u00b4 Negation (not): !\n\n\u00b4 Conjunction (logical and): &&\n\n\u00b4 Disjunction (logical or): ||\n\n28\n\nLogic Gates\n\n14\n\n\f29\n\nNegation (not)\n\n!a\n\n!true  equals false\n!false equals true\n\n30\n\nConjunction (logical and)\n\na && b\n\ntrue  && true   equals\ntrue\nequals false\ntrue  && false\nfalse && true   equals false\nequals false\nfalse && false\n\n15\n\n\f31\n\nDisjunction (logical or)\n\na || b\n\ntrue  || true   equals\nequals\ntrue  || false\nfalse || true   equals\nfalse || false\n\ntrue\nequals false\n\ntrue\ntrue\n\n32\n\nArithmetic & Logic\nCalculator\n\nC ;\n\nd =    0;\n\n9\n8\n7\n6\n5\n4\n1 2 3\n\n\u2044\n*\n\u2212\n. +\n\n0\n\nT\n\nF\n\n&&\n\n||\n\n!\n\n>=\n\n>\n\n==\n\n!=\n\n<=\n\n<\n\n16\n\n\f33\n\nComparison Operations\n\n\u00b4 n<m\n\u00b4 n>m\n\n\u00b4 n<=m\n\u00b4 n>=m\n\n\u00b4 n==m\n\u00b4 n!=m\n\n(less than, n<m)\n\n(greater than, n>m)\n\n(less or equal than, n\u2264m)\n\n(greater or equal than, n\u2265m)\n\n(equal than, n=m)\n\n(not equal than, n\u2260m)\n\n34\n\nFunctionality\n\n+:  x        \n\n+: (3, 4)      7\n&&: B x B     B\n\n&&: (true, false)     false\n\n>:     x        B\n\n>: (3, 4)     false\n\n17\n\n\f35\n\nText\n\nCharacters\n'a'\n\n'A'\n\n'1'\n'.'\n\n' '\n\nStrings\n\"Java\"\n\n\"Hello, World!\"\n\n\"2015\"\n\" \"\n\n\"\"\n\n36\n\nEscaping\n\n\"\\\"Hello\\\"\"\n\n\"Hello\\n\"\n\n\"\\\\ and \\\"\"\n\n18\n\n\f37\n\nIdentifiers and Strings\n\nString s = \"s\";\n\nIdentifier\n\nString\n\n38\n\nConcatenation\n\nString s = \"s\";\nString t = \"top\";\nString p = s + t;\nString q = t + s;\n\n\"stop\"\n\"tops\"\n\n19\n\n\f39\n\nConcatenation and Addition\n\nint\n\nn = 1;\n\nString s = \"1\";\n\nint m = n + n;\n\nString p = s + s;\n\nString q = s + n;\n\n2\n\n\"11\"\n\n\"11\"\n\n40\n\nLength\n\nString s = \"s\";\n\nString t = \"top\";\n\nString p = \"\";\n\nString q = \" \";\n\nint n = s.length();\n\nint m = t.length();\n\nint j = p.length();\n\nint k = q.length();\n\n1\n\n3\n\n0\n\n1\n\n20\n\n\f41\n\nSubstring\n\nString s = \"Hello!\";\n\nString t = s.substring(2,4); \"ll\"\n\nString p = s.substring(0,2); \"He\"\n\nString q = s.substring(2,6);\"llo!\"\n\nString r = s.substring(2);  \"llo!\"\n\n\"Hello!\"\n0  1  2  3  4  5\n\n42\n\nPrinting\n\nSystem.out.print(\u2026)\n\nSystem.out.println(\u2026)\n\n21\n\n\f43\n\n6. Identifiers (Freely Chosen Names)\nfor Variables\n\n3\n\nx\n\n3\n\nset\n\nget\n\nset\n\nget\n\n44\n\nDeclaration of Variables\n\nint number;\nint veryLongName;\n\nboolean b;\n\nString s;\n\n22\n\n\f45\n\nWhat are Legal Names?\n\nCorrect\n\nIncorrect\n\nint n;\n\nint _n;\n\nint n1;\n\nint int;\n\nint n?;\n\nint 1n;\n\nint noMore;\n\nint no More;\n\nint no; int more;\n\nint no; int no;\n\n46\n\nRecommendations for Names\n\nRecommended\n\nNot Recommended\n\nint average;\n\nint sjdflsJDJF;\n\nint finalBalance;\n\nint finalbalance;\n\nint ONE;\n\nint one;\n\nFor variables that are \nFor variables that are \nnot going to change\nnot going to change\n\n23\n\n\f47\n\nDeclaration and Assignment\n\nboolean b;\nint n;\n\nboolean b=true;\nint n=1;\n\nb=true;\nn=1;\n\nboolean b=1;\nint n=true;\n\n48\n\nSee you in the next class!\n\n\u00b4Remember\nto watch videos and \ndo exercises before\nyou come to class!\n\n24\n\n\f", "pages_description": ["Overview\n\nThe slide is titled \"Overview\" and lists six items: Values, Expressions, Statements, Programs, Data Types, and Identifiers.\n\n1. Display for Values\n\nThis slide shows a calculator with the number 36 in the display. \n", "Values\n\nThis slide introduces the concept of numeric integer values. \n- They can have multiple digits. \n- They can be positive or negative.\n\nExamples are provided: 0, -1, 36, 987654321\n\n2. Display for Expressions\n\nThis slide shows a basic calculator with the expression \"3 x 12\" in the display. \n", "Expressions\n\nIn the first expression, we have the operand 3, the operator \"*\", and the operand 12.\n\nIn the second expression, we have the expression \"(1 + 2)\", the operator \"*\", and the operand 12.\n", "Expressions (with Integers)\n\nThe image shows examples of expressions with integers and their values. In the first part, we see examples of expressions written in infix, postfix, and prefix notation. In the second part, we see a list of expressions and their corresponding values. For example, the expression (3*4)+2 evaluates to 14, the expression 3*(4+2) evaluates to 18, and so on. \n", "**3. Display for Statements**\n\nThe image shows a calculator with a display showing \"x=x*12;\". There are two memory cells labeled \"2 y\" and \"3 x\". The \"2 y\" memory cell has buttons labeled \"set\" and \"get\". The \"3 x\" memory cell also has buttons labeled \"set\" and \"get\".\n\n**Variables**\n\n- We can buy extensions (memory cells) for our calculator that are able to store a value for future usage.\n- Each memory cell comes with a predefined name.\n- We'll call each memory cell, a variable.\n- We can store a value in the variable (set) or retrieve the stored value (get).\n", "Expressions with Variables (get)\n\nThis slide introduces the concept of expressions with variables. It explains that to get the value stored in a variable, you simply need to write the name of the variable. Assuming that the variable \"x\" is set to 3 and \"y\" is set to 2, the slide presents three expressions for evaluation: \"(x * 4) + 2\", \"(x * 4) + y\", and \"(x * 4) + (x - 1)\".\n\nVariable Assignment (set)\n\nThis slide explains how to assign values to variables. It states that to set a variable to a value, you write the name of the variable followed by \"=\", then the expression whose value you want to store, and finally a semicolon. It emphasizes that this should not be interpreted as an equation to solve or an equality to be computed. The process involves first evaluating the expression on the right side and then assigning the obtained value to the variable on the left side. The slide provides three examples: \"x = 3;\", \"y = 3 * 2;\", and \"y = x * 2; x = x * y;\". In the second example, an arrow points to the number 6, indicating the result of the expression \"3 * 2\". \n", "**Statement**\n\nAn assignment is not an expression, it is a statement. Statements have effects on the set of values stored, called the state. \n\nFor example, if x and y both equal 1, then the statement x=3 will change the value of x to 3, while y remains equal to 1. If we then have the statement y=x*2, the value of y will change to 6, which is 3 multiplied by 2, while x remains equal to 3. Finally, if we have the statement x=x*y, the value of x will change to 18, which is 3 multiplied by 6, while the value of y remains at 6.\n\n**State Transformation**\n\nThere is a table with columns labeled u, v, w, x, y, and z. Each column has a value of 1 in the first row.\n\nThe first transformation we will make is w=2, which changes the value of w to 2 in the second row, while all other values remain at 1.\n\nThe second transformation is z=u+v+w+x, which changes the value of z to 5 in the third row, as this is the sum of u, v, w, and x in the second row. All other values remain the same as the second row.\n\nThe third transformation is x=x-y, which changes the value of x to 0 in the fourth row, as this is the difference between the values of x and y in the third row. All other values remain the same as the third row.\n", "Display for Statements\n\nThis slide shows a calculator with the statement \"x = x * 12\" displayed on the screen. The buttons \"2\", \"y\", \"set\", \"get\", \"3\", \"x\" are highlighted to illustrate the sequence of keys that need to be pressed to execute the statement. \n\nDisplay for Programs\n\nThis slide shows a calculator with the statements \"x = 3\" and \"x = x * 12\" displayed on the screen. The buttons \"3\", \"x\", \"set\", \"get\" are highlighted to illustrate the sequence of keys that need to be pressed to execute the program. \n", "There are two slides.\n\nThe first slide numbered 19 shows a calculator with two blue up arrows around it. The calculator displays the number 153 and then the number 2. A piece of paper is shown above the calculator with the same numbers 153 and 2 printed on it. Another piece of paper is shown below the calculator with the same numbers 153 and 2 printed on it.\n\nThe second slide numbered 20 is titled **Program**. It contains a definition of a computer program and an example of a simple program written in a C-like programming language.\n\nThe definition of a program lists the following points:\n- A program is a recorded computation\n- It is a record of the computation\n- It can be:\n  - stored for later use\n  - run several times\n  - checked for correctness\n  - modified\n- The program is the software, the device, the hardware\n\nThe example program shown in the slide is a function called `processData` that reads data using the function `getData` and then calls either the function `performOperation1` or `performOperation2` depending on whether the data is negative or not. The function `processData` repeats this process in a loop as long as there is more data to process, which is determined by the function `hasMoreData`.\n", "**Recipe for Spanish Potato Omelet**\n\nThe recipe for Spanish potato omelet lists the ingredients: 1lb/450g waxy potatoes, 1 large white/Spanish onion (optional), about 1 liter of oil (olive oil is best), 6 eggs, and a pinch of salt. \n\nThe procedure is as follows: Peel and slice the potatoes thinly. Meanwhile, heat the oil on low heat in a large saut\u00e9 pan. Add the potatoes to the pan and fry until soft and cooked through but not browned. Slice the onion thinly and fry lightly in a frying pan, stirring frequently for a few minutes or until sweet. Beat the eggs in a large bowl and add salt. Add the hot cooked potatoes and onion to the egg in the bowl, gently mix, and leave for five minutes. Drain the oil and reserve for another time. Pour the potatoes, onion, and egg mix back into the pan and cook for about 5 minutes on low heat. When the edge of the tortilla looks cooked, place a large, flat plate over the pan like a lid, put one hand on the plate to hold it in place, and turn the whole thing over. Check the pan, clean and scrape any bits that have stuck in the pan, and add a bit of oil if it is looking dry. Slide the omelet back into the pan to cook the bottom. Cook for another few minutes. Repeat the turning process a couple of times to make sure it is cooked evenly. Serve on a large plate, cut into wedges, and serve with more tapas. \n\nThere is an image of the finished omelet on the right side. \n\n**Instructions to Draw a Triangle**\n\nThe instructions to draw a triangle are presented as a code sequence. The code sequence consists of the following blocks: \"repeat 3\", \"move 100 steps\", \"wait 1 sec\", \"turn right 120 degrees\", and \"wait 1 sec\". \n\nThe output of the code sequence is shown in the image on the right side, which is a drawing of an equilateral triangle. \n", "There are four concepts being described: value, expression, statement, and program. A value is 7. An expression is 3 + 4. A statement is d = 3 + 4;. A program is d = 2 - 1; x = d; d = x * d; d = 3 + 4;\n\nThe next topic is data types, which include arithmetic, logic, and text. Arithmetic refers to numbers, and an example is 1 + 2. Logic refers to Boolean values, and an example is true and false. Text refers to strings, and an example is \"he\" + \"llo\". \n", "Arithmetic Calculator\nAn arithmetic calculator with a display showing \"d = 0;\". The calculator has buttons for digits 0-9, arithmetic operators for addition, subtraction, multiplication, and division, and buttons for \"C\" and \";\".\n\nLogic Calculator\nA logic calculator with a display showing \"d = false;\". The calculator has buttons for \"C\" and \";\", as well as buttons for logical operators \"&&\", \"||\", and \"!\". \n", "**Boolean Algebra**\n\n- Values: true, false\n- Operations: Negation (not): !, Conjunction (logical and): &&, Disjunction (logical or): ||\n\n**Logic Gates**\n\nThe first figure shows four truth tables for the following logical operations: AND, OR, XOR, and NOT. Each table lists the inputs x and y, and the output for each combination of inputs.\n\nThe second figure shows the logic gates corresponding to the truth tables in the first figure. The AND gate outputs a 1 only if both inputs are 1. The OR gate outputs a 1 if at least one input is 1. The XOR gate outputs a 1 if only one input is 1. The NOT gate outputs the opposite of its input.\n\nThe third figure shows the De Morgan equivalents of the AND and OR gates. The De Morgan's theorem states that the negation of a conjunction is the disjunction of the negations, and the negation of a disjunction is the conjunction of the negations.\n\nThe fourth figure shows the Venn diagrams for the AND and OR operations. In the AND diagram, the overlapping area represents the cases where both x and y are true. In the OR diagram, the shaded area represents the cases where either x or y is true, or both.\n", "Negation (not)\n\n- The negation of a boolean value 'a' is denoted by '! a'.\n- If 'a' is true, then '! a' is false.\n- If 'a' is false, then '! a' is true.\n\nConjunction (logical and)\n\n- The conjunction of two boolean values 'a' and 'b' is denoted by 'a && b'.\n- The conjunction is true only if both 'a' and 'b' are true.\n- In all other cases, the conjunction is false.\n- The truth table for conjunction is as follows:\n    - true && true equals true\n    - true && false equals false\n    - false && true equals false\n    - false && false equals false\n- There are three diagrams illustrating the concept of conjunction:\n    - The first diagram is a truth table for conjunction, with inputs 'x' and 'y' and output 'x\u2227y'.\n    - The second diagram shows a logic gate representation of conjunction, with inputs 'x' and 'y' and output 'x\u2227y'.\n    - The third diagram shows a Venn diagram representation of conjunction, with two overlapping circles representing 'x' and 'y' and the overlapping region representing 'x\u2227y'.\n", "**Disjunction (logical or)**\n\nThe image describes the disjunction operator, also known as the logical OR. It presents a truth table for the operator, which shows that the result of a disjunction is true if at least one of the operands is true. The result is false only if both operands are false.\n\n**Arithmetic & Logic Calculator**\n\nThe image shows a calculator with arithmetic and logic functions. The arithmetic functions include addition, subtraction, multiplication, and division. The logic functions include AND, OR, and NOT. The calculator also has a display that shows the current value. \n", "**Comparison Operations**\n\n- We have the less than operator, written as 'n' less than 'm'.\n- We have the greater than operator, written as 'n' greater than 'm'.\n- We have the less than or equal operator, written as 'n' less than or equal to 'm'.\n- We have the greater than or equal operator, written as 'n' greater than or equal to 'm'.\n- We have the equal operator, written as 'n' equal to 'm'.\n- And last, we have the not equal operator, written as 'n' not equal to 'm'.\n\n**Functionality**\n\n- The plus operator maps from the Cartesian product of the set of real numbers with itself to the set of real numbers. For example, 3 plus 4 maps to 7.\n- The logical and operator maps from the Cartesian product of the set of Boolean values with itself to the set of Boolean values. For example, true and false maps to false.\n- The greater than operator maps from the Cartesian product of the set of real numbers with itself to the set of Boolean values. For example, 3 greater than 4 maps to false.\n", "Text\n\nThis slide explains the concept of characters and strings.\nThere are examples of characters enclosed in single quotes like the letter a lowercase, the letter A uppercase, the number 1, and a single quote.\nThere are examples of strings enclosed in double quotes like the words Java, Hello, World, the number 2015, a single space, and an empty string.\n\nEscaping\n\nThis slide explains the concept of escaping characters in strings.\nThere are three examples, the first one shows how to escape a double quote inside a string, the second one shows how to escape a newline character, and the third one shows how to escape a backslash.\n", "Identifiers and Strings\n\nWe have a code snippet that shows how to declare a string variable in a program. The string variable 's' is assigned the value \"s\".\n\nConcatenation\n\nThis slide shows a code snippet that demonstrates string concatenation. We first declare and assign values to string variables 's' and 't'. Variable 's' is assigned the string \"s\" and variable 't' is assigned the string \"top\". We then create two new string variables 'p' and 'q' by concatenating the values of 's' and 't'. Variable 'p' is assigned the concatenated string \"stop\" which is the result of combining \"s\" and \"top\". Similarly, variable 'q' is assigned the concatenated string \"tops\" which is the result of combining \"top\" and \"s\". \n", "**Concatenation and Addition**\n\nWe have four variable declarations. Integer variable `n` is initialized to 1. String variable `s` is initialized to string \"1\". Integer variable `m` is initialized to the sum of `n` and `n`, which is 2. String variable `p` is initialized to the concatenation of `s` and `s`, which is \"11\". String variable `q` is initialized to the concatenation of `s` and `n`, which is \"11\".\n\n**Length**\n\nWe have four string variable declarations and four integer variable declarations. String variable `s` is initialized to string \"s\". String variable `t` is initialized to string \"top\". String variable `p` is initialized to an empty string. String variable `q` is initialized to a string containing a single space. Integer variable `n` is initialized to the length of `s`, which is 1. Integer variable `m` is initialized to the length of `t`, which is 3. Integer variable `j` is initialized to the length of `p`, which is 0. Integer variable `k` is initialized to the length of `q`, which is 1. \n", "Substring\n\nWe have a string \"Hello!\" and we are showing how to use the substring method to extract different parts of the string.\n\n- The first substring starts at index 2 and ends at index 4, resulting in \"11\".\n- The second substring starts at index 0 and ends at index 2, resulting in \"He\".\n- The third substring starts at index 2 and ends at index 6, resulting in \"llo!\".\n- The last substring starts at index 2 and continues until the end of the string, resulting in \"llo!\".\n\nPrinting\n\nThis slide focuses on printing in a programming context.\n\nIt presents two commonly used methods:\n\n- System.out.print: This method prints its arguments without appending a newline character.\n- System.out.println: This method prints its arguments and appends a newline character, moving the cursor to the beginning of the next line. \n", "Identifiers (Freely Chosen Names) for Variables\n\nWe have two diagrams representing variables. The first one is a variable named \"x\" containing the value \"3\". The second one is a variable with a longer name containing the value \"1\". Both variables can be set and retrieved using the corresponding buttons.\n\nDeclaration of Variables\n\nThere are four variable declarations: an integer variable named \"number\", an integer variable named \"veryLongName\", a boolean variable named \"b\", and a String variable named \"s\". Each declaration ends with a semicolon. \n", "What are Legal Names?\n\nHere are some examples of correct and incorrect variable names.\nCorrect variable names include: \"n\", \"_n\", \"n1\", \"noMore\", \"no\", and \"more\".\nIncorrect variable names include: \"int\", \"n?\", \"1n\", \"no More\", and two variables named \"no\".\n\nRecommendations for Names\n\nHere are some recommendations for variable names.\nRecommended variable names include: \"average\", \"finalBalance\", and \"ONE\".\nVariable names that are not recommended include: \"sjdflsJDJF\", \"finalbalance\", and \"one\".\nThe text \"For variables that are not going to change\" is pointing to the variable name \"ONE\".\n", "Declaration and Assignment\n\nWe see two columns of code, both showing examples of declaration and assignment. On the left side, we see the declaration of a boolean variable 'b' and an integer variable 'n'. Then, we see the assignment of the value 'true' to 'b' and the assignment of the value '1' to 'n'. On the right side, we see the declaration of a boolean variable 'b' and an integer variable 'n' with assignment of values in the same line. 'b' is assigned 'true' and 'n' is assigned '1'. The last two lines are crossed out. They show an attempt to assign the value '1' to the boolean 'b' and the value 'true' to the integer 'n', which is incorrect.\n\nSee you in the next class!\n\nRemember to watch videos and do exercises before you come to class!\n"]}, {"filename": "6 en.pdf", "text": "Recursion\n\nCarlos Delgado Kloos & Carlos Alario Hoyos\n\nUniversidad Carlos III de Madrid\n\n\f2\n\nSummary\n\n\u00b4 Partial functions\n\n\u00b4 Recursive methods\n\n\f3\n\nPartial Functions\n\n\f4\n\nTotal Function\n\nX   g Y\n\n\f5\n\nPartial Function\n\nX   g Y\n\n\f6\n\nTotal Function\n\nX'  g Y\n\n\f7\n\nMathematics and Programming\n\n\u00b4 In Mathematics,\n\nwe can freely finetune the sets\nin order to make the functions total\n\n\u00b4 In Programming,\n\nwith types instead of sets,\nwe cannot adjust the elements as we wish\n\n\f8\n\nSquare Root\n\nsqrt(4)\n\nUse\n\nDefinition\ndouble sqrt (int x)\n\n{\n\n}\n\nreturn \u2026;\n\nint\n\nx\nsqrt\nsquare\nx*x\n\ndouble\n\n\f9\n\nSquare Root\n\nsqrt(-4)\n\nUse\n\nDefinition\ndouble sqrt (int x)\n\n{\n\n}\n\nreturn \u2026;\n\nint\n\nx\nsqrt\nsquare\nx*x\n\ndouble\n\n\f10\n\nSquare Root: Partial Definition\n\nNot defined\n\nDefined\n\ng\n\n\f11\n\nWhat to do when a method is called\nwith a value for which there is no image?\n\n1. Expect an error!\n\n\u00b4 The programmer should pay more attention\n\n2. Give information for correct use\n\n\u00b4 Help the programmer pay attention\n\n3. Prepare useful documentation\n\n\u00b4 Help building this documentation\n\n4.\n\nTreat this case programmatically\n\n\u00b4 Program the exceptional cases\n\nComments\n\nJavadoc\n\nExceptions\n\n\f12\n\nComments: one line\n\nComments\n\ndouble sqrt (int x){\n\n// x has to be non-negative\n\nreturn \u2026; // here comes the return value\n\n}\n\n\f13\n\nComments: multiple lines\n\nComments\n\ndouble sqrt (int x){\n\n/* x has to be\n\nnon-negative */\n\nreturn \u2026;\n\n}\n\n\f14\n\nJavadoc\n\nJavadoc\n\n/**\n\n* This method calculates the square root of the input value\n\n*\n\n* @author Carlos\n\n* @version 1.0\n\n* @param x an int value with x>=0\n\n* @return the non-negative square root\n\n*/\n\ndouble sqrt (int x){\n\nreturn \u2026;\n\n}\n\n\f15\n\nJavadoc\n\n\u00b4 Method sqrt provided by Java\n\nJavadoc\n\nMath.sqrt(4) \n\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html\n\n\f16\n\nExceptions\n\nExceptions\n\ndouble sqrt (int x) throws Exception{\n\nif (x<0) {throw new Exception();}\n\nreturn \u2026;\n\n}\n\n\f17\n\nExceptions: Examples\n\nExceptions\n\nvoid method (int a[]){\n\nfor (int i = 0; i <= a.length; i++) {\n\nSystem.out.println(a[i]);\n\n}\n\n}\n\nArrayIndexOutOfBoundException\n\n\f18\n\nExceptions: Examples\n\nExceptions\n\nvoid method (int a[]){\n\nfor (int i = 0; i < a.length; i++) {\n\nSystem.out.println(a[i]);\n\n}\n\n}\n\nIf the array is not initialized\nNullPointerException\n\n\f19\n\nExceptions: Examples\n\nExceptions\n\nvoid method (int a[]){\n\ntry{\n\nfor (int i = 0; i < a.length; i++) {\n\nSystem.out.println(a[i]);\n\n}\n\n} catch (NullPointerException e){\n\nSystem.err.println(\"The array was not initialized\");\n\n}\n\n}\n\n\f20\n\nExceptions: Examples\n\nExceptions\n\nint method (int a, int b) {\n\nreturn a/b;\n\n}\n\nIf b is 0 \nArithmeticException\n\n\f21\n\nExceptions: Examples\n\nExceptions\n\nint method (int a, int b) throws Exception{\n\nif (b==0) {throw new Exception();}\n\nreturn a/b;\n\n}\n\n\f22\n\nRecursive Methods\n\n\f23\n\nSquare: x2\n\nint square (int x)\n\n{\n\n}\n\nreturn x*x;\n\nint\n\nx\nsquare\nsquare\nx*x\n\nint\n\n\f24\n\nPower: xy\n\nint power (int x, int y)\n\n{\n\n}\n\n\u2026\n\nint\n\nint\n\nx\nx\npower\nsquare\nx*x\n\nint\n\n\f25\n\nPower: xy\n\nint power (int x, int y){\n\nif (y==0) \n\n{return 1;}\n\nelse if (y==1) {return x;}\n\nelse if (y==2) {return square(x);}\n\nelse if (y==3) {return cube(x);}\n\n\u2026 // until when?\n\n}\n\n\f26\n\nPower: xy\n\nint power (int x, int y){\n\nif (y==0) \n\n{return 1;}\n\nelse if (y==1) {return x;}\n\nelse if (y==2) {return square(x);}\n\nelse if (y==3) {return cube(x);}\n\n\u2026 // not very intelligent!\n\n}\n\n\f27\n\nPower: xy\n\nProvided y>=0:\n\nx0=1\nxy = x * \u2026 * x\n\ny\n\n\f28\n\nPower: xy\n\nint power (int x, int y)\n\n{ // y>=0\n\nint z=1;\n\nfor (int i=1; i<=y; i++)\n\n{z=x*z;}\n\nreturn z;\n\n}\n\n\f29\n\nTable for y equal 3\n\ni\n\n1\n\n2\n\n3\n\n4\n\ni<=y\n\ntrue\n\ntrue\n\ntrue\n\nfalse\n\nz\n\n1\n\nx\n\nx2\nx3\n\nreturn\n\nx3\n\n\f30\n\nTable for y equal 0\n\ni\n\n1\n\ni<=y\n\nfalse\n\nreturn\n\nz\n\n1\n\n1\n\n\f31\n\nRecurrence Equation\n\n\u00b4 Precondition: y>=0\n\n\u00b4 xy = 1\n\u00b4 xy = x * xy-1\n\n\u00b4 power(x,y)= 1\n\u00b4 power(x,y)=\n\nif (y==0)\n\nif (y>0)\n\nif (y==0)\n\nx*power(x,y-1)\n\nif (y>0)\n\nPrecondition satisfied \u00e7 y-1>=0 \u00e7 y>=1 \u00e7 y>0\n\n\f32\n\nRecursive Method\n\nint power (int x, int y){ // y>=0\n\nif (y==0)\n\nreturn 1;\n\nelse\n\nreturn x*power(x,y-1);\n\n}\n\nCan we\ndo that?\n\n\f33\n\npower(x,3)\n\n\u00b4 power(x,3) \n\u00b4 if (3==0){return 1}\n\nelse return x*power(x,3-1)\n\n\u00b4 if (false){return 1}\n\nelse return x*power(x,2)\n\n\u00b4 return x*power(x,2)\n\n\u00b4 power(x,3) \u00e8 x*power(x,2)\n\n\f34\n\npower(x,2)\n\n\u00b4 power(x,2) \n\u00b4 if (2==0){return 1}\n\nelse return x*power(x,2-1)\n\n\u00b4 if (false){return 1}\n\nelse return x*power(x,1)\n\n\u00b4 return x*power(x,1)\n\n\u00b4 power(x,2) \u00e8 x*power(x,1)\n\n\f35\n\npower(x,1)\n\n\u00b4 power(x,1) \n\u00b4 if (1==0){return 1}\n\nelse return x*power(x,1-1)\n\n\u00b4 if (false){return 1}\n\nelse return x*power(x,0)\n\n\u00b4 return x*power(x,0)\n\n\u00b4 power(x,1) \u00e8 x*power(x,0)\n\n\f36\n\npower(x,0)\n\n\u00b4 power(x,0) \n\u00b4 if (0==0){return 1}\n\nelse return x*power(x,0-1)\n\n\u00b4 if (true){return 1}\n\nelse return x*power(x,-1)\n\n\u00b4 return 1\n\n\u00b4 power(x,0) \u00e8 1\n\n\f37\n\nSummary\n\n\u00b4power(x,3) \u00e8 x*power(x,2)\n\u00b4power(x,2) \u00e8 x*power(x,1)\n\u00b4power(x,1) \u00e8 x*power(x,0)\n\u00b4power(x,0) \u00e8 1\n\n\f38\n\nAll Together\n\n\u00b4power(x,3)\n\u00b4x*power(x,2)\n\u00b4x*(x*power(x,1)) \n\u00b4x*(x*(x*power(x,0)))\n\u00b4x*(x*(x*1))\n\u00b4x*(x*x)\n\n\f39\n\npower(x,y)\n\nint power (int x, int y){ // y>=0\n\nif (y==0)\n\nreturn 1;\n\nelse\n\nreturn x*power(x,y-1);\n\n}\n\n\f40\n\npower(x,-2)\n\n\u00b4power(x,-2) \n\u00b4if (-2==0){return 1}\n\nelse return x*power(x,-2-1)\n\n\u00b4if (false){return 1}\n\nelse return x*power(x,-3)\n\n\u00b4return x*power(x,-3)\n\n\u00b4power(x,-2) \u00e8 x*power(x,-3)\n\n\f41\n\npower(x,-3)\n\n\u00b4power(x,-3) \n\u00b4if (-3==0){return 1}\n\nelse return x*power(x,-3-1)\n\n\u00b4if (false){return 1}\n\nelse return x*power(x,-4)\n\n\u00b4return x*power(x,-4)\n\n\u00b4power(x,-3) \u00e8 x*power(x,-4)\n\n\f42\n\n\u00b4power(x,-2) \u00e8 x*power(x,-3)\n\u00b4power(x,-3) \u00e8 x*power(x,-4)\n\u00b4power(x,-4) \u00e8 x*power(x,-5)\n\u00b4power(x,-5) \u00e8 x*power(x,-6)\n\u00b4\u2026\n\n\u00b4Non-termination\n\n\f43\n\npower(x,y)\n\nint power (int x, int y){ // y>=0\n\nif (y==0)\n\nreturn 1;\n\nelse\n\nreturn x*power(x,y-1);\n\n}\n\n\f44\n\nTermination condition\n\nint power (int x, int y){ // y>=0\n\nif (y==0)\n\nreturn 1;\n\nelse\n\nreturn x*power(x,y-1);\n\n}\n\nBase case\n\nRecursive case\n\n\f45\n\nExercise 1\n\n\u00b4 Implement the recursive method square(int n), which \n\ncalculates the square of n (when n > 1). We shall \nconsider the following formula in your implementation:\n\n(N-1)2 = N2 - 2N + 1\n\n\f46\n\nExercise 2\n\n\u2022\n\nImplement the recursive method  riddle(int p, int q) \nwith p and q > 0. Each time this method is called, the value of \nq increases in one unit, while the value of p decreases in one \nunit. When p is zero, the method returns the value of q.\n\n\u2022 How many time are the recursive and base cases executed \nwhen calling riddle(3,5) and what value is returned?\n\n\f47\n\nFactorial\n\nTask: Write a recursive method\nto compute the factorial of a natural number n\n\nfac(n) = n! = n*(n-1)*\u2026*2*1\n\nfac(5) = 5! = 5*4*3*2*1\n\nfac(4) = 4! =   4*3*2*1\n\n\f48\n\nFactorial\n\nTrick: 1. Assume you have\nthe problem solved for a simpler task\n\nfac(n)   =     n! = n*(n-1)*\u2026*2*1\n\nfac(n-1) = (n-1)! =   (n-1)*\u2026*2*1\n\nn! = n*(n-1)!\n\nfac(n) = n*fac(n-1)\n\n\f49\n\nFactorial\n\nTrick: 2. Check the border conditions\n\nfac(0) = 0! = 1\n\n\f50\n\nFactorial\n\nfac(n) = \n\n1\n\n(if n=0)\n\nn*fac(n-1) (if n>0)\n\n\f51\n\nFactorial\n\nfac(n) = \n\n1\n\n(if n\u22641)\n\nn*fac(n-1) (if n>1)\n\nlong fac (int n){\n\nif (n<=1) return 1;\nelse\n\nreturn n*fac(n-1);\n\n}\n\nBase case\n\nRecursive case\n\n\f52\n\nOperational View\n\nfac(3)\u00e83*fac(2)\nfac(2)\u00e82*fac(1)\nfac(1)\u00e81\n\nfac(3)\u00e83*fac(2)\u00e83*(2*fac(1))\n\n\u00e83*(2*1)\u00e86\n\n\f53\n\nMathematical View\n\nfac(3) = 3*fac(2) = 3*2 = 6\n\nfac(2) = 2*fac(1) = 2*1 = 2\n\nfac(1) = 1\n\n\f54\n\nExercise 3\n\n\u2022\n\nImplement the recursive method gcd(int a, int b), \nwhich allows computing the greatest common divisor of two \ninteger numbers.\n\n\f55\n\nExercise 4\n\n\u2022\n\nImplement the recursive method \ndecToBin(int decimal, String binary), \nwhich receives a decimal number and returns \na String with the equivalent binary number. \n\n\f", "pages_description": ["Summary\n\nThe slide is titled \"Summary\" and lists two bullet points: \"Partial functions\" and \"Recursive methods\". \n\nThe first bullet point \"Partial functions\" is accompanied by a diagram depicting two sets, X and Y, with several dots inside each set. Some dots in set X are connected with some dots in set Y with arrows pointing from X to Y. \n\nThe second bullet point \"Recursive methods\" is accompanied by an image of a computer screen showing several open windows nested within each other, creating an illusion of an endless tunnel. \n", "Partial Functions\n\nThe image shows two ovals, labeled X and Y, with several dots in each oval. Arrows are drawn from some of the dots in oval X to some of the dots in oval Y. Not all dots in X have arrows pointing from them, and some dots in Y are receiving multiple arrows from X. An arrow points from X to Y. \n", "Total Function\n\nThe diagram depicts two ovals representing sets 'X' and 'Y'.  Each oval contains several dots symbolizing elements within the sets. Red arrows connect each dot in set 'X' to a corresponding dot in set 'Y', illustrating a function mapping every element in 'X' to an element in 'Y'. \n", "Partial Function\n\nWe see a diagram depicting a partial function from X to Y. The diagram shows two ovals representing the sets X and Y. Inside each oval, there are multiple dots representing the elements of the sets. Some dots in X are connected to dots in Y with arrows, indicating the mapping from X to Y. However, not all dots in X have corresponding arrows pointing to dots in Y. \n", "Total Function\n\nWe see two sets, X prime and Y. Each set contains several dots representing elements. All of the dots in the first set, X prime, have lines connecting them to dots in the second set, Y. Some dots in Y are connected to multiple dots in X prime. \n", "Mathematics and Programming\n\nIn mathematics, we can freely fine-tune the sets in order to make the functions total. In programming, with types instead of sets, we cannot adjust the elements as we wish. \n", "Square Root\n\nThe image describes the concept of the square root function in programming. The function, named \"sqrt\", takes an integer \"x\" as input and returns a double-precision floating-point number representing the square root of \"x\". The image illustrates this with an example: \"sqrt(4)\". The input, 4, is an integer, and the output is a double-precision floating-point number. \n", "Square Root\n\nThe image shows a code snippet that calculates the square root of a given integer. The function `double sqrt(int x)` takes an integer `x` as input and returns a double-precision floating-point number, which represents the square root of `x`. The code uses the `sqrt()` function from a library, as indicated by the blue box labeled \"sqrt\". The input to this library function is an integer (`int`) and the output is a double-precision floating-point number (`double`).\n", "Square Root: Partial Definition\n\nWe have a number line ranging from minus five to plus five. There are two lines below the number line, one in red covering the negative numbers and zero, labeled \"Not defined\", and one in brown covering the positive numbers, labeled \"Defined\". Below, we see \"N arrow pointing to right R\". \n", "What to do when a method is called with a value for which there is no image?\n\nWe have four options: expect an error, give information for correct use, prepare useful documentation, or treat this case programmatically. Expecting an error means that the programmer should pay more attention. Giving information for correct use can be done with comments to help the programmer pay attention. Preparing useful documentation can be done with Javadoc. This helps when building documentation. Lastly, treating this case programmatically means programming the exceptional cases with exceptions. \n", "Comments\n\nThe slide is titled \"Comments: one line\" and shows an example of how to write single-line comments in code. The comment is marked with two forward slashes (//) and explains that the variable x in the square root function has to be non-negative. \n", "Comments: multiple lines\n\nWe have a function definition for a function called \"sqrt\" which takes an integer \"x\" as input and returns a double. There is a multi-line comment inside the function definition that says \"x has to be non-negative\". The body of the function simply returns \"...\" for now. \n", "Javadoc\n\nThis slide introduces the concept and syntax of Javadoc in Java programming. It presents a code snippet with Javadoc comments, which are used to generate documentation for the code.\n\nThe Javadoc comment block starts with `/**` and ends with `*/`. Inside the block, there are several tags starting with `@`, such as `@author`, `@version`, `@param`, and `@return`. These tags provide specific information about the code element they are documenting.\n\n- `@author` specifies the author of the code.\n- `@version` indicates the version of the code.\n- `@param` describes a parameter of a method, including its name and a brief description.\n- `@return` describes the return value of a method.\n\nThe code snippet defines a method named `sqrt` that takes an integer `x` as input and returns a double-precision floating-point value. The Javadoc comments explain that this method calculates the square root of the input value `x`, which should be greater than or equal to 0. The method returns the non-negative square root of `x`.\n\nThe slide also shows a sample output of the Javadoc documentation for the `sqrt` method. The output includes the method's description, parameters, return value, version, and author, all extracted from the Javadoc comments in the code.\n", "Javadoc\n\nThe slide is titled \"Javadoc\" and focuses on the Java method \"sqrt\" provided by the Java language. The specific example shown is \"Math.sqrt(4)\". The slide shows a screenshot of the Javadoc documentation for the \"sqrt\" method. The method is named \"sqrt\" and is a public static method that returns a double. It takes a single double-precision floating-point number, \"a\", as an argument. The documentation describes the method's purpose, which is to return the correctly rounded positive square root of the input value. It also lists special cases: if the argument is NaN (Not a Number) or less than zero, the result is NaN. If the argument is positive infinity, the result is positive infinity. If the argument is positive zero or negative zero, the result is the same as the argument. Otherwise, the result is the double value closest to the true mathematical square root of the argument value. The documentation also provides the parameter \"a\", which is a value, and the return value, which is the positive square root of \"a\". If the argument is NaN or less than zero, the result is NaN. The URL for this Javadoc page is provided at the bottom of the slide. \n", "Exceptions\n\nThis slide titled \"Exceptions\" shows a code snippet. The code defines a function called \"sqrt\" that takes an integer \"x\" as input and returns a double. The function throws an exception if the input \"x\" is less than 0. Otherwise, it returns a value represented by \"...\". \n", "Exceptions: Examples\n\nThis slide shows a code snippet of a Java method. The method takes an integer array as input. The for loop iterates through the array and prints each element. However, the loop condition is incorrect: it should be \"i < a.length\" instead of \"i <= a.length\". This will cause an ArrayIndexOutOfBoundsException when i equals the length of the array. \n", "Exceptions: Examples\n\nWe have a code snippet that shows an example of an exception. The method takes an integer array as an argument and iterates through it, printing each element. If the array is not initialized, a NullPointerException will be thrown. \n", "Exceptions: Examples\n\nWe have a piece of code that shows an example of exception handling. The code defines a method that takes an integer array as input. Inside the method, there is a try block that iterates over the array and prints each element. If the array is not initialized, a NullPointerException will be thrown. This exception is caught by the catch block, which prints an error message to the standard error stream. \n", "Exceptions: Examples\n\nWe have a code snippet that shows an example of an exception. The code defines an integer method that takes two integer arguments, a and b, and returns the result of dividing a by b. If b is 0, an ArithmeticException will be thrown. \n", "Exceptions: Examples\n\nWe have a code snippet that shows an example of an exception. The method takes two integers, a and b, as input and is designed to return the result of a divided by b. However, there is a condition that checks if b is equal to zero. If b is zero, an exception is thrown using the \"throw new Exception\" statement. Otherwise, the method proceeds to return the result of a divided by b. \n", "Recursive Methods\n\nThe image shows a screenshot of a computer screen with multiple windows open. The windows are nested inside each other, creating a visual effect of infinite recursion. This image is a metaphor for recursive methods, which are functions that call themselves. \n", "Square: x<sup>2</sup>\n\nThis slide seems to illustrate a function named \"square\". The function takes an integer \"x\" as input and returns an integer. The body of the function simply returns the square of the input, which is calculated as \"x*x\". The data flow of the function is illustrated with a diagram. The input of the function is an integer, which is represented by a downward arrow labeled \"int\". This input is then passed to the \"square\" function, which is represented by a blue box. The output of the function is also an integer, which is represented by a downward arrow labeled \"int\". \n", "Power: XY\n\nWe have a function definition for a function called \"power\" that takes two integer arguments, x and y, and returns an integer value. The function calculates the value of x raised to the power of y. \n", "Power: XY\n\nWe have a code snippet that shows a function definition in C programming language. The function is called \"power\" and takes two integer arguments: x and y. The goal of the function is to calculate x to the power of y. \n\nThe function starts by checking if y is equal to 0. If it is, it returns 1. Otherwise, it checks if y is equal to 1. If it is, it returns x. Otherwise, it checks if y is equal to 2. If it is, it returns the result of calling the function \"square\" with x as an argument. Otherwise, it checks if y is equal to 3. If it is, it returns the result of calling the function \"cube\" with x as an argument. The code ends with a comment: \"// until when?\". This comment suggests that the code is incomplete and that there should be more else if statements to handle other values of y. \n", "Power: XY\n\nWe see a code snippet, apparently the beginning of a function definition written in C. The function is called \"power\" and takes two integer arguments, x and y. The goal of the function is to compute x to the power of y.\n\nThe code implements this by checking for specific values of y: if y is 0, it returns 1. If y is 1, it returns x. If y is 2, it returns the result of calling a function named \"square\" with x as an argument. If y is 3, it returns the result of calling a function named \"cube\" with x as an argument. \n\nThe comment at the end suggests that this implementation is not very intelligent, probably because it only handles a few specific cases for y and does not provide a general solution for all possible values of y. \n", "Power: XY\n\nThe expression X to the power of Y, provided Y is greater than or equal to zero, is equal to X multiplied by itself Y times. \n", "Power: XY\n\nWe have a code snippet that defines a function named \"power\" that takes two integer arguments, x and y. The function calculates x raised to the power of y. Inside the function, an integer variable z is initialized to 1. A for loop iterates from 1 to y, and in each iteration, z is updated by multiplying it with x. Finally, the function returns the value of z. \n", "Table for y equal 3\n\nWe have a table that describes the value of z and the return value of a function, for different values of i. The table has four columns: i, i less than or equal to y, z, and return. The first row of the table shows that the initial value of z is 1. For i equal to 1, 2, and 3, the condition i less than or equal to y is true, and the value of z is x, x squared, and x cubed, respectively. For i equal to 4, the condition i less than or equal to y is false. The return value of the function is x cubed. \n", "Table for y equal 0\n\nThe table has four columns: i, i less than or equal to y, z, and return. When i is 1, i less than or equal to y is false, z is unknown, and return is 1. \n", "Recurrence Equation\n\nThe image describes a recurrence equation for calculating the power of a number.\n\n- The precondition for this equation is that y should be greater than or equal to 0.\n- If y is equal to 0, then x to the power of y is 1.\n- If y is greater than 0, then x to the power of y is equal to x multiplied by x to the power of y minus 1.\n\nThe equation is also presented in a functional form:\n\n- If y is equal to 0, then power(x,y) is equal to 1.\n- If y is greater than 0, then power(x,y) is equal to x multiplied by power(x, y-1).\n\nThe precondition is satisfied because y-1 is greater than or equal to 0, which implies that y is greater than or equal to 1, which in turn implies that y is greater than 0.\n", "Recursive Method\n\nWe see a code snippet for a recursive function called \"power\" that takes two integer arguments, x and y, and returns an integer. The function calculates x raised to the power of y. \n\nThe function first checks if y is equal to 0. If it is, it returns 1. Otherwise, it returns x multiplied by the result of calling the power function recursively with x and y-1 as arguments.\n\nThere is a red starburst shape with the text \"Can we do that?\" pointing to the recursive call of the power function. \n", "power(x,3)\n\nThis slide seems to illustrate a recursive approach to calculate the power of a number. The expression \"power(x,3)\" suggests calculating x raised to the power of 3. The subsequent lines break down this calculation into recursive steps.  It first checks if the exponent, in this case \"3\", is equal to 0. If true, it would return 1. However, since it's not, it proceeds to the else condition.  The else condition multiplies \"x\" with the result of the function call \"power(x, 3-1)\", essentially reducing the exponent by 1 in each recursive step. This process continues until the base case (exponent equals 0) is reached. The final step simplifies the expression \"power(x,3)\" to \"x*power(x,2)\", highlighting the recursive nature of the calculation. \n", "power(x,2)\n\nThe image shows a code snippet for a recursive function named \"power\" that takes two arguments, x and 2. The function is designed to calculate the result of x raised to the power of 2. \n\nThe code first checks if the second argument, 2, is equal to 0. If it is, the function returns 1. \n\nIf the second argument is not 0, the code enters an \"else\" block. This block contains another \"if\" statement that always evaluates to false. As a result, the code always executes the \"else\" block within this nested \"if\" statement. This inner \"else\" block recursively calls the \"power\" function with arguments x and 2-1, multiplies the result by x, and returns the final value.\n\nFinally, the code includes a line that demonstrates the function call \"power(x,2)\" and indicates that it is equivalent to \"x*power(x,1)\". This highlights the recursive nature of the function. \n", "power(x,1)\n\nThis slide seems to illustrate a recursive approach to calculate the power of a number. The base case is when the exponent is zero, in which case the result is 1. Otherwise, the result is obtained by multiplying the base by the result of calling the power function recursively with the same base and the exponent decremented by 1. The final result is x*power(x,0). \n", "power(x,0)\n\nThe image shows a code snippet for a function named \"power\" that takes two arguments, x and 0. The function checks if the second argument is equal to 0. If it is, it returns 1. Otherwise, it multiplies x by the result of calling the \"power\" function recursively with x and 0-1 as arguments. However, there is a logical error in the code. The second if statement always evaluates to true, resulting in the function always returning 1. Finally, we see the expression \"power(x,0)\" which would evaluate to 1. \n", "Summary\n\nWe see four mathematical equations that recursively define the power function for non-negative integer powers. The equations are:  power(x,3) equals x times power(x,2), power(x,2) equals x times power(x,1), power(x,1) equals x times power(x,0), and power(x,0) equals 1. \n", "All Together\n\n- power(x,3)\n- x * power(x,2)\n- x * (x * power(x,1))\n- x * (x * (x * power(x,0)))\n- x * (x * (x * 1))\n- x * (x * x) \n", "power(x,y)\n\nThis code defines a function called \"power\" that takes two integer arguments, x and y. The function returns an integer value. The function has a comment that says \"// y>=0\", which means that the function assumes that the value of y is greater than or equal to 0. The function body contains an if statement that checks if the value of y is equal to 0. If it is, the function returns 1. Otherwise, the function returns the value of x multiplied by the result of calling the power function recursively with the arguments x and y-1. \n", "power(x,-2)\n\nThe image shows a code snippet for a recursive function named \"power\" that calculates the result of x raised to the power of -2. \n\nThe function first checks if the exponent (-2 in this case) is equal to 0. If it is, it returns 1. \n\nIf the exponent is not 0, the function checks if a condition, which is always false, is true. Since the condition is always false, the function executes the code in the else block, which returns x multiplied by the result of calling the \"power\" function again with the arguments x and -3 (the original exponent minus 1). \n\nFinally, the last line of code shows that the initial call to the \"power\" function with the arguments x and -2 can be simplified to x multiplied by the result of calling the \"power\" function with the arguments x and -3. \n", "power(x,-3)\n\nThis slide seems to illustrate a recursive approach to calculate the power of a number. The expression \"power(x,-3)\" is being simplified to \"x*power(x,-4)\". There are also code snippets that seem to implement this logic, using conditional statements to handle the base case where the exponent is zero. \n", "The image shows a list of recursive calls to a function named \"power\". Each call takes two arguments: \"x\" and a negative integer. The first call is power(x, -2), which leads to x*power(x, -3). Similarly, power(x, -3) leads to x*power(x, -4), power(x, -4) leads to x*power(x, -5), and power(x, -5) leads to x*power(x, -6). The ellipsis indicates that this pattern continues indefinitely. \n\nFinally, the text \"Non-termination\" highlights that this recursive process will not terminate. \n", "A code snippet shows a function named \"power\" that takes two integer arguments, x and y. \nThe function returns an integer value. \nThere is a comment \"//y>=0\" next to the function definition.\nInside the function, there is an if statement that checks if y is equal to 0. \nIf y is equal to 0, the function returns 1. \nOtherwise, the function returns the product of x and the result of calling the power function recursively with arguments x and y-1. \n", "Termination condition\n\nWe see a code snippet that shows a function called power. The function takes two integer arguments, x and y. There is a comment that y is greater than or equal to zero. There is an if statement that checks if y is equal to zero. If it is, the function returns one. This is labeled as the base case. Otherwise, the function returns x times the result of calling power recursively with x and y minus one. This is labeled as the recursive case. \n", "Exercise 1\n\nImplement the recursive method \"square\" of integer n, which calculates the square of n when n is greater than 1. The formula to consider in the implementation is: open parenthesis N minus 1 close parenthesis squared, equals N squared minus 2N plus 1. \n", "Exercise 2\n\nWe are asked to implement a recursive method called \"riddle\" that takes two integer arguments, p and q, both greater than zero. Each time the method is called, the value of q increases by one, while the value of p decreases by one. When p reaches zero, the method returns the value of q.\n\nThe second question asks how many times the recursive and base cases are executed when calling riddle with arguments 3 and 5, and what value is returned. \n", "Factorial\n\nThis slide introduces the concept of factorial and presents a recursive method to compute the factorial of a natural number.\n\nThe factorial of a natural number n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1.\n\nThe slide presents a recursive method to compute the factorial of a natural number n, denoted by fac(n). The method defines fac(n) as n multiplied by the factorial of n-1, which is fac(n-1). This recursive definition continues until n becomes 1, at which point fac(1) is defined as 1.\n\nThe slide provides two examples to illustrate the recursive method:\n\n- fac(5) = 5! = 5 * 4 * 3 * 2 * 1\n- fac(4) = 4! = 4 * 3 * 2 * 1\n", "Factorial\n\nTrick: Assume you have the problem solved for a simpler task.\n\nFac of n equals n factorial, which equals n times n minus 1 times 2 times 1.\n\nFac of n minus 1 equals n minus 1 factorial, which equals n minus 1 times 2 times 1.\n\nn factorial equals n times n minus 1 factorial.\n\nFac of n equals n times fac of n minus 1.\n", "Factorial\n\nThe slide is about factorials. The second trick to remember about factorials is to check the border conditions. The factorial of zero is equal to zero factorial, which is equal to one. \n", "Factorial\n\nThis slide describes a factorial function, called \"fac\".\nIf the input \"n\" is equal to zero, the function returns one.\nIf the input \"n\" is greater than zero, the function returns n multiplied by the factorial of n minus one. \n", "Factorial\n\nThis slide explains the concept of factorial and shows a possible implementation in C programming language. \n\nThe factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120. The value of 0! is 1.\n\nThe slide presents a mathematical definition of the factorial function:\n- If n is less than or equal to 1, then the factorial of n is 1.\n- Otherwise, the factorial of n is calculated by multiplying n by the factorial of n-1.\n\nThe slide also provides the C code implementation of the factorial function:\n- The function `fac` takes an integer `n` as input and returns a long integer.\n- It first checks if `n` is less than or equal to 1. If it is, it returns 1 (base case).\n- Otherwise, it recursively calls the `fac` function with `n-1` and multiplies the result by `n` (recursive case).\n\nThe code implementation highlights the two key aspects of recursion: the base case and the recursive case. The base case stops the recursion, while the recursive case breaks down the problem into smaller subproblems.\n", "Operational View\n\nThis slide describes the operational view of a factorial function. It shows two ways to calculate the factorial of 3. The first way is to calculate the factorial of 2, then multiply the result by 3. The factorial of 2 is calculated by multiplying 2 by the factorial of 1. The factorial of 1 is 1. The second way is to calculate 2 multiplied by the factorial of 1, then multiply the result by 3. The factorial of 1 is 1. Both ways result in the same answer, which is 6. \n", "Mathematical View\n\nWe see three equations that describe a way to calculate the factorial of a number. The first equation shows that the factorial of 3 is equal to 3 multiplied by the factorial of 2. The second equation shows that the factorial of 2 is equal to 2 multiplied by the factorial of 1. The third equation shows that the factorial of 1 is equal to 1. \n", "Exercise 3\n\nImplement the recursive method gcd(int a, int b), which allows computing the greatest common divisor of two integer numbers.\n\nThe method is defined as follows:\n\ngcd(x, y) = x if y = 0\ngcd(x, y) = gcd(y, remainder(x, y)) if y > 0 \n", "Exercise 4\n\nImplement the recursive method \"decToBin\" that takes an integer \"decimal\" and a String \"binary\" as parameters. This method receives a decimal number and returns a String containing the equivalent binary representation of that number. \n"]}, {"filename": "7 en calario-Sorting (I).pdf", "text": "Sorting (I)\n\nCarlos Alario Hoyos & Carlos Delgado Kloos\n\nUniversidad Carlos III de Madrid\n\n\f2\n\nOverview\n\n1. Searching\n2. Sorting (basic algorithms)\n\nA. Bubble Sort\nB. Selection Sort\nInsertion Sort\nC.\n\n\f3\n\n1. Searching\n\n\f4\n\n1. Searching\n\n1. One of the most common operations in computer science\n\n2. The efficiency of the searching algorithm depends on \n\nwhether the information is sorted or not\n\n3. Searching algorithms may internally call a sorting algorithm\n\n\f5\n\n1. Searching: Practical example\n\n1. Think of a number between 0 and 999\n\n2. Tell someone to guess your number\n\n3.\n\nIn every try your colleague tells you a number and you \ncan answer:\n\n\u00b4 If the number is correct\n\n\u00b4 If the number is higher than your number\n\n\u00b4 If the number is lower that you number\n\n\f6\n\n1. Searching: Linear search\n\n1. Starting from:\n\n\u00b4 An array of elements a[ ] and\n\n\u00b4 An element x we want to search\n\n2. We traverse the array from left to right comparing each \n\nof its elements with x\n\n\u00b4 If they are equal, then we return the position of the element \n\nand the search ends\n\n\u00b4 If they are different, then we keep searching until the end \n\nof the array.\n\nIf we do not find the element x we return value -1\n\n3.\n\u00fc Complexity of linear order => O(n)\n\nhttp://www.cs.armstrong.edu/liang/animation/web/LinearSearch.html\n\n\f7\n\n1. Searching: Linear search\n\npublic static int linearSearch(int a[], int x) {\n\nfor (int i = 0; i < a.length ; i++) {\n\nif (a[i] == x){\n\nreturn i;\n\n}\n\n}\nreturn -1;\n\n}\n\n26 8\n\n0\n\n-2 31 3 12 9 10 -5\n\n6\n\n0     1     2     3     4     5     6     7     8     9     10    \n\n\f8\n\n1. Searching: Binary search\n\n1.\n\nStarting from:\n\u00b4 A sorted array of elements a[ ] and\n\n\u00b4 An element x we want to search\n\n2. We store in a variable \u201chalf\u201d the position of the element which is in the middle of \n\nthe array\n\n3. We compare the element which is in \u201chalf\u201d with x\n\n\u00b4 If they are equal, then we return \u201chalf\u201d\n\n\u00b4 If it is lower, then we repeat the search between \u201chalf+1\u201d and the end of the array\n\n\u00b4 If it is higher, then we repeat the search between the beginning of the array and \u201chalf-1\u201d\n\nIn each iteration we get a subarray which is approximately half the size\n\nIf we do not find the element x we return value -1\n\n4.\n\n5.\n\n\u00fc Complexity of logarithmic order (more efficient) => O(log n)\n\nhttp://www.cs.armstrong.edu/liang/animation/web/BinarySearch.html\n\n\f9\n\n1. Searching: Binary search\n\npublic static int binarySearch(int a[], int x) {\n\nint half;\nint first = 0;\nint last = a.length -1;\nwhile (first <= last) {\n\nhalf = (first + last)/2;\nif(a[half] == x){\n\nreturn half;\n\n}else if(a[half] < x){\nfirst = half+1;\n}else if(a[half] > x){\nlast = half-1;\n\n}\n\n}\nreturn -1;\n\n}\n\nFirst iteration\n\u2022\n\u2022\n\nIf a[half]>x, we search in [0...half-1]\nIf a[half]<x, we search in a[half+1, a.length-1]\n\n-5 -2\n\n0\n\n3\n\n6\n\n8\n\n9 10 12 26 31\n\n0     1     2     3     4     5     6     7     8     9     10    \n\n\f10\n\nExercise 1\n\n\u00b4 Implement the method public static int\n\nbinarySearchString(String[] s, String x), \nwhich does a binary search of element x in the array \nof strings s. Use the method compareTo() of class \nString, which compares two strings \nlexicographically.\n\n\u00b4 Given the array {\"a\",\"b\",\"d\",\"f\",\"h\",\"n\",\"p\",\"q\",\"r\",\"v\",\"z\"} \nhow many iterations are needed to search \u201cf\u201d, \u201cr\u201d \nand \u201cw\u201d with binary search? And with linear search?\n\n\f11\n\n1. Searching: Conclusions\n\n1. For smaller sizes (e.g., N<6)\n\n\u00b4 It is not worthy using a binary search since it uses \napproximately the same number of comparisons \nas a linear search\n\n2. Last iterations in a binary search are slower\n3. A hybrid approach could be interesting\n\n\u00b4 We apply binary search until the range is small\n\u00b4 Then, we apply linear search\n\n\f12\n\n2. Sorting\n\n\f13\n\n2. Sorting\n\n1. Sorted data structures makes searching easier \n\n(e.g., book, dictionary\u2026)\n\n2. Binary search takes advantage of the order\n\n\f14\n\n2.1 Bubble Sort\n\n1. The algorithm moves forward through the data \n\nstructure swapping pairs of contiguous elements \nwhich are not in the correct order\n\n\u00b4 If we sort from the lowest to the highest, the highest \nelement moves to the end (as it was a bubble)\n\n2. These passes are repeated until no more swapping \n\nis needed\n\n3. Elements which advanced to their correct position \n\ndo not need to be checked again \n\u00b4 Each pass needs to check one less element\n\nhttp://www.cs.armstrong.edu/liang/animation/web/BubbleSort.html\nhttp://www.algostructure.com/sorting/bubblesort.php\n\n\f15\n\n2.1 Bubble Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nq Two loops: internal and external\n\nq External loop: first iteration\nq Internal loop from 0 to length-1 (6 in \n\nthis example)\n\nv Swapping if element in position j is \nhigher than element in position j+1\n\nv Ends with 1 element in its correct \n\nposition\n\nq External loop: second iteration\nq Internal loop from 0 to length-2 (5 in \n\nthe example)\n\nv Swapping if element in position j is \nhigher than element in position j+1\n\nv Ends with 2 elements in their correct \n\nposition\n\n\f16\n\n2.1 Bubble Sort. Example (II)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nq External loop: third iteration\nq Internal loop from 0 to length-3 (4 in \n\nthe example)\n\nv \u2026\nv 3 elements in the correct position\n\nq External: fourth iteration. \nq Internal: from 0 to length-4\n\nq External: fifth iteration. \nq Internal: from 0 to length-5\n\nq External: sixth iteration. \nq Internal: from 0 to length-6\nv In the example with six iterations of the external \nloop all the elements are in their correct position\n\n\f17\n\n2.1 Bubble Sort\n\n1. External loop:\n\no\n\nNumber of iterations: length of array - 1 (in each iteration one element is \nsorted, except for the last one in which two elements are sorted)\n\n\u2022\n\nRange of the index in the external loop [0, length of array \u2013 1)\n\n2.\n\nInternal loop:\n\no\n\no\n\no\n\nIn the first iteration of the external (i=0), length of array - 1 iterations\n\nIn the second iteration of the external (i=1), length of array - 2 iterations\n\nIn the m-th iteration of the external (i=m-1), length of array - i - 1 iterations\n\n\u2022\n\nRange of the index in the internal loop [0,  length of array - 1 - i) \n\n3. After m-th iteration (i=m-1) of the external loop:\n\no\n\no\n\nElements from 0 to length of array - 2 - i are unsorted\n\nElements from length of array - 1 - i to length of array - 1 are sorted \n\n\f18\n\n2.1 Bubble Sort\n\npublic static void bubbleSort (int[] a) {\nfor (int i=0; i<a.length-1; i++) {\n\nfor (int j=0; j<a.length-1-i; j++) {\n\nif (a[j]>a[j+1]){\n\nswap(a, j, j+1);\n\n}\n\n}\n\n}\n\n}\n\nq Alternative:\n\nv External loop from 1 to a.length and    \nInternal loop from 0 to a.length-i\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n\f19\n\nExercise 2\n\n\u00b4 Starting from the implementation of Bubble Sort \nprovided, which sorts the elements in an array in \nascending order, make the necessary changes to sort \nthe array received as parameter in descending order\n\n\f20\n\nExercise 3\n\n\u00b4 Using the sorting algorithm Bubble Sort, how many \n\nswaps are needed to sort the following array from the \nhighest element to the lowest element (descending \norder)?\n\n{1,3,5,7,11,13}\n\n\f21\n\n2.1 Bubble Sort: Conclusions\n\nv Advantages:\n\n\u00b4 Little additional memory is needed\n\n\u00b4 Few lines of code\n\n\u00b4 Efficient for arrays with few elements\n\nv Drawbacks:\n\n\u00b4 Inefficient for arrays with many elements\n\nv\n\nv\n\nv\n\nO(n2) => quadratic order (two nested loops for an array of n elements)\n\nFor a given array there are always the same number of iterations/comparisons (even though it is already \nsorted), even though there are no swaps\n\nToo many swaps\n\n\u00b4 Larger elements move fast to the end (they can reach the end in one iteration of \n\nthe external loop), but lower elements move slower to the beginning (they gain one \nposition per iteration)\n\nv\n\nImprovement: Cocktail sort (double internal loop to pass from left to right and from right to left in each \niteration of the external loop)\n\n\f22\n\n2.2 Selection Sort\n\n1.\n\nIn ascending order\n\u00b4 Searches the minimum element and puts it in the first position (swap)\n\u00b4 Searches the next minimum element and puts it in the second position \n\n(swap)\n\n\u00b4 In general, searches the minimum element between i and the end of \nthe data structure and puts in the i-th position through swapping\n\n2.\n\nIn descending order\n\u00b4 Searches the maximum element and puts it in the first position (swap)\n\u00b4 Searches the next maximum element and puts it in the second position \n\n(swap)\n\n\u00b4 In general, searches the maximum element between i and the end of \n\nthe data structure and puts in the i-th position through swapping\n\nhttp://www.cs.armstrong.edu/liang/animation/web/SelectionSort.html\nhttp://www.algostructure.com/sorting/selectionsort.php\n\n\f23\n\n2.2 Selection Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n14 is the minimum unsorted element: swapping with element in position 0\n\nq Two loops: internal and external\n\n29 is the minimum unsorted element: swapping with element in position 1\n\n49 is the minimum unsorted element: swapping with element in position 2\n\nq External loop: sorts the first position. \n\nAs part of this loop there is a \nswapping between the element in \nposition i and the minimum unsorted \nelement\n\nq Internal loop: searches the minimum \nelement from position i until the end \nof the data structure\n\n\f24\n\n2.2 Selection Sort. Example (II)\n\n\u2022 Ascending order (from the lowest to the highest)\n\n66 is the minimum unsorted element: swapping with element in position 3\n\n80 is the minimum unsorted element: swapping with element in position 4\n\n95 is the minimum unsorted element. It is in the correct position. No swapping.\n\n98 is the minimum unsorted element. It is in the correct position. No swapping.\n\n\f25\n\n2.2 Selection Sort\n\n1. External loop:\n\no\n\nNumber of iterations: length of array (in each iteration one element is \nsorted, although the last iteration is not strictly needed)\n\n\u2022\n\nRange of the index in the external loop [0, length of array \u2013 1]\n\n2.\n\nInternal loop (searching the minimum / maximum):\n\no\n\no\n\no\n\nIn the first iteration of the external (i=0), length of array - 1 iterations\n\nIn the second iteration of the external (i=1), length of array - 2 iterations\n\nIn the m-th iteration of the external (i=m-1), length of array - i iterations\n\n\u2022\n\nRange of the index in the internal loop [i,  length of array \u2013 1] \n\n3. After m-th iteration (i=m-1) of the external loop:\n\no\n\no\n\nElements from 0 to i are sorted\n\nElements from i+1 to length of array - 1 are unsorted \n\n\f26\n\n2.2 Selection Sort\n\npublic static void selectionSort (int[] a) {\n\nfor (int i=0; i<a.length; i++) {\n\nint m = i;\nfor (int j=i; j<a.length; j++) {\n\nif (a[j]<a[m]){\nm = j;\n\n}\n\n}\nswap(a, i, m);\n\n}\n\n}\n\nq Alternative:\n\nv External loop to a.length - 1\nv Internal loop from j+1 to a.length\nsaves one unnecessary comparison\n\npublic static void swap (int[] a, int i, int j) {\n\nint aux=a[i];\na[i]=a[j];\na[j]=aux; \n\n}\n\n\f27\n\nExercise 4\n\n\u00b4 Starting from the implementation of Selection Sort \nprovided, which sorts the elements in an array in \nascending order, make the necessary changes to sort \nthe array received as parameter in descending order\n\n\f28\n\nExercise 5\n\n\u00b4 Using the sorting algorithm Selection Sort, how many \n\nswaps are needed to sort the following array from the \nhighest element to the lowest element (descending \norder)? Use the algorithm we saw in the class, which \nmoves to the left the maximum unsorted element\n\n{1,3,5,7,11,13}\n\n\f29\n\n2.2 Selection Sort: Conclusions\n\nv Advantages:\n\n\u00b4 Little additional memory is needed\n\n\u00b4 Few lines of code\n\n\u00b4 Efficient for arrays with few elements\n\nv Drawbacks:\n\n\u00b4 Inefficient for arrays with many elements\n\nv\n\nv\n\nv Variant:\n\nO(n2) => quadratic order (two nested loops for an array of n elements)\n\nFor a given array there are always the same number of iterations (even though it is already \nsorted), even though there are no swaps\n\n\u00fc\n\nBut much less swaps than with Bubble Sort\n\n\u00b4 Placing the maximum/minimum at the end, instead of placing the \n\nmaximum/minimum at the beginning\n\n\f30\n\n2.3 Insertion Sort\n\n1. The data structure is divided in two parts:\n\n\u00b4 the first part (e.g., left side) is already sorted,\n\n\u00b4 the second part (e.g., right side) is unsorted.\n\n\u00b4 At the beginning the first part is empty and the second part full\n\n2. We extract the first element of the second part, inserting it in \n\nits correct position in the first part (sorted)\n\n3. This step is repeated until all the elements are (sorted) in the \n\nfirst part.\n\nhttp://www.cs.armstrong.edu/liang/animation/web/InsertionSort.html\nhttp://www.algostructure.com/sorting/insertionsort.php\n\n\f31\n\n2.3 Insertion Sort. Example (I)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nWe take 80 from the unsorted part and insert it in its correct position in the sorted part\n\nWe take 95 from the unsorted part and insert it in its correct position in the sorted part. \n\nWe take 14 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80 and 95 are moved one position to the right to fill the gap left by 14\n\nq Two loops: internal and external\n\nq External loop: it traverses the array, \nleaving sorted what is behind \nposition i. As part of the external \nloop the element to be sorted is \nmoved to its right position \n\nq Internal loop: it moves one position \nto the right all the elements that are \nlocated between where the new \nsorted element is inserted and the \nposition it left in the unsorted part of \nthe array (now that position is \nsorted)\n\n\f32\n\n2.3 Insertion Sort. Example (II)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nWe take 98 from the unsorted part and insert it in its correct position in the sorted part\n\nWe take 29 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 29\n\n\f33\n\n2.3 Insertion Sort. Example (III)\n\n\u2022 Ascending order (from the lowest to the highest)\n\nWe take 49 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49\n\nWe take 66 from the unsorted part and insert it in its correct position in the sorted part.\nAdditionally, 80, 95 and 96 are moved one position to the right to fill the gap left by 66\n\n\f34\n\n2.3 Insertion Sort\n\n1. External loop:\n\no Number of iterations: length of array (in each iteration one \n\nelement is sorted, including in the last iteration)\n\n\u2022\n\nRange of the index in the external loop [0, length of array \u2013 1]\n\n2.\n\nInternal loop (finding the correct position to insert):\n\no\n\no\n\nThe number of iterations depends on the position \u201cadvanced\u201d by \nthe element which is inserted\n\nIf the element inserted moves k positions to the left, then there are \nk elements that are moved one position to the right\n\n3. After m-th iteration (i=m-1) of the external loop:\n\no\n\no\n\nElements from 0 to i are sorted\n\nElements from i+1 to length of array - 1 are unsorted \n\n\f35\n\n2.3 Insertion Sort\n\npublic static void insertionSort (int[] a){\n\nfor (int i=0; i<a.length; i++){\n\nint tmp=a[i];\nint j=i;\nwhile (j>0 && tmp<a[j-1]){\n\na[j]=a[j-1];\nj--;\n\n}\na[j]=tmp;\n\n}\n\n}\n\nq Alternative:\n\nv External loop from i=1, since the \n\nfirst element always stays in the \nsame position\n\n\f36\n\n2.3 Insertion Sort with auxiliary method\n\npublic static void insertionSort (int[] a) {\n\nfor (int i=0; i<a.length; i++) {\n\ninsert (a, i); \n\n}\n\n}\n\nprivate static void insert (int[] a, int i) {\n\nint tmp=a[i];\nint j=i;\nwhile (j>0 && tmp<a[j-1]){\n\na[j]=a[j-1];\nj--; \n\n}\na[j]=tmp; \n\n}\n\nv Auxiliary method insert(int[a], int i), \n\ninserts the element at position i in \nthe appropriate place of a, moving \nthe needed elements one position to \nthe right\n\n\f37\n\nExercise 6\n\n\u00b4 Starting from the implementation of Insertion Sort \nprovided, which sorts the elements in an array in \nascending order, make the necessary changes to sort \nthe array received as parameter in descending order\n\n\f38\n\nExercise 7\n\n\u00b4 Using the sorting algorithm Insertion Sort, how many \n\nswaps are needed to sort the following array from the \nhighest element to the lowest element (descending \norder)? \n\n{1,3,5,7,11,13}\n\n\u00b4 Of the three algorithms seen so far, which was the most efficient \none for this array? Try with other arrays with different values and \nlengths\n\n\f39\n\n2.3 Insertion Sort: Conclusions\n\nv Advantages:\n\n\u00b4 Little additional memory is needed\n\n\u00b4 Few lines of code\n\n\u00b4 Efficient for arrays with few elements\n\n\u00b4 More efficient than Selection Sort for (partially) sorted arrays\n\nv For a given array there are always the same number of iterations in the external loop \n\n(even though it is already sorted), but the internal loop is adaptable\n\nv Drawbacks:\n\n\u00b4 Inefficient for arrays with many elements\n\nv O(n2) => quadratic order (two nested loops for an array of n elements)\n\n\u00b4 Inefficient when the array to sort in the reverse sorted order\n\n\f", "pages_description": ["Overview\n\nThis slide titled \"Overview\" presents two main topics: Searching and Sorting. The Sorting section focuses on basic algorithms, specifically Bubble Sort, Selection Sort, and Insertion Sort. \n", "1. Searching\n\nThe image shows wooden letter tiles spelling out the word \"SEARCH\". The tiles are scattered among many other blank tiles. \n", "1. Searching\n\n- One of the most common operations in computer science.\n- The efficiency of the searching algorithm depends on whether the information is sorted or not.\n- Searching algorithms may internally call a sorting algorithm. \n", "**1. Searching: Practical example**\n\nThe slide describes a practical example of searching.\n\nThe first step is to think of a number between 0 and 999.\n\nThe second step is to tell someone to guess your number.\n\nThe third step is to have your colleague guess a number and for you to tell them if the number is correct, higher than your number, or lower than your number. \n", "1. Searching: Linear search\n\nLinear search starts with an array of elements and an element we want to search for.\nWe traverse the array from left to right comparing each of its elements with the element we are searching for.\nIf the elements are equal, then we return the position of the element and the search ends.\nIf they are different, then we keep searching until the end of the array.\nIf we do not find the element we return value -1.\nThe complexity of linear order is O(n).\n", "1. Searching: Linear search\n\nThis slide explains how to search for an element in an array using linear search. The algorithm is implemented in a function called \"linearSearch\" which takes as input an array of integers \"a\" and an integer \"x\". The function iterates over the array and checks if the current element is equal to \"x\". If it is, the function returns the index of the current element. Otherwise, the function continues to the next element. If the element is not found in the array, the function returns -1.\n\nThe slide also shows an example of an array with 10 elements. The elements are: 26, 8, 0, -2, 31, 3, 12, 9, 10, -5, and 6. The indices of the elements are: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10. \n", "1. Searching: Binary search\n\nThe image describes the binary search algorithm.\n\nWe start from a sorted array of elements and an element we want to search for. We store in a variable called \"half\" the position of the element which is in the middle of the array. We compare the element in position \"half\" with the element we are searching for. If they are equal, then we return \"half\". If the element in position \"half\" is lower than the element we are searching for, then we repeat the search between \"half+1\" and the end of the array. If the element in position \"half\" is higher than the element we are searching for, then we repeat the search between the beginning of the array and \"half-1\". In each iteration we get a sub-array which is approximately half the size. If we do not find the element we are searching for, we return value -1.\n\nThe complexity of the binary search algorithm is logarithmic order, which is more efficient than linear order. \n", "1. Searching: Binary search\n\nThe image shows a code snippet for a binary search algorithm in Java. \n\n```java\npublic static int binarySearch(int a[], int x) {\n  int half;\n  int first = 0;\n  int last = a.length - 1;\n  while (first <= last) {\n    half = (first + last) / 2;\n    if (a[half] == x) {\n      return half;\n    } else if (a[half] < x) {\n      first = half+1;\n    } else if (a[half] > x) {\n      last = half-1;\n    }\n  }\n  return -1;\n}\n```\n\nThe code searches for a given value `x` in a sorted array `a`. It initializes two pointers, `first` and `last`, to the first and last indices of the array, respectively. \n\nThe algorithm then enters a loop that continues as long as `first` is less than or equal to `last`. In each iteration, it calculates the middle index `half` and compares the value at `a[half]` with `x`. \n\n- If `a[half]` is equal to `x`, the search is successful, and the index `half` is returned. \n\n- If `a[half]` is less than `x`, the search continues in the right half of the array by updating `first` to `half+1`. \n\n- If `a[half]` is greater than `x`, the search continues in the left half of the array by updating `last` to `half-1`. \n\nIf the loop completes without finding `x`, the algorithm returns -1, indicating that the value is not present in the array.\n\nThe image also includes a visual representation of the first iteration of the algorithm. The array contains the following sorted values: -5, -2, 0, 3, 6, 8, 9, 10, 12, 26, and 31. \n\n- If the value of `x` is greater than the value at `a[half]`, the search continues in the subarray from index `half+1` to `a.length-1`.\n\n- If the value of `x` is less than the value at `a[half]`, the search continues in the subarray from index 0 to `half-1`.\n", "Exercise 1\n\nWe will implement the method \"binarySearchString\" which takes as input an array of strings and a string. This method performs a binary search of the string in the array of strings. The method uses the \"compareTo\" method of the string class, which compares two strings lexicographically.\n\nGiven the array of strings \"a\", \"b\", \"d\", \"f\", \"h\", \"n\", \"p\", \"q\", \"r\", \"v\", \"z\", we are asked to count the number of iterations needed to search for the strings \"f\", \"r\" and \"w\" using binary search and linear search. \n", "Searching: Conclusions\n\nThere are three conclusions about searching algorithms. First, for smaller data sizes, for example, N less than 6, it is not worth using a binary search since it uses approximately the same number of comparisons as a linear search. Second, the last iterations in a binary search are slower than the last iterations in a linear search. Finally, a hybrid approach could be interesting. In this approach, we apply binary search until the range is small, then we apply linear search. \n", "2. Sorting\n\nThe image shows five glasses containing liquids of different colors. From left to right, the colors are orange, blue, yellow, turquoise, and red. The glasses are identical in shape and size, and are arranged in a row on a surface. The background of the image is blurred, but appears to be an outdoor setting with snow on the ground and trees in the distance. \n", "2. Sorting\n\n- Sorted data structures make searching easier, for example, books and dictionaries.\n- Binary search takes advantage of the order. \n", "2.1 Bubble Sort\n\nThe algorithm moves forward through the data structure swapping pairs of contiguous elements which are not in the correct order. If we sort from the lowest to the highest, the highest element moves to the end (as it was a bubble). These passes are repeated until no more swapping is needed. Elements which advanced to their correct position do not need to be checked again. Each pass needs to check one less element. \n", "2.1 Bubble Sort. Example (I)\n\nWe have an example of a bubble sort algorithm, sorting in ascending order from the lowest to the highest. The original array is 80 95 14 98 29 49 66.\n\nThe algorithm uses two loops: internal and external. The external loop iterates over the array multiple times. The internal loop iterates over the unsorted portion of the array, comparing adjacent elements and swapping them if they are in the wrong order.\n\nIn the first iteration of the external loop, the internal loop iterates from index 0 to length-1, which is 6 in this example. The algorithm swaps elements if the element in position j is higher than the element in position j+1. At the end of the first iteration, the largest element, 98, is in its correct position at the end of the array.\n\nThe second iteration of the external loop is similar to the first, but the internal loop iterates from index 0 to length-2, which is 5 in this example. At the end of the second iteration, the two largest elements, 95 and 98, are in their correct positions at the end of the array. The algorithm continues in this manner, with each iteration of the external loop placing one more element in its correct position, until the entire array is sorted.\n", "2.1 Bubble Sort. Example (II)\n\nThe image describes the Bubble sort algorithm with an example.\n\nThe algorithm sorts an array of numbers in ascending order, from the lowest to the highest.\n\nThe example shows 7 arrays, each array represents an iteration of the external loop of the algorithm.\n\nThe first array contains the following unsorted elements: 14, 80, 29, 49, 66, 95, 98.\n\nThe second array shows the status after the first iteration of the external loop: 14, 29, 80, 49, 66, 95, 98.\n\nThe third array shows the status after the second iteration of the external loop: 14, 29, 49, 80, 66, 95, 98.\n\nThe fourth array shows the status after the third iteration of the external loop: 14, 29, 49, 66, 80, 95, 98.\n\nThe fifth, sixth and seventh arrays are identical to the fourth array, meaning that the array was fully sorted after 4 iterations.\n\nThe image also describes the internal loop for each iteration:\n- The internal loop for the third iteration of the external loop iterates from element at index 0 to the element at index length-3, which is 4 in this example.\n- The internal loop for the fourth iteration of the external loop iterates from element at index 0 to the element at index length-4.\n- The internal loop for the fifth iteration of the external loop iterates from element at index 0 to the element at index length-5.\n- The internal loop for the sixth iteration of the external loop iterates from element at index 0 to the element at index length-6.\n\nAfter 3 iterations, the last 3 elements are in the correct position.\n\nAfter 6 iterations, all the elements are in the correct position.\n", "2.1 Bubble Sort\n\nThe image describes the Bubble Sort algorithm.\n\n- The **external loop** iterates length of array - 1 times. In each iteration, one element is sorted, except for the last iteration in which two elements are sorted. The index in the external loop ranges from 0 to length of array - 1.\n\n- The **internal loop** iterates a different number of times depending on the iteration of the external loop. In the first iteration of the external loop (i=0), the internal loop iterates length of array - 1 times. In the second iteration of the external loop (i=1), the internal loop iterates length of array - 2 times. In the m-th iteration of the external loop (i=m-1), the internal loop iterates length of array - i - 1 times. The index in the internal loop ranges from 0 to length of array - 1 - i.\n\n- After the m-th iteration (i=m-1) of the external loop, the elements from index 0 to length of array - 2 - i are unsorted, and the elements from index length of array - 1 - i to length of array - 1 are sorted. \n", "2.1 Bubble Sort\n\nThe image shows code for a bubble sort algorithm in Java. The first function *bubbleSort* takes an integer array as input. It then iterates through the array with two nested for loops. The outer loop iterates from 0 to the length of the array minus 1. The inner loop iterates from 0 to the length of the array minus 1 minus the index of the outer loop. Inside the inner loop, if the element at the current index is greater than the element at the next index, the two elements are swapped. \n\nThe second function *swap* takes as input an integer array and two integer indices. It swaps the elements at the two given indices in the array.\n\nThere is also an alternative implementation of the algorithm where the external loop iterates from 1 to the length of the array and the internal loop iterates from 0 to the length of the array minus the index of the outer loop. \n", "Exercise 2\n\nStarting from the implementation of Bubble Sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order. \n", "Exercise 3\n\nUsing the sorting algorithm Bubble Sort, how many swaps are needed to sort the following array from the highest element to the lowest element (descending order)? The array is: 1, 3, 5, 7, 11, 13. \n", "2.1 Bubble Sort: Conclusions\n\nThis slide describes the advantages and disadvantages of the bubble sort algorithm.\n\nAdvantages:\n- Little additional memory is needed\n- Few lines of code\n- Efficient for arrays with few elements\n\nDrawbacks:\n- Inefficient for arrays with many elements\n  - O(n^2) => quadratic order (two nested loops for an array of n elements)\n  - For a given array there are always the same number of iterations/comparisons (even though it is already sorted), even though there are no swaps\n- Too many swaps\n- Larger elements move fast to the end (they can reach the end in one iteration of the external loop), but lower elements move slower to the beginning (they gain one position per iteration)\n\nImprovement: Cocktail sort (double internal loop to pass from left to right and from right to left in each iteration of the external loop)\n", "2.2 Selection Sort\n\nThe slide describes the selection sort algorithm. \n\nSelection sort can be performed in ascending or descending order.\n\nIn ascending order, the algorithm first searches for the minimum element and puts it in the first position by swapping it with the element currently in the first position. It then searches for the next minimum element and puts it in the second position, again by swapping. In general, the algorithm searches for the minimum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping.\n\nIn descending order, the algorithm first searches for the maximum element and puts it in the first position by swapping it with the element currently in the first position. It then searches for the next maximum element and puts it in the second position, again by swapping. In general, the algorithm searches for the maximum element between the i-th position and the end of the data structure and puts it in the i-th position through swapping.\n\nTwo URLs are provided at the bottom of the slide. \n", "2.2 Selection Sort. Example (1)\n\nThis slide explains how the selection sort algorithm works, showing an example of sorting elements in ascending order, from the lowest to the highest.\n\nThe algorithm uses two loops: an external loop and an internal loop. The external loop sorts the first position. As part of this loop, there is a swapping between the element in position i and the minimum unsorted element. The internal loop searches the minimum element from position i until the end of the data structure.\n\nThe example shows a list of numbers: 80, 95, 14, 98, 29, 49, and 66. The algorithm starts by finding the minimum unsorted element, which is 14. Then, it swaps 14 with the element in the first position, which is 80. The list now becomes: 14, 95, 80, 98, 29, 49, 66.\n\nThe algorithm continues in the same way, finding the minimum unsorted element and swapping it with the element in the correct position. The next minimum unsorted element is 29, which is swapped with 95. The list becomes: 14, 29, 80, 98, 95, 49, 66.\n\nThe process repeats until the list is sorted in ascending order: 14, 29, 49, 98, 95, 80, 66.\n", "2.2 Selection Sort. Example (II)\n\nThe image illustrates the ascending selection sort algorithm.\n\nThe unsorted array is: 14, 29, 49, 98, 95, 80, 66.\n\nFirst, 66 is selected as the minimum value and swapped with the element in position 3. The array becomes: 14, 29, 49, 66, 95, 80, 98.\n\nNext, 80 is selected as the minimum value and swapped with the element in position 4. The array becomes: 14, 29, 49, 66, 80, 95, 98.\n\nThe next two elements, 95 and 98, are already in the correct position, so no swapping is needed.\n\nThe final sorted array is: 14, 29, 49, 66, 80, 95, 98.\n", "2.2 Selection Sort\n\nWe're going to talk about the selection sort algorithm. The algorithm consists of two nested loops: an external loop and an internal loop.\n\nThe external loop iterates over the array, and for each iteration, one element is sorted. The number of iterations is equal to the length of the array. The range of the index in the external loop is from 0 to the length of the array minus 1.\n\nThe internal loop searches for the minimum or maximum value in the unsorted part of the array. In the first iteration of the external loop, the internal loop performs length of the array minus 1 iterations. In the second iteration of the external loop, the internal loop performs length of the array minus 2 iterations. In the m-th iteration of the external loop, the internal loop performs length of the array minus m iterations. The range of the index in the internal loop is from i to the length of the array minus 1.\n\nAfter the m-th iteration of the external loop, the elements from index 0 to index i are sorted, and the elements from index i plus 1 to the length of the array minus 1 are unsorted. \n", "2.2 Selection Sort\n\nThe image shows a code snippet for the Selection Sort algorithm in Java. \n\nThe first function `selectionSort` takes an integer array `a` as input. It has two nested for loops. The outer loop iterates through the array from index 0 to the end. The inner loop iterates through the unsorted subarray from index `i` to the end. The inner loop finds the index `m` of the minimum element in the unsorted subarray. After the inner loop, the function swaps the elements at indices `i` and `m` using the `swap` function.\n\nThe second function `swap` takes an integer array `a` and two integer indices `i` and `j` as input. It swaps the elements at indices `i` and `j` using an auxiliary variable `aux`.\n\nThere is also an \"Alternative\" note that suggests two optimizations for the `selectionSort` function:\n- Change the outer loop to iterate up to `a.length - 1`.\n- Change the inner loop to iterate from `j + 1` to `a.length`.\n\nThese optimizations save one unnecessary comparison because the last element will already be in its sorted position.\n", "Exercise 4\n\nStarting from the implementation of Selection Sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order. \n", "Exercise 5\n\nUsing the sorting algorithm Selection Sort, how many swaps are needed to sort the following array from the highest element to the lowest element (descending order)? Use the algorithm we saw in the class, which moves to the left the maximum unsorted element.\n\nThe array is: 1, 3, 5, 7, 11, 13. \n", "2.2 Selection Sort: Conclusions\n\nLet's talk about the advantages and drawbacks of selection sort, as well as a variant of the algorithm.\n\nSome of the advantages of selection sort are that it requires little additional memory, only a few lines of code are needed to implement it, and it is efficient for arrays with few elements.\n\nHowever, selection sort also has some drawbacks. It is inefficient for arrays with many elements, as it has a time complexity of big O of n squared, meaning it has a quadratic order. This is because the algorithm uses two nested loops for an array of n elements. Additionally, for a given array, there are always the same number of iterations, even if the array is already sorted, and even though there are no swaps. However, it is worth noting that selection sort does perform much less swaps than bubble sort.\n\nFinally, let's discuss a variant of the selection sort algorithm. Instead of placing the maximum or minimum element at the beginning of the array, this variant places it at the end. \n", "2.3 Insertion Sort\n\nThe data structure is divided into two parts: the first part, for example the left side, is already sorted and the second part, for example the right side, is unsorted. At the beginning, the first part is empty and the second part is full. We extract the first element of the second part, inserting it in its correct position in the first part, which is sorted. This step is repeated until all the elements are sorted in the first part.\n\nThe first diagram shows an example of this with the sorted partial result on the left, less than x and greater than x, and the unsorted data on the right. One element from the unsorted data, x, is highlighted in red with an arrow pointing to where it will be inserted in the sorted partial result.\n\nThe second diagram shows the result after the insertion of x. The sorted partial result is now less than x, x, and greater than x. The unsorted data now has one less element. \n", "2.3 Insertion Sort. Example (1)\n\nThe image illustrates the insertion sort algorithm with an example, focusing on arranging numbers in ascending order, from lowest to highest. The initial unsorted array is: 80, 95, 14, 98, 29, 49, 66.\n\nThe algorithm utilizes two loops: an external and an internal loop. The external loop iterates through the array, progressively leaving the elements behind its current position sorted. The internal loop shifts elements larger than the element being inserted one position to the right, creating space for the element to be placed in its correct sorted position.\n\nThe example demonstrates this process step-by-step. Initially, 80 is considered sorted. Then, 95 is compared to 80 and remains in its position as it's larger. Next, 14 is encountered. The internal loop moves 95 and 80 one position to the right, and 14 is inserted at the beginning, resulting in the sequence: 14, 80, 95, 98, 29, 49, 66. This process continues for each remaining element in the unsorted part of the array until the entire array becomes sorted.\n", "2.3 Insertion Sort. Example (II)\n\nThe slide describes the insertion sort algorithm in ascending order. It starts with the array \"14 80 95 98 29 49 66\". The algorithm takes the element 98, which is the first element of the unsorted part, and inserts it into its correct position in the sorted part. The sorted part is the sub-array that includes the elements before 98. The second step is to take the element 29 and insert it into its correct position in the sorted part. The elements 80, 95, and 98 are moved one position to the right to fill the gap left by 29. The final sorted array is \"14 29 80 95 98 49 66\". \n", "2.3 Insertion Sort. Example (III)\n\nThe image describes the insertion sort algorithm in ascending order, using an example.\n\nWe take the number 49 from the unsorted part and insert it in its correct position in the sorted part. Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 49.\n\nWe take 66 from the unsorted part and insert it in its correct position in the sorted part. Additionally, 80, 95 and 98 are moved one position to the right to fill the gap left by 66. \n", "2.3 Insertion Sort\n\nThe image describes the Insertion Sort algorithm.\n\n* **External loop**: \n    * The number of iterations is equal to the length of the array. In each iteration, one element is sorted, including the last iteration.\n    * The range of the index in the external loop is from 0 to the length of the array - 1.\n\n* **Internal loop (finding the correct position to insert)**:\n    * The number of iterations depends on the position \"advanced\" by the element which is inserted.\n    * If the element inserted moves k positions to the left, then there are k elements that are moved one position to the right.\n\n* **After m-th iteration (i=m-1) of the external loop**:\n    * Elements from index 0 to i are sorted.\n    * Elements from index i+1 to the length of the array - 1 are unsorted. \n", "2.3 Insertion Sort\n\nWe have the code for an insertion sort algorithm in Java. The method signature is public static void insertionSort and it takes an integer array a as input. \n\nThe algorithm iterates through the array with a for loop, starting from the second element (index 1). For each element a[i], it stores its value in a temporary variable tmp and initializes an index j to i. \n\nThen, a while loop compares tmp with the elements to its left (a[j-1]). If tmp is smaller than the element to its left, it shifts the left element one position to the right (a[j]=a[j-1]) and decrements j. This process continues until tmp is no longer smaller than the element to its left or j reaches 0. \n\nFinally, tmp is placed in its correct sorted position (a[j]=tmp).\n\nAn alternative implementation could start the external loop from i=1, as the first element is always considered sorted. \n", "2.3 Insertion Sort with auxiliary method\n\nThe image shows two code snippets. \n\nThe first snippet shows a function called \"insertionSort\" which takes an integer array \"a\" as input. It iterates through the array from the first element to the last one. For each element at index \"i\", it calls the \"insert\" function with the array \"a\" and the index \"i\" as input.\n\nThe second snippet shows a function called \"insert\" which takes an integer array \"a\" and an integer \"i\" as input. It first stores the value of the element at index \"i\" in a temporary variable \"tmp\". Then, it iterates through the array from index \"i\" down to the first element. For each element at index \"j\", if the value of \"tmp\" is less than the value of the element at index \"j-1\", it moves the element at index \"j-1\" to index \"j\". Otherwise, it breaks the loop. Finally, it assigns the value of \"tmp\" to the element at index \"j\".\n\nThe auxiliary method \"insert(int[a], int i)\" inserts the element at position \"i\" in the appropriate place of \"a\", moving the needed elements one position to the right. \n", "Exercise 6\n\nStarting from the implementation of insertion sort provided, which sorts the elements in an array in ascending order, make the necessary changes to sort the array received as parameter in descending order. \n", "Exercise 7\n\nWe are asked to count the swaps needed to sort the array \"1, 3, 5, 7, 11, 13\" from highest to lowest using the Insertion Sort algorithm.\n\nThen, we are asked which of the three algorithms seen so far is the most efficient for this particular array and encouraged to try other arrays with different values and lengths. \n", "2.3 Insertion Sort: Conclusions\n\nThis slide describes the advantages and drawbacks of insertion sort.\n\nAdvantages:\n- Little additional memory is needed\n- Few lines of code\n- Efficient for arrays with few elements\n- More efficient than Selection Sort for (partially) sorted arrays because for a given array there are always the same number of iterations in the external loop (even though it is already sorted), but the internal loop is adaptable\n\nDrawbacks:\n- Inefficient for arrays with many elements because it has quadratic order: two nested loops for an array of n elements\n- Inefficient when the array to sort is in reverse sorted order \n"]}]